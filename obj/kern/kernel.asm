
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 90 17 00 	lgdtl  0x179018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 90 17 f0       	mov    $0xf0179000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 22 00 00 00       	call   f010005f <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	c7 05 b0 4f 55 f0 01 	movl   $0x1,0xf0554fb0
f0100049:	00 00 00 
f010004c:	90                   	nop
f010004d:	5d                   	pop    %ebp
f010004e:	c3                   	ret    

f010004f <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f010004f:	55                   	push   %ebp
f0100050:	89 e5                	mov    %esp,%ebp
f0100052:	c7 05 04 4f 55 f0 01 	movl   $0x1,0xf0554f04
f0100059:	00 00 00 
f010005c:	90                   	nop
f010005d:	5d                   	pop    %ebp
f010005e:	c3                   	ret    

f010005f <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
bool autograde ;
void FOS_initialize()
{
f010005f:	55                   	push   %ebp
f0100060:	89 e5                	mov    %esp,%ebp
f0100062:	83 ec 28             	sub    $0x28,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100065:	ba a8 79 57 f0       	mov    $0xf05779a8,%edx
f010006a:	b8 b2 17 55 f0       	mov    $0xf05517b2,%eax
f010006f:	29 c2                	sub    %eax,%edx
f0100071:	89 d0                	mov    %edx,%eax
f0100073:	83 ec 04             	sub    $0x4,%esp
f0100076:	50                   	push   %eax
f0100077:	6a 00                	push   $0x0
f0100079:	68 b2 17 55 f0       	push   $0xf05517b2
f010007e:	e8 bc 06 02 00       	call   f012073f <memset>
f0100083:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f0100086:	e8 8d 0d 00 00       	call   f0100e18 <cons_init>
		//print welcome message
		print_welcome_message();
f010008b:	e8 11 02 00 00       	call   f01002a1 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100090:	83 ec 0c             	sub    $0xc,%esp
f0100093:	68 c0 16 12 f0       	push   $0xf01216c0
f0100098:	e8 cf 0e 00 00       	call   f0100f6c <cprintf>
f010009d:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f01000a0:	83 ec 0c             	sub    $0xc,%esp
f01000a3:	68 07 17 12 f0       	push   $0xf0121707
f01000a8:	e8 bf 0e 00 00       	call   f0100f6c <cprintf>
f01000ad:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000b0:	83 ec 0c             	sub    $0xc,%esp
f01000b3:	68 1b 17 12 f0       	push   $0xf012171b
f01000b8:	e8 af 0e 00 00       	call   f0100f6c <cprintf>
f01000bd:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000c0:	83 ec 0c             	sub    $0xc,%esp
f01000c3:	68 2f 17 12 f0       	push   $0xf012172f
f01000c8:	e8 9f 0e 00 00       	call   f0100f6c <cprintf>
f01000cd:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000d0:	83 ec 0c             	sub    $0xc,%esp
f01000d3:	6a 00                	push   $0x0
f01000d5:	e8 4b 6d 00 00       	call   f0106e25 <cpu_init>
f01000da:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000dd:	83 ec 0c             	sub    $0xc,%esp
f01000e0:	68 3b 17 12 f0       	push   $0xf012173b
f01000e5:	e8 82 0e 00 00       	call   f0100f6c <cprintf>
f01000ea:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000ed:	83 ec 0c             	sub    $0xc,%esp
f01000f0:	68 43 17 12 f0       	push   $0xf0121743
f01000f5:	e8 72 0e 00 00       	call   f0100f6c <cprintf>
f01000fa:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 2 memory management initialization functions
		detect_memory();
f01000fd:	e8 83 76 00 00       	call   f0107785 <detect_memory>
		initialize_kernel_VM();
f0100102:	e8 31 72 00 00       	call   f0107338 <initialize_kernel_VM>
		initialize_paging();
f0100107:	e8 fe 79 00 00       	call   f0107b0a <initialize_paging>
		initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
#endif
		//	page_check();
		//setPageReplacmentAlgorithmNchanceCLOCK();
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
		setPageReplacmentAlgorithmFIFO();
f010010c:	e8 34 e2 00 00       	call   f010e345 <setPageReplacmentAlgorithmFIFO>
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);

		setUHeapPlacementStrategyFIRSTFIT();
f0100111:	e8 39 ff ff ff       	call   f010004f <setUHeapPlacementStrategyFIRSTFIT>
		setKHeapPlacementStrategyFIRSTFIT();
f0100116:	e8 24 ff ff ff       	call   f010003f <setKHeapPlacementStrategyFIRSTFIT>

		enableBuffering(0);
f010011b:	83 ec 0c             	sub    $0xc,%esp
f010011e:	6a 00                	push   $0x0
f0100120:	e8 1d e3 00 00       	call   f010e442 <enableBuffering>
f0100125:	83 c4 10             	add    $0x10,%esp
		//enableModifiedBuffer(1) ;
		enableModifiedBuffer(0) ;
f0100128:	83 ec 0c             	sub    $0xc,%esp
f010012b:	6a 00                	push   $0x0
f010012d:	e8 f8 e2 00 00       	call   f010e42a <enableModifiedBuffer>
f0100132:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(1000);
f0100135:	83 ec 0c             	sub    $0xc,%esp
f0100138:	68 e8 03 00 00       	push   $0x3e8
f010013d:	e8 18 e3 00 00       	call   f010e45a <setModifiedBufferLength>
f0100142:	83 c4 10             	add    $0x10,%esp

		ide_init();
f0100145:	e8 4c 0b 02 00       	call   f0120c96 <ide_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) USER ENVs...");
f010014a:	83 ec 0c             	sub    $0xc,%esp
f010014d:	68 51 17 12 f0       	push   $0xf0121751
f0100152:	e8 15 0e 00 00       	call   f0100f6c <cprintf>
f0100157:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 3 user environment initialization functions
		env_init();
f010015a:	e8 e1 93 00 00       	call   f0109540 <env_init>
		ts_init();
f010015f:	e8 4e bc 00 00       	call   f010bdb2 <ts_init>
		//2024: removed. called inside cpuinit()
		//idt_init();
	}
	cprintf("[DONE]\n");
f0100164:	83 ec 0c             	sub    $0xc,%esp
f0100167:	68 3b 17 12 f0       	push   $0xf012173b
f010016c:	e8 fb 0d 00 00       	call   f0100f6c <cprintf>
f0100171:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f0100174:	83 ec 0c             	sub    $0xc,%esp
f0100177:	68 64 17 12 f0       	push   $0xf0121764
f010017c:	e8 eb 0d 00 00       	call   f0100f6c <cprintf>
f0100181:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f0100184:	e8 88 69 00 00       	call   f0106b11 <pic_init>
		cprintf("*	PIC is initialized\n");
f0100189:	83 ec 0c             	sub    $0xc,%esp
f010018c:	68 8d 17 12 f0       	push   $0xf012178d
f0100191:	e8 d6 0d 00 00       	call   f0100f6c <cprintf>
f0100196:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f0100199:	83 ec 0c             	sub    $0xc,%esp
f010019c:	6a 00                	push   $0x0
f010019e:	e8 60 6b 00 00       	call   f0106d03 <irq_clear_mask>
f01001a3:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f01001a6:	83 ec 0c             	sub    $0xc,%esp
f01001a9:	68 a3 17 12 f0       	push   $0xf01217a3
f01001ae:	e8 b9 0d 00 00       	call   f0100f6c <cprintf>
f01001b3:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001b6:	83 ec 0c             	sub    $0xc,%esp
f01001b9:	6a 01                	push   $0x1
f01001bb:	e8 43 6b 00 00       	call   f0106d03 <irq_clear_mask>
f01001c0:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001c3:	83 ec 0c             	sub    $0xc,%esp
f01001c6:	68 c0 17 12 f0       	push   $0xf01217c0
f01001cb:	e8 9c 0d 00 00       	call   f0100f6c <cprintf>
f01001d0:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001d3:	83 ec 0c             	sub    $0xc,%esp
f01001d6:	6a 04                	push   $0x4
f01001d8:	e8 26 6b 00 00       	call   f0106d03 <irq_clear_mask>
f01001dd:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001e0:	83 ec 0c             	sub    $0xc,%esp
f01001e3:	68 df 17 12 f0       	push   $0xf01217df
f01001e8:	e8 7f 0d 00 00       	call   f0100f6c <cprintf>
f01001ed:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
//		irq_clear_mask(14);
//		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
	}
	cprintf("* 5) SCHEDULER & MULTI-TASKING:\n");
f01001f0:	83 ec 0c             	sub    $0xc,%esp
f01001f3:	68 fc 17 12 f0       	push   $0xf01217fc
f01001f8:	e8 6f 0d 00 00       	call   f0100f6c <cprintf>
f01001fd:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 4 multitasking initialization functions
		kclock_init();
f0100200:	e8 df 46 00 00       	call   f01048e4 <kclock_init>
		sched_init() ;
f0100205:	e8 62 62 00 00       	call   f010646c <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 6) ESP to SCHED KERN STACK:\n");
f010020a:	83 ec 0c             	sub    $0xc,%esp
f010020d:	68 20 18 12 f0       	push   $0xf0121820
f0100212:	e8 55 0d 00 00       	call   f0100f6c <cprintf>
f0100217:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f010021a:	89 e0                	mov    %esp,%eax
f010021c:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010021f:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100222:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100225:	b8 00 90 17 f0       	mov    $0xf0179000,%eax
f010022a:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010022d:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f0100230:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100235:	2b 45 f0             	sub    -0x10(%ebp),%eax
f0100238:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010023b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010023e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100241:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100244:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100246:	89 e0                	mov    %esp,%eax
f0100248:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f010024b:	8b 45 e0             	mov    -0x20(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f010024e:	83 ec 04             	sub    $0x4,%esp
f0100251:	50                   	push   %eax
f0100252:	ff 75 f4             	pushl  -0xc(%ebp)
f0100255:	68 40 18 12 f0       	push   $0xf0121840
f010025a:	e8 0d 0d 00 00       	call   f0100f6c <cprintf>
f010025f:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("********************************************************************\n");
f0100262:	83 ec 0c             	sub    $0xc,%esp
f0100265:	68 64 18 12 f0       	push   $0xf0121864
f010026a:	e8 fd 0c 00 00       	call   f0100f6c <cprintf>
f010026f:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	autograde = 0;
f0100272:	c7 05 dc 51 55 f0 00 	movl   $0x0,0xf05551dc
f0100279:	00 00 00 
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f010027c:	83 ec 0c             	sub    $0xc,%esp
f010027f:	68 ac 18 12 f0       	push   $0xf01218ac
f0100284:	e8 e3 0c 00 00       	call   f0100f6c <cprintf>
f0100289:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f010028c:	83 ec 0c             	sub    $0xc,%esp
f010028f:	68 d8 18 12 f0       	push   $0xf01218d8
f0100294:	e8 d3 0c 00 00       	call   f0100f6c <cprintf>
f0100299:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f010029c:	e8 02 1b 00 00       	call   f0101da3 <get_into_prompt>

f01002a1 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f01002a1:	55                   	push   %ebp
f01002a2:	89 e5                	mov    %esp,%ebp
f01002a4:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f01002a7:	83 ec 0c             	sub    $0xc,%esp
f01002aa:	68 fd 18 12 f0       	push   $0xf01218fd
f01002af:	e8 b8 0c 00 00       	call   f0100f6c <cprintf>
f01002b4:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002b7:	83 ec 0c             	sub    $0xc,%esp
f01002ba:	68 04 19 12 f0       	push   $0xf0121904
f01002bf:	e8 a8 0c 00 00       	call   f0100f6c <cprintf>
f01002c4:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002c7:	83 ec 0c             	sub    $0xc,%esp
f01002ca:	68 4c 19 12 f0       	push   $0xf012194c
f01002cf:	e8 98 0c 00 00       	call   f0100f6c <cprintf>
f01002d4:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f01002d7:	83 ec 0c             	sub    $0xc,%esp
f01002da:	68 94 19 12 f0       	push   $0xf0121994
f01002df:	e8 88 0c 00 00       	call   f0100f6c <cprintf>
f01002e4:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002e7:	83 ec 0c             	sub    $0xc,%esp
f01002ea:	68 4c 19 12 f0       	push   $0xf012194c
f01002ef:	e8 78 0c 00 00       	call   f0100f6c <cprintf>
f01002f4:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002f7:	83 ec 0c             	sub    $0xc,%esp
f01002fa:	68 04 19 12 f0       	push   $0xf0121904
f01002ff:	e8 68 0c 00 00       	call   f0100f6c <cprintf>
f0100304:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100307:	83 ec 0c             	sub    $0xc,%esp
f010030a:	68 d9 19 12 f0       	push   $0xf01219d9
f010030f:	e8 58 0c 00 00       	call   f0100f6c <cprintf>
f0100314:	83 c4 10             	add    $0x10,%esp
}
f0100317:	90                   	nop
f0100318:	c9                   	leave  
f0100319:	c3                   	ret    

f010031a <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f010031a:	55                   	push   %ebp
f010031b:	89 e5                	mov    %esp,%ebp
f010031d:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f0100320:	e8 69 a1 00 00       	call   f010a48e <get_cpu_proc>
f0100325:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100328:	8b 45 10             	mov    0x10(%ebp),%eax
f010032b:	a3 c0 17 55 f0       	mov    %eax,0xf05517c0

	va_start(ap, fmt);
f0100330:	8d 45 10             	lea    0x10(%ebp),%eax
f0100333:	83 c0 04             	add    $0x4,%eax
f0100336:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100339:	83 ec 04             	sub    $0x4,%esp
f010033c:	ff 75 0c             	pushl  0xc(%ebp)
f010033f:	ff 75 08             	pushl  0x8(%ebp)
f0100342:	68 e0 19 12 f0       	push   $0xf01219e0
f0100347:	e8 20 0c 00 00       	call   f0100f6c <cprintf>
f010034c:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010034f:	8b 45 10             	mov    0x10(%ebp),%eax
f0100352:	83 ec 08             	sub    $0x8,%esp
f0100355:	ff 75 f0             	pushl  -0x10(%ebp)
f0100358:	50                   	push   %eax
f0100359:	e8 e5 0b 00 00       	call   f0100f43 <vcprintf>
f010035e:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100361:	83 ec 0c             	sub    $0xc,%esp
f0100364:	68 05 1a 12 f0       	push   $0xf0121a05
f0100369:	e8 fe 0b 00 00       	call   f0100f6c <cprintf>
f010036e:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100371:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100375:	74 10                	je     f0100387 <_panic+0x6d>
f0100377:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010037a:	8b 40 18             	mov    0x18(%eax),%eax
f010037d:	83 f8 02             	cmp    $0x2,%eax
f0100380:	75 05                	jne    f0100387 <_panic+0x6d>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f0100382:	e8 c5 a0 00 00       	call   f010a44c <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100387:	89 e0                	mov    %esp,%eax
f0100389:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010038c:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f010038f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f0100392:	83 ec 08             	sub    $0x8,%esp
f0100395:	ff 75 ec             	pushl  -0x14(%ebp)
f0100398:	68 07 1a 12 f0       	push   $0xf0121a07
f010039d:	e8 ca 0b 00 00       	call   f0100f6c <cprintf>
f01003a2:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01003a5:	e8 f9 19 00 00       	call   f0101da3 <get_into_prompt>

f01003aa <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f01003aa:	55                   	push   %ebp
f01003ab:	89 e5                	mov    %esp,%ebp
f01003ad:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f01003b0:	8b 45 10             	mov    0x10(%ebp),%eax
f01003b3:	a3 c0 17 55 f0       	mov    %eax,0xf05517c0

	va_start(ap, fmt);
f01003b8:	8d 45 10             	lea    0x10(%ebp),%eax
f01003bb:	83 c0 04             	add    $0x4,%eax
f01003be:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f01003c1:	83 ec 04             	sub    $0x4,%esp
f01003c4:	ff 75 0c             	pushl  0xc(%ebp)
f01003c7:	ff 75 08             	pushl  0x8(%ebp)
f01003ca:	68 11 1a 12 f0       	push   $0xf0121a11
f01003cf:	e8 98 0b 00 00       	call   f0100f6c <cprintf>
f01003d4:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01003d7:	8b 45 10             	mov    0x10(%ebp),%eax
f01003da:	83 ec 08             	sub    $0x8,%esp
f01003dd:	ff 75 f4             	pushl  -0xc(%ebp)
f01003e0:	50                   	push   %eax
f01003e1:	e8 5d 0b 00 00       	call   f0100f43 <vcprintf>
f01003e6:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01003e9:	83 ec 0c             	sub    $0xc,%esp
f01003ec:	68 05 1a 12 f0       	push   $0xf0121a05
f01003f1:	e8 76 0b 00 00       	call   f0100f6c <cprintf>
f01003f6:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f01003f9:	e8 e0 6a 00 00       	call   f0106ede <pushcli>
	struct cpu *c = mycpu();
f01003fe:	e8 18 6a 00 00       	call   f0106e1b <mycpu>
f0100403:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100406:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100409:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010040f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100412:	e8 19 6b 00 00       	call   f0106f30 <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100417:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f010041b:	74 23                	je     f0100440 <_panic_all+0x96>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f010041d:	e8 d0 5d 00 00       	call   f01061f2 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100422:	e8 67 a0 00 00       	call   f010a48e <get_cpu_proc>
f0100427:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f010042a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010042e:	74 10                	je     f0100440 <_panic_all+0x96>
f0100430:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100433:	8b 40 18             	mov    0x18(%eax),%eax
f0100436:	83 f8 02             	cmp    $0x2,%eax
f0100439:	75 05                	jne    f0100440 <_panic_all+0x96>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010043b:	e8 0c a0 00 00       	call   f010a44c <env_exit>
		}
	}
	//else //2024: panic from Kernel and no current running env
	{
		get_into_prompt();
f0100440:	e8 5e 19 00 00       	call   f0101da3 <get_into_prompt>

f0100445 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100445:	55                   	push   %ebp
f0100446:	89 e5                	mov    %esp,%ebp
f0100448:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f010044b:	8b 45 10             	mov    0x10(%ebp),%eax
f010044e:	a3 c0 17 55 f0       	mov    %eax,0xf05517c0

	va_start(ap, fmt);
f0100453:	8d 45 10             	lea    0x10(%ebp),%eax
f0100456:	83 c0 04             	add    $0x4,%eax
f0100459:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f010045c:	83 ec 04             	sub    $0x4,%esp
f010045f:	ff 75 0c             	pushl  0xc(%ebp)
f0100462:	ff 75 08             	pushl  0x8(%ebp)
f0100465:	68 11 1a 12 f0       	push   $0xf0121a11
f010046a:	e8 fd 0a 00 00       	call   f0100f6c <cprintf>
f010046f:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100472:	8b 45 10             	mov    0x10(%ebp),%eax
f0100475:	83 ec 08             	sub    $0x8,%esp
f0100478:	ff 75 f4             	pushl  -0xc(%ebp)
f010047b:	50                   	push   %eax
f010047c:	e8 c2 0a 00 00       	call   f0100f43 <vcprintf>
f0100481:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100484:	83 ec 0c             	sub    $0xc,%esp
f0100487:	68 05 1a 12 f0       	push   $0xf0121a05
f010048c:	e8 db 0a 00 00       	call   f0100f6c <cprintf>
f0100491:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f0100494:	e8 f5 9f 00 00       	call   f010a48e <get_cpu_proc>
f0100499:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f010049c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01004a0:	74 10                	je     f01004b2 <_panic_into_prompt+0x6d>
f01004a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01004a5:	8b 40 18             	mov    0x18(%eax),%eax
f01004a8:	83 f8 02             	cmp    $0x2,%eax
f01004ab:	75 05                	jne    f01004b2 <_panic_into_prompt+0x6d>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01004ad:	e8 9a 9f 00 00       	call   f010a44c <env_exit>
	}

	get_into_prompt();
f01004b2:	e8 ec 18 00 00       	call   f0101da3 <get_into_prompt>

f01004b7 <_warn>:
}


/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f01004b7:	55                   	push   %ebp
f01004b8:	89 e5                	mov    %esp,%ebp
f01004ba:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f01004bd:	8d 45 10             	lea    0x10(%ebp),%eax
f01004c0:	83 c0 04             	add    $0x4,%eax
f01004c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel warning at %s:%d: ", file, line);
f01004c6:	83 ec 04             	sub    $0x4,%esp
f01004c9:	ff 75 0c             	pushl  0xc(%ebp)
f01004cc:	ff 75 08             	pushl  0x8(%ebp)
f01004cf:	68 2a 1a 12 f0       	push   $0xf0121a2a
f01004d4:	e8 93 0a 00 00       	call   f0100f6c <cprintf>
f01004d9:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01004dc:	8b 45 10             	mov    0x10(%ebp),%eax
f01004df:	83 ec 08             	sub    $0x8,%esp
f01004e2:	ff 75 f4             	pushl  -0xc(%ebp)
f01004e5:	50                   	push   %eax
f01004e6:	e8 58 0a 00 00       	call   f0100f43 <vcprintf>
f01004eb:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01004ee:	83 ec 0c             	sub    $0xc,%esp
f01004f1:	68 05 1a 12 f0       	push   $0xf0121a05
f01004f6:	e8 71 0a 00 00       	call   f0100f6c <cprintf>
f01004fb:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f01004fe:	90                   	nop
f01004ff:	c9                   	leave  
f0100500:	c3                   	ret    

f0100501 <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f0100501:	55                   	push   %ebp
f0100502:	89 e5                	mov    %esp,%ebp
f0100504:	83 ec 10             	sub    $0x10,%esp
f0100507:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010050e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100511:	89 c2                	mov    %eax,%edx
f0100513:	ec                   	in     (%dx),%al
f0100514:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0100517:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f010051a:	0f b6 c0             	movzbl %al,%eax
f010051d:	83 e0 01             	and    $0x1,%eax
f0100520:	85 c0                	test   %eax,%eax
f0100522:	75 07                	jne    f010052b <serial_proc_data+0x2a>
		return -1;
f0100524:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100529:	eb 16                	jmp    f0100541 <serial_proc_data+0x40>
f010052b:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100532:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100535:	89 c2                	mov    %eax,%edx
f0100537:	ec                   	in     (%dx),%al
f0100538:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f010053b:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f010053e:	0f b6 c0             	movzbl %al,%eax
}
f0100541:	c9                   	leave  
f0100542:	c3                   	ret    

f0100543 <serial_intr>:

void
serial_intr(void)
{
f0100543:	55                   	push   %ebp
f0100544:	89 e5                	mov    %esp,%ebp
f0100546:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f0100549:	a1 e4 17 55 f0       	mov    0xf05517e4,%eax
f010054e:	85 c0                	test   %eax,%eax
f0100550:	74 10                	je     f0100562 <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f0100552:	83 ec 0c             	sub    $0xc,%esp
f0100555:	68 01 05 10 f0       	push   $0xf0100501
f010055a:	e8 9d 07 00 00       	call   f0100cfc <cons_intr>
f010055f:	83 c4 10             	add    $0x10,%esp
}
f0100562:	90                   	nop
f0100563:	c9                   	leave  
f0100564:	c3                   	ret    

f0100565 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0100565:	55                   	push   %ebp
f0100566:	89 e5                	mov    %esp,%ebp
f0100568:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f010056b:	83 ec 0c             	sub    $0xc,%esp
f010056e:	68 48 1a 12 f0       	push   $0xf0121a48
f0100573:	e8 f4 09 00 00       	call   f0100f6c <cprintf>
f0100578:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f010057b:	e8 c3 ff ff ff       	call   f0100543 <serial_intr>
}
f0100580:	90                   	nop
f0100581:	c9                   	leave  
f0100582:	c3                   	ret    

f0100583 <serial_init>:

void
serial_init(void)
{
f0100583:	55                   	push   %ebp
f0100584:	89 e5                	mov    %esp,%ebp
f0100586:	83 ec 48             	sub    $0x48,%esp
f0100589:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f0100590:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100594:	8a 45 c6             	mov    -0x3a(%ebp),%al
f0100597:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010059a:	ee                   	out    %al,(%dx)
f010059b:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f01005a2:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f01005a6:	8a 45 c7             	mov    -0x39(%ebp),%al
f01005a9:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01005ac:	ee                   	out    %al,(%dx)
f01005ad:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f01005b4:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f01005b8:	8a 45 c8             	mov    -0x38(%ebp),%al
f01005bb:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01005be:	ee                   	out    %al,(%dx)
f01005bf:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f01005c6:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f01005ca:	8a 45 c9             	mov    -0x37(%ebp),%al
f01005cd:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01005d0:	ee                   	out    %al,(%dx)
f01005d1:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f01005d8:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f01005dc:	8a 45 ca             	mov    -0x36(%ebp),%al
f01005df:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01005e2:	ee                   	out    %al,(%dx)
f01005e3:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f01005ea:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f01005ee:	8a 45 cb             	mov    -0x35(%ebp),%al
f01005f1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01005f4:	ee                   	out    %al,(%dx)
f01005f5:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f01005fc:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f0100600:	8a 45 cc             	mov    -0x34(%ebp),%al
f0100603:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0100606:	ee                   	out    %al,(%dx)
f0100607:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010060e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0100611:	89 c2                	mov    %eax,%edx
f0100613:	ec                   	in     (%dx),%al
f0100614:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f0100617:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f010061a:	3c ff                	cmp    $0xff,%al
f010061c:	0f 95 c0             	setne  %al
f010061f:	0f b6 c0             	movzbl %al,%eax
f0100622:	a3 e4 17 55 f0       	mov    %eax,0xf05517e4
f0100627:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010062e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100631:	89 c2                	mov    %eax,%edx
f0100633:	ec                   	in     (%dx),%al
f0100634:	88 45 ce             	mov    %al,-0x32(%ebp)
f0100637:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f010063e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0100641:	89 c2                	mov    %eax,%edx
f0100643:	ec                   	in     (%dx),%al
f0100644:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f0100647:	83 ec 08             	sub    $0x8,%esp
f010064a:	68 65 05 10 f0       	push   $0xf0100565
f010064f:	6a 04                	push   $0x4
f0100651:	e8 60 ca 00 00       	call   f010d0b6 <irq_install_handler>
f0100656:	83 c4 10             	add    $0x10,%esp

}
f0100659:	90                   	nop
f010065a:	c9                   	leave  
f010065b:	c3                   	ret    

f010065c <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f010065c:	55                   	push   %ebp
f010065d:	89 e5                	mov    %esp,%ebp
f010065f:	83 ec 20             	sub    $0x20,%esp
f0100662:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0100669:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010066c:	89 c2                	mov    %eax,%edx
f010066e:	ec                   	in     (%dx),%al
f010066f:	88 45 ec             	mov    %al,-0x14(%ebp)
f0100672:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0100679:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010067c:	89 c2                	mov    %eax,%edx
f010067e:	ec                   	in     (%dx),%al
f010067f:	88 45 ed             	mov    %al,-0x13(%ebp)
f0100682:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f0100689:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010068c:	89 c2                	mov    %eax,%edx
f010068e:	ec                   	in     (%dx),%al
f010068f:	88 45 ee             	mov    %al,-0x12(%ebp)
f0100692:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f0100699:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010069c:	89 c2                	mov    %eax,%edx
f010069e:	ec                   	in     (%dx),%al
f010069f:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f01006a2:	90                   	nop
f01006a3:	c9                   	leave  
f01006a4:	c3                   	ret    

f01006a5 <lpt_putc>:

static void
lpt_putc(int c)
{
f01006a5:	55                   	push   %ebp
f01006a6:	89 e5                	mov    %esp,%ebp
f01006a8:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006ab:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01006b2:	eb 08                	jmp    f01006bc <lpt_putc+0x17>
		delay();
f01006b4:	e8 a3 ff ff ff       	call   f010065c <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006b9:	ff 45 fc             	incl   -0x4(%ebp)
f01006bc:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f01006c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01006c6:	89 c2                	mov    %eax,%edx
f01006c8:	ec                   	in     (%dx),%al
f01006c9:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f01006cc:	8a 45 eb             	mov    -0x15(%ebp),%al
f01006cf:	84 c0                	test   %al,%al
f01006d1:	78 09                	js     f01006dc <lpt_putc+0x37>
f01006d3:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f01006da:	7e d8                	jle    f01006b4 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f01006dc:	8b 45 08             	mov    0x8(%ebp),%eax
f01006df:	0f b6 c0             	movzbl %al,%eax
f01006e2:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f01006e9:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01006ec:	8a 45 e8             	mov    -0x18(%ebp),%al
f01006ef:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01006f2:	ee                   	out    %al,(%dx)
f01006f3:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f01006fa:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f01006fe:	8a 45 e9             	mov    -0x17(%ebp),%al
f0100701:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100704:	ee                   	out    %al,(%dx)
f0100705:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f010070c:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f0100710:	8a 45 ea             	mov    -0x16(%ebp),%al
f0100713:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0100716:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f0100717:	90                   	nop
f0100718:	c9                   	leave  
f0100719:	c3                   	ret    

f010071a <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f010071a:	55                   	push   %ebp
f010071b:	89 e5                	mov    %esp,%ebp
f010071d:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f0100720:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f0100727:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010072a:	66 8b 00             	mov    (%eax),%ax
f010072d:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f0100731:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100734:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f0100739:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010073c:	66 8b 00             	mov    (%eax),%ax
f010073f:	66 3d 5a a5          	cmp    $0xa55a,%ax
f0100743:	74 13                	je     f0100758 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f0100745:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f010074c:	c7 05 e8 17 55 f0 b4 	movl   $0x3b4,0xf05517e8
f0100753:	03 00 00 
f0100756:	eb 14                	jmp    f010076c <cga_init+0x52>
	} else {
		*cp = was;
f0100758:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010075b:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f010075f:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f0100762:	c7 05 e8 17 55 f0 d4 	movl   $0x3d4,0xf05517e8
f0100769:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f010076c:	a1 e8 17 55 f0       	mov    0xf05517e8,%eax
f0100771:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100774:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0100778:	8a 45 e0             	mov    -0x20(%ebp),%al
f010077b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010077e:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010077f:	a1 e8 17 55 f0       	mov    0xf05517e8,%eax
f0100784:	40                   	inc    %eax
f0100785:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100788:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010078b:	89 c2                	mov    %eax,%edx
f010078d:	ec                   	in     (%dx),%al
f010078e:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f0100791:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100794:	0f b6 c0             	movzbl %al,%eax
f0100797:	c1 e0 08             	shl    $0x8,%eax
f010079a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f010079d:	a1 e8 17 55 f0       	mov    0xf05517e8,%eax
f01007a2:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01007a5:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01007a9:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01007ac:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01007af:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f01007b0:	a1 e8 17 55 f0       	mov    0xf05517e8,%eax
f01007b5:	40                   	inc    %eax
f01007b6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01007bc:	89 c2                	mov    %eax,%edx
f01007be:	ec                   	in     (%dx),%al
f01007bf:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f01007c2:	8a 45 e3             	mov    -0x1d(%ebp),%al
f01007c5:	0f b6 c0             	movzbl %al,%eax
f01007c8:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f01007cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01007ce:	a3 ec 17 55 f0       	mov    %eax,0xf05517ec
	crt_pos = pos;
f01007d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01007d6:	66 a3 f0 17 55 f0    	mov    %ax,0xf05517f0
}
f01007dc:	90                   	nop
f01007dd:	c9                   	leave  
f01007de:	c3                   	ret    

f01007df <cga_putc>:
//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.

void
cga_putc(int c)
{
f01007df:	55                   	push   %ebp
f01007e0:	89 e5                	mov    %esp,%ebp
f01007e2:	53                   	push   %ebx
f01007e3:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
f01007e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01007e9:	b0 00                	mov    $0x0,%al
f01007eb:	85 c0                	test   %eax,%eax
f01007ed:	75 07                	jne    f01007f6 <cga_putc+0x17>
		c |= 0x0700;
f01007ef:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)

	switch (c & 0xff) {
f01007f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01007f9:	0f b6 c0             	movzbl %al,%eax
f01007fc:	83 f8 0a             	cmp    $0xa,%eax
f01007ff:	74 77                	je     f0100878 <cga_putc+0x99>
f0100801:	83 f8 0a             	cmp    $0xa,%eax
f0100804:	7f 13                	jg     f0100819 <cga_putc+0x3a>
f0100806:	83 f8 08             	cmp    $0x8,%eax
f0100809:	74 2e                	je     f0100839 <cga_putc+0x5a>
f010080b:	83 f8 09             	cmp    $0x9,%eax
f010080e:	0f 84 a8 00 00 00    	je     f01008bc <cga_putc+0xdd>
f0100814:	e9 22 01 00 00       	jmp    f010093b <cga_putc+0x15c>
f0100819:	3d e4 00 00 00       	cmp    $0xe4,%eax
f010081e:	0f 84 de 00 00 00    	je     f0100902 <cga_putc+0x123>
f0100824:	3d e5 00 00 00       	cmp    $0xe5,%eax
f0100829:	0f 84 f1 00 00 00    	je     f0100920 <cga_putc+0x141>
f010082f:	83 f8 0d             	cmp    $0xd,%eax
f0100832:	74 5d                	je     f0100891 <cga_putc+0xb2>
f0100834:	e9 02 01 00 00       	jmp    f010093b <cga_putc+0x15c>
	case '\b':
		if (crt_pos > 0) {
f0100839:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f010083f:	66 85 c0             	test   %ax,%ax
f0100842:	0f 84 4f 01 00 00    	je     f0100997 <cga_putc+0x1b8>
			crt_pos--;
f0100848:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f010084e:	48                   	dec    %eax
f010084f:	66 a3 f0 17 55 f0    	mov    %ax,0xf05517f0
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0100855:	8b 15 ec 17 55 f0    	mov    0xf05517ec,%edx
f010085b:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100861:	0f b7 c0             	movzwl %ax,%eax
f0100864:	01 c0                	add    %eax,%eax
f0100866:	01 c2                	add    %eax,%edx
f0100868:	8b 45 08             	mov    0x8(%ebp),%eax
f010086b:	b0 00                	mov    $0x0,%al
f010086d:	83 c8 20             	or     $0x20,%eax
f0100870:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0100873:	e9 1f 01 00 00       	jmp    f0100997 <cga_putc+0x1b8>
	case '\n':
		crt_pos += CRT_COLS;
f0100878:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f010087e:	83 c0 50             	add    $0x50,%eax
f0100881:	66 a3 f0 17 55 f0    	mov    %ax,0xf05517f0
		text_length = 0;
f0100887:	c7 05 e0 17 55 f0 00 	movl   $0x0,0xf05517e0
f010088e:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f0100891:	66 8b 0d f0 17 55 f0 	mov    0xf05517f0,%cx
f0100898:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f010089e:	bb 50 00 00 00       	mov    $0x50,%ebx
f01008a3:	ba 00 00 00 00       	mov    $0x0,%edx
f01008a8:	66 f7 f3             	div    %bx
f01008ab:	89 d0                	mov    %edx,%eax
f01008ad:	29 c1                	sub    %eax,%ecx
f01008af:	89 c8                	mov    %ecx,%eax
f01008b1:	66 a3 f0 17 55 f0    	mov    %ax,0xf05517f0
		break;
f01008b7:	e9 e5 00 00 00       	jmp    f01009a1 <cga_putc+0x1c2>
	case '\t':
		cons_putc(' ');
f01008bc:	83 ec 0c             	sub    $0xc,%esp
f01008bf:	6a 20                	push   $0x20
f01008c1:	e8 30 05 00 00       	call   f0100df6 <cons_putc>
f01008c6:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008c9:	83 ec 0c             	sub    $0xc,%esp
f01008cc:	6a 20                	push   $0x20
f01008ce:	e8 23 05 00 00       	call   f0100df6 <cons_putc>
f01008d3:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008d6:	83 ec 0c             	sub    $0xc,%esp
f01008d9:	6a 20                	push   $0x20
f01008db:	e8 16 05 00 00       	call   f0100df6 <cons_putc>
f01008e0:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008e3:	83 ec 0c             	sub    $0xc,%esp
f01008e6:	6a 20                	push   $0x20
f01008e8:	e8 09 05 00 00       	call   f0100df6 <cons_putc>
f01008ed:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008f0:	83 ec 0c             	sub    $0xc,%esp
f01008f3:	6a 20                	push   $0x20
f01008f5:	e8 fc 04 00 00       	call   f0100df6 <cons_putc>
f01008fa:	83 c4 10             	add    $0x10,%esp
		break;
f01008fd:	e9 9f 00 00 00       	jmp    f01009a1 <cga_putc+0x1c2>
	case 228:
		if(crt_pos>0)
f0100902:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100908:	66 85 c0             	test   %ax,%ax
f010090b:	0f 84 89 00 00 00    	je     f010099a <cga_putc+0x1bb>
			crt_pos--;
f0100911:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100917:	48                   	dec    %eax
f0100918:	66 a3 f0 17 55 f0    	mov    %ax,0xf05517f0
		break;
f010091e:	eb 7a                	jmp    f010099a <cga_putc+0x1bb>
	case 229:
		if (crt_pos < CRT_SIZE)
f0100920:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100926:	66 3d cf 07          	cmp    $0x7cf,%ax
f010092a:	77 71                	ja     f010099d <cga_putc+0x1be>
			crt_pos++;
f010092c:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100932:	40                   	inc    %eax
f0100933:	66 a3 f0 17 55 f0    	mov    %ax,0xf05517f0
		break;
f0100939:	eb 62                	jmp    f010099d <cga_putc+0x1be>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f010093b:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f0100942:	74 5c                	je     f01009a0 <cga_putc+0x1c1>
f0100944:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f010094b:	74 53                	je     f01009a0 <cga_putc+0x1c1>
			crt_buf[crt_pos++] = c;		/* write the character */
f010094d:	8b 0d ec 17 55 f0    	mov    0xf05517ec,%ecx
f0100953:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100959:	8d 50 01             	lea    0x1(%eax),%edx
f010095c:	66 89 15 f0 17 55 f0 	mov    %dx,0xf05517f0
f0100963:	0f b7 c0             	movzwl %ax,%eax
f0100966:	01 c0                	add    %eax,%eax
f0100968:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010096b:	8b 45 08             	mov    0x8(%ebp),%eax
f010096e:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f0100971:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100977:	0f b7 c0             	movzwl %ax,%eax
f010097a:	8b 15 e0 17 55 f0    	mov    0xf05517e0,%edx
f0100980:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100986:	39 d0                	cmp    %edx,%eax
f0100988:	7e 16                	jle    f01009a0 <cga_putc+0x1c1>
				text_length++;
f010098a:	a1 e0 17 55 f0       	mov    0xf05517e0,%eax
f010098f:	40                   	inc    %eax
f0100990:	a3 e0 17 55 f0       	mov    %eax,0xf05517e0
		}
		break;
f0100995:	eb 09                	jmp    f01009a0 <cga_putc+0x1c1>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f0100997:	90                   	nop
f0100998:	eb 07                	jmp    f01009a1 <cga_putc+0x1c2>
		cons_putc(' ');
		break;
	case 228:
		if(crt_pos>0)
			crt_pos--;
		break;
f010099a:	90                   	nop
f010099b:	eb 04                	jmp    f01009a1 <cga_putc+0x1c2>
	case 229:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f010099d:	90                   	nop
f010099e:	eb 01                	jmp    f01009a1 <cga_putc+0x1c2>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f01009a0:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f01009a1:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f01009a7:	66 3d cf 07          	cmp    $0x7cf,%ax
f01009ab:	76 58                	jbe    f0100a05 <cga_putc+0x226>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f01009ad:	a1 ec 17 55 f0       	mov    0xf05517ec,%eax
f01009b2:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f01009b8:	a1 ec 17 55 f0       	mov    0xf05517ec,%eax
f01009bd:	83 ec 04             	sub    $0x4,%esp
f01009c0:	68 00 0f 00 00       	push   $0xf00
f01009c5:	52                   	push   %edx
f01009c6:	50                   	push   %eax
f01009c7:	e8 a3 fd 01 00       	call   f012076f <memcpy>
f01009cc:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009cf:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f01009d6:	eb 15                	jmp    f01009ed <cga_putc+0x20e>
			crt_buf[i] = 0x0700 | ' ';
f01009d8:	8b 15 ec 17 55 f0    	mov    0xf05517ec,%edx
f01009de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01009e1:	01 c0                	add    %eax,%eax
f01009e3:	01 d0                	add    %edx,%eax
f01009e5:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009ea:	ff 45 f4             	incl   -0xc(%ebp)
f01009ed:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f01009f4:	7e e2                	jle    f01009d8 <cga_putc+0x1f9>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f01009f6:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f01009fc:	83 e8 50             	sub    $0x50,%eax
f01009ff:	66 a3 f0 17 55 f0    	mov    %ax,0xf05517f0
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f0100a05:	a1 e8 17 55 f0       	mov    0xf05517e8,%eax
f0100a0a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100a0d:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100a11:	8a 45 e0             	mov    -0x20(%ebp),%al
f0100a14:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100a17:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f0100a18:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100a1e:	66 c1 e8 08          	shr    $0x8,%ax
f0100a22:	0f b6 c0             	movzbl %al,%eax
f0100a25:	8b 15 e8 17 55 f0    	mov    0xf05517e8,%edx
f0100a2b:	42                   	inc    %edx
f0100a2c:	89 55 ec             	mov    %edx,-0x14(%ebp)
f0100a2f:	88 45 e1             	mov    %al,-0x1f(%ebp)
f0100a32:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100a35:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0100a38:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f0100a39:	a1 e8 17 55 f0       	mov    0xf05517e8,%eax
f0100a3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100a41:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f0100a45:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0100a48:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100a4b:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f0100a4c:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100a52:	0f b6 c0             	movzbl %al,%eax
f0100a55:	8b 15 e8 17 55 f0    	mov    0xf05517e8,%edx
f0100a5b:	42                   	inc    %edx
f0100a5c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0100a5f:	88 45 e3             	mov    %al,-0x1d(%ebp)
f0100a62:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0100a65:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100a68:	ee                   	out    %al,(%dx)
}
f0100a69:	90                   	nop
f0100a6a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100a6d:	c9                   	leave  
f0100a6e:	c3                   	ret    

f0100a6f <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f0100a6f:	55                   	push   %ebp
f0100a70:	89 e5                	mov    %esp,%ebp
f0100a72:	83 ec 28             	sub    $0x28,%esp
f0100a75:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100a7c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100a7f:	89 c2                	mov    %eax,%edx
f0100a81:	ec                   	in     (%dx),%al
f0100a82:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0100a85:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0100a88:	0f b6 c0             	movzbl %al,%eax
f0100a8b:	83 e0 01             	and    $0x1,%eax
f0100a8e:	85 c0                	test   %eax,%eax
f0100a90:	75 0a                	jne    f0100a9c <kbd_proc_data+0x2d>
		return -1;
f0100a92:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100a97:	e9 2a 02 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
f0100a9c:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100aa3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100aa6:	89 c2                	mov    %eax,%edx
f0100aa8:	ec                   	in     (%dx),%al
f0100aa9:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0100aac:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f0100aaf:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f0100ab2:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0100ab6:	75 17                	jne    f0100acf <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0100ab8:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100abd:	83 c8 40             	or     $0x40,%eax
f0100ac0:	a3 08 1a 55 f0       	mov    %eax,0xf0551a08
		return 0;
f0100ac5:	b8 00 00 00 00       	mov    $0x0,%eax
f0100aca:	e9 f7 01 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f0100acf:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100ad2:	84 c0                	test   %al,%al
f0100ad4:	79 44                	jns    f0100b1a <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0100ad6:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100adb:	83 e0 40             	and    $0x40,%eax
f0100ade:	85 c0                	test   %eax,%eax
f0100ae0:	75 08                	jne    f0100aea <kbd_proc_data+0x7b>
f0100ae2:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100ae5:	83 e0 7f             	and    $0x7f,%eax
f0100ae8:	eb 03                	jmp    f0100aed <kbd_proc_data+0x7e>
f0100aea:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100aed:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f0100af0:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100af4:	8a 80 20 90 17 f0    	mov    -0xfe86fe0(%eax),%al
f0100afa:	83 c8 40             	or     $0x40,%eax
f0100afd:	0f b6 c0             	movzbl %al,%eax
f0100b00:	f7 d0                	not    %eax
f0100b02:	89 c2                	mov    %eax,%edx
f0100b04:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100b09:	21 d0                	and    %edx,%eax
f0100b0b:	a3 08 1a 55 f0       	mov    %eax,0xf0551a08
		return 0;
f0100b10:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b15:	e9 ac 01 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f0100b1a:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100b1f:	83 e0 40             	and    $0x40,%eax
f0100b22:	85 c0                	test   %eax,%eax
f0100b24:	74 11                	je     f0100b37 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f0100b26:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f0100b2a:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100b2f:	83 e0 bf             	and    $0xffffffbf,%eax
f0100b32:	a3 08 1a 55 f0       	mov    %eax,0xf0551a08
	}

	shift |= shiftcode[data];
f0100b37:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b3b:	8a 80 20 90 17 f0    	mov    -0xfe86fe0(%eax),%al
f0100b41:	0f b6 d0             	movzbl %al,%edx
f0100b44:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100b49:	09 d0                	or     %edx,%eax
f0100b4b:	a3 08 1a 55 f0       	mov    %eax,0xf0551a08
	shift ^= togglecode[data];
f0100b50:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b54:	8a 80 20 91 17 f0    	mov    -0xfe86ee0(%eax),%al
f0100b5a:	0f b6 d0             	movzbl %al,%edx
f0100b5d:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100b62:	31 d0                	xor    %edx,%eax
f0100b64:	a3 08 1a 55 f0       	mov    %eax,0xf0551a08

	c = charcode[shift & (CTL | SHIFT)][data];
f0100b69:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100b6e:	83 e0 03             	and    $0x3,%eax
f0100b71:	8b 14 85 20 95 17 f0 	mov    -0xfe86ae0(,%eax,4),%edx
f0100b78:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b7c:	01 d0                	add    %edx,%eax
f0100b7e:	8a 00                	mov    (%eax),%al
f0100b80:	0f b6 c0             	movzbl %al,%eax
f0100b83:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0100b86:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100b8d:	0f 85 9c 00 00 00    	jne    f0100c2f <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0100b93:	a1 e0 17 55 f0       	mov    0xf05517e0,%eax
f0100b98:	85 c0                	test   %eax,%eax
f0100b9a:	0f 8e 85 00 00 00    	jle    f0100c25 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f0100ba0:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100ba6:	0f b7 c0             	movzwl %ax,%eax
f0100ba9:	8b 15 e0 17 55 f0    	mov    0xf05517e0,%edx
f0100baf:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100bb5:	39 d0                	cmp    %edx,%eax
f0100bb7:	75 0a                	jne    f0100bc3 <kbd_proc_data+0x154>
				return 0;
f0100bb9:	b8 00 00 00 00       	mov    $0x0,%eax
f0100bbe:	e9 03 01 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
			else {
				text_length--;
f0100bc3:	a1 e0 17 55 f0       	mov    0xf05517e0,%eax
f0100bc8:	48                   	dec    %eax
f0100bc9:	a3 e0 17 55 f0       	mov    %eax,0xf05517e0
				int crt_pos_Length = crt_pos - 1925;
f0100bce:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100bd4:	0f b7 c0             	movzwl %ax,%eax
f0100bd7:	2d 85 07 00 00       	sub    $0x785,%eax
f0100bdc:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100bdf:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100be5:	0f b7 c0             	movzwl %ax,%eax
f0100be8:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100beb:	eb 26                	jmp    f0100c13 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f0100bed:	8b 15 ec 17 55 f0    	mov    0xf05517ec,%edx
f0100bf3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100bf6:	01 c0                	add    %eax,%eax
f0100bf8:	01 c2                	add    %eax,%edx
f0100bfa:	a1 ec 17 55 f0       	mov    0xf05517ec,%eax
f0100bff:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0100c02:	41                   	inc    %ecx
f0100c03:	01 c9                	add    %ecx,%ecx
f0100c05:	01 c8                	add    %ecx,%eax
f0100c07:	66 8b 00             	mov    (%eax),%ax
f0100c0a:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f0100c0d:	ff 45 e8             	incl   -0x18(%ebp)
f0100c10:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100c13:	a1 e0 17 55 f0       	mov    0xf05517e0,%eax
f0100c18:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0100c1b:	7e d0                	jle    f0100bed <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f0100c1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100c20:	e9 a1 00 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
			}
		}
		return 0;
f0100c25:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c2a:	e9 97 00 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f0100c2f:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100c34:	83 e0 08             	and    $0x8,%eax
f0100c37:	85 c0                	test   %eax,%eax
f0100c39:	74 22                	je     f0100c5d <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f0100c3b:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f0100c3f:	7e 0c                	jle    f0100c4d <kbd_proc_data+0x1de>
f0100c41:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f0100c45:	7f 06                	jg     f0100c4d <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f0100c47:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f0100c4b:	eb 10                	jmp    f0100c5d <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f0100c4d:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f0100c51:	7e 0a                	jle    f0100c5d <kbd_proc_data+0x1ee>
f0100c53:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0100c57:	7f 04                	jg     f0100c5d <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0100c59:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f0100c5d:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100c62:	83 f8 10             	cmp    $0x10,%eax
f0100c65:	75 13                	jne    f0100c7a <kbd_proc_data+0x20b>
f0100c67:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0100c6b:	7e 0d                	jle    f0100c7a <kbd_proc_data+0x20b>
f0100c6d:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f0100c71:	7f 07                	jg     f0100c7a <kbd_proc_data+0x20b>
		return 0;
f0100c73:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c78:	eb 4c                	jmp    f0100cc6 <kbd_proc_data+0x257>
	if (c == 255)
f0100c7a:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0100c81:	75 07                	jne    f0100c8a <kbd_proc_data+0x21b>
		return 0;
f0100c83:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c88:	eb 3c                	jmp    f0100cc6 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0100c8a:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100c8f:	f7 d0                	not    %eax
f0100c91:	83 e0 06             	and    $0x6,%eax
f0100c94:	85 c0                	test   %eax,%eax
f0100c96:	75 2b                	jne    f0100cc3 <kbd_proc_data+0x254>
f0100c98:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100c9f:	75 22                	jne    f0100cc3 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f0100ca1:	83 ec 0c             	sub    $0xc,%esp
f0100ca4:	68 5b 1a 12 f0       	push   $0xf0121a5b
f0100ca9:	e8 be 02 00 00       	call   f0100f6c <cprintf>
f0100cae:	83 c4 10             	add    $0x10,%esp
f0100cb1:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0100cb8:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100cbc:	8a 45 d9             	mov    -0x27(%ebp),%al
f0100cbf:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100cc2:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0100cc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100cc6:	c9                   	leave  
f0100cc7:	c3                   	ret    

f0100cc8 <kbd_intr>:

void
kbd_intr(void)
{
f0100cc8:	55                   	push   %ebp
f0100cc9:	89 e5                	mov    %esp,%ebp
f0100ccb:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f0100cce:	83 ec 0c             	sub    $0xc,%esp
f0100cd1:	68 6f 0a 10 f0       	push   $0xf0100a6f
f0100cd6:	e8 21 00 00 00       	call   f0100cfc <cons_intr>
f0100cdb:	83 c4 10             	add    $0x10,%esp
}
f0100cde:	90                   	nop
f0100cdf:	c9                   	leave  
f0100ce0:	c3                   	ret    

f0100ce1 <kbd_init>:

void
kbd_init(void)
{
f0100ce1:	55                   	push   %ebp
f0100ce2:	89 e5                	mov    %esp,%ebp
f0100ce4:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0100ce7:	83 ec 08             	sub    $0x8,%esp
f0100cea:	68 83 0e 10 f0       	push   $0xf0100e83
f0100cef:	6a 01                	push   $0x1
f0100cf1:	e8 c0 c3 00 00       	call   f010d0b6 <irq_install_handler>
f0100cf6:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f0100cf9:	90                   	nop
f0100cfa:	c9                   	leave  
f0100cfb:	c3                   	ret    

f0100cfc <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f0100cfc:	55                   	push   %ebp
f0100cfd:	89 e5                	mov    %esp,%ebp
f0100cff:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f0100d02:	eb 35                	jmp    f0100d39 <cons_intr+0x3d>
		if (c == 0)
f0100d04:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100d08:	75 02                	jne    f0100d0c <cons_intr+0x10>
			continue;
f0100d0a:	eb 2d                	jmp    f0100d39 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f0100d0c:	a1 04 1a 55 f0       	mov    0xf0551a04,%eax
f0100d11:	8d 50 01             	lea    0x1(%eax),%edx
f0100d14:	89 15 04 1a 55 f0    	mov    %edx,0xf0551a04
f0100d1a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100d1d:	88 90 00 18 55 f0    	mov    %dl,-0xfaae800(%eax)
		if (cons.wpos == CONSBUFSIZE)
f0100d23:	a1 04 1a 55 f0       	mov    0xf0551a04,%eax
f0100d28:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d2d:	75 0a                	jne    f0100d39 <cons_intr+0x3d>
			cons.wpos = 0;
f0100d2f:	c7 05 04 1a 55 f0 00 	movl   $0x0,0xf0551a04
f0100d36:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f0100d39:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d3c:	ff d0                	call   *%eax
f0100d3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100d41:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f0100d45:	75 bd                	jne    f0100d04 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f0100d47:	90                   	nop
f0100d48:	c9                   	leave  
f0100d49:	c3                   	ret    

f0100d4a <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f0100d4a:	55                   	push   %ebp
f0100d4b:	89 e5                	mov    %esp,%ebp
f0100d4d:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f0100d50:	e8 ee f7 ff ff       	call   f0100543 <serial_intr>
	kbd_intr();
f0100d55:	e8 6e ff ff ff       	call   f0100cc8 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0100d5a:	8b 15 00 1a 55 f0    	mov    0xf0551a00,%edx
f0100d60:	a1 04 1a 55 f0       	mov    0xf0551a04,%eax
f0100d65:	39 c2                	cmp    %eax,%edx
f0100d67:	74 35                	je     f0100d9e <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0100d69:	a1 00 1a 55 f0       	mov    0xf0551a00,%eax
f0100d6e:	8d 50 01             	lea    0x1(%eax),%edx
f0100d71:	89 15 00 1a 55 f0    	mov    %edx,0xf0551a00
f0100d77:	8a 80 00 18 55 f0    	mov    -0xfaae800(%eax),%al
f0100d7d:	0f b6 c0             	movzbl %al,%eax
f0100d80:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100d83:	a1 00 1a 55 f0       	mov    0xf0551a00,%eax
f0100d88:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d8d:	75 0a                	jne    f0100d99 <cons_getc+0x4f>
			cons.rpos = 0;
f0100d8f:	c7 05 00 1a 55 f0 00 	movl   $0x0,0xf0551a00
f0100d96:	00 00 00 
		return c;
f0100d99:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100d9c:	eb 05                	jmp    f0100da3 <cons_getc+0x59>
	}
	return 0;
f0100d9e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100da3:	c9                   	leave  
f0100da4:	c3                   	ret    

f0100da5 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0100da5:	55                   	push   %ebp
f0100da6:	89 e5                	mov    %esp,%ebp
f0100da8:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0100dab:	8b 15 00 1a 55 f0    	mov    0xf0551a00,%edx
f0100db1:	a1 04 1a 55 f0       	mov    0xf0551a04,%eax
f0100db6:	39 c2                	cmp    %eax,%edx
f0100db8:	74 35                	je     f0100def <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0100dba:	a1 00 1a 55 f0       	mov    0xf0551a00,%eax
f0100dbf:	8d 50 01             	lea    0x1(%eax),%edx
f0100dc2:	89 15 00 1a 55 f0    	mov    %edx,0xf0551a00
f0100dc8:	8a 80 00 18 55 f0    	mov    -0xfaae800(%eax),%al
f0100dce:	0f b6 c0             	movzbl %al,%eax
f0100dd1:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100dd4:	a1 00 1a 55 f0       	mov    0xf0551a00,%eax
f0100dd9:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dde:	75 0a                	jne    f0100dea <cons_getc2+0x45>
			cons.rpos = 0;
f0100de0:	c7 05 00 1a 55 f0 00 	movl   $0x0,0xf0551a00
f0100de7:	00 00 00 
		return c;
f0100dea:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100ded:	eb 05                	jmp    f0100df4 <cons_getc2+0x4f>
	}
	return 0;
f0100def:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100df4:	c9                   	leave  
f0100df5:	c3                   	ret    

f0100df6 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f0100df6:	55                   	push   %ebp
f0100df7:	89 e5                	mov    %esp,%ebp
f0100df9:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f0100dfc:	ff 75 08             	pushl  0x8(%ebp)
f0100dff:	e8 a1 f8 ff ff       	call   f01006a5 <lpt_putc>
f0100e04:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f0100e07:	83 ec 0c             	sub    $0xc,%esp
f0100e0a:	ff 75 08             	pushl  0x8(%ebp)
f0100e0d:	e8 cd f9 ff ff       	call   f01007df <cga_putc>
f0100e12:	83 c4 10             	add    $0x10,%esp
}
f0100e15:	90                   	nop
f0100e16:	c9                   	leave  
f0100e17:	c3                   	ret    

f0100e18 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f0100e18:	55                   	push   %ebp
f0100e19:	89 e5                	mov    %esp,%ebp
f0100e1b:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f0100e1e:	e8 f7 f8 ff ff       	call   f010071a <cga_init>
	kbd_init();
f0100e23:	e8 b9 fe ff ff       	call   f0100ce1 <kbd_init>
	serial_init();
f0100e28:	e8 56 f7 ff ff       	call   f0100583 <serial_init>

	if (!serial_exists)
f0100e2d:	a1 e4 17 55 f0       	mov    0xf05517e4,%eax
f0100e32:	85 c0                	test   %eax,%eax
f0100e34:	75 10                	jne    f0100e46 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f0100e36:	83 ec 0c             	sub    $0xc,%esp
f0100e39:	68 67 1a 12 f0       	push   $0xf0121a67
f0100e3e:	e8 29 01 00 00       	call   f0100f6c <cprintf>
f0100e43:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f0100e46:	90                   	nop
f0100e47:	c9                   	leave  
f0100e48:	c3                   	ret    

f0100e49 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f0100e49:	55                   	push   %ebp
f0100e4a:	89 e5                	mov    %esp,%ebp
f0100e4c:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0100e4f:	83 ec 0c             	sub    $0xc,%esp
f0100e52:	ff 75 08             	pushl  0x8(%ebp)
f0100e55:	e8 9c ff ff ff       	call   f0100df6 <cons_putc>
f0100e5a:	83 c4 10             	add    $0x10,%esp
}
f0100e5d:	90                   	nop
f0100e5e:	c9                   	leave  
f0100e5f:	c3                   	ret    

f0100e60 <getchar>:

int
getchar(void)
{
f0100e60:	55                   	push   %ebp
f0100e61:	89 e5                	mov    %esp,%ebp
f0100e63:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0100e66:	e8 df fe ff ff       	call   f0100d4a <cons_getc>
f0100e6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100e6e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100e72:	74 f2                	je     f0100e66 <getchar+0x6>
		/* do nothing */;
	return c;
f0100e74:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100e77:	c9                   	leave  
f0100e78:	c3                   	ret    

f0100e79 <iscons>:

int
iscons(int fdnum)
{
f0100e79:	55                   	push   %ebp
f0100e7a:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0100e7c:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0100e81:	5d                   	pop    %ebp
f0100e82:	c3                   	ret    

f0100e83 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0100e83:	55                   	push   %ebp
f0100e84:	89 e5                	mov    %esp,%ebp
f0100e86:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0100e89:	e8 3a fe ff ff       	call   f0100cc8 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0100e8e:	90                   	nop
f0100e8f:	c9                   	leave  
f0100e90:	c3                   	ret    

f0100e91 <cons_lock>:

void cons_lock(void)
{
f0100e91:	55                   	push   %ebp
f0100e92:	89 e5                	mov    %esp,%ebp
f0100e94:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100e97:	e8 0a 3b 00 00       	call   f01049a6 <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0100e9c:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100e9d:	e8 ec 95 00 00       	call   f010a48e <get_cpu_proc>
f0100ea2:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100ea5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ea9:	75 17                	jne    f0100ec2 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0100eab:	83 ec 04             	sub    $0x4,%esp
f0100eae:	68 84 1a 12 f0       	push   $0xf0121a84
f0100eb3:	68 2d 02 00 00       	push   $0x22d
f0100eb8:	68 ab 1a 12 f0       	push   $0xf0121aab
f0100ebd:	e8 58 f4 ff ff       	call   f010031a <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0100ec2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100ec5:	8b 00                	mov    (%eax),%eax
f0100ec7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100eca:	8b 12                	mov    (%edx),%edx
f0100ecc:	8b 52 38             	mov    0x38(%edx),%edx
f0100ecf:	80 e6 fd             	and    $0xfd,%dh
f0100ed2:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0100ed5:	90                   	nop
f0100ed6:	c9                   	leave  
f0100ed7:	c3                   	ret    

f0100ed8 <cons_unlock>:

void cons_unlock(void)
{
f0100ed8:	55                   	push   %ebp
f0100ed9:	89 e5                	mov    %esp,%ebp
f0100edb:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100ede:	e8 c3 3a 00 00       	call   f01049a6 <kclock_stop>
f0100ee3:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100ee4:	e8 a5 95 00 00       	call   f010a48e <get_cpu_proc>
f0100ee9:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100eec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ef0:	75 17                	jne    f0100f09 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0100ef2:	83 ec 04             	sub    $0x4,%esp
f0100ef5:	68 c0 1a 12 f0       	push   $0xf0121ac0
f0100efa:	68 46 02 00 00       	push   $0x246
f0100eff:	68 ab 1a 12 f0       	push   $0xf0121aab
f0100f04:	e8 11 f4 ff ff       	call   f010031a <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0100f09:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f0c:	8b 00                	mov    (%eax),%eax
f0100f0e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100f11:	8b 12                	mov    (%edx),%edx
f0100f13:	8b 52 38             	mov    0x38(%edx),%edx
f0100f16:	80 ce 02             	or     $0x2,%dh
f0100f19:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0100f1c:	90                   	nop
f0100f1d:	c9                   	leave  
f0100f1e:	c3                   	ret    

f0100f1f <putch>:
#include <kern/cpu/cpu.h>


static void
putch(int ch, int *cnt)
{
f0100f1f:	55                   	push   %ebp
f0100f20:	89 e5                	mov    %esp,%ebp
f0100f22:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0100f25:	83 ec 0c             	sub    $0xc,%esp
f0100f28:	ff 75 08             	pushl  0x8(%ebp)
f0100f2b:	e8 19 ff ff ff       	call   f0100e49 <cputchar>
f0100f30:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0100f33:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f36:	8b 00                	mov    (%eax),%eax
f0100f38:	8d 50 01             	lea    0x1(%eax),%edx
f0100f3b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f3e:	89 10                	mov    %edx,(%eax)
}
f0100f40:	90                   	nop
f0100f41:	c9                   	leave  
f0100f42:	c3                   	ret    

f0100f43 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0100f43:	55                   	push   %ebp
f0100f44:	89 e5                	mov    %esp,%ebp
f0100f46:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0100f49:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0100f50:	ff 75 0c             	pushl  0xc(%ebp)
f0100f53:	ff 75 08             	pushl  0x8(%ebp)
f0100f56:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0100f59:	50                   	push   %eax
f0100f5a:	68 1f 0f 10 f0       	push   $0xf0100f1f
f0100f5f:	e8 2b ef 01 00       	call   f011fe8f <vprintfmt>
f0100f64:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0100f67:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100f6a:	c9                   	leave  
f0100f6b:	c3                   	ret    

f0100f6c <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0100f6c:	55                   	push   %ebp
f0100f6d:	89 e5                	mov    %esp,%ebp
f0100f6f:	83 ec 18             	sub    $0x18,%esp
	//2024 - better to use locks instead (to support multiprocessors)
	int cnt;
	pushcli();	//disable interrupts
f0100f72:	e8 67 5f 00 00       	call   f0106ede <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0100f77:	8d 45 0c             	lea    0xc(%ebp),%eax
f0100f7a:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0100f7d:	8b 45 08             	mov    0x8(%ebp),%eax
f0100f80:	83 ec 08             	sub    $0x8,%esp
f0100f83:	ff 75 f4             	pushl  -0xc(%ebp)
f0100f86:	50                   	push   %eax
f0100f87:	e8 b7 ff ff ff       	call   f0100f43 <vcprintf>
f0100f8c:	83 c4 10             	add    $0x10,%esp
f0100f8f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0100f92:	e8 99 5f 00 00       	call   f0106f30 <popcli>

	return cnt;
f0100f97:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0100f9a:	c9                   	leave  
f0100f9b:	c3                   	ret    

f0100f9c <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0100f9c:	55                   	push   %ebp
f0100f9d:	89 e5                	mov    %esp,%ebp
f0100f9f:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0100fa2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0100fa9:	eb 10                	jmp    f0100fbb <clearandwritecommand+0x1f>
		cputchar('\b');
f0100fab:	83 ec 0c             	sub    $0xc,%esp
f0100fae:	6a 08                	push   $0x8
f0100fb0:	e8 94 fe ff ff       	call   f0100e49 <cputchar>
f0100fb5:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f0100fb8:	ff 45 f4             	incl   -0xc(%ebp)
f0100fbb:	8b 45 08             	mov    0x8(%ebp),%eax
f0100fbe:	8b 00                	mov    (%eax),%eax
f0100fc0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100fc3:	7f e6                	jg     f0100fab <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f0100fc5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100fc8:	c1 e0 0a             	shl    $0xa,%eax
f0100fcb:	05 a0 e2 56 f0       	add    $0xf056e2a0,%eax
f0100fd0:	83 ec 0c             	sub    $0xc,%esp
f0100fd3:	50                   	push   %eax
f0100fd4:	e8 78 f5 01 00       	call   f0120551 <strlen>
f0100fd9:	83 c4 10             	add    $0x10,%esp
f0100fdc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f0100fdf:	83 ec 04             	sub    $0x4,%esp
f0100fe2:	68 00 04 00 00       	push   $0x400
f0100fe7:	68 c0 32 57 f0       	push   $0xf05732c0
f0100fec:	ff 75 10             	pushl  0x10(%ebp)
f0100fef:	e8 7b f7 01 00       	call   f012076f <memcpy>
f0100ff4:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0100ff7:	8b 45 08             	mov    0x8(%ebp),%eax
f0100ffa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0101000:	eb 52                	jmp    f0101054 <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f0101002:	8b 45 08             	mov    0x8(%ebp),%eax
f0101005:	8b 00                	mov    (%eax),%eax
f0101007:	8b 55 0c             	mov    0xc(%ebp),%edx
f010100a:	c1 e2 0a             	shl    $0xa,%edx
f010100d:	01 d0                	add    %edx,%eax
f010100f:	05 a0 e2 56 f0       	add    $0xf056e2a0,%eax
f0101014:	8a 00                	mov    (%eax),%al
f0101016:	0f be c0             	movsbl %al,%eax
f0101019:	83 ec 0c             	sub    $0xc,%esp
f010101c:	50                   	push   %eax
f010101d:	e8 27 fe ff ff       	call   f0100e49 <cputchar>
f0101022:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f0101025:	8b 45 08             	mov    0x8(%ebp),%eax
f0101028:	8b 00                	mov    (%eax),%eax
f010102a:	89 c2                	mov    %eax,%edx
f010102c:	8b 45 10             	mov    0x10(%ebp),%eax
f010102f:	01 c2                	add    %eax,%edx
f0101031:	8b 45 08             	mov    0x8(%ebp),%eax
f0101034:	8b 00                	mov    (%eax),%eax
f0101036:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0101039:	c1 e1 0a             	shl    $0xa,%ecx
f010103c:	01 c8                	add    %ecx,%eax
f010103e:	05 a0 e2 56 f0       	add    $0xf056e2a0,%eax
f0101043:	8a 00                	mov    (%eax),%al
f0101045:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f0101047:	8b 45 08             	mov    0x8(%ebp),%eax
f010104a:	8b 00                	mov    (%eax),%eax
f010104c:	8d 50 01             	lea    0x1(%eax),%edx
f010104f:	8b 45 08             	mov    0x8(%ebp),%eax
f0101052:	89 10                	mov    %edx,(%eax)
f0101054:	8b 45 08             	mov    0x8(%ebp),%eax
f0101057:	8b 00                	mov    (%eax),%eax
f0101059:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010105c:	7c a4                	jl     f0101002 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f010105e:	8b 45 14             	mov    0x14(%ebp),%eax
f0101061:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101064:	89 10                	mov    %edx,(%eax)
}
f0101066:	90                   	nop
f0101067:	c9                   	leave  
f0101068:	c3                   	ret    

f0101069 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0101069:	55                   	push   %ebp
f010106a:	89 e5                	mov    %esp,%ebp
f010106c:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f010106f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101076:	eb 10                	jmp    f0101088 <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f0101078:	83 ec 0c             	sub    $0xc,%esp
f010107b:	6a 08                	push   $0x8
f010107d:	e8 c7 fd ff ff       	call   f0100e49 <cputchar>
f0101082:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f0101085:	ff 45 f4             	incl   -0xc(%ebp)
f0101088:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010108b:	3b 45 08             	cmp    0x8(%ebp),%eax
f010108e:	7c e8                	jl     f0101078 <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f0101090:	83 ec 0c             	sub    $0xc,%esp
f0101093:	ff 75 0c             	pushl  0xc(%ebp)
f0101096:	e8 b6 f4 01 00       	call   f0120551 <strlen>
f010109b:	83 c4 10             	add    $0x10,%esp
f010109e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f01010a1:	83 ec 04             	sub    $0x4,%esp
f01010a4:	68 00 04 00 00       	push   $0x400
f01010a9:	68 c0 32 57 f0       	push   $0xf05732c0
f01010ae:	ff 75 10             	pushl  0x10(%ebp)
f01010b1:	e8 b9 f6 01 00       	call   f012076f <memcpy>
f01010b6:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f01010b9:	8b 45 14             	mov    0x14(%ebp),%eax
f01010bc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01010c2:	eb 46                	jmp    f010110a <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f01010c4:	8b 45 14             	mov    0x14(%ebp),%eax
f01010c7:	8b 00                	mov    (%eax),%eax
f01010c9:	89 c2                	mov    %eax,%edx
f01010cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010ce:	01 d0                	add    %edx,%eax
f01010d0:	8a 00                	mov    (%eax),%al
f01010d2:	0f be c0             	movsbl %al,%eax
f01010d5:	83 ec 0c             	sub    $0xc,%esp
f01010d8:	50                   	push   %eax
f01010d9:	e8 6b fd ff ff       	call   f0100e49 <cputchar>
f01010de:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f01010e1:	8b 45 14             	mov    0x14(%ebp),%eax
f01010e4:	8b 00                	mov    (%eax),%eax
f01010e6:	89 c2                	mov    %eax,%edx
f01010e8:	8b 45 10             	mov    0x10(%ebp),%eax
f01010eb:	01 c2                	add    %eax,%edx
f01010ed:	8b 45 14             	mov    0x14(%ebp),%eax
f01010f0:	8b 00                	mov    (%eax),%eax
f01010f2:	89 c1                	mov    %eax,%ecx
f01010f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010f7:	01 c8                	add    %ecx,%eax
f01010f9:	8a 00                	mov    (%eax),%al
f01010fb:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f01010fd:	8b 45 14             	mov    0x14(%ebp),%eax
f0101100:	8b 00                	mov    (%eax),%eax
f0101102:	8d 50 01             	lea    0x1(%eax),%edx
f0101105:	8b 45 14             	mov    0x14(%ebp),%eax
f0101108:	89 10                	mov    %edx,(%eax)
f010110a:	8b 45 14             	mov    0x14(%ebp),%eax
f010110d:	8b 00                	mov    (%eax),%eax
f010110f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0101112:	7c b0                	jl     f01010c4 <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f0101114:	8b 45 18             	mov    0x18(%ebp),%eax
f0101117:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010111a:	89 10                	mov    %edx,(%eax)
}
f010111c:	90                   	nop
f010111d:	c9                   	leave  
f010111e:	c3                   	ret    

f010111f <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f010111f:	55                   	push   %ebp
f0101120:	89 e5                	mov    %esp,%ebp
f0101122:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f0101125:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010112c:	eb 21                	jmp    f010114f <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f010112e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101131:	c1 e0 0a             	shl    $0xa,%eax
f0101134:	05 a0 52 55 f0       	add    $0xf05552a0,%eax
f0101139:	83 ec 04             	sub    $0x4,%esp
f010113c:	68 00 04 00 00       	push   $0x400
f0101141:	6a 00                	push   $0x0
f0101143:	50                   	push   %eax
f0101144:	e8 f6 f5 01 00       	call   f012073f <memset>
f0101149:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f010114c:	ff 45 f4             	incl   -0xc(%ebp)
f010114f:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f0101153:	7e d9                	jle    f010112e <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f0101155:	90                   	nop
f0101156:	c9                   	leave  
f0101157:	c3                   	ret    

f0101158 <command_prompt_readline>:

void command_prompt_readline(const char *prompt, char* buf) {
f0101158:	55                   	push   %ebp
f0101159:	89 e5                	mov    %esp,%ebp
f010115b:	57                   	push   %edi
f010115c:	53                   	push   %ebx
f010115d:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f0101163:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0101167:	74 13                	je     f010117c <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0101169:	83 ec 08             	sub    $0x8,%esp
f010116c:	ff 75 08             	pushl  0x8(%ebp)
f010116f:	68 ec 1a 12 f0       	push   $0xf0121aec
f0101174:	e8 f3 fd ff ff       	call   f0100f6c <cprintf>
f0101179:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f010117c:	a1 30 95 17 f0       	mov    0xf0179530,%eax
f0101181:	40                   	inc    %eax
f0101182:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f0101185:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f010118c:	00 00 00 
f010118f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101195:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f010119b:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f01011a4:	83 ec 0c             	sub    $0xc,%esp
f01011a7:	6a 00                	push   $0x0
f01011a9:	e8 cb fc ff ff       	call   f0100e79 <iscons>
f01011ae:	83 c4 10             	add    $0x10,%esp
f01011b1:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f01011b4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f01011bb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f01011c2:	e8 99 fc ff ff       	call   f0100e60 <getchar>
f01011c7:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f01011ca:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f01011d0:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011d6:	39 c2                	cmp    %eax,%edx
f01011d8:	7e 0c                	jle    f01011e6 <command_prompt_readline+0x8e>
			lastIndex = i;
f01011da:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011e0:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f01011e6:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f01011ea:	79 22                	jns    f010120e <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f01011ec:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f01011f0:	0f 84 94 0a 00 00    	je     f0101c8a <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f01011f6:	83 ec 08             	sub    $0x8,%esp
f01011f9:	ff 75 94             	pushl  -0x6c(%ebp)
f01011fc:	68 ef 1a 12 f0       	push   $0xf0121aef
f0101201:	e8 66 fd ff ff       	call   f0100f6c <cprintf>
f0101206:	83 c4 10             	add    $0x10,%esp
			return;
f0101209:	e9 7c 0a 00 00       	jmp    f0101c8a <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f010120e:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f0101215:	75 2a                	jne    f0101241 <command_prompt_readline+0xe9>
			if (commandidx)
f0101217:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010121b:	74 03                	je     f0101220 <command_prompt_readline+0xc8>
				commandidx--;
f010121d:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101220:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101226:	50                   	push   %eax
f0101227:	ff 75 0c             	pushl  0xc(%ebp)
f010122a:	ff 75 f4             	pushl  -0xc(%ebp)
f010122d:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101233:	50                   	push   %eax
f0101234:	e8 63 fd ff ff       	call   f0100f9c <clearandwritecommand>
f0101239:	83 c4 10             	add    $0x10,%esp
f010123c:	e9 32 0a 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f0101241:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f0101248:	75 3b                	jne    f0101285 <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f010124a:	a1 30 95 17 f0       	mov    0xf0179530,%eax
f010124f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0101252:	7d 03                	jge    f0101257 <command_prompt_readline+0xff>
				commandidx++;
f0101254:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f0101257:	a1 30 95 17 f0       	mov    0xf0179530,%eax
f010125c:	85 c0                	test   %eax,%eax
f010125e:	0f 88 0f 0a 00 00    	js     f0101c73 <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101264:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f010126a:	50                   	push   %eax
f010126b:	ff 75 0c             	pushl  0xc(%ebp)
f010126e:	ff 75 f4             	pushl  -0xc(%ebp)
f0101271:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101277:	50                   	push   %eax
f0101278:	e8 1f fd ff ff       	call   f0100f9c <clearandwritecommand>
f010127d:	83 c4 10             	add    $0x10,%esp
f0101280:	e9 ee 09 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f0101285:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f0101289:	0f 85 6d 07 00 00    	jne    f01019fc <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f010128f:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f0101293:	0f 84 fc 06 00 00    	je     f0101995 <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f0101299:	83 ec 08             	sub    $0x8,%esp
f010129c:	6a 64                	push   $0x64
f010129e:	68 a0 52 55 f0       	push   $0xf05552a0
f01012a3:	e8 77 fe ff ff       	call   f010111f <clear_prefix_list>
f01012a8:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f01012ab:	83 ec 0c             	sub    $0xc,%esp
f01012ae:	ff 75 0c             	pushl  0xc(%ebp)
f01012b1:	e8 9b f2 01 00       	call   f0120551 <strlen>
f01012b6:	83 c4 10             	add    $0x10,%esp
f01012b9:	85 c0                	test   %eax,%eax
f01012bb:	0f 84 bd 09 00 00    	je     f0101c7e <command_prompt_readline+0xb26>
f01012c1:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f01012c8:	0f 84 b0 09 00 00    	je     f0101c7e <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f01012ce:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01012d5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01012d8:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f01012de:	83 ec 08             	sub    $0x8,%esp
f01012e1:	ff 75 0c             	pushl  0xc(%ebp)
f01012e4:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01012ea:	50                   	push   %eax
f01012eb:	e8 b0 f2 01 00       	call   f01205a0 <strcpy>
f01012f0:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f01012f3:	83 ec 0c             	sub    $0xc,%esp
f01012f6:	ff 75 0c             	pushl  0xc(%ebp)
f01012f9:	e8 53 f2 01 00       	call   f0120551 <strlen>
f01012fe:	83 c4 10             	add    $0x10,%esp
f0101301:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f0101304:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101307:	8d 50 ff             	lea    -0x1(%eax),%edx
f010130a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010130d:	01 d0                	add    %edx,%eax
f010130f:	8a 00                	mov    (%eax),%al
f0101311:	3c 20                	cmp    $0x20,%al
f0101313:	0f 84 6b 09 00 00    	je     f0101c84 <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f0101319:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f010131f:	50                   	push   %eax
f0101320:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f0101326:	50                   	push   %eax
f0101327:	68 ff 1a 12 f0       	push   $0xf0121aff
f010132c:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101332:	50                   	push   %eax
f0101333:	e8 2e f8 01 00       	call   f0120b66 <strsplit>
f0101338:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f010133b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f0101342:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101348:	83 f8 01             	cmp    $0x1,%eax
f010134b:	0f 8e 28 01 00 00    	jle    f0101479 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f0101351:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101357:	83 ec 08             	sub    $0x8,%esp
f010135a:	68 04 1b 12 f0       	push   $0xf0121b04
f010135f:	50                   	push   %eax
f0101360:	e8 f8 f2 01 00       	call   f012065d <strcmp>
f0101365:	83 c4 10             	add    $0x10,%esp
f0101368:	85 c0                	test   %eax,%eax
f010136a:	74 3c                	je     f01013a8 <command_prompt_readline+0x250>
f010136c:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101372:	83 ec 08             	sub    $0x8,%esp
f0101375:	68 08 1b 12 f0       	push   $0xf0121b08
f010137a:	50                   	push   %eax
f010137b:	e8 dd f2 01 00       	call   f012065d <strcmp>
f0101380:	83 c4 10             	add    $0x10,%esp
f0101383:	85 c0                	test   %eax,%eax
f0101385:	74 21                	je     f01013a8 <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f0101387:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f010138d:	83 ec 08             	sub    $0x8,%esp
f0101390:	68 0d 1b 12 f0       	push   $0xf0121b0d
f0101395:	50                   	push   %eax
f0101396:	e8 c2 f2 01 00       	call   f012065d <strcmp>
f010139b:	83 c4 10             	add    $0x10,%esp
f010139e:	85 c0                	test   %eax,%eax
f01013a0:	74 06                	je     f01013a8 <command_prompt_readline+0x250>
						continue;
f01013a2:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f01013a3:	e9 d6 08 00 00       	jmp    f0101c7e <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f01013a8:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013ae:	83 ec 08             	sub    $0x8,%esp
f01013b1:	68 0d 1b 12 f0       	push   $0xf0121b0d
f01013b6:	50                   	push   %eax
f01013b7:	e8 a1 f2 01 00       	call   f012065d <strcmp>
f01013bc:	83 c4 10             	add    $0x10,%esp
f01013bf:	85 c0                	test   %eax,%eax
f01013c1:	75 09                	jne    f01013cc <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f01013c3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f01013ca:	eb 07                	jmp    f01013d3 <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f01013cc:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f01013d3:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01013da:	00 00 00 
f01013dd:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01013e3:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01013e8:	b8 00 00 00 00       	mov    $0x0,%eax
f01013ed:	89 d7                	mov    %edx,%edi
f01013ef:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f01013f1:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01013f7:	48                   	dec    %eax
f01013f8:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f01013ff:	83 ec 0c             	sub    $0xc,%esp
f0101402:	50                   	push   %eax
f0101403:	e8 49 f1 01 00       	call   f0120551 <strlen>
f0101408:	83 c4 10             	add    $0x10,%esp
f010140b:	8b 55 90             	mov    -0x70(%ebp),%edx
f010140e:	29 c2                	sub    %eax,%edx
f0101410:	89 d0                	mov    %edx,%eax
f0101412:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f0101415:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010141c:	eb 1d                	jmp    f010143b <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f010141e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101421:	8d 50 01             	lea    0x1(%eax),%edx
f0101424:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0101427:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f010142a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010142d:	01 ca                	add    %ecx,%edx
f010142f:	8a 12                	mov    (%edx),%dl
f0101431:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f0101438:	ff 45 d8             	incl   -0x28(%ebp)
f010143b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010143e:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0101441:	7c db                	jl     f010141e <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f0101443:	83 ec 08             	sub    $0x8,%esp
f0101446:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010144c:	50                   	push   %eax
f010144d:	ff 75 0c             	pushl  0xc(%ebp)
f0101450:	e8 4b f1 01 00       	call   f01205a0 <strcpy>
f0101455:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f0101458:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010145e:	48                   	dec    %eax
f010145f:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f0101466:	83 ec 08             	sub    $0x8,%esp
f0101469:	50                   	push   %eax
f010146a:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101470:	50                   	push   %eax
f0101471:	e8 2a f1 01 00       	call   f01205a0 <strcpy>
f0101476:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0101479:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f0101480:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101486:	83 f8 01             	cmp    $0x1,%eax
f0101489:	0f 85 30 01 00 00    	jne    f01015bf <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f010148f:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f0101496:	e9 0f 01 00 00       	jmp    f01015aa <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f010149b:	83 ec 0c             	sub    $0xc,%esp
f010149e:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014a4:	50                   	push   %eax
f01014a5:	e8 a7 f0 01 00       	call   f0120551 <strlen>
f01014aa:	83 c4 10             	add    $0x10,%esp
f01014ad:	89 c1                	mov    %eax,%ecx
f01014af:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01014b2:	89 d0                	mov    %edx,%eax
f01014b4:	01 c0                	add    %eax,%eax
f01014b6:	01 d0                	add    %edx,%eax
f01014b8:	c1 e0 03             	shl    $0x3,%eax
f01014bb:	05 40 95 17 f0       	add    $0xf0179540,%eax
f01014c0:	8b 00                	mov    (%eax),%eax
f01014c2:	83 ec 04             	sub    $0x4,%esp
f01014c5:	51                   	push   %ecx
f01014c6:	50                   	push   %eax
f01014c7:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014cd:	50                   	push   %eax
f01014ce:	e8 c2 f1 01 00       	call   f0120695 <strncmp>
f01014d3:	83 c4 10             	add    $0x10,%esp
f01014d6:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f01014d9:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f01014dd:	0f 85 c4 00 00 00    	jne    f01015a7 <command_prompt_readline+0x44f>
							it_str = -1;
f01014e3:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f01014ea:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01014f1:	00 00 00 
f01014f4:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01014fa:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01014ff:	b8 00 00 00 00       	mov    $0x0,%eax
f0101504:	89 d7                	mov    %edx,%edi
f0101506:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f0101508:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010150f:	eb 2d                	jmp    f010153e <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f0101511:	ff 45 dc             	incl   -0x24(%ebp)
f0101514:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101517:	89 d0                	mov    %edx,%eax
f0101519:	01 c0                	add    %eax,%eax
f010151b:	01 d0                	add    %edx,%eax
f010151d:	c1 e0 03             	shl    $0x3,%eax
f0101520:	05 40 95 17 f0       	add    $0xf0179540,%eax
f0101525:	8b 10                	mov    (%eax),%edx
f0101527:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010152a:	01 d0                	add    %edx,%eax
f010152c:	8a 00                	mov    (%eax),%al
f010152e:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101534:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101537:	01 ca                	add    %ecx,%edx
f0101539:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f010153b:	ff 45 cc             	incl   -0x34(%ebp)
f010153e:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101541:	89 d0                	mov    %edx,%eax
f0101543:	01 c0                	add    %eax,%eax
f0101545:	01 d0                	add    %edx,%eax
f0101547:	c1 e0 03             	shl    $0x3,%eax
f010154a:	05 40 95 17 f0       	add    $0xf0179540,%eax
f010154f:	8b 00                	mov    (%eax),%eax
f0101551:	83 ec 0c             	sub    $0xc,%esp
f0101554:	50                   	push   %eax
f0101555:	e8 f7 ef 01 00       	call   f0120551 <strlen>
f010155a:	83 c4 10             	add    $0x10,%esp
f010155d:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f0101560:	7f af                	jg     f0101511 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0101562:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101565:	c1 e0 0a             	shl    $0xa,%eax
f0101568:	05 a0 52 55 f0       	add    $0xf05552a0,%eax
f010156d:	83 ec 04             	sub    $0x4,%esp
f0101570:	68 00 04 00 00       	push   $0x400
f0101575:	6a 00                	push   $0x0
f0101577:	50                   	push   %eax
f0101578:	e8 c2 f1 01 00       	call   f012073f <memset>
f010157d:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101580:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101583:	40                   	inc    %eax
f0101584:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0101587:	c1 e2 0a             	shl    $0xa,%edx
f010158a:	81 c2 a0 52 55 f0    	add    $0xf05552a0,%edx
f0101590:	83 ec 04             	sub    $0x4,%esp
f0101593:	50                   	push   %eax
f0101594:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010159a:	50                   	push   %eax
f010159b:	52                   	push   %edx
f010159c:	e8 2d f0 01 00       	call   f01205ce <strncpy>
f01015a1:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f01015a4:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01015a7:	ff 45 d0             	incl   -0x30(%ebp)
f01015aa:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01015ad:	a1 60 99 17 f0       	mov    0xf0179960,%eax
f01015b2:	39 c2                	cmp    %eax,%edx
f01015b4:	0f 82 e1 fe ff ff    	jb     f010149b <command_prompt_readline+0x343>
f01015ba:	e9 fe 02 00 00       	jmp    f01018bd <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f01015bf:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01015c3:	0f 84 7b 01 00 00    	je     f0101744 <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01015c9:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f01015d0:	e9 5c 01 00 00       	jmp    f0101731 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f01015d5:	83 ec 0c             	sub    $0xc,%esp
f01015d8:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01015de:	50                   	push   %eax
f01015df:	e8 6d ef 01 00       	call   f0120551 <strlen>
f01015e4:	83 c4 10             	add    $0x10,%esp
f01015e7:	89 c1                	mov    %eax,%ecx
f01015e9:	8b 1d a4 9c 17 f0    	mov    0xf0179ca4,%ebx
f01015ef:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01015f2:	89 d0                	mov    %edx,%eax
f01015f4:	01 c0                	add    %eax,%eax
f01015f6:	01 d0                	add    %edx,%eax
f01015f8:	c1 e0 02             	shl    $0x2,%eax
f01015fb:	01 d8                	add    %ebx,%eax
f01015fd:	8b 00                	mov    (%eax),%eax
f01015ff:	83 ec 04             	sub    $0x4,%esp
f0101602:	51                   	push   %ecx
f0101603:	50                   	push   %eax
f0101604:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010160a:	50                   	push   %eax
f010160b:	e8 85 f0 01 00       	call   f0120695 <strncmp>
f0101610:	83 c4 10             	add    $0x10,%esp
f0101613:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f0101616:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f010161a:	0f 85 0e 01 00 00    	jne    f010172e <command_prompt_readline+0x5d6>
								it_str = -1;
f0101620:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0101627:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f010162e:	00 00 00 
f0101631:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101637:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010163c:	b8 00 00 00 00       	mov    $0x0,%eax
f0101641:	89 d7                	mov    %edx,%edi
f0101643:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f0101645:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010164b:	83 f8 01             	cmp    $0x1,%eax
f010164e:	7e 39                	jle    f0101689 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101650:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0101657:	eb 1d                	jmp    f0101676 <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0101659:	ff 45 dc             	incl   -0x24(%ebp)
f010165c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010165f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101662:	01 d0                	add    %edx,%eax
f0101664:	8a 00                	mov    (%eax),%al
f0101666:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010166c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010166f:	01 ca                	add    %ecx,%edx
f0101671:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101673:	ff 45 c4             	incl   -0x3c(%ebp)
f0101676:	83 ec 0c             	sub    $0xc,%esp
f0101679:	ff 75 0c             	pushl  0xc(%ebp)
f010167c:	e8 d0 ee 01 00       	call   f0120551 <strlen>
f0101681:	83 c4 10             	add    $0x10,%esp
f0101684:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0101687:	7f d0                	jg     f0101659 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f0101689:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f0101690:	eb 30                	jmp    f01016c2 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f0101692:	ff 45 dc             	incl   -0x24(%ebp)
f0101695:	8b 0d a4 9c 17 f0    	mov    0xf0179ca4,%ecx
f010169b:	8b 55 c8             	mov    -0x38(%ebp),%edx
f010169e:	89 d0                	mov    %edx,%eax
f01016a0:	01 c0                	add    %eax,%eax
f01016a2:	01 d0                	add    %edx,%eax
f01016a4:	c1 e0 02             	shl    $0x2,%eax
f01016a7:	01 c8                	add    %ecx,%eax
f01016a9:	8b 10                	mov    (%eax),%edx
f01016ab:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01016ae:	01 d0                	add    %edx,%eax
f01016b0:	8a 00                	mov    (%eax),%al
f01016b2:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01016b8:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01016bb:	01 ca                	add    %ecx,%edx
f01016bd:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016bf:	ff 45 c0             	incl   -0x40(%ebp)
f01016c2:	8b 0d a4 9c 17 f0    	mov    0xf0179ca4,%ecx
f01016c8:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016cb:	89 d0                	mov    %edx,%eax
f01016cd:	01 c0                	add    %eax,%eax
f01016cf:	01 d0                	add    %edx,%eax
f01016d1:	c1 e0 02             	shl    $0x2,%eax
f01016d4:	01 c8                	add    %ecx,%eax
f01016d6:	8b 00                	mov    (%eax),%eax
f01016d8:	83 ec 0c             	sub    $0xc,%esp
f01016db:	50                   	push   %eax
f01016dc:	e8 70 ee 01 00       	call   f0120551 <strlen>
f01016e1:	83 c4 10             	add    $0x10,%esp
f01016e4:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f01016e7:	7f a9                	jg     f0101692 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f01016e9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01016ec:	c1 e0 0a             	shl    $0xa,%eax
f01016ef:	05 a0 52 55 f0       	add    $0xf05552a0,%eax
f01016f4:	83 ec 04             	sub    $0x4,%esp
f01016f7:	68 00 04 00 00       	push   $0x400
f01016fc:	6a 00                	push   $0x0
f01016fe:	50                   	push   %eax
f01016ff:	e8 3b f0 01 00       	call   f012073f <memset>
f0101704:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101707:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010170a:	40                   	inc    %eax
f010170b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010170e:	c1 e2 0a             	shl    $0xa,%edx
f0101711:	81 c2 a0 52 55 f0    	add    $0xf05552a0,%edx
f0101717:	83 ec 04             	sub    $0x4,%esp
f010171a:	50                   	push   %eax
f010171b:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0101721:	50                   	push   %eax
f0101722:	52                   	push   %edx
f0101723:	e8 a6 ee 01 00       	call   f01205ce <strncpy>
f0101728:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f010172b:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f010172e:	ff 45 c8             	incl   -0x38(%ebp)
f0101731:	a1 a8 9c 17 f0       	mov    0xf0179ca8,%eax
f0101736:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f0101739:	0f 8c 96 fe ff ff    	jl     f01015d5 <command_prompt_readline+0x47d>
f010173f:	e9 79 01 00 00       	jmp    f01018bd <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f0101744:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0101748:	0f 84 6f 01 00 00    	je     f01018bd <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f010174e:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0101755:	e9 53 01 00 00       	jmp    f01018ad <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f010175a:	83 ec 0c             	sub    $0xc,%esp
f010175d:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101763:	50                   	push   %eax
f0101764:	e8 e8 ed 01 00       	call   f0120551 <strlen>
f0101769:	83 c4 10             	add    $0x10,%esp
f010176c:	89 c1                	mov    %eax,%ecx
f010176e:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101771:	89 d0                	mov    %edx,%eax
f0101773:	01 c0                	add    %eax,%eax
f0101775:	01 d0                	add    %edx,%eax
f0101777:	c1 e0 02             	shl    $0x2,%eax
f010177a:	05 c0 9c 17 f0       	add    $0xf0179cc0,%eax
f010177f:	8b 00                	mov    (%eax),%eax
f0101781:	83 ec 04             	sub    $0x4,%esp
f0101784:	51                   	push   %ecx
f0101785:	50                   	push   %eax
f0101786:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010178c:	50                   	push   %eax
f010178d:	e8 03 ef 01 00       	call   f0120695 <strncmp>
f0101792:	83 c4 10             	add    $0x10,%esp
f0101795:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f0101798:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f010179c:	0f 85 08 01 00 00    	jne    f01018aa <command_prompt_readline+0x752>
								it_str = -1;
f01017a2:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01017a9:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01017b0:	00 00 00 
f01017b3:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01017b9:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01017be:	b8 00 00 00 00       	mov    $0x0,%eax
f01017c3:	89 d7                	mov    %edx,%edi
f01017c5:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01017c7:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01017cd:	83 f8 01             	cmp    $0x1,%eax
f01017d0:	7e 39                	jle    f010180b <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017d2:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f01017d9:	eb 1d                	jmp    f01017f8 <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f01017db:	ff 45 dc             	incl   -0x24(%ebp)
f01017de:	8b 55 b8             	mov    -0x48(%ebp),%edx
f01017e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01017e4:	01 d0                	add    %edx,%eax
f01017e6:	8a 00                	mov    (%eax),%al
f01017e8:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01017ee:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01017f1:	01 ca                	add    %ecx,%edx
f01017f3:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017f5:	ff 45 b8             	incl   -0x48(%ebp)
f01017f8:	83 ec 0c             	sub    $0xc,%esp
f01017fb:	ff 75 0c             	pushl  0xc(%ebp)
f01017fe:	e8 4e ed 01 00       	call   f0120551 <strlen>
f0101803:	83 c4 10             	add    $0x10,%esp
f0101806:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0101809:	7f d0                	jg     f01017db <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010180b:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f0101812:	eb 2d                	jmp    f0101841 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f0101814:	ff 45 dc             	incl   -0x24(%ebp)
f0101817:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010181a:	89 d0                	mov    %edx,%eax
f010181c:	01 c0                	add    %eax,%eax
f010181e:	01 d0                	add    %edx,%eax
f0101820:	c1 e0 02             	shl    $0x2,%eax
f0101823:	05 c0 9c 17 f0       	add    $0xf0179cc0,%eax
f0101828:	8b 10                	mov    (%eax),%edx
f010182a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010182d:	01 d0                	add    %edx,%eax
f010182f:	8a 00                	mov    (%eax),%al
f0101831:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101837:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010183a:	01 ca                	add    %ecx,%edx
f010183c:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010183e:	ff 45 b4             	incl   -0x4c(%ebp)
f0101841:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101844:	89 d0                	mov    %edx,%eax
f0101846:	01 c0                	add    %eax,%eax
f0101848:	01 d0                	add    %edx,%eax
f010184a:	c1 e0 02             	shl    $0x2,%eax
f010184d:	05 c0 9c 17 f0       	add    $0xf0179cc0,%eax
f0101852:	8b 00                	mov    (%eax),%eax
f0101854:	83 ec 0c             	sub    $0xc,%esp
f0101857:	50                   	push   %eax
f0101858:	e8 f4 ec 01 00       	call   f0120551 <strlen>
f010185d:	83 c4 10             	add    $0x10,%esp
f0101860:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0101863:	7f af                	jg     f0101814 <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101865:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101868:	c1 e0 0a             	shl    $0xa,%eax
f010186b:	05 a0 52 55 f0       	add    $0xf05552a0,%eax
f0101870:	83 ec 04             	sub    $0x4,%esp
f0101873:	68 00 04 00 00       	push   $0x400
f0101878:	6a 00                	push   $0x0
f010187a:	50                   	push   %eax
f010187b:	e8 bf ee 01 00       	call   f012073f <memset>
f0101880:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101883:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101886:	40                   	inc    %eax
f0101887:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010188a:	c1 e2 0a             	shl    $0xa,%edx
f010188d:	81 c2 a0 52 55 f0    	add    $0xf05552a0,%edx
f0101893:	83 ec 04             	sub    $0x4,%esp
f0101896:	50                   	push   %eax
f0101897:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010189d:	50                   	push   %eax
f010189e:	52                   	push   %edx
f010189f:	e8 2a ed 01 00       	call   f01205ce <strncpy>
f01018a4:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01018a7:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01018aa:	ff 45 bc             	incl   -0x44(%ebp)
f01018ad:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01018b0:	a1 74 9d 17 f0       	mov    0xf0179d74,%eax
f01018b5:	39 c2                	cmp    %eax,%edx
f01018b7:	0f 82 9d fe ff ff    	jb     f010175a <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f01018bd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01018c0:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f01018c3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01018c7:	0f 84 a6 03 00 00    	je     f0101c73 <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f01018cd:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01018d4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018da:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f01018e1:	eb 1f                	jmp    f0101902 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f01018e3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018e6:	8d 50 01             	lea    0x1(%eax),%edx
f01018e9:	89 55 dc             	mov    %edx,-0x24(%ebp)
f01018ec:	89 c2                	mov    %eax,%edx
f01018ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f01018f1:	01 c2                	add    %eax,%edx
f01018f3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01018f6:	05 a0 52 55 f0       	add    $0xf05552a0,%eax
f01018fb:	8a 00                	mov    (%eax),%al
f01018fd:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018ff:	ff 45 b0             	incl   -0x50(%ebp)
f0101902:	83 ec 0c             	sub    $0xc,%esp
f0101905:	68 a0 52 55 f0       	push   $0xf05552a0
f010190a:	e8 42 ec 01 00       	call   f0120551 <strlen>
f010190f:	83 c4 10             	add    $0x10,%esp
f0101912:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0101915:	7f cc                	jg     f01018e3 <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0101917:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f010191e:	eb 10                	jmp    f0101930 <command_prompt_readline+0x7d8>
						cputchar('\b');}
f0101920:	83 ec 0c             	sub    $0xc,%esp
f0101923:	6a 08                	push   $0x8
f0101925:	e8 1f f5 ff ff       	call   f0100e49 <cputchar>
f010192a:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f010192d:	ff 45 ac             	incl   -0x54(%ebp)
f0101930:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0101933:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0101936:	7c e8                	jl     f0101920 <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101938:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f010193f:	eb 1c                	jmp    f010195d <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0101941:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0101944:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101947:	01 d0                	add    %edx,%eax
f0101949:	8a 00                	mov    (%eax),%al
f010194b:	0f be c0             	movsbl %al,%eax
f010194e:	83 ec 0c             	sub    $0xc,%esp
f0101951:	50                   	push   %eax
f0101952:	e8 f2 f4 ff ff       	call   f0100e49 <cputchar>
f0101957:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f010195a:	ff 45 a8             	incl   -0x58(%ebp)
f010195d:	83 ec 0c             	sub    $0xc,%esp
f0101960:	ff 75 0c             	pushl  0xc(%ebp)
f0101963:	e8 e9 eb 01 00       	call   f0120551 <strlen>
f0101968:	83 c4 10             	add    $0x10,%esp
f010196b:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f010196e:	7f d1                	jg     f0101941 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f0101970:	83 ec 0c             	sub    $0xc,%esp
f0101973:	ff 75 0c             	pushl  0xc(%ebp)
f0101976:	e8 d6 eb 01 00       	call   f0120551 <strlen>
f010197b:	83 c4 10             	add    $0x10,%esp
f010197e:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101984:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010198a:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101990:	e9 de 02 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f0101995:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0101999:	0f 8e d4 02 00 00    	jle    f0101c73 <command_prompt_readline+0xb1b>
f010199f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019a2:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f01019a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019ab:	40                   	inc    %eax
f01019ac:	99                   	cltd   
f01019ad:	f7 7d ec             	idivl  -0x14(%ebp)
f01019b0:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f01019b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019b6:	c1 e0 0a             	shl    $0xa,%eax
f01019b9:	8d 98 a0 52 55 f0    	lea    -0xfaaad60(%eax),%ebx
f01019bf:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f01019c5:	c1 e0 0a             	shl    $0xa,%eax
f01019c8:	05 a0 52 55 f0       	add    $0xf05552a0,%eax
f01019cd:	83 ec 0c             	sub    $0xc,%esp
f01019d0:	50                   	push   %eax
f01019d1:	e8 7b eb 01 00       	call   f0120551 <strlen>
f01019d6:	83 c4 10             	add    $0x10,%esp
f01019d9:	83 ec 0c             	sub    $0xc,%esp
f01019dc:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f01019e2:	52                   	push   %edx
f01019e3:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f01019e9:	52                   	push   %edx
f01019ea:	ff 75 0c             	pushl  0xc(%ebp)
f01019ed:	53                   	push   %ebx
f01019ee:	50                   	push   %eax
f01019ef:	e8 75 f6 ff ff       	call   f0101069 <RoundAutoCompleteCommandWithTheSamePrefix>
f01019f4:	83 c4 20             	add    $0x20,%esp
f01019f7:	e9 77 02 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f01019fc:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101a03:	75 2e                	jne    f0101a33 <command_prompt_readline+0x8db>
			if (i > 0) {
f0101a05:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a0b:	85 c0                	test   %eax,%eax
f0101a0d:	0f 8e 60 02 00 00    	jle    f0101c73 <command_prompt_readline+0xb1b>
				i--;
f0101a13:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a19:	48                   	dec    %eax
f0101a1a:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a20:	83 ec 0c             	sub    $0xc,%esp
f0101a23:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a26:	e8 1e f4 ff ff       	call   f0100e49 <cputchar>
f0101a2b:	83 c4 10             	add    $0x10,%esp
f0101a2e:	e9 40 02 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0101a33:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101a3a:	75 34                	jne    f0101a70 <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0101a3c:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0101a42:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101a48:	39 c2                	cmp    %eax,%edx
f0101a4a:	0f 8d 23 02 00 00    	jge    f0101c73 <command_prompt_readline+0xb1b>
				i++;
f0101a50:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a56:	40                   	inc    %eax
f0101a57:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a5d:	83 ec 0c             	sub    $0xc,%esp
f0101a60:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a63:	e8 e1 f3 ff ff       	call   f0100e49 <cputchar>
f0101a68:	83 c4 10             	add    $0x10,%esp
f0101a6b:	e9 03 02 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0101a70:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0101a77:	75 4c                	jne    f0101ac5 <command_prompt_readline+0x96d>
f0101a79:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a7f:	85 c0                	test   %eax,%eax
f0101a81:	7e 42                	jle    f0101ac5 <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0101a83:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a89:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0101a8c:	eb 1a                	jmp    f0101aa8 <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0101a8e:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0101a91:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101a94:	01 c2                	add    %eax,%edx
f0101a96:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0101a99:	8d 48 01             	lea    0x1(%eax),%ecx
f0101a9c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101a9f:	01 c8                	add    %ecx,%eax
f0101aa1:	8a 00                	mov    (%eax),%al
f0101aa3:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0101aa5:	ff 45 a4             	incl   -0x5c(%ebp)
f0101aa8:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101aae:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0101ab1:	7e db                	jle    f0101a8e <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0101ab3:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101ab9:	48                   	dec    %eax
f0101aba:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101ac0:	e9 ae 01 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0101ac5:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0101ac9:	7e 60                	jle    f0101b2b <command_prompt_readline+0x9d3>
f0101acb:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101ad1:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0101ad6:	7f 53                	jg     f0101b2b <command_prompt_readline+0x9d3>
f0101ad8:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101adf:	74 4a                	je     f0101b2b <command_prompt_readline+0x9d3>
f0101ae1:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101ae8:	74 41                	je     f0101b2b <command_prompt_readline+0x9d3>
			if (echoing)
f0101aea:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101aee:	74 0e                	je     f0101afe <command_prompt_readline+0x9a6>
				cputchar(c);
f0101af0:	83 ec 0c             	sub    $0xc,%esp
f0101af3:	ff 75 94             	pushl  -0x6c(%ebp)
f0101af6:	e8 4e f3 ff ff       	call   f0100e49 <cputchar>
f0101afb:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0101afe:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b04:	8d 50 01             	lea    0x1(%eax),%edx
f0101b07:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0101b0d:	89 c2                	mov    %eax,%edx
f0101b0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b12:	01 d0                	add    %edx,%eax
f0101b14:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0101b17:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0101b19:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101b1f:	40                   	inc    %eax
f0101b20:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101b26:	e9 48 01 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0101b2b:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0101b2f:	75 60                	jne    f0101b91 <command_prompt_readline+0xa39>
f0101b31:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b37:	85 c0                	test   %eax,%eax
f0101b39:	7e 56                	jle    f0101b91 <command_prompt_readline+0xa39>

			if (echoing)
f0101b3b:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b3f:	74 0e                	je     f0101b4f <command_prompt_readline+0x9f7>
				cputchar(c);
f0101b41:	83 ec 0c             	sub    $0xc,%esp
f0101b44:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b47:	e8 fd f2 ff ff       	call   f0100e49 <cputchar>
f0101b4c:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0101b4f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b55:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0101b58:	eb 1a                	jmp    f0101b74 <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0101b5a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0101b5d:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101b60:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b63:	01 c2                	add    %eax,%edx
f0101b65:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0101b68:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b6b:	01 c8                	add    %ecx,%eax
f0101b6d:	8a 00                	mov    (%eax),%al
f0101b6f:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0101b71:	ff 45 a0             	incl   -0x60(%ebp)
f0101b74:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b7a:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0101b7d:	7e db                	jle    f0101b5a <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0101b7f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b85:	48                   	dec    %eax
f0101b86:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101b8c:	e9 e2 00 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0101b91:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0101b95:	74 0a                	je     f0101ba1 <command_prompt_readline+0xa49>
f0101b97:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0101b9b:	0f 85 d2 00 00 00    	jne    f0101c73 <command_prompt_readline+0xb1b>

			if (echoing)
f0101ba1:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101ba5:	74 0e                	je     f0101bb5 <command_prompt_readline+0xa5d>
				cputchar(c);
f0101ba7:	83 ec 0c             	sub    $0xc,%esp
f0101baa:	ff 75 94             	pushl  -0x6c(%ebp)
f0101bad:	e8 97 f2 ff ff       	call   f0100e49 <cputchar>
f0101bb2:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0101bb5:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101bbb:	89 c2                	mov    %eax,%edx
f0101bbd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101bc0:	01 d0                	add    %edx,%eax
f0101bc2:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0101bc5:	a1 30 95 17 f0       	mov    0xf0179530,%eax
f0101bca:	83 f8 13             	cmp    $0x13,%eax
f0101bcd:	75 56                	jne    f0101c25 <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101bcf:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0101bd6:	eb 2d                	jmp    f0101c05 <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0101bd8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101bdb:	40                   	inc    %eax
f0101bdc:	c1 e0 0a             	shl    $0xa,%eax
f0101bdf:	8d 90 a0 e2 56 f0    	lea    -0xfa91d60(%eax),%edx
f0101be5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101be8:	c1 e0 0a             	shl    $0xa,%eax
f0101beb:	05 a0 e2 56 f0       	add    $0xf056e2a0,%eax
f0101bf0:	83 ec 04             	sub    $0x4,%esp
f0101bf3:	68 00 04 00 00       	push   $0x400
f0101bf8:	52                   	push   %edx
f0101bf9:	50                   	push   %eax
f0101bfa:	e8 70 eb 01 00       	call   f012076f <memcpy>
f0101bff:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101c02:	ff 45 9c             	incl   -0x64(%ebp)
f0101c05:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0101c09:	7e cd                	jle    f0101bd8 <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0101c0b:	83 ec 04             	sub    $0x4,%esp
f0101c0e:	68 00 04 00 00       	push   $0x400
f0101c13:	ff 75 0c             	pushl  0xc(%ebp)
f0101c16:	68 a0 2e 57 f0       	push   $0xf0572ea0
f0101c1b:	e8 4f eb 01 00       	call   f012076f <memcpy>
f0101c20:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c23:	eb 68                	jmp    f0101c8d <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0101c25:	a1 30 95 17 f0       	mov    0xf0179530,%eax
f0101c2a:	c1 e0 0a             	shl    $0xa,%eax
f0101c2d:	05 a0 e2 56 f0       	add    $0xf056e2a0,%eax
f0101c32:	83 ec 08             	sub    $0x8,%esp
f0101c35:	ff 75 0c             	pushl  0xc(%ebp)
f0101c38:	50                   	push   %eax
f0101c39:	e8 1f ea 01 00       	call   f012065d <strcmp>
f0101c3e:	83 c4 10             	add    $0x10,%esp
f0101c41:	85 c0                	test   %eax,%eax
f0101c43:	74 48                	je     f0101c8d <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0101c45:	a1 30 95 17 f0       	mov    0xf0179530,%eax
f0101c4a:	40                   	inc    %eax
f0101c4b:	a3 30 95 17 f0       	mov    %eax,0xf0179530
f0101c50:	a1 30 95 17 f0       	mov    0xf0179530,%eax
f0101c55:	c1 e0 0a             	shl    $0xa,%eax
f0101c58:	05 a0 e2 56 f0       	add    $0xf056e2a0,%eax
f0101c5d:	83 ec 04             	sub    $0x4,%esp
f0101c60:	68 00 04 00 00       	push   $0x400
f0101c65:	ff 75 0c             	pushl  0xc(%ebp)
f0101c68:	50                   	push   %eax
f0101c69:	e8 01 eb 01 00       	call   f012076f <memcpy>
f0101c6e:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0101c71:	eb 1a                	jmp    f0101c8d <command_prompt_readline+0xb35>

		}
		last_c = c;
f0101c73:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0101c76:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101c79:	e9 44 f5 ff ff       	jmp    f01011c2 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0101c7e:	90                   	nop
f0101c7f:	e9 3e f5 ff ff       	jmp    f01011c2 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0101c84:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0101c85:	e9 38 f5 ff ff       	jmp    f01011c2 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0101c8a:	90                   	nop
f0101c8b:	eb 01                	jmp    f0101c8e <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c8d:	90                   	nop

		}
		last_c = c;
	}
}
f0101c8e:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101c91:	5b                   	pop    %ebx
f0101c92:	5f                   	pop    %edi
f0101c93:	5d                   	pop    %ebp
f0101c94:	c3                   	ret    

f0101c95 <run_command_prompt>:
// ******************************************************************
// ******************************************************************

extern bool autograde ;
void run_command_prompt()
{
f0101c95:	55                   	push   %ebp
f0101c96:	89 e5                	mov    %esp,%ebp
f0101c98:	57                   	push   %edi
f0101c99:	56                   	push   %esi
f0101c9a:	53                   	push   %ebx
f0101c9b:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (autograde)
f0101ca1:	a1 dc 51 55 f0       	mov    0xf05551dc,%eax
f0101ca6:	85 c0                	test   %eax,%eax
f0101ca8:	0f 84 85 00 00 00    	je     f0101d33 <run_command_prompt+0x9e>
	{
		char cmd1_2[BUFLEN] = "tst bsd_nice 0";
f0101cae:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101cb4:	bb 17 1b 12 f0       	mov    $0xf0121b17,%ebx
f0101cb9:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101cbe:	89 c7                	mov    %eax,%edi
f0101cc0:	89 de                	mov    %ebx,%esi
f0101cc2:	89 d1                	mov    %edx,%ecx
f0101cc4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101cc6:	8d 95 f7 ef ff ff    	lea    -0x1009(%ebp),%edx
f0101ccc:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cd1:	b0 00                	mov    $0x0,%al
f0101cd3:	89 d7                	mov    %edx,%edi
f0101cd5:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd2_2[BUFLEN] = "tst bsd_nice 1";
f0101cd7:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101cdd:	bb 17 1f 12 f0       	mov    $0xf0121f17,%ebx
f0101ce2:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101ce7:	89 c7                	mov    %eax,%edi
f0101ce9:	89 de                	mov    %ebx,%esi
f0101ceb:	89 d1                	mov    %edx,%ecx
f0101ced:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101cef:	8d 95 f7 f3 ff ff    	lea    -0xc09(%ebp),%edx
f0101cf5:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cfa:	b0 00                	mov    $0x0,%al
f0101cfc:	89 d7                	mov    %edx,%edi
f0101cfe:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd3_2[BUFLEN] = "tst bsd_nice 2";
f0101d00:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101d06:	bb 17 23 12 f0       	mov    $0xf0122317,%ebx
f0101d0b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d10:	89 c7                	mov    %eax,%edi
f0101d12:	89 de                	mov    %ebx,%esi
f0101d14:	89 d1                	mov    %edx,%ecx
f0101d16:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d18:	8d 95 f7 f7 ff ff    	lea    -0x809(%ebp),%edx
f0101d1e:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d23:	b0 00                	mov    $0x0,%al
f0101d25:	89 d7                	mov    %edx,%edi
f0101d27:	f3 aa                	rep stos %al,%es:(%edi)
		//execute_command(cmd3_2);
		autograde = 0;
f0101d29:	c7 05 dc 51 55 f0 00 	movl   $0x0,0xf05551dc
f0101d30:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101d33:	c7 05 6c 51 55 f0 00 	movl   $0x0,0xf055516c
f0101d3a:	00 00 00 
f0101d3d:	c7 05 70 51 55 f0 00 	movl   $0x0,0xf0555170
f0101d44:	00 00 00 
f0101d47:	c7 05 78 51 55 f0 00 	movl   $0x0,0xf0555178
f0101d4e:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101d51:	83 ec 04             	sub    $0x4,%esp
f0101d54:	68 00 04 00 00       	push   $0x400
f0101d59:	6a 00                	push   $0x0
f0101d5b:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d61:	50                   	push   %eax
f0101d62:	e8 d8 e9 01 00       	call   f012073f <memset>
f0101d67:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101d6a:	83 ec 08             	sub    $0x8,%esp
f0101d6d:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d73:	50                   	push   %eax
f0101d74:	68 11 1b 12 f0       	push   $0xf0121b11
f0101d79:	e8 da f3 ff ff       	call   f0101158 <command_prompt_readline>
f0101d7e:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101d81:	83 ec 0c             	sub    $0xc,%esp
f0101d84:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d8a:	50                   	push   %eax
f0101d8b:	e8 4c 01 00 00       	call   f0101edc <execute_command>
f0101d90:	83 c4 10             	add    $0x10,%esp
f0101d93:	85 c0                	test   %eax,%eax
f0101d95:	78 02                	js     f0101d99 <run_command_prompt+0x104>
				break;
	}
f0101d97:	eb b8                	jmp    f0101d51 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101d99:	90                   	nop
	}
}
f0101d9a:	90                   	nop
f0101d9b:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101d9e:	5b                   	pop    %ebx
f0101d9f:	5e                   	pop    %esi
f0101da0:	5f                   	pop    %edi
f0101da1:	5d                   	pop    %ebp
f0101da2:	c3                   	ret    

f0101da3 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101da3:	55                   	push   %ebp
f0101da4:	89 e5                	mov    %esp,%ebp
f0101da6:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101da9:	9c                   	pushf  
f0101daa:	58                   	pop    %eax
f0101dab:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101dae:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101db1:	25 00 02 00 00       	and    $0x200,%eax
f0101db6:	85 c0                	test   %eax,%eax
f0101db8:	74 01                	je     f0101dbb <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101dba:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101dbb:	e8 67 89 00 00       	call   f010a727 <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101dc0:	e8 56 50 00 00       	call   f0106e1b <mycpu>
f0101dc5:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101dc8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dcb:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101dd2:	00 00 00 
		c->intena = 0;
f0101dd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dd8:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101ddf:	00 00 00 
		c->scheduler = NULL;
f0101de2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101de5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101dec:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101def:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101df6:	00 00 00 
		c->proc = NULL;
f0101df9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dfc:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101e03:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101e06:	89 e0                	mov    %esp,%eax
f0101e08:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101e0b:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101e0e:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101e11:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e14:	8b 40 08             	mov    0x8(%eax),%eax
f0101e17:	05 00 80 00 00       	add    $0x8000,%eax
f0101e1c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101e1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e22:	8b 40 08             	mov    0x8(%eax),%eax
f0101e25:	05 00 10 00 00       	add    $0x1000,%eax
f0101e2a:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101e2d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e30:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101e33:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e36:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e38:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e3b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101e3e:	73 44                	jae    f0101e84 <get_into_prompt+0xe1>
f0101e40:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e43:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101e46:	72 3c                	jb     f0101e84 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101e48:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e4b:	a3 80 52 55 f0       	mov    %eax,0xf0555280
			m = cpuStackTop - cur_esp;
f0101e50:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e53:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101e56:	a3 a0 32 57 f0       	mov    %eax,0xf05732a0
			while (--m >= 0)
f0101e5b:	eb 11                	jmp    f0101e6e <get_into_prompt+0xcb>
				*p++ = 0;
f0101e5d:	a1 80 52 55 f0       	mov    0xf0555280,%eax
f0101e62:	8d 50 01             	lea    0x1(%eax),%edx
f0101e65:	89 15 80 52 55 f0    	mov    %edx,0xf0555280
f0101e6b:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101e6e:	a1 a0 32 57 f0       	mov    0xf05732a0,%eax
f0101e73:	48                   	dec    %eax
f0101e74:	a3 a0 32 57 f0       	mov    %eax,0xf05732a0
f0101e79:	a1 a0 32 57 f0       	mov    0xf05732a0,%eax
f0101e7e:	85 c0                	test   %eax,%eax
f0101e80:	79 db                	jns    f0101e5d <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e82:	eb 3a                	jmp    f0101ebe <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101e84:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101e87:	a3 80 52 55 f0       	mov    %eax,0xf0555280
			m = cpuStackTop - cpuStackBottom;
f0101e8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e8f:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101e92:	a3 a0 32 57 f0       	mov    %eax,0xf05732a0
			while (--m >= 0)
f0101e97:	eb 11                	jmp    f0101eaa <get_into_prompt+0x107>
				*p++ = 0;
f0101e99:	a1 80 52 55 f0       	mov    0xf0555280,%eax
f0101e9e:	8d 50 01             	lea    0x1(%eax),%edx
f0101ea1:	89 15 80 52 55 f0    	mov    %edx,0xf0555280
f0101ea7:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101eaa:	a1 a0 32 57 f0       	mov    0xf05732a0,%eax
f0101eaf:	48                   	dec    %eax
f0101eb0:	a3 a0 32 57 f0       	mov    %eax,0xf05732a0
f0101eb5:	a1 a0 32 57 f0       	mov    0xf05732a0,%eax
f0101eba:	85 c0                	test   %eax,%eax
f0101ebc:	79 db                	jns    f0101e99 <get_into_prompt+0xf6>
f0101ebe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101ec5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101ec8:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101eca:	83 ec 0c             	sub    $0xc,%esp
f0101ecd:	6a 00                	push   $0x0
f0101ecf:	e8 c1 fd ff ff       	call   f0101c95 <run_command_prompt>
f0101ed4:	83 c4 10             	add    $0x10,%esp
	}
f0101ed7:	e9 cd fe ff ff       	jmp    f0101da9 <get_into_prompt+0x6>

f0101edc <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101edc:	55                   	push   %ebp
f0101edd:	89 e5                	mov    %esp,%ebp
f0101edf:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101ee2:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101ee5:	50                   	push   %eax
f0101ee6:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101ee9:	50                   	push   %eax
f0101eea:	68 ff 1a 12 f0       	push   $0xf0121aff
f0101eef:	ff 75 08             	pushl  0x8(%ebp)
f0101ef2:	e8 6f ec 01 00       	call   f0120b66 <strsplit>
f0101ef7:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101efa:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101efd:	85 c0                	test   %eax,%eax
f0101eff:	75 0a                	jne    f0101f0b <execute_command+0x2f>
		return 0;
f0101f01:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f06:	e9 a4 02 00 00       	jmp    f01021af <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101f0b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f0e:	83 ec 08             	sub    $0x8,%esp
f0101f11:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101f14:	52                   	push   %edx
f0101f15:	50                   	push   %eax
f0101f16:	e8 96 02 00 00       	call   f01021b1 <process_command>
f0101f1b:	83 c4 10             	add    $0x10,%esp
f0101f1e:	89 45 e0             	mov    %eax,-0x20(%ebp)

	//cprintf("cmd %s, num of args %d, return %d\n", arguments[0], number_of_arguments, ret);

	if (ret == CMD_INVALID)
f0101f21:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101f25:	75 19                	jne    f0101f40 <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101f27:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101f2a:	83 ec 08             	sub    $0x8,%esp
f0101f2d:	50                   	push   %eax
f0101f2e:	68 17 27 12 f0       	push   $0xf0122717
f0101f33:	e8 34 f0 ff ff       	call   f0100f6c <cprintf>
f0101f38:	83 c4 10             	add    $0x10,%esp
f0101f3b:	e9 6a 02 00 00       	jmp    f01021aa <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101f40:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101f44:	75 4f                	jne    f0101f95 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101f46:	a1 78 51 55 f0       	mov    0xf0555178,%eax
f0101f4b:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101f4e:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101f52:	74 17                	je     f0101f6b <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101f54:	83 ec 04             	sub    $0x4,%esp
f0101f57:	68 30 27 12 f0       	push   $0xf0122730
f0101f5c:	68 8b 01 00 00       	push   $0x18b
f0101f61:	68 81 27 12 f0       	push   $0xf0122781
f0101f66:	e8 af e3 ff ff       	call   f010031a <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101f6b:	a1 6c 51 55 f0       	mov    0xf055516c,%eax
f0101f70:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101f73:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f76:	8b 50 04             	mov    0x4(%eax),%edx
f0101f79:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f7c:	8b 00                	mov    (%eax),%eax
f0101f7e:	83 ec 04             	sub    $0x4,%esp
f0101f81:	52                   	push   %edx
f0101f82:	50                   	push   %eax
f0101f83:	68 9c 27 12 f0       	push   $0xf012279c
f0101f88:	e8 df ef ff ff       	call   f0100f6c <cprintf>
f0101f8d:	83 c4 10             	add    $0x10,%esp
f0101f90:	e9 15 02 00 00       	jmp    f01021aa <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101f95:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101f99:	0f 85 e6 01 00 00    	jne    f0102185 <execute_command+0x2a9>
	{
		int i = 1;
f0101f9f:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101fa6:	a1 78 51 55 f0       	mov    0xf0555178,%eax
f0101fab:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101fae:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101fb2:	75 17                	jne    f0101fcb <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101fb4:	83 ec 04             	sub    $0x4,%esp
f0101fb7:	68 cc 27 12 f0       	push   $0xf01227cc
f0101fbc:	68 96 01 00 00       	push   $0x196
f0101fc1:	68 81 27 12 f0       	push   $0xf0122781
f0101fc6:	e8 4f e3 ff ff       	call   f010031a <_panic>
		}
		struct Command * cmd = NULL;
f0101fcb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101fd2:	a1 6c 51 55 f0       	mov    0xf055516c,%eax
f0101fd7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101fda:	eb 28                	jmp    f0102004 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101fdc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101fdf:	8b 10                	mov    (%eax),%edx
f0101fe1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101fe4:	8d 48 01             	lea    0x1(%eax),%ecx
f0101fe7:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0101fea:	83 ec 04             	sub    $0x4,%esp
f0101fed:	52                   	push   %edx
f0101fee:	50                   	push   %eax
f0101fef:	68 f6 27 12 f0       	push   $0xf01227f6
f0101ff4:	e8 73 ef ff ff       	call   f0100f6c <cprintf>
f0101ff9:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f0101ffc:	a1 74 51 55 f0       	mov    0xf0555174,%eax
f0102001:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102004:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102008:	74 08                	je     f0102012 <execute_command+0x136>
f010200a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010200d:	8b 40 10             	mov    0x10(%eax),%eax
f0102010:	eb 05                	jmp    f0102017 <execute_command+0x13b>
f0102012:	b8 00 00 00 00       	mov    $0x0,%eax
f0102017:	a3 74 51 55 f0       	mov    %eax,0xf0555174
f010201c:	a1 74 51 55 f0       	mov    0xf0555174,%eax
f0102021:	85 c0                	test   %eax,%eax
f0102023:	75 b7                	jne    f0101fdc <execute_command+0x100>
f0102025:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102029:	75 b1                	jne    f0101fdc <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f010202b:	83 ec 08             	sub    $0x8,%esp
f010202e:	ff 75 dc             	pushl  -0x24(%ebp)
f0102031:	68 00 28 12 f0       	push   $0xf0122800
f0102036:	e8 31 ef ff ff       	call   f0100f6c <cprintf>
f010203b:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f010203e:	e8 1d ee ff ff       	call   f0100e60 <getchar>
f0102043:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0102046:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f010204a:	83 ec 0c             	sub    $0xc,%esp
f010204d:	50                   	push   %eax
f010204e:	e8 f6 ed ff ff       	call   f0100e49 <cputchar>
f0102053:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0102056:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f010205d:	eb 40                	jmp    f010209f <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f010205f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0102062:	89 d0                	mov    %edx,%eax
f0102064:	c1 e0 02             	shl    $0x2,%eax
f0102067:	01 d0                	add    %edx,%eax
f0102069:	01 c0                	add    %eax,%eax
f010206b:	89 c2                	mov    %eax,%edx
f010206d:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102071:	83 e8 30             	sub    $0x30,%eax
f0102074:	01 d0                	add    %edx,%eax
f0102076:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0102079:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010207d:	7e 2c                	jle    f01020ab <execute_command+0x1cf>
f010207f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102082:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0102085:	7f 24                	jg     f01020ab <execute_command+0x1cf>
				break;

			Chose = getchar();
f0102087:	e8 d4 ed ff ff       	call   f0100e60 <getchar>
f010208c:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f010208f:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102093:	83 ec 0c             	sub    $0xc,%esp
f0102096:	50                   	push   %eax
f0102097:	e8 ad ed ff ff       	call   f0100e49 <cputchar>
f010209c:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f010209f:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f01020a3:	7e 06                	jle    f01020ab <execute_command+0x1cf>
f01020a5:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f01020a9:	7e b4                	jle    f010205f <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f01020ab:	83 ec 0c             	sub    $0xc,%esp
f01020ae:	6a 0a                	push   $0xa
f01020b0:	e8 94 ed ff ff       	call   f0100e49 <cputchar>
f01020b5:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f01020b8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01020bc:	0f 8e e8 00 00 00    	jle    f01021aa <execute_command+0x2ce>
f01020c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020c5:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020c8:	0f 8f dc 00 00 00    	jg     f01021aa <execute_command+0x2ce>
		{
			int c = 1;
f01020ce:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f01020d5:	a1 6c 51 55 f0       	mov    0xf055516c,%eax
f01020da:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01020dd:	eb 75                	jmp    f0102154 <execute_command+0x278>
			{
				if (c++ == selection)
f01020df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01020e2:	8d 50 01             	lea    0x1(%eax),%edx
f01020e5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01020e8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01020eb:	75 5f                	jne    f010214c <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f01020ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01020f0:	8b 40 0c             	mov    0xc(%eax),%eax
f01020f3:	85 c0                	test   %eax,%eax
f01020f5:	75 31                	jne    f0102128 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f01020f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01020fa:	8b 00                	mov    (%eax),%eax
f01020fc:	83 ec 08             	sub    $0x8,%esp
f01020ff:	50                   	push   %eax
f0102100:	68 63 28 12 f0       	push   $0xf0122863
f0102105:	e8 62 ee ff ff       	call   f0100f6c <cprintf>
f010210a:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010210d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102110:	8b 40 08             	mov    0x8(%eax),%eax
f0102113:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102116:	83 ec 08             	sub    $0x8,%esp
f0102119:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010211c:	51                   	push   %ecx
f010211d:	52                   	push   %edx
f010211e:	ff d0                	call   *%eax
f0102120:	83 c4 10             	add    $0x10,%esp
f0102123:	e9 87 00 00 00       	jmp    f01021af <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102128:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010212b:	8b 50 04             	mov    0x4(%eax),%edx
f010212e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102131:	8b 00                	mov    (%eax),%eax
f0102133:	83 ec 04             	sub    $0x4,%esp
f0102136:	52                   	push   %edx
f0102137:	50                   	push   %eax
f0102138:	68 6c 28 12 f0       	push   $0xf012286c
f010213d:	e8 2a ee ff ff       	call   f0100f6c <cprintf>
f0102142:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102145:	b8 00 00 00 00       	mov    $0x0,%eax
f010214a:	eb 63                	jmp    f01021af <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010214c:	a1 74 51 55 f0       	mov    0xf0555174,%eax
f0102151:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102154:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102158:	74 08                	je     f0102162 <execute_command+0x286>
f010215a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010215d:	8b 40 10             	mov    0x10(%eax),%eax
f0102160:	eb 05                	jmp    f0102167 <execute_command+0x28b>
f0102162:	b8 00 00 00 00       	mov    $0x0,%eax
f0102167:	a3 74 51 55 f0       	mov    %eax,0xf0555174
f010216c:	a1 74 51 55 f0       	mov    0xf0555174,%eax
f0102171:	85 c0                	test   %eax,%eax
f0102173:	0f 85 66 ff ff ff    	jne    f01020df <execute_command+0x203>
f0102179:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010217d:	0f 85 5c ff ff ff    	jne    f01020df <execute_command+0x203>
f0102183:	eb 25                	jmp    f01021aa <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f0102185:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102188:	89 d0                	mov    %edx,%eax
f010218a:	01 c0                	add    %eax,%eax
f010218c:	01 d0                	add    %edx,%eax
f010218e:	c1 e0 03             	shl    $0x3,%eax
f0102191:	05 48 95 17 f0       	add    $0xf0179548,%eax
f0102196:	8b 00                	mov    (%eax),%eax
f0102198:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010219b:	83 ec 08             	sub    $0x8,%esp
f010219e:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01021a1:	51                   	push   %ecx
f01021a2:	52                   	push   %edx
f01021a3:	ff d0                	call   *%eax
f01021a5:	83 c4 10             	add    $0x10,%esp
f01021a8:	eb 05                	jmp    f01021af <execute_command+0x2d3>
	}
	return 0;
f01021aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01021af:	c9                   	leave  
f01021b0:	c3                   	ret    

f01021b1 <process_command>:


int process_command(int number_of_arguments, char** arguments)
{
f01021b1:	55                   	push   %ebp
f01021b2:	89 e5                	mov    %esp,%ebp
f01021b4:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #01] [1] PLAY WITH CODE! - process_command

	for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01021b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01021be:	eb 31                	jmp    f01021f1 <process_command+0x40>
	{
		if (strcmp(arguments[0], commands[i].name) == 0)
f01021c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01021c3:	89 d0                	mov    %edx,%eax
f01021c5:	01 c0                	add    %eax,%eax
f01021c7:	01 d0                	add    %edx,%eax
f01021c9:	c1 e0 03             	shl    $0x3,%eax
f01021cc:	05 40 95 17 f0       	add    $0xf0179540,%eax
f01021d1:	8b 10                	mov    (%eax),%edx
f01021d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01021d6:	8b 00                	mov    (%eax),%eax
f01021d8:	83 ec 08             	sub    $0x8,%esp
f01021db:	52                   	push   %edx
f01021dc:	50                   	push   %eax
f01021dd:	e8 7b e4 01 00       	call   f012065d <strcmp>
f01021e2:	83 c4 10             	add    $0x10,%esp
f01021e5:	85 c0                	test   %eax,%eax
f01021e7:	75 05                	jne    f01021ee <process_command+0x3d>
		{
			return i;
f01021e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01021ec:	eb 14                	jmp    f0102202 <process_command+0x51>

int process_command(int number_of_arguments, char** arguments)
{
	//TODO: [PROJECT'24.MS1 - #01] [1] PLAY WITH CODE! - process_command

	for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01021ee:	ff 45 f4             	incl   -0xc(%ebp)
f01021f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01021f4:	a1 60 99 17 f0       	mov    0xf0179960,%eax
f01021f9:	39 c2                	cmp    %eax,%edx
f01021fb:	72 c3                	jb     f01021c0 <process_command+0xf>
		if (strcmp(arguments[0], commands[i].name) == 0)
		{
			return i;
		}
	}
	return CMD_INVALID;
f01021fd:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f0102202:	c9                   	leave  
f0102203:	c3                   	ret    

f0102204 <setKHeapPlacementStrategyCONTALLOC>:
#define KHP_PLACE_FIRSTFIT 	0x1
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
f0102204:	55                   	push   %ebp
f0102205:	89 e5                	mov    %esp,%ebp
f0102207:	c7 05 b0 4f 55 f0 00 	movl   $0x0,0xf0554fb0
f010220e:	00 00 00 
f0102211:	90                   	nop
f0102212:	5d                   	pop    %ebp
f0102213:	c3                   	ret    

f0102214 <setKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f0102214:	55                   	push   %ebp
f0102215:	89 e5                	mov    %esp,%ebp
f0102217:	c7 05 b0 4f 55 f0 01 	movl   $0x1,0xf0554fb0
f010221e:	00 00 00 
f0102221:	90                   	nop
f0102222:	5d                   	pop    %ebp
f0102223:	c3                   	ret    

f0102224 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f0102224:	55                   	push   %ebp
f0102225:	89 e5                	mov    %esp,%ebp
f0102227:	c7 05 b0 4f 55 f0 02 	movl   $0x2,0xf0554fb0
f010222e:	00 00 00 
f0102231:	90                   	nop
f0102232:	5d                   	pop    %ebp
f0102233:	c3                   	ret    

f0102234 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0102234:	55                   	push   %ebp
f0102235:	89 e5                	mov    %esp,%ebp
f0102237:	c7 05 b0 4f 55 f0 03 	movl   $0x3,0xf0554fb0
f010223e:	00 00 00 
f0102241:	90                   	nop
f0102242:	5d                   	pop    %ebp
f0102243:	c3                   	ret    

f0102244 <setKHeapPlacementStrategyWORSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}
f0102244:	55                   	push   %ebp
f0102245:	89 e5                	mov    %esp,%ebp
f0102247:	c7 05 b0 4f 55 f0 04 	movl   $0x4,0xf0554fb0
f010224e:	00 00 00 
f0102251:	90                   	nop
f0102252:	5d                   	pop    %ebp
f0102253:	c3                   	ret    

f0102254 <isKHeapPlacementStrategyCONTALLOC>:

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
f0102254:	55                   	push   %ebp
f0102255:	89 e5                	mov    %esp,%ebp
f0102257:	a1 b0 4f 55 f0       	mov    0xf0554fb0,%eax
f010225c:	85 c0                	test   %eax,%eax
f010225e:	75 04                	jne    f0102264 <isKHeapPlacementStrategyCONTALLOC+0x10>
f0102260:	b0 01                	mov    $0x1,%al
f0102262:	eb 02                	jmp    f0102266 <isKHeapPlacementStrategyCONTALLOC+0x12>
f0102264:	b0 00                	mov    $0x0,%al
f0102266:	5d                   	pop    %ebp
f0102267:	c3                   	ret    

f0102268 <isKHeapPlacementStrategyFIRSTFIT>:
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f0102268:	55                   	push   %ebp
f0102269:	89 e5                	mov    %esp,%ebp
f010226b:	a1 b0 4f 55 f0       	mov    0xf0554fb0,%eax
f0102270:	83 f8 01             	cmp    $0x1,%eax
f0102273:	75 04                	jne    f0102279 <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0102275:	b0 01                	mov    $0x1,%al
f0102277:	eb 02                	jmp    f010227b <isKHeapPlacementStrategyFIRSTFIT+0x13>
f0102279:	b0 00                	mov    $0x0,%al
f010227b:	5d                   	pop    %ebp
f010227c:	c3                   	ret    

f010227d <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f010227d:	55                   	push   %ebp
f010227e:	89 e5                	mov    %esp,%ebp
f0102280:	a1 b0 4f 55 f0       	mov    0xf0554fb0,%eax
f0102285:	83 f8 02             	cmp    $0x2,%eax
f0102288:	75 04                	jne    f010228e <isKHeapPlacementStrategyBESTFIT+0x11>
f010228a:	b0 01                	mov    $0x1,%al
f010228c:	eb 02                	jmp    f0102290 <isKHeapPlacementStrategyBESTFIT+0x13>
f010228e:	b0 00                	mov    $0x0,%al
f0102290:	5d                   	pop    %ebp
f0102291:	c3                   	ret    

f0102292 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f0102292:	55                   	push   %ebp
f0102293:	89 e5                	mov    %esp,%ebp
f0102295:	a1 b0 4f 55 f0       	mov    0xf0554fb0,%eax
f010229a:	83 f8 03             	cmp    $0x3,%eax
f010229d:	75 04                	jne    f01022a3 <isKHeapPlacementStrategyNEXTFIT+0x11>
f010229f:	b0 01                	mov    $0x1,%al
f01022a1:	eb 02                	jmp    f01022a5 <isKHeapPlacementStrategyNEXTFIT+0x13>
f01022a3:	b0 00                	mov    $0x0,%al
f01022a5:	5d                   	pop    %ebp
f01022a6:	c3                   	ret    

f01022a7 <isKHeapPlacementStrategyWORSTFIT>:
static inline uint8 isKHeapPlacementStrategyWORSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_WORSTFIT) return 1; return 0;}
f01022a7:	55                   	push   %ebp
f01022a8:	89 e5                	mov    %esp,%ebp
f01022aa:	a1 b0 4f 55 f0       	mov    0xf0554fb0,%eax
f01022af:	83 f8 04             	cmp    $0x4,%eax
f01022b2:	75 04                	jne    f01022b8 <isKHeapPlacementStrategyWORSTFIT+0x11>
f01022b4:	b0 01                	mov    $0x1,%al
f01022b6:	eb 02                	jmp    f01022ba <isKHeapPlacementStrategyWORSTFIT+0x13>
f01022b8:	b0 00                	mov    $0x0,%al
f01022ba:	5d                   	pop    %ebp
f01022bb:	c3                   	ret    

f01022bc <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f01022bc:	55                   	push   %ebp
f01022bd:	89 e5                	mov    %esp,%ebp
f01022bf:	c7 05 04 4f 55 f0 01 	movl   $0x1,0xf0554f04
f01022c6:	00 00 00 
f01022c9:	90                   	nop
f01022ca:	5d                   	pop    %ebp
f01022cb:	c3                   	ret    

f01022cc <setUHeapPlacementStrategyBESTFIT>:
static inline void setUHeapPlacementStrategyBESTFIT(){_UHeapPlacementStrategy = UHP_PLACE_BESTFIT;}
f01022cc:	55                   	push   %ebp
f01022cd:	89 e5                	mov    %esp,%ebp
f01022cf:	c7 05 04 4f 55 f0 02 	movl   $0x2,0xf0554f04
f01022d6:	00 00 00 
f01022d9:	90                   	nop
f01022da:	5d                   	pop    %ebp
f01022db:	c3                   	ret    

f01022dc <setUHeapPlacementStrategyNEXTFIT>:
static inline void setUHeapPlacementStrategyNEXTFIT(){_UHeapPlacementStrategy = UHP_PLACE_NEXTFIT;}
f01022dc:	55                   	push   %ebp
f01022dd:	89 e5                	mov    %esp,%ebp
f01022df:	c7 05 04 4f 55 f0 03 	movl   $0x3,0xf0554f04
f01022e6:	00 00 00 
f01022e9:	90                   	nop
f01022ea:	5d                   	pop    %ebp
f01022eb:	c3                   	ret    

f01022ec <setUHeapPlacementStrategyWORSTFIT>:
static inline void setUHeapPlacementStrategyWORSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_WORSTFIT;}
f01022ec:	55                   	push   %ebp
f01022ed:	89 e5                	mov    %esp,%ebp
f01022ef:	c7 05 04 4f 55 f0 04 	movl   $0x4,0xf0554f04
f01022f6:	00 00 00 
f01022f9:	90                   	nop
f01022fa:	5d                   	pop    %ebp
f01022fb:	c3                   	ret    

f01022fc <isUHeapPlacementStrategyFIRSTFIT>:

static inline uint8 isUHeapPlacementStrategyFIRSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_FIRSTFIT) return 1; return 0;}
f01022fc:	55                   	push   %ebp
f01022fd:	89 e5                	mov    %esp,%ebp
f01022ff:	a1 04 4f 55 f0       	mov    0xf0554f04,%eax
f0102304:	83 f8 01             	cmp    $0x1,%eax
f0102307:	75 04                	jne    f010230d <isUHeapPlacementStrategyFIRSTFIT+0x11>
f0102309:	b0 01                	mov    $0x1,%al
f010230b:	eb 02                	jmp    f010230f <isUHeapPlacementStrategyFIRSTFIT+0x13>
f010230d:	b0 00                	mov    $0x0,%al
f010230f:	5d                   	pop    %ebp
f0102310:	c3                   	ret    

f0102311 <isUHeapPlacementStrategyBESTFIT>:
static inline uint8 isUHeapPlacementStrategyBESTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_BESTFIT) return 1; return 0;}
f0102311:	55                   	push   %ebp
f0102312:	89 e5                	mov    %esp,%ebp
f0102314:	a1 04 4f 55 f0       	mov    0xf0554f04,%eax
f0102319:	83 f8 02             	cmp    $0x2,%eax
f010231c:	75 04                	jne    f0102322 <isUHeapPlacementStrategyBESTFIT+0x11>
f010231e:	b0 01                	mov    $0x1,%al
f0102320:	eb 02                	jmp    f0102324 <isUHeapPlacementStrategyBESTFIT+0x13>
f0102322:	b0 00                	mov    $0x0,%al
f0102324:	5d                   	pop    %ebp
f0102325:	c3                   	ret    

f0102326 <isUHeapPlacementStrategyNEXTFIT>:
static inline uint8 isUHeapPlacementStrategyNEXTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_NEXTFIT) return 1; return 0;}
f0102326:	55                   	push   %ebp
f0102327:	89 e5                	mov    %esp,%ebp
f0102329:	a1 04 4f 55 f0       	mov    0xf0554f04,%eax
f010232e:	83 f8 03             	cmp    $0x3,%eax
f0102331:	75 04                	jne    f0102337 <isUHeapPlacementStrategyNEXTFIT+0x11>
f0102333:	b0 01                	mov    $0x1,%al
f0102335:	eb 02                	jmp    f0102339 <isUHeapPlacementStrategyNEXTFIT+0x13>
f0102337:	b0 00                	mov    $0x0,%al
f0102339:	5d                   	pop    %ebp
f010233a:	c3                   	ret    

f010233b <isUHeapPlacementStrategyWORSTFIT>:
static inline uint8 isUHeapPlacementStrategyWORSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_WORSTFIT) return 1; return 0;}
f010233b:	55                   	push   %ebp
f010233c:	89 e5                	mov    %esp,%ebp
f010233e:	a1 04 4f 55 f0       	mov    0xf0554f04,%eax
f0102343:	83 f8 04             	cmp    $0x4,%eax
f0102346:	75 04                	jne    f010234c <isUHeapPlacementStrategyWORSTFIT+0x11>
f0102348:	b0 01                	mov    $0x1,%al
f010234a:	eb 02                	jmp    f010234e <isUHeapPlacementStrategyWORSTFIT+0x13>
f010234c:	b0 00                	mov    $0x0,%al
f010234e:	5d                   	pop    %ebp
f010234f:	c3                   	ret    

f0102350 <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0102350:	55                   	push   %ebp
f0102351:	89 e5                	mov    %esp,%ebp
f0102353:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0102356:	8b 45 08             	mov    0x8(%ebp),%eax
f0102359:	c1 e8 0c             	shr    $0xc,%eax
f010235c:	89 c2                	mov    %eax,%edx
f010235e:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0102363:	39 c2                	cmp    %eax,%edx
f0102365:	72 14                	jb     f010237b <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0102367:	83 ec 04             	sub    $0x4,%esp
f010236a:	68 74 28 12 f0       	push   $0xf0122874
f010236f:	6a 55                	push   $0x55
f0102371:	68 9c 28 12 f0       	push   $0xf012289c
f0102376:	e8 9f df ff ff       	call   f010031a <_panic>
	return &frames_info[PPN(physical_address)];
f010237b:	8b 15 20 4f 55 f0    	mov    0xf0554f20,%edx
f0102381:	8b 45 08             	mov    0x8(%ebp),%eax
f0102384:	c1 e8 0c             	shr    $0xc,%eax
f0102387:	89 c1                	mov    %eax,%ecx
f0102389:	89 c8                	mov    %ecx,%eax
f010238b:	01 c0                	add    %eax,%eax
f010238d:	01 c8                	add    %ecx,%eax
f010238f:	c1 e0 03             	shl    $0x3,%eax
f0102392:	01 d0                	add    %edx,%eax
}
f0102394:	c9                   	leave  
f0102395:	c3                   	ret    

f0102396 <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f0102396:	55                   	push   %ebp
f0102397:	89 e5                	mov    %esp,%ebp
f0102399:	53                   	push   %ebx
f010239a:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f010239d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01023a4:	eb 3b                	jmp    f01023e1 <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f01023a6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01023a9:	89 d0                	mov    %edx,%eax
f01023ab:	01 c0                	add    %eax,%eax
f01023ad:	01 d0                	add    %edx,%eax
f01023af:	c1 e0 03             	shl    $0x3,%eax
f01023b2:	05 44 95 17 f0       	add    $0xf0179544,%eax
f01023b7:	8b 10                	mov    (%eax),%edx
f01023b9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01023bc:	89 c8                	mov    %ecx,%eax
f01023be:	01 c0                	add    %eax,%eax
f01023c0:	01 c8                	add    %ecx,%eax
f01023c2:	c1 e0 03             	shl    $0x3,%eax
f01023c5:	05 40 95 17 f0       	add    $0xf0179540,%eax
f01023ca:	8b 00                	mov    (%eax),%eax
f01023cc:	83 ec 04             	sub    $0x4,%esp
f01023cf:	52                   	push   %edx
f01023d0:	50                   	push   %eax
f01023d1:	68 4b 31 12 f0       	push   $0xf012314b
f01023d6:	e8 91 eb ff ff       	call   f0100f6c <cprintf>
f01023db:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01023de:	ff 45 f4             	incl   -0xc(%ebp)
f01023e1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01023e4:	a1 60 99 17 f0       	mov    0xf0179960,%eax
f01023e9:	39 c2                	cmp    %eax,%edx
f01023eb:	72 b9                	jb     f01023a6 <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f01023ed:	83 ec 0c             	sub    $0xc,%esp
f01023f0:	68 54 31 12 f0       	push   $0xf0123154
f01023f5:	e8 72 eb ff ff       	call   f0100f6c <cprintf>
f01023fa:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f01023fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102404:	eb 42                	jmp    f0102448 <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f0102406:	8b 0d a4 9c 17 f0    	mov    0xf0179ca4,%ecx
f010240c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010240f:	89 d0                	mov    %edx,%eax
f0102411:	01 c0                	add    %eax,%eax
f0102413:	01 d0                	add    %edx,%eax
f0102415:	c1 e0 02             	shl    $0x2,%eax
f0102418:	01 c8                	add    %ecx,%eax
f010241a:	8b 50 04             	mov    0x4(%eax),%edx
f010241d:	8b 1d a4 9c 17 f0    	mov    0xf0179ca4,%ebx
f0102423:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102426:	89 c8                	mov    %ecx,%eax
f0102428:	01 c0                	add    %eax,%eax
f010242a:	01 c8                	add    %ecx,%eax
f010242c:	c1 e0 02             	shl    $0x2,%eax
f010242f:	01 d8                	add    %ebx,%eax
f0102431:	8b 00                	mov    (%eax),%eax
f0102433:	83 ec 04             	sub    $0x4,%esp
f0102436:	52                   	push   %edx
f0102437:	50                   	push   %eax
f0102438:	68 69 31 12 f0       	push   $0xf0123169
f010243d:	e8 2a eb ff ff       	call   f0100f6c <cprintf>
f0102442:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102445:	ff 45 f4             	incl   -0xc(%ebp)
f0102448:	a1 a8 9c 17 f0       	mov    0xf0179ca8,%eax
f010244d:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0102450:	7c b4                	jl     f0102406 <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f0102452:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102457:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010245a:	c9                   	leave  
f010245b:	c3                   	ret    

f010245c <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f010245c:	55                   	push   %ebp
f010245d:	89 e5                	mov    %esp,%ebp
f010245f:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f0102462:	83 ec 0c             	sub    $0xc,%esp
f0102465:	68 85 31 12 f0       	push   $0xf0123185
f010246a:	e8 fd ea ff ff       	call   f0100f6c <cprintf>
f010246f:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f0102472:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f0102477:	83 ec 04             	sub    $0x4,%esp
f010247a:	50                   	push   %eax
f010247b:	68 0c 00 10 f0       	push   $0xf010000c
f0102480:	68 a0 31 12 f0       	push   $0xf01231a0
f0102485:	e8 e2 ea ff ff       	call   f0100f6c <cprintf>
f010248a:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f010248d:	b8 a1 16 12 00       	mov    $0x1216a1,%eax
f0102492:	83 ec 04             	sub    $0x4,%esp
f0102495:	50                   	push   %eax
f0102496:	68 a1 16 12 f0       	push   $0xf01216a1
f010249b:	68 dc 31 12 f0       	push   $0xf01231dc
f01024a0:	e8 c7 ea ff ff       	call   f0100f6c <cprintf>
f01024a5:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f01024a8:	b8 b2 17 55 00       	mov    $0x5517b2,%eax
f01024ad:	83 ec 04             	sub    $0x4,%esp
f01024b0:	50                   	push   %eax
f01024b1:	68 b2 17 55 f0       	push   $0xf05517b2
f01024b6:	68 18 32 12 f0       	push   $0xf0123218
f01024bb:	e8 ac ea ff ff       	call   f0100f6c <cprintf>
f01024c0:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f01024c3:	b8 a8 79 57 00       	mov    $0x5779a8,%eax
f01024c8:	83 ec 04             	sub    $0x4,%esp
f01024cb:	50                   	push   %eax
f01024cc:	68 a8 79 57 f0       	push   $0xf05779a8
f01024d1:	68 60 32 12 f0       	push   $0xf0123260
f01024d6:	e8 91 ea ff ff       	call   f0100f6c <cprintf>
f01024db:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f01024de:	b8 a8 79 57 f0       	mov    $0xf05779a8,%eax
f01024e3:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f01024e9:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f01024ee:	29 c2                	sub    %eax,%edx
f01024f0:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f01024f2:	85 c0                	test   %eax,%eax
f01024f4:	79 05                	jns    f01024fb <command_kernel_info+0x9f>
f01024f6:	05 ff 03 00 00       	add    $0x3ff,%eax
f01024fb:	c1 f8 0a             	sar    $0xa,%eax
f01024fe:	83 ec 08             	sub    $0x8,%esp
f0102501:	50                   	push   %eax
f0102502:	68 9c 32 12 f0       	push   $0xf012329c
f0102507:	e8 60 ea ff ff       	call   f0100f6c <cprintf>
f010250c:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f010250f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102514:	c9                   	leave  
f0102515:	c3                   	ret    

f0102516 <command_writeusermem>:

//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f0102516:	55                   	push   %ebp
f0102517:	89 e5                	mov    %esp,%ebp
f0102519:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f010251c:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102520:	75 37                	jne    f0102559 <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102522:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102525:	83 c0 04             	add    $0x4,%eax
f0102528:	8b 00                	mov    (%eax),%eax
f010252a:	83 ec 04             	sub    $0x4,%esp
f010252d:	6a 10                	push   $0x10
f010252f:	6a 00                	push   $0x0
f0102531:	50                   	push   %eax
f0102532:	e8 7a e3 01 00       	call   f01208b1 <strtol>
f0102537:	83 c4 10             	add    $0x10,%esp
f010253a:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f010253d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102540:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f0102543:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102546:	83 c0 08             	add    $0x8,%eax
f0102549:	8b 00                	mov    (%eax),%eax
f010254b:	8a 00                	mov    (%eax),%al
f010254d:	88 c2                	mov    %al,%dl
f010254f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102552:	88 10                	mov    %dl,(%eax)
f0102554:	e9 b9 00 00 00       	jmp    f0102612 <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f0102559:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f010255d:	0f 85 9f 00 00 00    	jne    f0102602 <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0102563:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102566:	83 c0 04             	add    $0x4,%eax
f0102569:	8b 00                	mov    (%eax),%eax
f010256b:	83 ec 04             	sub    $0x4,%esp
f010256e:	6a 0a                	push   $0xa
f0102570:	6a 00                	push   $0x0
f0102572:	50                   	push   %eax
f0102573:	e8 39 e3 01 00       	call   f01208b1 <strtol>
f0102578:	83 c4 10             	add    $0x10,%esp
f010257b:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f010257e:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0102585:	83 ec 04             	sub    $0x4,%esp
f0102588:	6a 00                	push   $0x0
f010258a:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010258d:	50                   	push   %eax
f010258e:	ff 75 f4             	pushl  -0xc(%ebp)
f0102591:	e8 48 7f 00 00       	call   f010a4de <envid2env>
f0102596:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0102599:	8b 45 0c             	mov    0xc(%ebp),%eax
f010259c:	83 c0 08             	add    $0x8,%eax
f010259f:	8b 00                	mov    (%eax),%eax
f01025a1:	83 ec 04             	sub    $0x4,%esp
f01025a4:	6a 10                	push   $0x10
f01025a6:	6a 00                	push   $0x0
f01025a8:	50                   	push   %eax
f01025a9:	e8 03 e3 01 00       	call   f01208b1 <strtol>
f01025ae:	83 c4 10             	add    $0x10,%esp
f01025b1:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01025b4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01025b7:	85 c0                	test   %eax,%eax
f01025b9:	75 07                	jne    f01025c2 <command_writeusermem+0xac>
f01025bb:	b8 00 00 00 00       	mov    $0x0,%eax
f01025c0:	eb 55                	jmp    f0102617 <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01025c2:	0f 20 d8             	mov    %cr3,%eax
f01025c5:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01025c8:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01025cb:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01025ce:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01025d1:	8b 40 68             	mov    0x68(%eax),%eax
f01025d4:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01025d7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01025da:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01025dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01025e0:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01025e3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01025e6:	83 c0 0c             	add    $0xc,%eax
f01025e9:	8b 00                	mov    (%eax),%eax
f01025eb:	8a 00                	mov    (%eax),%al
f01025ed:	88 c2                	mov    %al,%dl
f01025ef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01025f2:	88 10                	mov    %dl,(%eax)
f01025f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01025f7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01025fa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01025fd:	0f 22 d8             	mov    %eax,%cr3
f0102600:	eb 10                	jmp    f0102612 <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f0102602:	83 ec 0c             	sub    $0xc,%esp
f0102605:	68 c8 32 12 f0       	push   $0xf01232c8
f010260a:	e8 5d e9 ff ff       	call   f0100f6c <cprintf>
f010260f:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102612:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102617:	c9                   	leave  
f0102618:	c3                   	ret    

f0102619 <command_writemem_k>:

int command_writemem_k(int number_of_arguments, char **arguments)
{
f0102619:	55                   	push   %ebp
f010261a:	89 e5                	mov    %esp,%ebp
f010261c:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f010261f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102622:	83 c0 04             	add    $0x4,%eax
f0102625:	8b 00                	mov    (%eax),%eax
f0102627:	83 ec 04             	sub    $0x4,%esp
f010262a:	6a 10                	push   $0x10
f010262c:	6a 00                	push   $0x0
f010262e:	50                   	push   %eax
f010262f:	e8 7d e2 01 00       	call   f01208b1 <strtol>
f0102634:	83 c4 10             	add    $0x10,%esp
f0102637:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010263c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int c, i=0;
f010263f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int stringLen = strlen(arguments[2]);
f0102646:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102649:	83 c0 08             	add    $0x8,%eax
f010264c:	8b 00                	mov    (%eax),%eax
f010264e:	83 ec 0c             	sub    $0xc,%esp
f0102651:	50                   	push   %eax
f0102652:	e8 fa de 01 00       	call   f0120551 <strlen>
f0102657:	83 c4 10             	add    $0x10,%esp
f010265a:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(i=0;i < stringLen; i++)
f010265d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102664:	eb 1c                	jmp    f0102682 <command_writemem_k+0x69>
	{
		*address = arguments[2][i];
f0102666:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102669:	83 c0 08             	add    $0x8,%eax
f010266c:	8b 10                	mov    (%eax),%edx
f010266e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102671:	01 d0                	add    %edx,%eax
f0102673:	8a 00                	mov    (%eax),%al
f0102675:	88 c2                	mov    %al,%dl
f0102677:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010267a:	88 10                	mov    %dl,(%eax)
		address++;
f010267c:	ff 45 f4             	incl   -0xc(%ebp)
{
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int c, i=0;
	int stringLen = strlen(arguments[2]);

	for(i=0;i < stringLen; i++)
f010267f:	ff 45 f0             	incl   -0x10(%ebp)
f0102682:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102685:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0102688:	7c dc                	jl     f0102666 <command_writemem_k+0x4d>
	{
		*address = arguments[2][i];
		address++;
	}

	return 0;
f010268a:	b8 00 00 00 00       	mov    $0x0,%eax


}
f010268f:	c9                   	leave  
f0102690:	c3                   	ret    

f0102691 <print>:

int print(int number_of_arguments, char **arguments){
f0102691:	55                   	push   %ebp
f0102692:	89 e5                	mov    %esp,%ebp
f0102694:	83 ec 08             	sub    $0x8,%esp

	cprintf("we are in the project file!!");
f0102697:	83 ec 0c             	sub    $0xc,%esp
f010269a:	68 f2 32 12 f0       	push   $0xf01232f2
f010269f:	e8 c8 e8 ff ff       	call   f0100f6c <cprintf>
f01026a4:	83 c4 10             	add    $0x10,%esp
	return 0;
f01026a7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01026ac:	c9                   	leave  
f01026ad:	c3                   	ret    

f01026ae <command_readusermem>:

int command_readusermem(int number_of_arguments, char **arguments)
{
f01026ae:	55                   	push   %ebp
f01026af:	89 e5                	mov    %esp,%ebp
f01026b1:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f01026b4:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01026b8:	75 42                	jne    f01026fc <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f01026ba:	8b 45 0c             	mov    0xc(%ebp),%eax
f01026bd:	83 c0 04             	add    $0x4,%eax
f01026c0:	8b 00                	mov    (%eax),%eax
f01026c2:	83 ec 04             	sub    $0x4,%esp
f01026c5:	6a 10                	push   $0x10
f01026c7:	6a 00                	push   $0x0
f01026c9:	50                   	push   %eax
f01026ca:	e8 e2 e1 01 00       	call   f01208b1 <strtol>
f01026cf:	83 c4 10             	add    $0x10,%esp
f01026d2:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f01026d5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01026d8:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f01026db:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01026de:	8a 00                	mov    (%eax),%al
f01026e0:	0f b6 c0             	movzbl %al,%eax
f01026e3:	83 ec 04             	sub    $0x4,%esp
f01026e6:	50                   	push   %eax
f01026e7:	ff 75 d8             	pushl  -0x28(%ebp)
f01026ea:	68 0f 33 12 f0       	push   $0xf012330f
f01026ef:	e8 78 e8 ff ff       	call   f0100f6c <cprintf>
f01026f4:	83 c4 10             	add    $0x10,%esp
f01026f7:	e9 c4 00 00 00       	jmp    f01027c0 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f01026fc:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102700:	0f 85 aa 00 00 00    	jne    f01027b0 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0102706:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102709:	83 c0 04             	add    $0x4,%eax
f010270c:	8b 00                	mov    (%eax),%eax
f010270e:	83 ec 04             	sub    $0x4,%esp
f0102711:	6a 0a                	push   $0xa
f0102713:	6a 00                	push   $0x0
f0102715:	50                   	push   %eax
f0102716:	e8 96 e1 01 00       	call   f01208b1 <strtol>
f010271b:	83 c4 10             	add    $0x10,%esp
f010271e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0102721:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0102728:	83 ec 04             	sub    $0x4,%esp
f010272b:	6a 00                	push   $0x0
f010272d:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102730:	50                   	push   %eax
f0102731:	ff 75 f4             	pushl  -0xc(%ebp)
f0102734:	e8 a5 7d 00 00       	call   f010a4de <envid2env>
f0102739:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f010273c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010273f:	83 c0 08             	add    $0x8,%eax
f0102742:	8b 00                	mov    (%eax),%eax
f0102744:	83 ec 04             	sub    $0x4,%esp
f0102747:	6a 10                	push   $0x10
f0102749:	6a 00                	push   $0x0
f010274b:	50                   	push   %eax
f010274c:	e8 60 e1 01 00       	call   f01208b1 <strtol>
f0102751:	83 c4 10             	add    $0x10,%esp
f0102754:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f0102757:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010275a:	85 c0                	test   %eax,%eax
f010275c:	75 07                	jne    f0102765 <command_readusermem+0xb7>
f010275e:	b8 00 00 00 00       	mov    $0x0,%eax
f0102763:	eb 60                	jmp    f01027c5 <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102765:	0f 20 d8             	mov    %cr3,%eax
f0102768:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f010276b:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f010276e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f0102771:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102774:	8b 40 68             	mov    0x68(%eax),%eax
f0102777:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010277a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010277d:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f0102780:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102783:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f0102786:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102789:	8a 00                	mov    (%eax),%al
f010278b:	0f b6 c0             	movzbl %al,%eax
f010278e:	83 ec 04             	sub    $0x4,%esp
f0102791:	50                   	push   %eax
f0102792:	ff 75 f0             	pushl  -0x10(%ebp)
f0102795:	68 0f 33 12 f0       	push   $0xf012330f
f010279a:	e8 cd e7 ff ff       	call   f0100f6c <cprintf>
f010279f:	83 c4 10             	add    $0x10,%esp
f01027a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01027a5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01027a8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01027ab:	0f 22 d8             	mov    %eax,%cr3
f01027ae:	eb 10                	jmp    f01027c0 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f01027b0:	83 ec 0c             	sub    $0xc,%esp
f01027b3:	68 2c 33 12 f0       	push   $0xf012332c
f01027b8:	e8 af e7 ff ff       	call   f0100f6c <cprintf>
f01027bd:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f01027c0:	b8 00 00 00 00       	mov    $0x0,%eax

}
f01027c5:	c9                   	leave  
f01027c6:	c3                   	ret    

f01027c7 <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f01027c7:	55                   	push   %ebp
f01027c8:	89 e5                	mov    %esp,%ebp
f01027ca:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f01027cd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01027d0:	83 c0 04             	add    $0x4,%eax
f01027d3:	8b 00                	mov    (%eax),%eax
f01027d5:	83 ec 04             	sub    $0x4,%esp
f01027d8:	6a 10                	push   $0x10
f01027da:	6a 00                	push   $0x0
f01027dc:	50                   	push   %eax
f01027dd:	e8 cf e0 01 00       	call   f01208b1 <strtol>
f01027e2:	83 c4 10             	add    $0x10,%esp
f01027e5:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01027ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int i=0;
f01027ed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cprintf("%c",*address);
f01027f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01027f7:	8a 00                	mov    (%eax),%al
f01027f9:	0f b6 c0             	movzbl %al,%eax
f01027fc:	83 ec 08             	sub    $0x8,%esp
f01027ff:	50                   	push   %eax
f0102800:	68 56 33 12 f0       	push   $0xf0123356
f0102805:	e8 62 e7 ff ff       	call   f0100f6c <cprintf>
f010280a:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010280d:	83 ec 0c             	sub    $0xc,%esp
f0102810:	68 59 33 12 f0       	push   $0xf0123359
f0102815:	e8 52 e7 ff ff       	call   f0100f6c <cprintf>
f010281a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010281d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102822:	c9                   	leave  
f0102823:	c3                   	ret    

f0102824 <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f0102824:	55                   	push   %ebp
f0102825:	89 e5                	mov    %esp,%ebp
f0102827:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f010282a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010282d:	83 c0 04             	add    $0x4,%eax
f0102830:	8b 00                	mov    (%eax),%eax
f0102832:	83 ec 04             	sub    $0x4,%esp
f0102835:	6a 0a                	push   $0xa
f0102837:	6a 00                	push   $0x0
f0102839:	50                   	push   %eax
f010283a:	e8 72 e0 01 00       	call   f01208b1 <strtol>
f010283f:	83 c4 10             	add    $0x10,%esp
f0102842:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0102845:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f010284c:	83 ec 04             	sub    $0x4,%esp
f010284f:	6a 00                	push   $0x0
f0102851:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102854:	50                   	push   %eax
f0102855:	ff 75 ec             	pushl  -0x14(%ebp)
f0102858:	e8 81 7c 00 00       	call   f010a4de <envid2env>
f010285d:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0102860:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102863:	83 c0 08             	add    $0x8,%eax
f0102866:	8b 00                	mov    (%eax),%eax
f0102868:	83 ec 04             	sub    $0x4,%esp
f010286b:	6a 10                	push   $0x10
f010286d:	6a 00                	push   $0x0
f010286f:	50                   	push   %eax
f0102870:	e8 3c e0 01 00       	call   f01208b1 <strtol>
f0102875:	83 c4 10             	add    $0x10,%esp
f0102878:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f010287b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010287e:	83 c0 0c             	add    $0xc,%eax
f0102881:	8b 00                	mov    (%eax),%eax
f0102883:	83 ec 04             	sub    $0x4,%esp
f0102886:	6a 0a                	push   $0xa
f0102888:	6a 00                	push   $0x0
f010288a:	50                   	push   %eax
f010288b:	e8 21 e0 01 00       	call   f01208b1 <strtol>
f0102890:	83 c4 10             	add    $0x10,%esp
f0102893:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f0102896:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102899:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f010289c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010289f:	85 c0                	test   %eax,%eax
f01028a1:	75 07                	jne    f01028aa <command_readuserblock+0x86>
f01028a3:	b8 00 00 00 00       	mov    $0x0,%eax
f01028a8:	eb 65                	jmp    f010290f <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01028aa:	0f 20 d8             	mov    %cr3,%eax
f01028ad:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f01028b0:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f01028b3:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f01028b6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028b9:	8b 40 68             	mov    0x68(%eax),%eax
f01028bc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01028bf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01028c2:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f01028c5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01028cc:	eb 28                	jmp    f01028f6 <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f01028ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01028d1:	8a 00                	mov    (%eax),%al
f01028d3:	0f b6 d0             	movzbl %al,%edx
f01028d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01028d9:	8a 00                	mov    (%eax),%al
f01028db:	0f b6 c0             	movzbl %al,%eax
f01028de:	52                   	push   %edx
f01028df:	50                   	push   %eax
f01028e0:	ff 75 f4             	pushl  -0xc(%ebp)
f01028e3:	68 5b 33 12 f0       	push   $0xf012335b
f01028e8:	e8 7f e6 ff ff       	call   f0100f6c <cprintf>
f01028ed:	83 c4 10             	add    $0x10,%esp
		ptr++;
f01028f0:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f01028f3:	ff 45 f0             	incl   -0x10(%ebp)
f01028f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01028f9:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01028fc:	7c d0                	jl     f01028ce <command_readuserblock+0xaa>
f01028fe:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102901:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0102904:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102907:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f010290a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010290f:	c9                   	leave  
f0102910:	c3                   	ret    

f0102911 <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f0102911:	55                   	push   %ebp
f0102912:	89 e5                	mov    %esp,%ebp
f0102914:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102917:	8b 45 0c             	mov    0xc(%ebp),%eax
f010291a:	83 c0 04             	add    $0x4,%eax
f010291d:	8b 00                	mov    (%eax),%eax
f010291f:	83 ec 04             	sub    $0x4,%esp
f0102922:	6a 0a                	push   $0xa
f0102924:	6a 00                	push   $0x0
f0102926:	50                   	push   %eax
f0102927:	e8 85 df 01 00       	call   f01208b1 <strtol>
f010292c:	83 c4 10             	add    $0x10,%esp
f010292f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0102932:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0102939:	83 ec 04             	sub    $0x4,%esp
f010293c:	6a 00                	push   $0x0
f010293e:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0102941:	50                   	push   %eax
f0102942:	ff 75 f4             	pushl  -0xc(%ebp)
f0102945:	e8 94 7b 00 00       	call   f010a4de <envid2env>
f010294a:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f010294d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102950:	85 c0                	test   %eax,%eax
f0102952:	75 0a                	jne    f010295e <command_remove_table+0x4d>
f0102954:	b8 00 00 00 00       	mov    $0x0,%eax
f0102959:	e9 a1 00 00 00       	jmp    f01029ff <command_remove_table+0xee>

	uint32 address = strtol(arguments[2], NULL, 16);
f010295e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102961:	83 c0 08             	add    $0x8,%eax
f0102964:	8b 00                	mov    (%eax),%eax
f0102966:	83 ec 04             	sub    $0x4,%esp
f0102969:	6a 10                	push   $0x10
f010296b:	6a 00                	push   $0x0
f010296d:	50                   	push   %eax
f010296e:	e8 3e df 01 00       	call   f01208b1 <strtol>
f0102973:	83 c4 10             	add    $0x10,%esp
f0102976:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0102979:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010297c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f010297f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102982:	8b 40 64             	mov    0x64(%eax),%eax
f0102985:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102988:	c1 ea 16             	shr    $0x16,%edx
f010298b:	c1 e2 02             	shl    $0x2,%edx
f010298e:	01 d0                	add    %edx,%eax
f0102990:	8b 00                	mov    (%eax),%eax
f0102992:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102997:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree((void*)kheap_virtual_address(table_pa));
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f010299a:	83 ec 0c             	sub    $0xc,%esp
f010299d:	ff 75 e8             	pushl  -0x18(%ebp)
f01029a0:	e8 ab f9 ff ff       	call   f0102350 <to_frame_info>
f01029a5:	83 c4 10             	add    $0x10,%esp
f01029a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f01029ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01029ae:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f01029b4:	83 ec 0c             	sub    $0xc,%esp
f01029b7:	ff 75 e4             	pushl  -0x1c(%ebp)
f01029ba:	e8 83 56 00 00       	call   f0108042 <free_frame>
f01029bf:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f01029c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01029c5:	c1 e8 16             	shr    $0x16,%eax
f01029c8:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f01029cb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01029ce:	8b 40 64             	mov    0x64(%eax),%eax
f01029d1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01029d4:	c1 e2 02             	shl    $0x2,%edx
f01029d7:	01 c2                	add    %eax,%edx
f01029d9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01029dc:	8b 40 64             	mov    0x64(%eax),%eax
f01029df:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f01029e2:	c1 e1 02             	shl    $0x2,%ecx
f01029e5:	01 c8                	add    %ecx,%eax
f01029e7:	8b 00                	mov    (%eax),%eax
f01029e9:	83 e0 fe             	and    $0xfffffffe,%eax
f01029ec:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01029ee:	0f 20 d8             	mov    %cr3,%eax
f01029f1:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01029f4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01029f7:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f01029fa:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01029ff:	c9                   	leave  
f0102a00:	c3                   	ret    

f0102a01 <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f0102a01:	55                   	push   %ebp
f0102a02:	89 e5                	mov    %esp,%ebp
f0102a04:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0102a07:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0102a0b:	7e 06                	jle    f0102a13 <command_allocuserpage+0x12>
f0102a0d:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102a11:	7e 1a                	jle    f0102a2d <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0102a13:	83 ec 0c             	sub    $0xc,%esp
f0102a16:	68 6c 33 12 f0       	push   $0xf012336c
f0102a1b:	e8 4c e5 ff ff       	call   f0100f6c <cprintf>
f0102a20:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102a23:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a28:	e9 46 01 00 00       	jmp    f0102b73 <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f0102a2d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a30:	83 c0 04             	add    $0x4,%eax
f0102a33:	8b 00                	mov    (%eax),%eax
f0102a35:	83 ec 04             	sub    $0x4,%esp
f0102a38:	6a 0a                	push   $0xa
f0102a3a:	6a 00                	push   $0x0
f0102a3c:	50                   	push   %eax
f0102a3d:	e8 6f de 01 00       	call   f01208b1 <strtol>
f0102a42:	83 c4 10             	add    $0x10,%esp
f0102a45:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0102a48:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0102a4f:	83 ec 04             	sub    $0x4,%esp
f0102a52:	6a 00                	push   $0x0
f0102a54:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0102a57:	50                   	push   %eax
f0102a58:	ff 75 f0             	pushl  -0x10(%ebp)
f0102a5b:	e8 7e 7a 00 00       	call   f010a4de <envid2env>
f0102a60:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102a63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102a66:	85 c0                	test   %eax,%eax
f0102a68:	75 0a                	jne    f0102a74 <command_allocuserpage+0x73>
f0102a6a:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a6f:	e9 ff 00 00 00       	jmp    f0102b73 <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f0102a74:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a77:	83 c0 08             	add    $0x8,%eax
f0102a7a:	8b 00                	mov    (%eax),%eax
f0102a7c:	83 ec 04             	sub    $0x4,%esp
f0102a7f:	6a 10                	push   $0x10
f0102a81:	6a 00                	push   $0x0
f0102a83:	50                   	push   %eax
f0102a84:	e8 28 de 01 00       	call   f01208b1 <strtol>
f0102a89:	83 c4 10             	add    $0x10,%esp
f0102a8c:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f0102a8f:	83 ec 0c             	sub    $0xc,%esp
f0102a92:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0102a95:	50                   	push   %eax
f0102a96:	e8 53 54 00 00       	call   f0107eee <allocate_frame>
f0102a9b:	83 c4 10             	add    $0x10,%esp
f0102a9e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0102aa1:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0102aa5:	75 1a                	jne    f0102ac1 <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f0102aa7:	83 ec 0c             	sub    $0xc,%esp
f0102aaa:	68 96 33 12 f0       	push   $0xf0123396
f0102aaf:	e8 b8 e4 ff ff       	call   f0100f6c <cprintf>
f0102ab4:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102ab7:	b8 00 00 00 00       	mov    $0x0,%eax
f0102abc:	e9 b2 00 00 00       	jmp    f0102b73 <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f0102ac1:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102ac5:	75 1d                	jne    f0102ae4 <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f0102ac7:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102aca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102acd:	8b 40 64             	mov    0x64(%eax),%eax
f0102ad0:	6a 06                	push   $0x6
f0102ad2:	ff 75 ec             	pushl  -0x14(%ebp)
f0102ad5:	52                   	push   %edx
f0102ad6:	50                   	push   %eax
f0102ad7:	e8 28 58 00 00       	call   f0108304 <map_frame>
f0102adc:	83 c4 10             	add    $0x10,%esp
f0102adf:	e9 8a 00 00 00       	jmp    f0102b6e <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0102ae4:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102ae8:	0f 85 80 00 00 00    	jne    f0102b6e <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0102aee:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102af1:	83 c0 0c             	add    $0xc,%eax
f0102af4:	8b 00                	mov    (%eax),%eax
f0102af6:	8a 00                	mov    (%eax),%al
f0102af8:	3c 72                	cmp    $0x72,%al
f0102afa:	74 0e                	je     f0102b0a <command_allocuserpage+0x109>
f0102afc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102aff:	83 c0 0c             	add    $0xc,%eax
f0102b02:	8b 00                	mov    (%eax),%eax
f0102b04:	8a 00                	mov    (%eax),%al
f0102b06:	3c 52                	cmp    $0x52,%al
f0102b08:	75 09                	jne    f0102b13 <command_allocuserpage+0x112>
			rw = 0 ;
f0102b0a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102b11:	eb 3c                	jmp    f0102b4f <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0102b13:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b16:	83 c0 0c             	add    $0xc,%eax
f0102b19:	8b 00                	mov    (%eax),%eax
f0102b1b:	8a 00                	mov    (%eax),%al
f0102b1d:	3c 77                	cmp    $0x77,%al
f0102b1f:	74 0e                	je     f0102b2f <command_allocuserpage+0x12e>
f0102b21:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b24:	83 c0 0c             	add    $0xc,%eax
f0102b27:	8b 00                	mov    (%eax),%eax
f0102b29:	8a 00                	mov    (%eax),%al
f0102b2b:	3c 57                	cmp    $0x57,%al
f0102b2d:	75 09                	jne    f0102b38 <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0102b2f:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0102b36:	eb 17                	jmp    f0102b4f <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0102b38:	83 ec 0c             	sub    $0xc,%esp
f0102b3b:	68 b0 33 12 f0       	push   $0xf01233b0
f0102b40:	e8 27 e4 ff ff       	call   f0100f6c <cprintf>
f0102b45:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0102b48:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0102b4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102b52:	83 c8 04             	or     $0x4,%eax
f0102b55:	89 c1                	mov    %eax,%ecx
f0102b57:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102b5a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102b5d:	8b 40 64             	mov    0x64(%eax),%eax
f0102b60:	51                   	push   %ecx
f0102b61:	ff 75 ec             	pushl  -0x14(%ebp)
f0102b64:	52                   	push   %edx
f0102b65:	50                   	push   %eax
f0102b66:	e8 99 57 00 00       	call   f0108304 <map_frame>
f0102b6b:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102b6e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102b73:	c9                   	leave  
f0102b74:	c3                   	ret    

f0102b75 <command_meminfo>:

int command_meminfo(int number_of_arguments, char **arguments)
{
f0102b75:	55                   	push   %ebp
f0102b76:	89 e5                	mov    %esp,%ebp
f0102b78:	56                   	push   %esi
f0102b79:	53                   	push   %ebx
f0102b7a:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0102b7d:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0102b80:	83 ec 0c             	sub    $0xc,%esp
f0102b83:	50                   	push   %eax
f0102b84:	e8 33 5a 00 00       	call   f01085bc <calculate_available_frames>
f0102b89:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102b8c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102b8f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102b92:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0102b95:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0102b98:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0102b9b:	01 de                	add    %ebx,%esi
f0102b9d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
}

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102ba0:	01 f3                	add    %esi,%ebx
f0102ba2:	83 ec 0c             	sub    $0xc,%esp
f0102ba5:	51                   	push   %ecx
f0102ba6:	52                   	push   %edx
f0102ba7:	50                   	push   %eax
f0102ba8:	53                   	push   %ebx
f0102ba9:	68 f4 33 12 f0       	push   $0xf01233f4
f0102bae:	e8 b9 e3 ff ff       	call   f0100f6c <cprintf>
f0102bb3:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0102bb6:	a1 d0 50 55 f0       	mov    0xf05550d0,%eax
f0102bbb:	83 ec 08             	sub    $0x8,%esp
f0102bbe:	50                   	push   %eax
f0102bbf:	68 4c 34 12 f0       	push   $0xf012344c
f0102bc4:	e8 a3 e3 ff ff       	call   f0100f6c <cprintf>
f0102bc9:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102bcc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102bd1:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102bd4:	5b                   	pop    %ebx
f0102bd5:	5e                   	pop    %esi
f0102bd6:	5d                   	pop    %ebp
f0102bd7:	c3                   	ret    

f0102bd8 <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0102bd8:	55                   	push   %ebp
f0102bd9:	89 e5                	mov    %esp,%ebp
f0102bdb:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0102bde:	c7 45 ec 88 13 00 00 	movl   $0x1388,-0x14(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0102be5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0102bec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0102bf3:	c7 45 e8 9c ff ff ff 	movl   $0xffffff9c,-0x18(%ebp)
//			assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
//		}
	}
#else
	{
		switch (number_of_arguments)
f0102bfa:	8b 45 08             	mov    0x8(%ebp),%eax
f0102bfd:	83 f8 02             	cmp    $0x2,%eax
f0102c00:	74 3c                	je     f0102c3e <CreateEnv+0x66>
f0102c02:	83 f8 03             	cmp    $0x3,%eax
f0102c05:	75 1d                	jne    f0102c24 <CreateEnv+0x4c>
		{
		case 3:
			percent_WS_pages_to_remove = strtol(arguments[2], NULL, 10);
f0102c07:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c0a:	83 c0 08             	add    $0x8,%eax
f0102c0d:	8b 00                	mov    (%eax),%eax
f0102c0f:	83 ec 04             	sub    $0x4,%esp
f0102c12:	6a 0a                	push   $0xa
f0102c14:	6a 00                	push   $0x0
f0102c16:	50                   	push   %eax
f0102c17:	e8 95 dc 01 00       	call   f01208b1 <strtol>
f0102c1c:	83 c4 10             	add    $0x10,%esp
f0102c1f:	89 45 f0             	mov    %eax,-0x10(%ebp)
			break;
f0102c22:	eb 1b                	jmp    f0102c3f <CreateEnv+0x67>
		case 2:
			break;
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f0102c24:	83 ec 0c             	sub    $0xc,%esp
f0102c27:	68 88 34 12 f0       	push   $0xf0123488
f0102c2c:	e8 3b e3 ff ff       	call   f0100f6c <cprintf>
f0102c31:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0102c34:	b8 00 00 00 00       	mov    $0x0,%eax
f0102c39:	e9 a7 00 00 00       	jmp    f0102ce5 <CreateEnv+0x10d>
		{
		case 3:
			percent_WS_pages_to_remove = strtol(arguments[2], NULL, 10);
			break;
		case 2:
			break;
f0102c3e:	90                   	nop
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
			return NULL;

			break;
		}
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102c3f:	83 ec 0c             	sub    $0xc,%esp
f0102c42:	6a 02                	push   $0x2
f0102c44:	e8 44 b7 00 00       	call   f010e38d <isPageReplacmentAlgorithmLRU>
f0102c49:	83 c4 10             	add    $0x10,%esp
f0102c4c:	85 c0                	test   %eax,%eax
f0102c4e:	74 07                	je     f0102c57 <CreateEnv+0x7f>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
f0102c50:	c7 45 f4 f4 01 00 00 	movl   $0x1f4,-0xc(%ebp)
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0102c57:	83 7d f0 64          	cmpl   $0x64,-0x10(%ebp)
f0102c5b:	76 19                	jbe    f0102c76 <CreateEnv+0x9e>
f0102c5d:	68 f8 34 12 f0       	push   $0xf01234f8
f0102c62:	68 3d 35 12 f0       	push   $0xf012353d
f0102c67:	68 c7 01 00 00       	push   $0x1c7
f0102c6c:	68 52 35 12 f0       	push   $0xf0123552
f0102c71:	e8 a4 d6 ff ff       	call   f010031a <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f0102c76:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c79:	83 c0 04             	add    $0x4,%eax
f0102c7c:	8b 00                	mov    (%eax),%eax
f0102c7e:	ff 75 f0             	pushl  -0x10(%ebp)
f0102c81:	ff 75 f4             	pushl  -0xc(%ebp)
f0102c84:	ff 75 ec             	pushl  -0x14(%ebp)
f0102c87:	50                   	push   %eax
f0102c88:	e8 01 6b 00 00       	call   f010978e <env_create>
f0102c8d:	83 c4 10             	add    $0x10,%esp
f0102c90:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (BSDSchedNiceVal != -100)
f0102c93:	83 7d e8 9c          	cmpl   $0xffffff9c,-0x18(%ebp)
f0102c97:	74 49                	je     f0102ce2 <CreateEnv+0x10a>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f0102c99:	83 ec 08             	sub    $0x8,%esp
f0102c9c:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c9f:	68 66 35 12 f0       	push   $0xf0123566
f0102ca4:	e8 c3 e2 ff ff       	call   f0100f6c <cprintf>
f0102ca9:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f0102cac:	83 7d e8 ec          	cmpl   $0xffffffec,-0x18(%ebp)
f0102cb0:	7c 06                	jl     f0102cb8 <CreateEnv+0xe0>
f0102cb2:	83 7d e8 14          	cmpl   $0x14,-0x18(%ebp)
f0102cb6:	7e 19                	jle    f0102cd1 <CreateEnv+0xf9>
f0102cb8:	68 78 35 12 f0       	push   $0xf0123578
f0102cbd:	68 3d 35 12 f0       	push   $0xf012353d
f0102cc2:	68 cc 01 00 00       	push   $0x1cc
f0102cc7:	68 52 35 12 f0       	push   $0xf0123552
f0102ccc:	e8 49 d6 ff ff       	call   f010031a <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f0102cd1:	83 ec 08             	sub    $0x8,%esp
f0102cd4:	ff 75 e8             	pushl  -0x18(%ebp)
f0102cd7:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102cda:	e8 e6 36 00 00       	call   f01063c5 <env_set_nice>
f0102cdf:	83 c4 10             	add    $0x10,%esp
	}
	return env;
f0102ce2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f0102ce5:	c9                   	leave  
f0102ce6:	c3                   	ret    

f0102ce7 <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f0102ce7:	55                   	push   %ebp
f0102ce8:	89 e5                	mov    %esp,%ebp
f0102cea:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0102ced:	83 ec 08             	sub    $0x8,%esp
f0102cf0:	ff 75 0c             	pushl  0xc(%ebp)
f0102cf3:	ff 75 08             	pushl  0x8(%ebp)
f0102cf6:	e8 dd fe ff ff       	call   f0102bd8 <CreateEnv>
f0102cfb:	83 c4 10             	add    $0x10,%esp
f0102cfe:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f0102d01:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0102d05:	75 07                	jne    f0102d0e <command_run_program+0x27>
f0102d07:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d0c:	eb 46                	jmp    f0102d54 <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0102d0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102d11:	8b 40 10             	mov    0x10(%eax),%eax
f0102d14:	83 ec 08             	sub    $0x8,%esp
f0102d17:	50                   	push   %eax
f0102d18:	68 a8 35 12 f0       	push   $0xf01235a8
f0102d1d:	e8 4a e2 ff ff       	call   f0100f6c <cprintf>
f0102d22:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f0102d25:	83 ec 0c             	sub    $0xc,%esp
f0102d28:	ff 75 f4             	pushl  -0xc(%ebp)
f0102d2b:	e8 93 26 00 00       	call   f01053c3 <sched_new_env>
f0102d30:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f0102d33:	c7 05 d0 50 55 f0 00 	movl   $0x0,0xf05550d0
f0102d3a:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f0102d3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102d40:	8b 40 10             	mov    0x10(%eax),%eax
f0102d43:	83 ec 0c             	sub    $0xc,%esp
f0102d46:	50                   	push   %eax
f0102d47:	e8 cd 26 00 00       	call   f0105419 <sched_run_env>
f0102d4c:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102d4f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102d54:	c9                   	leave  
f0102d55:	c3                   	ret    

f0102d56 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f0102d56:	55                   	push   %ebp
f0102d57:	89 e5                	mov    %esp,%ebp
f0102d59:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102d5c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d5f:	83 c0 04             	add    $0x4,%eax
f0102d62:	8b 00                	mov    (%eax),%eax
f0102d64:	83 ec 04             	sub    $0x4,%esp
f0102d67:	6a 0a                	push   $0xa
f0102d69:	6a 00                	push   $0x0
f0102d6b:	50                   	push   %eax
f0102d6c:	e8 40 db 01 00       	call   f01208b1 <strtol>
f0102d71:	83 c4 10             	add    $0x10,%esp
f0102d74:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f0102d77:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102d7a:	83 ec 0c             	sub    $0xc,%esp
f0102d7d:	50                   	push   %eax
f0102d7e:	e8 fe 29 00 00       	call   f0105781 <sched_kill_env>
f0102d83:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102d86:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102d8b:	c9                   	leave  
f0102d8c:	c3                   	ret    

f0102d8d <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f0102d8d:	55                   	push   %ebp
f0102d8e:	89 e5                	mov    %esp,%ebp
f0102d90:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0102d93:	83 ec 08             	sub    $0x8,%esp
f0102d96:	ff 75 0c             	pushl  0xc(%ebp)
f0102d99:	ff 75 08             	pushl  0x8(%ebp)
f0102d9c:	e8 37 fe ff ff       	call   f0102bd8 <CreateEnv>
f0102da1:	83 c4 10             	add    $0x10,%esp
f0102da4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0102da7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0102dab:	75 07                	jne    f0102db4 <commnad_load_env+0x27>
		return 0 ;
f0102dad:	b8 00 00 00 00       	mov    $0x0,%eax
f0102db2:	eb 2a                	jmp    f0102dde <commnad_load_env+0x51>

	sched_new_env(env) ;
f0102db4:	83 ec 0c             	sub    $0xc,%esp
f0102db7:	ff 75 f4             	pushl  -0xc(%ebp)
f0102dba:	e8 04 26 00 00       	call   f01053c3 <sched_new_env>
f0102dbf:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0102dc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102dc5:	8b 40 10             	mov    0x10(%eax),%eax
f0102dc8:	83 ec 08             	sub    $0x8,%esp
f0102dcb:	50                   	push   %eax
f0102dcc:	68 a8 35 12 f0       	push   $0xf01235a8
f0102dd1:	e8 96 e1 ff ff       	call   f0100f6c <cprintf>
f0102dd6:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102dd9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102dde:	c9                   	leave  
f0102ddf:	c3                   	ret    

f0102de0 <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f0102de0:	55                   	push   %ebp
f0102de1:	89 e5                	mov    %esp,%ebp
f0102de3:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f0102de6:	c7 05 d0 50 55 f0 00 	movl   $0x0,0xf05550d0
f0102ded:	00 00 00 
	sched_run_all();
f0102df0:	e8 7b 2f 00 00       	call   f0105d70 <sched_run_all>

	return 0 ;
f0102df5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102dfa:	c9                   	leave  
f0102dfb:	c3                   	ret    

f0102dfc <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f0102dfc:	55                   	push   %ebp
f0102dfd:	89 e5                	mov    %esp,%ebp
f0102dff:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f0102e02:	e8 38 2d 00 00       	call   f0105b3f <sched_print_all>

	return 0 ;
f0102e07:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102e0c:	c9                   	leave  
f0102e0d:	c3                   	ret    

f0102e0e <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f0102e0e:	55                   	push   %ebp
f0102e0f:	89 e5                	mov    %esp,%ebp
f0102e11:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f0102e14:	e8 ec 2f 00 00       	call   f0105e05 <sched_kill_all>

	return 0 ;
f0102e19:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102e1e:	c9                   	leave  
f0102e1f:	c3                   	ret    

f0102e20 <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f0102e20:	55                   	push   %ebp
f0102e21:	89 e5                	mov    %esp,%ebp
f0102e23:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f0102e26:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0102e2a:	7f 1a                	jg     f0102e46 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0102e2c:	83 ec 0c             	sub    $0xc,%esp
f0102e2f:	68 c0 35 12 f0       	push   $0xf01235c0
f0102e34:	e8 33 e1 ff ff       	call   f0100f6c <cprintf>
f0102e39:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102e3c:	b8 00 00 00 00       	mov    $0x0,%eax
f0102e41:	e9 83 00 00 00       	jmp    f0102ec9 <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f0102e46:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e49:	83 c0 04             	add    $0x4,%eax
f0102e4c:	8b 00                	mov    (%eax),%eax
f0102e4e:	83 ec 04             	sub    $0x4,%esp
f0102e51:	6a 0a                	push   $0xa
f0102e53:	6a 00                	push   $0x0
f0102e55:	50                   	push   %eax
f0102e56:	e8 56 da 01 00       	call   f01208b1 <strtol>
f0102e5b:	83 c4 10             	add    $0x10,%esp
f0102e5e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f0102e61:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0102e65:	75 20                	jne    f0102e87 <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f0102e67:	83 ec 0c             	sub    $0xc,%esp
f0102e6a:	ff 75 f4             	pushl  -0xc(%ebp)
f0102e6d:	e8 90 b4 00 00       	call   f010e302 <setPageReplacmentAlgorithmLRU>
f0102e72:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f0102e75:	83 ec 0c             	sub    $0xc,%esp
f0102e78:	68 20 36 12 f0       	push   $0xf0123620
f0102e7d:	e8 ea e0 ff ff       	call   f0100f6c <cprintf>
f0102e82:	83 c4 10             	add    $0x10,%esp
f0102e85:	eb 3d                	jmp    f0102ec4 <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f0102e87:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0102e8b:	75 20                	jne    f0102ead <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f0102e8d:	83 ec 0c             	sub    $0xc,%esp
f0102e90:	ff 75 f4             	pushl  -0xc(%ebp)
f0102e93:	e8 6a b4 00 00       	call   f010e302 <setPageReplacmentAlgorithmLRU>
f0102e98:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f0102e9b:	83 ec 0c             	sub    $0xc,%esp
f0102e9e:	68 64 36 12 f0       	push   $0xf0123664
f0102ea3:	e8 c4 e0 ff ff       	call   f0100f6c <cprintf>
f0102ea8:	83 c4 10             	add    $0x10,%esp
f0102eab:	eb 17                	jmp    f0102ec4 <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0102ead:	83 ec 0c             	sub    $0xc,%esp
f0102eb0:	68 a4 36 12 f0       	push   $0xf01236a4
f0102eb5:	e8 b2 e0 ff ff       	call   f0100f6c <cprintf>
f0102eba:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102ebd:	b8 00 00 00 00       	mov    $0x0,%eax
f0102ec2:	eb 05                	jmp    f0102ec9 <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f0102ec4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102ec9:	c9                   	leave  
f0102eca:	c3                   	ret    

f0102ecb <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f0102ecb:	55                   	push   %ebp
f0102ecc:	89 e5                	mov    %esp,%ebp
f0102ece:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f0102ed1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ed4:	83 c0 04             	add    $0x4,%eax
f0102ed7:	8b 00                	mov    (%eax),%eax
f0102ed9:	83 ec 04             	sub    $0x4,%esp
f0102edc:	6a 0a                	push   $0xa
f0102ede:	6a 00                	push   $0x0
f0102ee0:	50                   	push   %eax
f0102ee1:	e8 cb d9 01 00       	call   f01208b1 <strtol>
f0102ee6:	83 c4 10             	add    $0x10,%esp
f0102ee9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f0102eec:	83 ec 0c             	sub    $0xc,%esp
f0102eef:	ff 75 f4             	pushl  -0xc(%ebp)
f0102ef2:	e8 7e b4 00 00       	call   f010e375 <setPageReplacmentAlgorithmNchanceCLOCK>
f0102ef7:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f0102efa:	83 ec 0c             	sub    $0xc,%esp
f0102efd:	68 f8 36 12 f0       	push   $0xf01236f8
f0102f02:	e8 65 e0 ff ff       	call   f0100f6c <cprintf>
f0102f07:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102f0a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102f0f:	c9                   	leave  
f0102f10:	c3                   	ret    

f0102f11 <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f0102f11:	55                   	push   %ebp
f0102f12:	89 e5                	mov    %esp,%ebp
f0102f14:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f0102f17:	e8 19 b4 00 00       	call   f010e335 <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f0102f1c:	83 ec 0c             	sub    $0xc,%esp
f0102f1f:	68 2c 37 12 f0       	push   $0xf012372c
f0102f24:	e8 43 e0 ff ff       	call   f0100f6c <cprintf>
f0102f29:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102f2c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102f31:	c9                   	leave  
f0102f32:	c3                   	ret    

f0102f33 <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f0102f33:	55                   	push   %ebp
f0102f34:	89 e5                	mov    %esp,%ebp
f0102f36:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f0102f39:	e8 07 b4 00 00       	call   f010e345 <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f0102f3e:	83 ec 0c             	sub    $0xc,%esp
f0102f41:	68 58 37 12 f0       	push   $0xf0123758
f0102f46:	e8 21 e0 ff ff       	call   f0100f6c <cprintf>
f0102f4b:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102f4e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102f53:	c9                   	leave  
f0102f54:	c3                   	ret    

f0102f55 <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f0102f55:	55                   	push   %ebp
f0102f56:	89 e5                	mov    %esp,%ebp
f0102f58:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f0102f5b:	e8 f5 b3 00 00       	call   f010e355 <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f0102f60:	83 ec 0c             	sub    $0xc,%esp
f0102f63:	68 80 37 12 f0       	push   $0xf0123780
f0102f68:	e8 ff df ff ff       	call   f0100f6c <cprintf>
f0102f6d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102f70:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102f75:	c9                   	leave  
f0102f76:	c3                   	ret    

f0102f77 <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f0102f77:	55                   	push   %ebp
f0102f78:	89 e5                	mov    %esp,%ebp
f0102f7a:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f0102f7d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f80:	83 c0 04             	add    $0x4,%eax
f0102f83:	8b 00                	mov    (%eax),%eax
f0102f85:	83 ec 04             	sub    $0x4,%esp
f0102f88:	6a 0a                	push   $0xa
f0102f8a:	6a 00                	push   $0x0
f0102f8c:	50                   	push   %eax
f0102f8d:	e8 1f d9 01 00       	call   f01208b1 <strtol>
f0102f92:	83 c4 10             	add    $0x10,%esp
f0102f95:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f0102f98:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0102f9c:	83 ec 0c             	sub    $0xc,%esp
f0102f9f:	50                   	push   %eax
f0102fa0:	e8 4e 37 00 00       	call   f01066f3 <sched_init_RR>
f0102fa5:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f0102fa8:	a0 e4 4d 55 f0       	mov    0xf0554de4,%al
f0102fad:	0f b6 c0             	movzbl %al,%eax
f0102fb0:	83 ec 08             	sub    $0x8,%esp
f0102fb3:	50                   	push   %eax
f0102fb4:	68 b4 37 12 f0       	push   $0xf01237b4
f0102fb9:	e8 ae df ff ff       	call   f0100f6c <cprintf>
f0102fbe:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102fc1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102fc6:	c9                   	leave  
f0102fc7:	c3                   	ret    

f0102fc8 <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f0102fc8:	55                   	push   %ebp
f0102fc9:	89 e5                	mov    %esp,%ebp
f0102fcb:	53                   	push   %ebx
f0102fcc:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f0102fcf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fd2:	83 c0 04             	add    $0x4,%eax
f0102fd5:	8b 00                	mov    (%eax),%eax
f0102fd7:	83 ec 04             	sub    $0x4,%esp
f0102fda:	6a 0a                	push   $0xa
f0102fdc:	6a 00                	push   $0x0
f0102fde:	50                   	push   %eax
f0102fdf:	e8 cd d8 01 00       	call   f01208b1 <strtol>
f0102fe4:	83 c4 10             	add    $0x10,%esp
f0102fe7:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f0102fea:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0102ff1:	eb 2e                	jmp    f0103021 <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f0102ff3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102ff6:	8d 58 fe             	lea    -0x2(%eax),%ebx
f0102ff9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102ffc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103003:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103006:	01 d0                	add    %edx,%eax
f0103008:	8b 00                	mov    (%eax),%eax
f010300a:	83 ec 04             	sub    $0x4,%esp
f010300d:	6a 0a                	push   $0xa
f010300f:	6a 00                	push   $0x0
f0103011:	50                   	push   %eax
f0103012:	e8 9a d8 01 00       	call   f01208b1 <strtol>
f0103017:	83 c4 10             	add    $0x10,%esp
f010301a:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f010301e:	ff 45 f4             	incl   -0xc(%ebp)
f0103021:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103024:	3b 45 08             	cmp    0x8(%ebp),%eax
f0103027:	7c ca                	jl     f0102ff3 <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f0103029:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f010302d:	83 ec 08             	sub    $0x8,%esp
f0103030:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f0103033:	52                   	push   %edx
f0103034:	50                   	push   %eax
f0103035:	e8 32 37 00 00       	call   f010676c <sched_init_MLFQ>
f010303a:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f010303d:	83 ec 0c             	sub    $0xc,%esp
f0103040:	68 ec 37 12 f0       	push   $0xf01237ec
f0103045:	e8 22 df ff ff       	call   f0100f6c <cprintf>
f010304a:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f010304d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0103054:	eb 21                	jmp    f0103077 <command_sch_MLFQ+0xaf>
	{
		cprintf("%d   ", quantums[i]) ;
f0103056:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103059:	05 e4 4d 55 f0       	add    $0xf0554de4,%eax
f010305e:	8a 00                	mov    (%eax),%al
f0103060:	0f b6 c0             	movzbl %al,%eax
f0103063:	83 ec 08             	sub    $0x8,%esp
f0103066:	50                   	push   %eax
f0103067:	68 19 38 12 f0       	push   $0xf0123819
f010306c:	e8 fb de ff ff       	call   f0100f6c <cprintf>
f0103071:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f0103074:	ff 45 f0             	incl   -0x10(%ebp)
f0103077:	a0 60 51 55 f0       	mov    0xf0555160,%al
f010307c:	0f b6 c0             	movzbl %al,%eax
f010307f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0103082:	7f d2                	jg     f0103056 <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f0103084:	83 ec 0c             	sub    $0xc,%esp
f0103087:	68 59 33 12 f0       	push   $0xf0123359
f010308c:	e8 db de ff ff       	call   f0100f6c <cprintf>
f0103091:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103094:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103099:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010309c:	c9                   	leave  
f010309d:	c3                   	ret    

f010309e <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f010309e:	55                   	push   %ebp
f010309f:	89 e5                	mov    %esp,%ebp
f01030a1:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f01030a4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01030a7:	83 c0 04             	add    $0x4,%eax
f01030aa:	8b 00                	mov    (%eax),%eax
f01030ac:	83 ec 04             	sub    $0x4,%esp
f01030af:	6a 0a                	push   $0xa
f01030b1:	6a 00                	push   $0x0
f01030b3:	50                   	push   %eax
f01030b4:	e8 f8 d7 01 00       	call   f01208b1 <strtol>
f01030b9:	83 c4 10             	add    $0x10,%esp
f01030bc:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f01030bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01030c2:	83 c0 08             	add    $0x8,%eax
f01030c5:	8b 00                	mov    (%eax),%eax
f01030c7:	83 ec 04             	sub    $0x4,%esp
f01030ca:	6a 0a                	push   $0xa
f01030cc:	6a 00                	push   $0x0
f01030ce:	50                   	push   %eax
f01030cf:	e8 dd d7 01 00       	call   f01208b1 <strtol>
f01030d4:	83 c4 10             	add    $0x10,%esp
f01030d7:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f01030da:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f01030de:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01030e2:	83 ec 08             	sub    $0x8,%esp
f01030e5:	52                   	push   %edx
f01030e6:	50                   	push   %eax
f01030e7:	e8 a8 36 00 00       	call   f0106794 <sched_init_BSD>
f01030ec:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f01030ef:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f01030f3:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01030f7:	83 ec 04             	sub    $0x4,%esp
f01030fa:	52                   	push   %edx
f01030fb:	50                   	push   %eax
f01030fc:	68 20 38 12 f0       	push   $0xf0123820
f0103101:	e8 66 de ff ff       	call   f0100f6c <cprintf>
f0103106:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0103109:	83 ec 0c             	sub    $0xc,%esp
f010310c:	68 59 33 12 f0       	push   $0xf0123359
f0103111:	e8 56 de ff ff       	call   f0100f6c <cprintf>
f0103116:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103119:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010311e:	c9                   	leave  
f010311f:	c3                   	ret    

f0103120 <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f0103120:	55                   	push   %ebp
f0103121:	89 e5                	mov    %esp,%ebp
f0103123:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f0103126:	e8 0b 33 00 00       	call   f0106436 <isSchedMethodMLFQ>
f010312b:	85 c0                	test   %eax,%eax
f010312d:	74 59                	je     f0103188 <command_print_sch_method+0x68>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f010312f:	83 ec 0c             	sub    $0xc,%esp
f0103132:	68 5c 38 12 f0       	push   $0xf012385c
f0103137:	e8 30 de ff ff       	call   f0100f6c <cprintf>
f010313c:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f010313f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0103146:	eb 21                	jmp    f0103169 <command_print_sch_method+0x49>
		{
			cprintf("%d   ", quantums[i]) ;
f0103148:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010314b:	05 e4 4d 55 f0       	add    $0xf0554de4,%eax
f0103150:	8a 00                	mov    (%eax),%al
f0103152:	0f b6 c0             	movzbl %al,%eax
f0103155:	83 ec 08             	sub    $0x8,%esp
f0103158:	50                   	push   %eax
f0103159:	68 19 38 12 f0       	push   $0xf0123819
f010315e:	e8 09 de ff ff       	call   f0100f6c <cprintf>
f0103163:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f0103166:	ff 45 f4             	incl   -0xc(%ebp)
f0103169:	a0 60 51 55 f0       	mov    0xf0555160,%al
f010316e:	0f b6 c0             	movzbl %al,%eax
f0103171:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0103174:	7f d2                	jg     f0103148 <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f0103176:	83 ec 0c             	sub    $0xc,%esp
f0103179:	68 59 33 12 f0       	push   $0xf0123359
f010317e:	e8 e9 dd ff ff       	call   f0100f6c <cprintf>
f0103183:	83 c4 10             	add    $0x10,%esp
f0103186:	eb 61                	jmp    f01031e9 <command_print_sch_method+0xc9>
	}
	else if (isSchedMethodRR())
f0103188:	e8 8f 32 00 00       	call   f010641c <isSchedMethodRR>
f010318d:	85 c0                	test   %eax,%eax
f010318f:	74 1b                	je     f01031ac <command_print_sch_method+0x8c>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f0103191:	a0 e4 4d 55 f0       	mov    0xf0554de4,%al
f0103196:	0f b6 c0             	movzbl %al,%eax
f0103199:	83 ec 08             	sub    $0x8,%esp
f010319c:	50                   	push   %eax
f010319d:	68 90 38 12 f0       	push   $0xf0123890
f01031a2:	e8 c5 dd ff ff       	call   f0100f6c <cprintf>
f01031a7:	83 c4 10             	add    $0x10,%esp
f01031aa:	eb 3d                	jmp    f01031e9 <command_print_sch_method+0xc9>
	}
	else if (isSchedMethodBSD())
f01031ac:	e8 a0 32 00 00       	call   f0106451 <isSchedMethodBSD>
f01031b1:	85 c0                	test   %eax,%eax
f01031b3:	74 24                	je     f01031d9 <command_print_sch_method+0xb9>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f01031b5:	a0 e4 4d 55 f0       	mov    0xf0554de4,%al
f01031ba:	0f b6 d0             	movzbl %al,%edx
f01031bd:	a0 60 51 55 f0       	mov    0xf0555160,%al
f01031c2:	0f b6 c0             	movzbl %al,%eax
f01031c5:	83 ec 04             	sub    $0x4,%esp
f01031c8:	52                   	push   %edx
f01031c9:	50                   	push   %eax
f01031ca:	68 20 38 12 f0       	push   $0xf0123820
f01031cf:	e8 98 dd ff ff       	call   f0100f6c <cprintf>
f01031d4:	83 c4 10             	add    $0x10,%esp
f01031d7:	eb 10                	jmp    f01031e9 <command_print_sch_method+0xc9>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f01031d9:	83 ec 0c             	sub    $0xc,%esp
f01031dc:	68 cc 38 12 f0       	push   $0xf01238cc
f01031e1:	e8 86 dd ff ff       	call   f0100f6c <cprintf>
f01031e6:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031e9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031ee:	c9                   	leave  
f01031ef:	c3                   	ret    

f01031f0 <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f01031f0:	55                   	push   %ebp
f01031f1:	89 e5                	mov    %esp,%ebp
f01031f3:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f01031f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031f9:	83 c0 04             	add    $0x4,%eax
f01031fc:	8b 00                	mov    (%eax),%eax
f01031fe:	83 ec 04             	sub    $0x4,%esp
f0103201:	6a 0a                	push   $0xa
f0103203:	6a 00                	push   $0x0
f0103205:	50                   	push   %eax
f0103206:	e8 a6 d6 01 00       	call   f01208b1 <strtol>
f010320b:	83 c4 10             	add    $0x10,%esp
f010320e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f0103211:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103214:	0f b6 c0             	movzbl %al,%eax
f0103217:	83 ec 0c             	sub    $0xc,%esp
f010321a:	50                   	push   %eax
f010321b:	e8 8e c4 01 00       	call   f011f6ae <chksch>
f0103220:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f0103223:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103227:	75 12                	jne    f010323b <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f0103229:	83 ec 0c             	sub    $0xc,%esp
f010322c:	68 f4 38 12 f0       	push   $0xf01238f4
f0103231:	e8 36 dd ff ff       	call   f0100f6c <cprintf>
f0103236:	83 c4 10             	add    $0x10,%esp
f0103239:	eb 16                	jmp    f0103251 <command_sch_test+0x61>
	else if (status == 1)
f010323b:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010323f:	75 10                	jne    f0103251 <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f0103241:	83 ec 0c             	sub    $0xc,%esp
f0103244:	68 1c 39 12 f0       	push   $0xf012391c
f0103249:	e8 1e dd ff ff       	call   f0100f6c <cprintf>
f010324e:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103251:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103256:	c9                   	leave  
f0103257:	c3                   	ret    

f0103258 <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f0103258:	55                   	push   %ebp
f0103259:	89 e5                	mov    %esp,%ebp
f010325b:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f010325e:	e8 40 b1 00 00       	call   f010e3a3 <isPageReplacmentAlgorithmCLOCK>
f0103263:	85 c0                	test   %eax,%eax
f0103265:	74 15                	je     f010327c <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f0103267:	83 ec 0c             	sub    $0xc,%esp
f010326a:	68 40 39 12 f0       	push   $0xf0123940
f010326f:	e8 f8 dc ff ff       	call   f0100f6c <cprintf>
f0103274:	83 c4 10             	add    $0x10,%esp
f0103277:	e9 8c 00 00 00       	jmp    f0103308 <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010327c:	83 ec 0c             	sub    $0xc,%esp
f010327f:	6a 01                	push   $0x1
f0103281:	e8 07 b1 00 00       	call   f010e38d <isPageReplacmentAlgorithmLRU>
f0103286:	83 c4 10             	add    $0x10,%esp
f0103289:	85 c0                	test   %eax,%eax
f010328b:	74 12                	je     f010329f <command_print_page_rep+0x47>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f010328d:	83 ec 0c             	sub    $0xc,%esp
f0103290:	68 68 39 12 f0       	push   $0xf0123968
f0103295:	e8 d2 dc ff ff       	call   f0100f6c <cprintf>
f010329a:	83 c4 10             	add    $0x10,%esp
f010329d:	eb 69                	jmp    f0103308 <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010329f:	83 ec 0c             	sub    $0xc,%esp
f01032a2:	6a 02                	push   $0x2
f01032a4:	e8 e4 b0 00 00       	call   f010e38d <isPageReplacmentAlgorithmLRU>
f01032a9:	83 c4 10             	add    $0x10,%esp
f01032ac:	85 c0                	test   %eax,%eax
f01032ae:	74 12                	je     f01032c2 <command_print_page_rep+0x6a>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f01032b0:	83 ec 0c             	sub    $0xc,%esp
f01032b3:	68 a8 39 12 f0       	push   $0xf01239a8
f01032b8:	e8 af dc ff ff       	call   f0100f6c <cprintf>
f01032bd:	83 c4 10             	add    $0x10,%esp
f01032c0:	eb 46                	jmp    f0103308 <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmFIFO())
f01032c2:	e8 f7 b0 00 00       	call   f010e3be <isPageReplacmentAlgorithmFIFO>
f01032c7:	85 c0                	test   %eax,%eax
f01032c9:	74 12                	je     f01032dd <command_print_page_rep+0x85>
		cprintf("Page replacement algorithm is FIFO\n");
f01032cb:	83 ec 0c             	sub    $0xc,%esp
f01032ce:	68 e4 39 12 f0       	push   $0xf01239e4
f01032d3:	e8 94 dc ff ff       	call   f0100f6c <cprintf>
f01032d8:	83 c4 10             	add    $0x10,%esp
f01032db:	eb 2b                	jmp    f0103308 <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f01032dd:	e8 f7 b0 00 00       	call   f010e3d9 <isPageReplacmentAlgorithmModifiedCLOCK>
f01032e2:	85 c0                	test   %eax,%eax
f01032e4:	74 12                	je     f01032f8 <command_print_page_rep+0xa0>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f01032e6:	83 ec 0c             	sub    $0xc,%esp
f01032e9:	68 08 3a 12 f0       	push   $0xf0123a08
f01032ee:	e8 79 dc ff ff       	call   f0100f6c <cprintf>
f01032f3:	83 c4 10             	add    $0x10,%esp
f01032f6:	eb 10                	jmp    f0103308 <command_print_page_rep+0xb0>
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f01032f8:	83 ec 0c             	sub    $0xc,%esp
f01032fb:	68 38 3a 12 f0       	push   $0xf0123a38
f0103300:	e8 67 dc ff ff       	call   f0100f6c <cprintf>
f0103305:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103308:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010330d:	c9                   	leave  
f010330e:	c3                   	ret    

f010330f <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f010330f:	55                   	push   %ebp
f0103310:	89 e5                	mov    %esp,%ebp
f0103312:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyFIRSTFIT();
f0103315:	e8 a2 ef ff ff       	call   f01022bc <setUHeapPlacementStrategyFIRSTFIT>
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f010331a:	83 ec 0c             	sub    $0xc,%esp
f010331d:	68 64 3a 12 f0       	push   $0xf0123a64
f0103322:	e8 45 dc ff ff       	call   f0100f6c <cprintf>
f0103327:	83 c4 10             	add    $0x10,%esp
	return 0;
f010332a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010332f:	c9                   	leave  
f0103330:	c3                   	ret    

f0103331 <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0103331:	55                   	push   %ebp
f0103332:	89 e5                	mov    %esp,%ebp
f0103334:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyBESTFIT();
f0103337:	e8 90 ef ff ff       	call   f01022cc <setUHeapPlacementStrategyBESTFIT>
	cprintf("User Heap placement strategy is now BEST FIT\n");
f010333c:	83 ec 0c             	sub    $0xc,%esp
f010333f:	68 94 3a 12 f0       	push   $0xf0123a94
f0103344:	e8 23 dc ff ff       	call   f0100f6c <cprintf>
f0103349:	83 c4 10             	add    $0x10,%esp
	return 0;
f010334c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103351:	c9                   	leave  
f0103352:	c3                   	ret    

f0103353 <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f0103353:	55                   	push   %ebp
f0103354:	89 e5                	mov    %esp,%ebp
f0103356:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyNEXTFIT();
f0103359:	e8 7e ef ff ff       	call   f01022dc <setUHeapPlacementStrategyNEXTFIT>
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f010335e:	83 ec 0c             	sub    $0xc,%esp
f0103361:	68 c4 3a 12 f0       	push   $0xf0123ac4
f0103366:	e8 01 dc ff ff       	call   f0100f6c <cprintf>
f010336b:	83 c4 10             	add    $0x10,%esp
	return 0;
f010336e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103373:	c9                   	leave  
f0103374:	c3                   	ret    

f0103375 <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f0103375:	55                   	push   %ebp
f0103376:	89 e5                	mov    %esp,%ebp
f0103378:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyWORSTFIT();
f010337b:	e8 6c ef ff ff       	call   f01022ec <setUHeapPlacementStrategyWORSTFIT>
	cprintf("User Heap placement strategy is now WORST FIT\n");
f0103380:	83 ec 0c             	sub    $0xc,%esp
f0103383:	68 f4 3a 12 f0       	push   $0xf0123af4
f0103388:	e8 df db ff ff       	call   f0100f6c <cprintf>
f010338d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103390:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103395:	c9                   	leave  
f0103396:	c3                   	ret    

f0103397 <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f0103397:	55                   	push   %ebp
f0103398:	89 e5                	mov    %esp,%ebp
f010339a:	83 ec 08             	sub    $0x8,%esp
	if (isUHeapPlacementStrategyFIRSTFIT())
f010339d:	e8 5a ef ff ff       	call   f01022fc <isUHeapPlacementStrategyFIRSTFIT>
f01033a2:	84 c0                	test   %al,%al
f01033a4:	74 12                	je     f01033b8 <command_print_uheap_plac+0x21>
		cprintf("User Heap placement strategy is FIRST FIT\n");
f01033a6:	83 ec 0c             	sub    $0xc,%esp
f01033a9:	68 24 3b 12 f0       	push   $0xf0123b24
f01033ae:	e8 b9 db ff ff       	call   f0100f6c <cprintf>
f01033b3:	83 c4 10             	add    $0x10,%esp
f01033b6:	eb 61                	jmp    f0103419 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyBESTFIT())
f01033b8:	e8 54 ef ff ff       	call   f0102311 <isUHeapPlacementStrategyBESTFIT>
f01033bd:	84 c0                	test   %al,%al
f01033bf:	74 12                	je     f01033d3 <command_print_uheap_plac+0x3c>
		cprintf("User Heap placement strategy is BEST FIT\n");
f01033c1:	83 ec 0c             	sub    $0xc,%esp
f01033c4:	68 50 3b 12 f0       	push   $0xf0123b50
f01033c9:	e8 9e db ff ff       	call   f0100f6c <cprintf>
f01033ce:	83 c4 10             	add    $0x10,%esp
f01033d1:	eb 46                	jmp    f0103419 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyNEXTFIT())
f01033d3:	e8 4e ef ff ff       	call   f0102326 <isUHeapPlacementStrategyNEXTFIT>
f01033d8:	84 c0                	test   %al,%al
f01033da:	74 12                	je     f01033ee <command_print_uheap_plac+0x57>
		cprintf("User Heap placement strategy is NEXT FIT\n");
f01033dc:	83 ec 0c             	sub    $0xc,%esp
f01033df:	68 7c 3b 12 f0       	push   $0xf0123b7c
f01033e4:	e8 83 db ff ff       	call   f0100f6c <cprintf>
f01033e9:	83 c4 10             	add    $0x10,%esp
f01033ec:	eb 2b                	jmp    f0103419 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyWORSTFIT())
f01033ee:	e8 48 ef ff ff       	call   f010233b <isUHeapPlacementStrategyWORSTFIT>
f01033f3:	84 c0                	test   %al,%al
f01033f5:	74 12                	je     f0103409 <command_print_uheap_plac+0x72>
		cprintf("User Heap placement strategy is WORST FIT\n");
f01033f7:	83 ec 0c             	sub    $0xc,%esp
f01033fa:	68 a8 3b 12 f0       	push   $0xf0123ba8
f01033ff:	e8 68 db ff ff       	call   f0100f6c <cprintf>
f0103404:	83 c4 10             	add    $0x10,%esp
f0103407:	eb 10                	jmp    f0103419 <command_print_uheap_plac+0x82>
	else
		cprintf("User Heap placement strategy is UNDEFINED\n");
f0103409:	83 ec 0c             	sub    $0xc,%esp
f010340c:	68 d4 3b 12 f0       	push   $0xf0123bd4
f0103411:	e8 56 db ff ff       	call   f0100f6c <cprintf>
f0103416:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103419:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010341e:	c9                   	leave  
f010341f:	c3                   	ret    

f0103420 <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f0103420:	55                   	push   %ebp
f0103421:	89 e5                	mov    %esp,%ebp
f0103423:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyCONTALLOC();
f0103426:	e8 d9 ed ff ff       	call   f0102204 <setKHeapPlacementStrategyCONTALLOC>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f010342b:	83 ec 0c             	sub    $0xc,%esp
f010342e:	68 00 3c 12 f0       	push   $0xf0123c00
f0103433:	e8 34 db ff ff       	call   f0100f6c <cprintf>
f0103438:	83 c4 10             	add    $0x10,%esp
	return 0;
f010343b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103440:	c9                   	leave  
f0103441:	c3                   	ret    

f0103442 <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f0103442:	55                   	push   %ebp
f0103443:	89 e5                	mov    %esp,%ebp
f0103445:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyFIRSTFIT();
f0103448:	e8 c7 ed ff ff       	call   f0102214 <setKHeapPlacementStrategyFIRSTFIT>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f010344d:	83 ec 0c             	sub    $0xc,%esp
f0103450:	68 00 3c 12 f0       	push   $0xf0123c00
f0103455:	e8 12 db ff ff       	call   f0100f6c <cprintf>
f010345a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010345d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103462:	c9                   	leave  
f0103463:	c3                   	ret    

f0103464 <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0103464:	55                   	push   %ebp
f0103465:	89 e5                	mov    %esp,%ebp
f0103467:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyBESTFIT();
f010346a:	e8 b5 ed ff ff       	call   f0102224 <setKHeapPlacementStrategyBESTFIT>
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f010346f:	83 ec 0c             	sub    $0xc,%esp
f0103472:	68 34 3c 12 f0       	push   $0xf0123c34
f0103477:	e8 f0 da ff ff       	call   f0100f6c <cprintf>
f010347c:	83 c4 10             	add    $0x10,%esp
	return 0;
f010347f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103484:	c9                   	leave  
f0103485:	c3                   	ret    

f0103486 <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f0103486:	55                   	push   %ebp
f0103487:	89 e5                	mov    %esp,%ebp
f0103489:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyNEXTFIT();
f010348c:	e8 a3 ed ff ff       	call   f0102234 <setKHeapPlacementStrategyNEXTFIT>
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f0103491:	83 ec 0c             	sub    $0xc,%esp
f0103494:	68 64 3c 12 f0       	push   $0xf0123c64
f0103499:	e8 ce da ff ff       	call   f0100f6c <cprintf>
f010349e:	83 c4 10             	add    $0x10,%esp
	return 0;
f01034a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034a6:	c9                   	leave  
f01034a7:	c3                   	ret    

f01034a8 <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f01034a8:	55                   	push   %ebp
f01034a9:	89 e5                	mov    %esp,%ebp
f01034ab:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyWORSTFIT();
f01034ae:	e8 91 ed ff ff       	call   f0102244 <setKHeapPlacementStrategyWORSTFIT>
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f01034b3:	83 ec 0c             	sub    $0xc,%esp
f01034b6:	68 94 3c 12 f0       	push   $0xf0123c94
f01034bb:	e8 ac da ff ff       	call   f0100f6c <cprintf>
f01034c0:	83 c4 10             	add    $0x10,%esp
	return 0;
f01034c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034c8:	c9                   	leave  
f01034c9:	c3                   	ret    

f01034ca <command_print_kheap_plac>:

int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f01034ca:	55                   	push   %ebp
f01034cb:	89 e5                	mov    %esp,%ebp
f01034cd:	83 ec 08             	sub    $0x8,%esp
	if (isKHeapPlacementStrategyCONTALLOC())
f01034d0:	e8 7f ed ff ff       	call   f0102254 <isKHeapPlacementStrategyCONTALLOC>
f01034d5:	84 c0                	test   %al,%al
f01034d7:	74 12                	je     f01034eb <command_print_kheap_plac+0x21>
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f01034d9:	83 ec 0c             	sub    $0xc,%esp
f01034dc:	68 c8 3c 12 f0       	push   $0xf0123cc8
f01034e1:	e8 86 da ff ff       	call   f0100f6c <cprintf>
f01034e6:	83 c4 10             	add    $0x10,%esp
f01034e9:	eb 7c                	jmp    f0103567 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyFIRSTFIT())
f01034eb:	e8 78 ed ff ff       	call   f0102268 <isKHeapPlacementStrategyFIRSTFIT>
f01034f0:	84 c0                	test   %al,%al
f01034f2:	74 12                	je     f0103506 <command_print_kheap_plac+0x3c>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f01034f4:	83 ec 0c             	sub    $0xc,%esp
f01034f7:	68 04 3d 12 f0       	push   $0xf0123d04
f01034fc:	e8 6b da ff ff       	call   f0100f6c <cprintf>
f0103501:	83 c4 10             	add    $0x10,%esp
f0103504:	eb 61                	jmp    f0103567 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyBESTFIT())
f0103506:	e8 72 ed ff ff       	call   f010227d <isKHeapPlacementStrategyBESTFIT>
f010350b:	84 c0                	test   %al,%al
f010350d:	74 12                	je     f0103521 <command_print_kheap_plac+0x57>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f010350f:	83 ec 0c             	sub    $0xc,%esp
f0103512:	68 34 3d 12 f0       	push   $0xf0123d34
f0103517:	e8 50 da ff ff       	call   f0100f6c <cprintf>
f010351c:	83 c4 10             	add    $0x10,%esp
f010351f:	eb 46                	jmp    f0103567 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyNEXTFIT())
f0103521:	e8 6c ed ff ff       	call   f0102292 <isKHeapPlacementStrategyNEXTFIT>
f0103526:	84 c0                	test   %al,%al
f0103528:	74 12                	je     f010353c <command_print_kheap_plac+0x72>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f010352a:	83 ec 0c             	sub    $0xc,%esp
f010352d:	68 60 3d 12 f0       	push   $0xf0123d60
f0103532:	e8 35 da ff ff       	call   f0100f6c <cprintf>
f0103537:	83 c4 10             	add    $0x10,%esp
f010353a:	eb 2b                	jmp    f0103567 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyWORSTFIT())
f010353c:	e8 66 ed ff ff       	call   f01022a7 <isKHeapPlacementStrategyWORSTFIT>
f0103541:	84 c0                	test   %al,%al
f0103543:	74 12                	je     f0103557 <command_print_kheap_plac+0x8d>
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f0103545:	83 ec 0c             	sub    $0xc,%esp
f0103548:	68 8c 3d 12 f0       	push   $0xf0123d8c
f010354d:	e8 1a da ff ff       	call   f0100f6c <cprintf>
f0103552:	83 c4 10             	add    $0x10,%esp
f0103555:	eb 10                	jmp    f0103567 <command_print_kheap_plac+0x9d>
	else
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f0103557:	83 ec 0c             	sub    $0xc,%esp
f010355a:	68 bc 3d 12 f0       	push   $0xf0123dbc
f010355f:	e8 08 da ff ff       	call   f0100f6c <cprintf>
f0103564:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103567:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010356c:	c9                   	leave  
f010356d:	c3                   	ret    

f010356e <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f010356e:	55                   	push   %ebp
f010356f:	89 e5                	mov    %esp,%ebp
f0103571:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103574:	e8 d7 ae 00 00       	call   f010e450 <isBufferingEnabled>
f0103579:	84 c0                	test   %al,%al
f010357b:	75 12                	jne    f010358f <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f010357d:	83 ec 0c             	sub    $0xc,%esp
f0103580:	68 ec 3d 12 f0       	push   $0xf0123dec
f0103585:	e8 e2 d9 ff ff       	call   f0100f6c <cprintf>
f010358a:	83 c4 10             	add    $0x10,%esp
f010358d:	eb 1d                	jmp    f01035ac <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f010358f:	83 ec 0c             	sub    $0xc,%esp
f0103592:	6a 00                	push   $0x0
f0103594:	e8 91 ae 00 00       	call   f010e42a <enableModifiedBuffer>
f0103599:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f010359c:	83 ec 0c             	sub    $0xc,%esp
f010359f:	68 28 3e 12 f0       	push   $0xf0123e28
f01035a4:	e8 c3 d9 ff ff       	call   f0100f6c <cprintf>
f01035a9:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f01035ac:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01035b1:	c9                   	leave  
f01035b2:	c3                   	ret    

f01035b3 <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f01035b3:	55                   	push   %ebp
f01035b4:	89 e5                	mov    %esp,%ebp
f01035b6:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f01035b9:	e8 92 ae 00 00       	call   f010e450 <isBufferingEnabled>
f01035be:	84 c0                	test   %al,%al
f01035c0:	75 12                	jne    f01035d4 <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f01035c2:	83 ec 0c             	sub    $0xc,%esp
f01035c5:	68 ec 3d 12 f0       	push   $0xf0123dec
f01035ca:	e8 9d d9 ff ff       	call   f0100f6c <cprintf>
f01035cf:	83 c4 10             	add    $0x10,%esp
f01035d2:	eb 1d                	jmp    f01035f1 <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f01035d4:	83 ec 0c             	sub    $0xc,%esp
f01035d7:	6a 01                	push   $0x1
f01035d9:	e8 4c ae 00 00       	call   f010e42a <enableModifiedBuffer>
f01035de:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f01035e1:	83 ec 0c             	sub    $0xc,%esp
f01035e4:	68 4c 3e 12 f0       	push   $0xf0123e4c
f01035e9:	e8 7e d9 ff ff       	call   f0100f6c <cprintf>
f01035ee:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f01035f1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01035f6:	c9                   	leave  
f01035f7:	c3                   	ret    

f01035f8 <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f01035f8:	55                   	push   %ebp
f01035f9:	89 e5                	mov    %esp,%ebp
f01035fb:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f01035fe:	83 ec 0c             	sub    $0xc,%esp
f0103601:	6a 00                	push   $0x0
f0103603:	e8 3a ae 00 00       	call   f010e442 <enableBuffering>
f0103608:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f010360b:	83 ec 0c             	sub    $0xc,%esp
f010360e:	6a 00                	push   $0x0
f0103610:	e8 15 ae 00 00       	call   f010e42a <enableModifiedBuffer>
f0103615:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f0103618:	83 ec 0c             	sub    $0xc,%esp
f010361b:	68 6c 3e 12 f0       	push   $0xf0123e6c
f0103620:	e8 47 d9 ff ff       	call   f0100f6c <cprintf>
f0103625:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103628:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010362d:	c9                   	leave  
f010362e:	c3                   	ret    

f010362f <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f010362f:	55                   	push   %ebp
f0103630:	89 e5                	mov    %esp,%ebp
f0103632:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0103635:	83 ec 0c             	sub    $0xc,%esp
f0103638:	6a 01                	push   $0x1
f010363a:	e8 03 ae 00 00       	call   f010e442 <enableBuffering>
f010363f:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0103642:	83 ec 0c             	sub    $0xc,%esp
f0103645:	6a 01                	push   $0x1
f0103647:	e8 de ad 00 00       	call   f010e42a <enableModifiedBuffer>
f010364c:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f010364f:	e8 14 ae 00 00       	call   f010e468 <getModifiedBufferLength>
f0103654:	85 c0                	test   %eax,%eax
f0103656:	75 59                	jne    f01036b1 <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f0103658:	83 ec 0c             	sub    $0xc,%esp
f010365b:	68 88 3e 12 f0       	push   $0xf0123e88
f0103660:	e8 07 d9 ff ff       	call   f0100f6c <cprintf>
f0103665:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f0103668:	83 ec 08             	sub    $0x8,%esp
f010366b:	8d 45 94             	lea    -0x6c(%ebp),%eax
f010366e:	50                   	push   %eax
f010366f:	68 b8 3e 12 f0       	push   $0xf0123eb8
f0103674:	e8 d0 cc 01 00       	call   f0120349 <readline>
f0103679:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f010367c:	83 ec 04             	sub    $0x4,%esp
f010367f:	6a 0a                	push   $0xa
f0103681:	6a 00                	push   $0x0
f0103683:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103686:	50                   	push   %eax
f0103687:	e8 25 d2 01 00       	call   f01208b1 <strtol>
f010368c:	83 c4 10             	add    $0x10,%esp
f010368f:	83 ec 0c             	sub    $0xc,%esp
f0103692:	50                   	push   %eax
f0103693:	e8 c2 ad 00 00       	call   f010e45a <setModifiedBufferLength>
f0103698:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f010369b:	e8 c8 ad 00 00       	call   f010e468 <getModifiedBufferLength>
f01036a0:	83 ec 08             	sub    $0x8,%esp
f01036a3:	50                   	push   %eax
f01036a4:	68 e4 3e 12 f0       	push   $0xf0123ee4
f01036a9:	e8 be d8 ff ff       	call   f0100f6c <cprintf>
f01036ae:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f01036b1:	83 ec 0c             	sub    $0xc,%esp
f01036b4:	68 09 3f 12 f0       	push   $0xf0123f09
f01036b9:	e8 ae d8 ff ff       	call   f0100f6c <cprintf>
f01036be:	83 c4 10             	add    $0x10,%esp
	return 0;
f01036c1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01036c6:	c9                   	leave  
f01036c7:	c3                   	ret    

f01036c8 <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f01036c8:	55                   	push   %ebp
f01036c9:	89 e5                	mov    %esp,%ebp
f01036cb:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f01036ce:	e8 7d ad 00 00       	call   f010e450 <isBufferingEnabled>
f01036d3:	84 c0                	test   %al,%al
f01036d5:	75 12                	jne    f01036e9 <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f01036d7:	83 ec 0c             	sub    $0xc,%esp
f01036da:	68 24 3f 12 f0       	push   $0xf0123f24
f01036df:	e8 88 d8 ff ff       	call   f0100f6c <cprintf>
f01036e4:	83 c4 10             	add    $0x10,%esp
f01036e7:	eb 19                	jmp    f0103702 <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f01036e9:	e8 4a ad 00 00       	call   f010e438 <isModifiedBufferEnabled>
f01036ee:	84 c0                	test   %al,%al
f01036f0:	75 10                	jne    f0103702 <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f01036f2:	83 ec 0c             	sub    $0xc,%esp
f01036f5:	68 74 3f 12 f0       	push   $0xf0123f74
f01036fa:	e8 6d d8 ff ff       	call   f0100f6c <cprintf>
f01036ff:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f0103702:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103705:	83 c0 04             	add    $0x4,%eax
f0103708:	8b 00                	mov    (%eax),%eax
f010370a:	83 ec 04             	sub    $0x4,%esp
f010370d:	6a 0a                	push   $0xa
f010370f:	6a 00                	push   $0x0
f0103711:	50                   	push   %eax
f0103712:	e8 9a d1 01 00       	call   f01208b1 <strtol>
f0103717:	83 c4 10             	add    $0x10,%esp
f010371a:	83 ec 0c             	sub    $0xc,%esp
f010371d:	50                   	push   %eax
f010371e:	e8 37 ad 00 00       	call   f010e45a <setModifiedBufferLength>
f0103723:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103726:	e8 3d ad 00 00       	call   f010e468 <getModifiedBufferLength>
f010372b:	83 ec 08             	sub    $0x8,%esp
f010372e:	50                   	push   %eax
f010372f:	68 e4 3e 12 f0       	push   $0xf0123ee4
f0103734:	e8 33 d8 ff ff       	call   f0100f6c <cprintf>
f0103739:	83 c4 10             	add    $0x10,%esp
	return 0;
f010373c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103741:	c9                   	leave  
f0103742:	c3                   	ret    

f0103743 <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103743:	55                   	push   %ebp
f0103744:	89 e5                	mov    %esp,%ebp
f0103746:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103749:	e8 02 ad 00 00       	call   f010e450 <isBufferingEnabled>
f010374e:	84 c0                	test   %al,%al
f0103750:	75 12                	jne    f0103764 <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103752:	83 ec 0c             	sub    $0xc,%esp
f0103755:	68 24 3f 12 f0       	push   $0xf0123f24
f010375a:	e8 0d d8 ff ff       	call   f0100f6c <cprintf>
f010375f:	83 c4 10             	add    $0x10,%esp
f0103762:	eb 19                	jmp    f010377d <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103764:	e8 cf ac 00 00       	call   f010e438 <isModifiedBufferEnabled>
f0103769:	84 c0                	test   %al,%al
f010376b:	75 10                	jne    f010377d <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f010376d:	83 ec 0c             	sub    $0xc,%esp
f0103770:	68 74 3f 12 f0       	push   $0xf0123f74
f0103775:	e8 f2 d7 ff ff       	call   f0100f6c <cprintf>
f010377a:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f010377d:	e8 e6 ac 00 00       	call   f010e468 <getModifiedBufferLength>
f0103782:	83 ec 08             	sub    $0x8,%esp
f0103785:	50                   	push   %eax
f0103786:	68 ba 3f 12 f0       	push   $0xf0123fba
f010378b:	e8 dc d7 ff ff       	call   f0100f6c <cprintf>
f0103790:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103793:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103798:	c9                   	leave  
f0103799:	c3                   	ret    

f010379a <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f010379a:	55                   	push   %ebp
f010379b:	89 e5                	mov    %esp,%ebp
f010379d:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f01037a0:	83 ec 08             	sub    $0x8,%esp
f01037a3:	ff 75 0c             	pushl  0xc(%ebp)
f01037a6:	ff 75 08             	pushl  0x8(%ebp)
f01037a9:	e8 7a b4 00 00       	call   f010ec28 <tst_handler>
f01037ae:	83 c4 10             	add    $0x10,%esp
}
f01037b1:	c9                   	leave  
f01037b2:	c3                   	ret    

f01037b3 <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f01037b3:	55                   	push   %ebp
f01037b4:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f01037b6:	8b 45 08             	mov    0x8(%ebp),%eax
f01037b9:	8b 15 20 4f 55 f0    	mov    0xf0554f20,%edx
f01037bf:	29 d0                	sub    %edx,%eax
f01037c1:	c1 f8 03             	sar    $0x3,%eax
f01037c4:	89 c2                	mov    %eax,%edx
f01037c6:	89 d0                	mov    %edx,%eax
f01037c8:	c1 e0 02             	shl    $0x2,%eax
f01037cb:	01 d0                	add    %edx,%eax
f01037cd:	c1 e0 02             	shl    $0x2,%eax
f01037d0:	01 d0                	add    %edx,%eax
f01037d2:	c1 e0 02             	shl    $0x2,%eax
f01037d5:	01 d0                	add    %edx,%eax
f01037d7:	89 c1                	mov    %eax,%ecx
f01037d9:	c1 e1 08             	shl    $0x8,%ecx
f01037dc:	01 c8                	add    %ecx,%eax
f01037de:	89 c1                	mov    %eax,%ecx
f01037e0:	c1 e1 10             	shl    $0x10,%ecx
f01037e3:	01 c8                	add    %ecx,%eax
f01037e5:	01 c0                	add    %eax,%eax
f01037e7:	01 d0                	add    %edx,%eax
}
f01037e9:	5d                   	pop    %ebp
f01037ea:	c3                   	ret    

f01037eb <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f01037eb:	55                   	push   %ebp
f01037ec:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f01037ee:	ff 75 08             	pushl  0x8(%ebp)
f01037f1:	e8 bd ff ff ff       	call   f01037b3 <to_frame_number>
f01037f6:	83 c4 04             	add    $0x4,%esp
f01037f9:	c1 e0 0c             	shl    $0xc,%eax
}
f01037fc:	c9                   	leave  
f01037fd:	c3                   	ret    

f01037fe <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f01037fe:	55                   	push   %ebp
f01037ff:	89 e5                	mov    %esp,%ebp
f0103801:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0103804:	8b 45 08             	mov    0x8(%ebp),%eax
f0103807:	c1 e8 0c             	shr    $0xc,%eax
f010380a:	89 c2                	mov    %eax,%edx
f010380c:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0103811:	39 c2                	cmp    %eax,%edx
f0103813:	72 14                	jb     f0103829 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0103815:	83 ec 04             	sub    $0x4,%esp
f0103818:	68 d8 3f 12 f0       	push   $0xf0123fd8
f010381d:	6a 55                	push   $0x55
f010381f:	68 00 40 12 f0       	push   $0xf0124000
f0103824:	e8 f1 ca ff ff       	call   f010031a <_panic>
	return &frames_info[PPN(physical_address)];
f0103829:	8b 15 20 4f 55 f0    	mov    0xf0554f20,%edx
f010382f:	8b 45 08             	mov    0x8(%ebp),%eax
f0103832:	c1 e8 0c             	shr    $0xc,%eax
f0103835:	89 c1                	mov    %eax,%ecx
f0103837:	89 c8                	mov    %ecx,%eax
f0103839:	01 c0                	add    %eax,%eax
f010383b:	01 c8                	add    %ecx,%eax
f010383d:	c1 e0 03             	shl    $0x3,%eax
f0103840:	01 d0                	add    %edx,%eax
}
f0103842:	c9                   	leave  
f0103843:	c3                   	ret    

f0103844 <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0103844:	55                   	push   %ebp
f0103845:	89 e5                	mov    %esp,%ebp
f0103847:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f010384a:	8b 45 08             	mov    0x8(%ebp),%eax
f010384d:	05 00 14 00 00       	add    $0x1400,%eax
f0103852:	c1 e0 03             	shl    $0x3,%eax
f0103855:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103858:	83 ec 04             	sub    $0x4,%esp
f010385b:	6a 08                	push   $0x8
f010385d:	ff 75 0c             	pushl  0xc(%ebp)
f0103860:	ff 75 f4             	pushl  -0xc(%ebp)
f0103863:	e8 d1 d4 01 00       	call   f0120d39 <ide_read>
f0103868:	83 c4 10             	add    $0x10,%esp
f010386b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f010386e:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103871:	c9                   	leave  
f0103872:	c3                   	ret    

f0103873 <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0103873:	55                   	push   %ebp
f0103874:	89 e5                	mov    %esp,%ebp
f0103876:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103879:	8b 45 08             	mov    0x8(%ebp),%eax
f010387c:	05 00 14 00 00       	add    $0x1400,%eax
f0103881:	c1 e0 03             	shl    $0x3,%eax
f0103884:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103887:	83 ec 04             	sub    $0x4,%esp
f010388a:	6a 08                	push   $0x8
f010388c:	ff 75 0c             	pushl  0xc(%ebp)
f010388f:	ff 75 f4             	pushl  -0xc(%ebp)
f0103892:	e8 e2 d5 01 00       	call   f0120e79 <ide_write>
f0103897:	83 c4 10             	add    $0x10,%esp
f010389a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f010389d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01038a1:	74 14                	je     f01038b7 <write_disk_page+0x44>
		panic("Error writing on disk\n");
f01038a3:	83 ec 04             	sub    $0x4,%esp
f01038a6:	68 22 40 12 f0       	push   $0xf0124022
f01038ab:	6a 2f                	push   $0x2f
f01038ad:	68 39 40 12 f0       	push   $0xf0124039
f01038b2:	e8 63 ca ff ff       	call   f010031a <_panic>
	return success;
f01038b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f01038ba:	c9                   	leave  
f01038bb:	c3                   	ret    

f01038bc <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f01038bc:	55                   	push   %ebp
f01038bd:	89 e5                	mov    %esp,%ebp
f01038bf:	53                   	push   %ebx
f01038c0:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f01038c3:	c7 05 e0 50 55 f0 00 	movl   $0x0,0xf05550e0
f01038ca:	00 00 00 
f01038cd:	c7 05 e4 50 55 f0 00 	movl   $0x0,0xf05550e4
f01038d4:	00 00 00 
f01038d7:	c7 05 ec 50 55 f0 00 	movl   $0x0,0xf05550ec
f01038de:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f01038e1:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f01038e8:	e9 e8 00 00 00       	jmp    f01039d5 <initialize_disk_page_file+0x119>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f01038ed:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f01038f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01038f6:	89 d0                	mov    %edx,%eax
f01038f8:	01 c0                	add    %eax,%eax
f01038fa:	01 d0                	add    %edx,%eax
f01038fc:	c1 e0 03             	shl    $0x3,%eax
f01038ff:	01 c8                	add    %ecx,%eax
f0103901:	83 ec 0c             	sub    $0xc,%esp
f0103904:	50                   	push   %eax
f0103905:	e8 c9 45 00 00       	call   f0107ed3 <initialize_frame_info>
f010390a:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f010390d:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f0103913:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103916:	89 d0                	mov    %edx,%eax
f0103918:	01 c0                	add    %eax,%eax
f010391a:	01 d0                	add    %edx,%eax
f010391c:	c1 e0 03             	shl    $0x3,%eax
f010391f:	01 c8                	add    %ecx,%eax
f0103921:	85 c0                	test   %eax,%eax
f0103923:	75 14                	jne    f0103939 <initialize_disk_page_file+0x7d>
f0103925:	83 ec 04             	sub    $0x4,%esp
f0103928:	68 58 40 12 f0       	push   $0xf0124058
f010392d:	6a 56                	push   $0x56
f010392f:	68 39 40 12 f0       	push   $0xf0124039
f0103934:	e8 e1 c9 ff ff       	call   f010031a <_panic>
f0103939:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f010393f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103942:	89 d0                	mov    %edx,%eax
f0103944:	01 c0                	add    %eax,%eax
f0103946:	01 d0                	add    %edx,%eax
f0103948:	c1 e0 03             	shl    $0x3,%eax
f010394b:	01 c8                	add    %ecx,%eax
f010394d:	8b 15 e0 50 55 f0    	mov    0xf05550e0,%edx
f0103953:	89 10                	mov    %edx,(%eax)
f0103955:	8b 00                	mov    (%eax),%eax
f0103957:	85 c0                	test   %eax,%eax
f0103959:	74 1f                	je     f010397a <initialize_disk_page_file+0xbe>
f010395b:	8b 15 e0 50 55 f0    	mov    0xf05550e0,%edx
f0103961:	8b 1d c0 22 55 f0    	mov    0xf05522c0,%ebx
f0103967:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010396a:	89 c8                	mov    %ecx,%eax
f010396c:	01 c0                	add    %eax,%eax
f010396e:	01 c8                	add    %ecx,%eax
f0103970:	c1 e0 03             	shl    $0x3,%eax
f0103973:	01 d8                	add    %ebx,%eax
f0103975:	89 42 04             	mov    %eax,0x4(%edx)
f0103978:	eb 19                	jmp    f0103993 <initialize_disk_page_file+0xd7>
f010397a:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f0103980:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103983:	89 d0                	mov    %edx,%eax
f0103985:	01 c0                	add    %eax,%eax
f0103987:	01 d0                	add    %edx,%eax
f0103989:	c1 e0 03             	shl    $0x3,%eax
f010398c:	01 c8                	add    %ecx,%eax
f010398e:	a3 e4 50 55 f0       	mov    %eax,0xf05550e4
f0103993:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f0103999:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010399c:	89 d0                	mov    %edx,%eax
f010399e:	01 c0                	add    %eax,%eax
f01039a0:	01 d0                	add    %edx,%eax
f01039a2:	c1 e0 03             	shl    $0x3,%eax
f01039a5:	01 c8                	add    %ecx,%eax
f01039a7:	a3 e0 50 55 f0       	mov    %eax,0xf05550e0
f01039ac:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f01039b2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01039b5:	89 d0                	mov    %edx,%eax
f01039b7:	01 c0                	add    %eax,%eax
f01039b9:	01 d0                	add    %edx,%eax
f01039bb:	c1 e0 03             	shl    $0x3,%eax
f01039be:	01 c8                	add    %ecx,%eax
f01039c0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01039c7:	a1 ec 50 55 f0       	mov    0xf05550ec,%eax
f01039cc:	40                   	inc    %eax
f01039cd:	a3 ec 50 55 f0       	mov    %eax,0xf05550ec
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f01039d2:	ff 45 f4             	incl   -0xc(%ebp)
f01039d5:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f01039dc:	0f 8e 0b ff ff ff    	jle    f01038ed <initialize_disk_page_file+0x31>
		initialize_frame_info(&(disk_frames_info[i]));

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}
}
f01039e2:	90                   	nop
f01039e3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01039e6:	c9                   	leave  
f01039e7:	c3                   	ret    

f01039e8 <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f01039e8:	55                   	push   %ebp
f01039e9:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f01039eb:	8b 45 08             	mov    0x8(%ebp),%eax
f01039ee:	8b 15 c0 22 55 f0    	mov    0xf05522c0,%edx
f01039f4:	29 d0                	sub    %edx,%eax
f01039f6:	c1 f8 03             	sar    $0x3,%eax
f01039f9:	89 c2                	mov    %eax,%edx
f01039fb:	89 d0                	mov    %edx,%eax
f01039fd:	c1 e0 02             	shl    $0x2,%eax
f0103a00:	01 d0                	add    %edx,%eax
f0103a02:	c1 e0 02             	shl    $0x2,%eax
f0103a05:	01 d0                	add    %edx,%eax
f0103a07:	c1 e0 02             	shl    $0x2,%eax
f0103a0a:	01 d0                	add    %edx,%eax
f0103a0c:	89 c1                	mov    %eax,%ecx
f0103a0e:	c1 e1 08             	shl    $0x8,%ecx
f0103a11:	01 c8                	add    %ecx,%eax
f0103a13:	89 c1                	mov    %eax,%ecx
f0103a15:	c1 e1 10             	shl    $0x10,%ecx
f0103a18:	01 c8                	add    %ecx,%eax
f0103a1a:	01 c0                	add    %eax,%eax
f0103a1c:	01 d0                	add    %edx,%eax
}
f0103a1e:	5d                   	pop    %ebp
f0103a1f:	c3                   	ret    

f0103a20 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0103a20:	55                   	push   %ebp
f0103a21:	89 e5                	mov    %esp,%ebp
f0103a23:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0103a26:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103a2d:	83 ec 0c             	sub    $0xc,%esp
f0103a30:	68 f0 50 55 f0       	push   $0xf05550f0
f0103a35:	e8 64 ad 00 00       	call   f010e79e <acquire_spinlock>
f0103a3a:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0103a3d:	a1 e0 50 55 f0       	mov    0xf05550e0,%eax
f0103a42:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f0103a45:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103a49:	75 0c                	jne    f0103a57 <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0103a4b:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f0103a52:	e9 a2 00 00 00       	jmp    f0103af9 <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0103a57:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103a5b:	75 14                	jne    f0103a71 <allocate_disk_frame+0x51>
f0103a5d:	83 ec 04             	sub    $0x4,%esp
f0103a60:	68 7b 40 12 f0       	push   $0xf012407b
f0103a65:	6a 7b                	push   $0x7b
f0103a67:	68 39 40 12 f0       	push   $0xf0124039
f0103a6c:	e8 a9 c8 ff ff       	call   f010031a <_panic>
f0103a71:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103a74:	8b 00                	mov    (%eax),%eax
f0103a76:	85 c0                	test   %eax,%eax
f0103a78:	74 10                	je     f0103a8a <allocate_disk_frame+0x6a>
f0103a7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103a7d:	8b 00                	mov    (%eax),%eax
f0103a7f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103a82:	8b 52 04             	mov    0x4(%edx),%edx
f0103a85:	89 50 04             	mov    %edx,0x4(%eax)
f0103a88:	eb 0b                	jmp    f0103a95 <allocate_disk_frame+0x75>
f0103a8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103a8d:	8b 40 04             	mov    0x4(%eax),%eax
f0103a90:	a3 e4 50 55 f0       	mov    %eax,0xf05550e4
f0103a95:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103a98:	8b 40 04             	mov    0x4(%eax),%eax
f0103a9b:	85 c0                	test   %eax,%eax
f0103a9d:	74 0f                	je     f0103aae <allocate_disk_frame+0x8e>
f0103a9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103aa2:	8b 40 04             	mov    0x4(%eax),%eax
f0103aa5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103aa8:	8b 12                	mov    (%edx),%edx
f0103aaa:	89 10                	mov    %edx,(%eax)
f0103aac:	eb 0a                	jmp    f0103ab8 <allocate_disk_frame+0x98>
f0103aae:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103ab1:	8b 00                	mov    (%eax),%eax
f0103ab3:	a3 e0 50 55 f0       	mov    %eax,0xf05550e0
f0103ab8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103abb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0103ac1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103ac4:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103acb:	a1 ec 50 55 f0       	mov    0xf05550ec,%eax
f0103ad0:	48                   	dec    %eax
f0103ad1:	a3 ec 50 55 f0       	mov    %eax,0xf05550ec
			initialize_frame_info(ptr_frame_info);
f0103ad6:	83 ec 0c             	sub    $0xc,%esp
f0103ad9:	ff 75 f0             	pushl  -0x10(%ebp)
f0103adc:	e8 f2 43 00 00       	call   f0107ed3 <initialize_frame_info>
f0103ae1:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f0103ae4:	83 ec 0c             	sub    $0xc,%esp
f0103ae7:	ff 75 f0             	pushl  -0x10(%ebp)
f0103aea:	e8 f9 fe ff ff       	call   f01039e8 <to_disk_frame_number>
f0103aef:	83 c4 10             	add    $0x10,%esp
f0103af2:	89 c2                	mov    %eax,%edx
f0103af4:	8b 45 08             	mov    0x8(%ebp),%eax
f0103af7:	89 10                	mov    %edx,(%eax)
		}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103af9:	83 ec 0c             	sub    $0xc,%esp
f0103afc:	68 f0 50 55 f0       	push   $0xf05550f0
f0103b01:	e8 1f ad 00 00       	call   f010e825 <release_spinlock>
f0103b06:	83 c4 10             	add    $0x10,%esp

	return ret;
f0103b09:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0103b0c:	c9                   	leave  
f0103b0d:	c3                   	ret    

f0103b0e <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f0103b0e:	55                   	push   %ebp
f0103b0f:	89 e5                	mov    %esp,%ebp
f0103b11:	53                   	push   %ebx
f0103b12:	83 ec 04             	sub    $0x4,%esp
	// Fill this function in
	if(dfn == 0) return;
f0103b15:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0103b19:	0f 84 ea 00 00 00    	je     f0103c09 <free_disk_frame+0xfb>
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103b1f:	83 ec 0c             	sub    $0xc,%esp
f0103b22:	68 f0 50 55 f0       	push   $0xf05550f0
f0103b27:	e8 72 ac 00 00       	call   f010e79e <acquire_spinlock>
f0103b2c:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f0103b2f:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f0103b35:	8b 55 08             	mov    0x8(%ebp),%edx
f0103b38:	89 d0                	mov    %edx,%eax
f0103b3a:	01 c0                	add    %eax,%eax
f0103b3c:	01 d0                	add    %edx,%eax
f0103b3e:	c1 e0 03             	shl    $0x3,%eax
f0103b41:	01 c8                	add    %ecx,%eax
f0103b43:	85 c0                	test   %eax,%eax
f0103b45:	75 17                	jne    f0103b5e <free_disk_frame+0x50>
f0103b47:	83 ec 04             	sub    $0x4,%esp
f0103b4a:	68 58 40 12 f0       	push   $0xf0124058
f0103b4f:	68 8e 00 00 00       	push   $0x8e
f0103b54:	68 39 40 12 f0       	push   $0xf0124039
f0103b59:	e8 bc c7 ff ff       	call   f010031a <_panic>
f0103b5e:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f0103b64:	8b 55 08             	mov    0x8(%ebp),%edx
f0103b67:	89 d0                	mov    %edx,%eax
f0103b69:	01 c0                	add    %eax,%eax
f0103b6b:	01 d0                	add    %edx,%eax
f0103b6d:	c1 e0 03             	shl    $0x3,%eax
f0103b70:	01 c8                	add    %ecx,%eax
f0103b72:	8b 15 e0 50 55 f0    	mov    0xf05550e0,%edx
f0103b78:	89 10                	mov    %edx,(%eax)
f0103b7a:	8b 00                	mov    (%eax),%eax
f0103b7c:	85 c0                	test   %eax,%eax
f0103b7e:	74 1f                	je     f0103b9f <free_disk_frame+0x91>
f0103b80:	8b 15 e0 50 55 f0    	mov    0xf05550e0,%edx
f0103b86:	8b 1d c0 22 55 f0    	mov    0xf05522c0,%ebx
f0103b8c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103b8f:	89 c8                	mov    %ecx,%eax
f0103b91:	01 c0                	add    %eax,%eax
f0103b93:	01 c8                	add    %ecx,%eax
f0103b95:	c1 e0 03             	shl    $0x3,%eax
f0103b98:	01 d8                	add    %ebx,%eax
f0103b9a:	89 42 04             	mov    %eax,0x4(%edx)
f0103b9d:	eb 19                	jmp    f0103bb8 <free_disk_frame+0xaa>
f0103b9f:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f0103ba5:	8b 55 08             	mov    0x8(%ebp),%edx
f0103ba8:	89 d0                	mov    %edx,%eax
f0103baa:	01 c0                	add    %eax,%eax
f0103bac:	01 d0                	add    %edx,%eax
f0103bae:	c1 e0 03             	shl    $0x3,%eax
f0103bb1:	01 c8                	add    %ecx,%eax
f0103bb3:	a3 e4 50 55 f0       	mov    %eax,0xf05550e4
f0103bb8:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f0103bbe:	8b 55 08             	mov    0x8(%ebp),%edx
f0103bc1:	89 d0                	mov    %edx,%eax
f0103bc3:	01 c0                	add    %eax,%eax
f0103bc5:	01 d0                	add    %edx,%eax
f0103bc7:	c1 e0 03             	shl    $0x3,%eax
f0103bca:	01 c8                	add    %ecx,%eax
f0103bcc:	a3 e0 50 55 f0       	mov    %eax,0xf05550e0
f0103bd1:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f0103bd7:	8b 55 08             	mov    0x8(%ebp),%edx
f0103bda:	89 d0                	mov    %edx,%eax
f0103bdc:	01 c0                	add    %eax,%eax
f0103bde:	01 d0                	add    %edx,%eax
f0103be0:	c1 e0 03             	shl    $0x3,%eax
f0103be3:	01 c8                	add    %ecx,%eax
f0103be5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103bec:	a1 ec 50 55 f0       	mov    0xf05550ec,%eax
f0103bf1:	40                   	inc    %eax
f0103bf2:	a3 ec 50 55 f0       	mov    %eax,0xf05550ec
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103bf7:	83 ec 0c             	sub    $0xc,%esp
f0103bfa:	68 f0 50 55 f0       	push   $0xf05550f0
f0103bff:	e8 21 ac 00 00       	call   f010e825 <release_spinlock>
f0103c04:	83 c4 10             	add    $0x10,%esp
f0103c07:	eb 01                	jmp    f0103c0a <free_disk_frame+0xfc>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f0103c09:	90                   	nop
	acquire_spinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_spinlock(&DiskFrameLists.dfllock);
}
f0103c0a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103c0d:	c9                   	leave  
f0103c0e:	c3                   	ret    

f0103c0f <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f0103c0f:	55                   	push   %ebp
f0103c10:	89 e5                	mov    %esp,%ebp
f0103c12:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f0103c15:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103c18:	c1 e8 16             	shr    $0x16,%eax
f0103c1b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103c22:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c25:	01 d0                	add    %edx,%eax
f0103c27:	8b 00                	mov    (%eax),%eax
f0103c29:	89 45 f4             	mov    %eax,-0xc(%ebp)
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f0103c2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103c2f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0103c34:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0103c37:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103c3a:	c1 e8 0c             	shr    $0xc,%eax
f0103c3d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0103c40:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0103c45:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0103c48:	72 17                	jb     f0103c61 <get_disk_page_table+0x52>
f0103c4a:	ff 75 f0             	pushl  -0x10(%ebp)
f0103c4d:	68 9c 40 12 f0       	push   $0xf012409c
f0103c52:	68 9d 00 00 00       	push   $0x9d
f0103c57:	68 39 40 12 f0       	push   $0xf0124039
f0103c5c:	e8 b9 c6 ff ff       	call   f010031a <_panic>
f0103c61:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103c64:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0103c69:	89 c2                	mov    %eax,%edx
f0103c6b:	8b 45 14             	mov    0x14(%ebp),%eax
f0103c6e:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f0103c70:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103c74:	0f 85 b7 00 00 00    	jne    f0103d31 <get_disk_page_table+0x122>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f0103c7a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0103c7e:	0f 84 9d 00 00 00    	je     f0103d21 <get_disk_page_table+0x112>
						,PERM_PRESENT);
			}
#else
			{
				struct FrameInfo* ptr_frame_info;
				allocate_frame(&ptr_frame_info) ;
f0103c84:	83 ec 0c             	sub    $0xc,%esp
f0103c87:	8d 45 dc             	lea    -0x24(%ebp),%eax
f0103c8a:	50                   	push   %eax
f0103c8b:	e8 5e 42 00 00       	call   f0107eee <allocate_frame>
f0103c90:	83 c4 10             	add    $0x10,%esp

				//LOG_STATMENT(cprintf("created table"));
				uint32 phys_page_table = to_physical_address(ptr_frame_info);
f0103c93:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0103c96:	83 ec 0c             	sub    $0xc,%esp
f0103c99:	50                   	push   %eax
f0103c9a:	e8 4c fb ff ff       	call   f01037eb <to_physical_address>
f0103c9f:	83 c4 10             	add    $0x10,%esp
f0103ca2:	89 45 e8             	mov    %eax,-0x18(%ebp)
				*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f0103ca5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0103ca8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0103cab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103cae:	c1 e8 0c             	shr    $0xc,%eax
f0103cb1:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0103cb4:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0103cb9:	39 45 e0             	cmp    %eax,-0x20(%ebp)
f0103cbc:	72 17                	jb     f0103cd5 <get_disk_page_table+0xc6>
f0103cbe:	ff 75 e4             	pushl  -0x1c(%ebp)
f0103cc1:	68 9c 40 12 f0       	push   $0xf012409c
f0103cc6:	68 b9 00 00 00       	push   $0xb9
f0103ccb:	68 39 40 12 f0       	push   $0xf0124039
f0103cd0:	e8 45 c6 ff ff       	call   f010031a <_panic>
f0103cd5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103cd8:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0103cdd:	89 c2                	mov    %eax,%edx
f0103cdf:	8b 45 14             	mov    0x14(%ebp),%eax
f0103ce2:	89 10                	mov    %edx,(%eax)
				ptr_frame_info->references = 1;
f0103ce4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0103ce7:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
f0103ced:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103cf0:	c1 e8 16             	shr    $0x16,%eax
f0103cf3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103cfa:	8b 45 08             	mov    0x8(%ebp),%eax
f0103cfd:	01 d0                	add    %edx,%eax
f0103cff:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0103d02:	83 ca 01             	or     $0x1,%edx
f0103d05:	89 10                	mov    %edx,(%eax)
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f0103d07:	8b 45 14             	mov    0x14(%ebp),%eax
f0103d0a:	8b 00                	mov    (%eax),%eax
f0103d0c:	83 ec 04             	sub    $0x4,%esp
f0103d0f:	68 00 10 00 00       	push   $0x1000
f0103d14:	6a 00                	push   $0x0
f0103d16:	50                   	push   %eax
f0103d17:	e8 23 ca 01 00       	call   f012073f <memset>
f0103d1c:	83 c4 10             	add    $0x10,%esp
f0103d1f:	eb 10                	jmp    f0103d31 <get_disk_page_table+0x122>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f0103d21:	8b 45 14             	mov    0x14(%ebp),%eax
f0103d24:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f0103d2a:	b8 00 00 00 00       	mov    $0x0,%eax
f0103d2f:	eb 05                	jmp    f0103d36 <get_disk_page_table+0x127>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f0103d31:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103d36:	c9                   	leave  
f0103d37:	c3                   	ret    

f0103d38 <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f0103d38:	55                   	push   %ebp
f0103d39:	89 e5                	mov    %esp,%ebp
f0103d3b:	83 ec 28             	sub    $0x28,%esp
f0103d3e:	8b 45 10             	mov    0x10(%ebp),%eax
f0103d41:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f0103d44:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f0103d48:	74 72                	je     f0103dbc <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f0103d4a:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0103d51:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103d54:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0103d59:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0103d5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103d5f:	ba 00 00 00 00       	mov    $0x0,%edx
f0103d64:	f7 75 f4             	divl   -0xc(%ebp)
f0103d67:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103d6a:	29 d0                	sub    %edx,%eax
f0103d6c:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0103d6f:	73 2f                	jae    f0103da0 <pf_add_empty_env_page+0x68>
f0103d71:	8b 45 08             	mov    0x8(%ebp),%eax
f0103d74:	8b 50 6c             	mov    0x6c(%eax),%edx
f0103d77:	b8 00 00 00 00       	mov    $0x0,%eax
f0103d7c:	29 d0                	sub    %edx,%eax
f0103d7e:	c1 e0 0c             	shl    $0xc,%eax
f0103d81:	2d 00 20 40 11       	sub    $0x11402000,%eax
f0103d86:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0103d89:	76 15                	jbe    f0103da0 <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f0103d8b:	8b 45 08             	mov    0x8(%ebp),%eax
f0103d8e:	8b 80 64 da 01 00    	mov    0x1da64(%eax),%eax
f0103d94:	8d 50 01             	lea    0x1(%eax),%edx
f0103d97:	8b 45 08             	mov    0x8(%ebp),%eax
f0103d9a:	89 90 64 da 01 00    	mov    %edx,0x1da64(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f0103da0:	a1 b4 4f 55 f0       	mov    0xf0554fb4,%eax
f0103da5:	83 ec 04             	sub    $0x4,%esp
f0103da8:	50                   	push   %eax
f0103da9:	ff 75 0c             	pushl  0xc(%ebp)
f0103dac:	ff 75 08             	pushl  0x8(%ebp)
f0103daf:	e8 b2 00 00 00       	call   f0103e66 <pf_add_env_page>
f0103db4:	83 c4 10             	add    $0x10,%esp
f0103db7:	e9 a8 00 00 00       	jmp    f0103e64 <pf_add_empty_env_page+0x12c>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0103dbc:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0103dc3:	76 19                	jbe    f0103dde <pf_add_empty_env_page+0xa6>
f0103dc5:	68 cc 40 12 f0       	push   $0xf01240cc
f0103dca:	68 f2 40 12 f0       	push   $0xf01240f2
f0103dcf:	68 dc 00 00 00       	push   $0xdc
f0103dd4:	68 39 40 12 f0       	push   $0xf0124039
f0103dd9:	e8 3c c5 ff ff       	call   f010031a <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0103dde:	8b 45 08             	mov    0x8(%ebp),%eax
f0103de1:	83 c0 74             	add    $0x74,%eax
f0103de4:	83 ec 08             	sub    $0x8,%esp
f0103de7:	50                   	push   %eax
f0103de8:	ff 75 08             	pushl  0x8(%ebp)
f0103deb:	e8 ce 05 00 00       	call   f01043be <get_disk_page_directory>
f0103df0:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f0103df3:	8b 45 08             	mov    0x8(%ebp),%eax
f0103df6:	8b 40 74             	mov    0x74(%eax),%eax
f0103df9:	8d 55 ec             	lea    -0x14(%ebp),%edx
f0103dfc:	52                   	push   %edx
f0103dfd:	6a 01                	push   $0x1
f0103dff:	ff 75 0c             	pushl  0xc(%ebp)
f0103e02:	50                   	push   %eax
f0103e03:	e8 07 fe ff ff       	call   f0103c0f <get_disk_page_table>
f0103e08:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0103e0b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103e0e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103e11:	c1 ea 0c             	shr    $0xc,%edx
f0103e14:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0103e1a:	c1 e2 02             	shl    $0x2,%edx
f0103e1d:	01 d0                	add    %edx,%eax
f0103e1f:	8b 00                	mov    (%eax),%eax
f0103e21:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f0103e24:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0103e27:	85 c0                	test   %eax,%eax
f0103e29:	75 34                	jne    f0103e5f <pf_add_empty_env_page+0x127>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f0103e2b:	83 ec 0c             	sub    $0xc,%esp
f0103e2e:	8d 45 e8             	lea    -0x18(%ebp),%eax
f0103e31:	50                   	push   %eax
f0103e32:	e8 e9 fb ff ff       	call   f0103a20 <allocate_disk_frame>
f0103e37:	83 c4 10             	add    $0x10,%esp
f0103e3a:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0103e3d:	75 07                	jne    f0103e46 <pf_add_empty_env_page+0x10e>
f0103e3f:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0103e44:	eb 1e                	jmp    f0103e64 <pf_add_empty_env_page+0x12c>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f0103e46:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103e49:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103e4c:	c1 ea 0c             	shr    $0xc,%edx
f0103e4f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0103e55:	c1 e2 02             	shl    $0x2,%edx
f0103e58:	01 c2                	add    %eax,%edx
f0103e5a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0103e5d:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f0103e5f:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0103e64:	c9                   	leave  
f0103e65:	c3                   	ret    

f0103e66 <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f0103e66:	55                   	push   %ebp
f0103e67:	89 e5                	mov    %esp,%ebp
f0103e69:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0103e6c:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0103e73:	76 19                	jbe    f0103e8e <pf_add_env_page+0x28>
f0103e75:	68 cc 40 12 f0       	push   $0xf01240cc
f0103e7a:	68 f2 40 12 f0       	push   $0xf01240f2
f0103e7f:	68 f1 00 00 00       	push   $0xf1
f0103e84:	68 39 40 12 f0       	push   $0xf0124039
f0103e89:	e8 8c c4 ff ff       	call   f010031a <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0103e8e:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e91:	83 c0 74             	add    $0x74,%eax
f0103e94:	83 ec 08             	sub    $0x8,%esp
f0103e97:	50                   	push   %eax
f0103e98:	ff 75 08             	pushl  0x8(%ebp)
f0103e9b:	e8 1e 05 00 00       	call   f01043be <get_disk_page_directory>
f0103ea0:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f0103ea3:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ea6:	8b 40 74             	mov    0x74(%eax),%eax
f0103ea9:	8d 55 f0             	lea    -0x10(%ebp),%edx
f0103eac:	52                   	push   %edx
f0103ead:	6a 01                	push   $0x1
f0103eaf:	ff 75 0c             	pushl  0xc(%ebp)
f0103eb2:	50                   	push   %eax
f0103eb3:	e8 57 fd ff ff       	call   f0103c0f <get_disk_page_table>
f0103eb8:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0103ebb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103ebe:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103ec1:	c1 ea 0c             	shr    $0xc,%edx
f0103ec4:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0103eca:	c1 e2 02             	shl    $0x2,%edx
f0103ecd:	01 d0                	add    %edx,%eax
f0103ecf:	8b 00                	mov    (%eax),%eax
f0103ed1:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f0103ed4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103ed7:	85 c0                	test   %eax,%eax
f0103ed9:	75 34                	jne    f0103f0f <pf_add_env_page+0xa9>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f0103edb:	83 ec 0c             	sub    $0xc,%esp
f0103ede:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0103ee1:	50                   	push   %eax
f0103ee2:	e8 39 fb ff ff       	call   f0103a20 <allocate_disk_frame>
f0103ee7:	83 c4 10             	add    $0x10,%esp
f0103eea:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0103eed:	75 07                	jne    f0103ef6 <pf_add_env_page+0x90>
f0103eef:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0103ef4:	eb 31                	jmp    f0103f27 <pf_add_env_page+0xc1>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f0103ef6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103ef9:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103efc:	c1 ea 0c             	shr    $0xc,%edx
f0103eff:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0103f05:	c1 e2 02             	shl    $0x2,%edx
f0103f08:	01 c2                	add    %eax,%edx
f0103f0a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103f0d:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f0103f0f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103f12:	83 ec 08             	sub    $0x8,%esp
f0103f15:	ff 75 10             	pushl  0x10(%ebp)
f0103f18:	50                   	push   %eax
f0103f19:	e8 55 f9 ff ff       	call   f0103873 <write_disk_page>
f0103f1e:	83 c4 10             	add    $0x10,%esp
f0103f21:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f0103f24:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0103f27:	c9                   	leave  
f0103f28:	c3                   	ret    

f0103f29 <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f0103f29:	55                   	push   %ebp
f0103f2a:	89 e5                	mov    %esp,%ebp
f0103f2c:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f0103f2f:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0103f36:	76 19                	jbe    f0103f51 <pf_update_env_page+0x28>
f0103f38:	68 cc 40 12 f0       	push   $0xf01240cc
f0103f3d:	68 f2 40 12 f0       	push   $0xf01240f2
f0103f42:	68 13 01 00 00       	push   $0x113
f0103f47:	68 39 40 12 f0       	push   $0xf0124039
f0103f4c:	e8 c9 c3 ff ff       	call   f010031a <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0103f51:	8b 45 08             	mov    0x8(%ebp),%eax
f0103f54:	83 c0 74             	add    $0x74,%eax
f0103f57:	83 ec 08             	sub    $0x8,%esp
f0103f5a:	50                   	push   %eax
f0103f5b:	ff 75 08             	pushl  0x8(%ebp)
f0103f5e:	e8 5b 04 00 00       	call   f01043be <get_disk_page_directory>
f0103f63:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0103f66:	8b 45 08             	mov    0x8(%ebp),%eax
f0103f69:	8b 40 74             	mov    0x74(%eax),%eax
f0103f6c:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0103f6f:	52                   	push   %edx
f0103f70:	6a 00                	push   $0x0
f0103f72:	ff 75 0c             	pushl  0xc(%ebp)
f0103f75:	50                   	push   %eax
f0103f76:	e8 94 fc ff ff       	call   f0103c0f <get_disk_page_table>
f0103f7b:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f0103f7e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0103f81:	85 c0                	test   %eax,%eax
f0103f83:	74 29                	je     f0103fae <pf_update_env_page+0x85>
f0103f85:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0103f88:	85 c0                	test   %eax,%eax
f0103f8a:	0f 84 c5 00 00 00    	je     f0104055 <pf_update_env_page+0x12c>
f0103f90:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0103f93:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103f96:	c1 ea 0c             	shr    $0xc,%edx
f0103f99:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0103f9f:	c1 e2 02             	shl    $0x2,%edx
f0103fa2:	01 d0                	add    %edx,%eax
f0103fa4:	8b 00                	mov    (%eax),%eax
f0103fa6:	85 c0                	test   %eax,%eax
f0103fa8:	0f 85 a7 00 00 00    	jne    f0104055 <pf_update_env_page+0x12c>
	{

		uint32 VA = (uint32)virtual_address ;
f0103fae:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103fb1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if ((VA >= USER_HEAP_START && VA < USER_HEAP_MAX) || (VA >= USTACKBOTTOM && VA < USTACKTOP))
f0103fb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103fb7:	85 c0                	test   %eax,%eax
f0103fb9:	79 09                	jns    f0103fc4 <pf_update_env_page+0x9b>
f0103fbb:	81 7d f4 ff ff ff 9f 	cmpl   $0x9fffffff,-0xc(%ebp)
f0103fc2:	76 30                	jbe    f0103ff4 <pf_update_env_page+0xcb>
f0103fc4:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0103fcb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103fce:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0103fd3:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0103fd6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103fd9:	ba 00 00 00 00       	mov    $0x0,%edx
f0103fde:	f7 75 f0             	divl   -0x10(%ebp)
f0103fe1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103fe4:	29 d0                	sub    %edx,%eax
f0103fe6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0103fe9:	77 53                	ja     f010403e <pf_update_env_page+0x115>
f0103feb:	81 7d f4 ff df bf ee 	cmpl   $0xeebfdfff,-0xc(%ebp)
f0103ff2:	77 4a                	ja     f010403e <pf_update_env_page+0x115>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, VA, 0);
f0103ff4:	83 ec 04             	sub    $0x4,%esp
f0103ff7:	6a 00                	push   $0x0
f0103ff9:	ff 75 f4             	pushl  -0xc(%ebp)
f0103ffc:	ff 75 08             	pushl  0x8(%ebp)
f0103fff:	e8 34 fd ff ff       	call   f0103d38 <pf_add_empty_env_page>
f0104004:	83 c4 10             	add    $0x10,%esp
f0104007:	89 45 e8             	mov    %eax,-0x18(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f010400a:	83 7d e8 f8          	cmpl   $0xfffffff8,-0x18(%ebp)
f010400e:	75 17                	jne    f0104027 <pf_update_env_page+0xfe>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f0104010:	83 ec 04             	sub    $0x4,%esp
f0104013:	68 08 41 12 f0       	push   $0xf0124108
f0104018:	68 43 01 00 00       	push   $0x143
f010401d:	68 39 40 12 f0       	push   $0xf0124039
f0104022:	e8 f3 c2 ff ff       	call   f010031a <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f0104027:	8b 45 08             	mov    0x8(%ebp),%eax
f010402a:	8b 80 64 da 01 00    	mov    0x1da64(%eax),%eax
f0104030:	8d 50 01             	lea    0x1(%eax),%edx
f0104033:	8b 45 08             	mov    0x8(%ebp),%eax
f0104036:	89 90 64 da 01 00    	mov    %edx,0x1da64(%eax)
f010403c:	eb 17                	jmp    f0104055 <pf_update_env_page+0x12c>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f010403e:	83 ec 04             	sub    $0x4,%esp
f0104041:	68 54 41 12 f0       	push   $0xf0124154
f0104046:	68 4c 01 00 00       	push   $0x14c
f010404b:	68 39 40 12 f0       	push   $0xf0124039
f0104050:	e8 c5 c2 ff ff       	call   f010031a <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104055:	8b 45 08             	mov    0x8(%ebp),%eax
f0104058:	8b 40 74             	mov    0x74(%eax),%eax
f010405b:	8d 55 d8             	lea    -0x28(%ebp),%edx
f010405e:	52                   	push   %edx
f010405f:	6a 00                	push   $0x0
f0104061:	ff 75 0c             	pushl  0xc(%ebp)
f0104064:	50                   	push   %eax
f0104065:	e8 a5 fb ff ff       	call   f0103c0f <get_disk_page_table>
f010406a:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010406d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0104070:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104073:	c1 ea 0c             	shr    $0xc,%edx
f0104076:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010407c:	c1 e2 02             	shl    $0x2,%edx
f010407f:	01 d0                	add    %edx,%eax
f0104081:	8b 00                	mov    (%eax),%eax
f0104083:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//cprintf("[%s] updating page\n",ptr_env->prog_name);
	}
#else
	{
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
f0104086:	83 ec 0c             	sub    $0xc,%esp
f0104089:	ff 75 10             	pushl  0x10(%ebp)
f010408c:	e8 5a f7 ff ff       	call   f01037eb <to_physical_address>
f0104091:	83 c4 10             	add    $0x10,%esp
f0104094:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0104097:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010409a:	c1 e8 0c             	shr    $0xc,%eax
f010409d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01040a0:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f01040a5:	39 45 dc             	cmp    %eax,-0x24(%ebp)
f01040a8:	72 17                	jb     f01040c1 <pf_update_env_page+0x198>
f01040aa:	ff 75 e0             	pushl  -0x20(%ebp)
f01040ad:	68 9c 40 12 f0       	push   $0xf012409c
f01040b2:	68 68 01 00 00       	push   $0x168
f01040b7:	68 39 40 12 f0       	push   $0xf0124039
f01040bc:	e8 59 c2 ff ff       	call   f010031a <_panic>
f01040c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01040c4:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01040c9:	83 ec 08             	sub    $0x8,%esp
f01040cc:	50                   	push   %eax
f01040cd:	ff 75 e4             	pushl  -0x1c(%ebp)
f01040d0:	e8 9e f7 ff ff       	call   f0103873 <write_disk_page>
f01040d5:	83 c4 10             	add    $0x10,%esp
f01040d8:	89 45 e8             	mov    %eax,-0x18(%ebp)
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f01040db:	8b 45 08             	mov    0x8(%ebp),%eax
f01040de:	8b 80 60 da 01 00    	mov    0x1da60(%eax),%eax
f01040e4:	8d 50 01             	lea    0x1(%eax),%edx
f01040e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01040ea:	89 90 60 da 01 00    	mov    %edx,0x1da60(%eax)
	//======================

	return ret;
f01040f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f01040f3:	c9                   	leave  
f01040f4:	c3                   	ret    

f01040f5 <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f01040f5:	55                   	push   %ebp
f01040f6:	89 e5                	mov    %esp,%ebp
f01040f8:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f01040fb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01040fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104101:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104104:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104109:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f010410c:	8b 45 08             	mov    0x8(%ebp),%eax
f010410f:	8b 40 74             	mov    0x74(%eax),%eax
f0104112:	85 c0                	test   %eax,%eax
f0104114:	75 0a                	jne    f0104120 <pf_read_env_page+0x2b>
f0104116:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010411b:	e9 90 00 00 00       	jmp    f01041b0 <pf_read_env_page+0xbb>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f0104120:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104123:	8b 45 08             	mov    0x8(%ebp),%eax
f0104126:	8b 40 74             	mov    0x74(%eax),%eax
f0104129:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f010412c:	51                   	push   %ecx
f010412d:	6a 00                	push   $0x0
f010412f:	52                   	push   %edx
f0104130:	50                   	push   %eax
f0104131:	e8 d9 fa ff ff       	call   f0103c0f <get_disk_page_table>
f0104136:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104139:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010413c:	85 c0                	test   %eax,%eax
f010413e:	75 07                	jne    f0104147 <pf_read_env_page+0x52>
f0104140:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0104145:	eb 69                	jmp    f01041b0 <pf_read_env_page+0xbb>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104147:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010414a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010414d:	c1 ea 0c             	shr    $0xc,%edx
f0104150:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104156:	c1 e2 02             	shl    $0x2,%edx
f0104159:	01 d0                	add    %edx,%eax
f010415b:	8b 00                	mov    (%eax),%eax
f010415d:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104160:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104164:	75 07                	jne    f010416d <pf_read_env_page+0x78>
f0104166:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010416b:	eb 43                	jmp    f01041b0 <pf_read_env_page+0xbb>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f010416d:	83 ec 08             	sub    $0x8,%esp
f0104170:	ff 75 0c             	pushl  0xc(%ebp)
f0104173:	ff 75 f0             	pushl  -0x10(%ebp)
f0104176:	e8 c9 f6 ff ff       	call   f0103844 <read_disk_page>
f010417b:	83 c4 10             	add    $0x10,%esp
f010417e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0104181:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104184:	8b 45 08             	mov    0x8(%ebp),%eax
f0104187:	8b 40 64             	mov    0x64(%eax),%eax
f010418a:	6a 40                	push   $0x40
f010418c:	6a 00                	push   $0x0
f010418e:	52                   	push   %edx
f010418f:	50                   	push   %eax
f0104190:	e8 b1 46 00 00       	call   f0108846 <pt_set_page_permissions>
f0104195:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f0104198:	8b 45 08             	mov    0x8(%ebp),%eax
f010419b:	8b 80 5c da 01 00    	mov    0x1da5c(%eax),%eax
f01041a1:	8d 50 01             	lea    0x1(%eax),%edx
f01041a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01041a7:	89 90 5c da 01 00    	mov    %edx,0x1da5c(%eax)
	//======================

	return disk_read_error;
f01041ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f01041b0:	c9                   	leave  
f01041b1:	c3                   	ret    

f01041b2 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f01041b2:	55                   	push   %ebp
f01041b3:	89 e5                	mov    %esp,%ebp
f01041b5:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f01041b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01041bb:	8b 40 74             	mov    0x74(%eax),%eax
f01041be:	85 c0                	test   %eax,%eax
f01041c0:	74 62                	je     f0104224 <pf_remove_env_page+0x72>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01041c2:	8b 45 08             	mov    0x8(%ebp),%eax
f01041c5:	8b 40 74             	mov    0x74(%eax),%eax
f01041c8:	8d 55 f0             	lea    -0x10(%ebp),%edx
f01041cb:	52                   	push   %edx
f01041cc:	6a 00                	push   $0x0
f01041ce:	ff 75 0c             	pushl  0xc(%ebp)
f01041d1:	50                   	push   %eax
f01041d2:	e8 38 fa ff ff       	call   f0103c0f <get_disk_page_table>
f01041d7:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f01041da:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01041dd:	85 c0                	test   %eax,%eax
f01041df:	74 46                	je     f0104227 <pf_remove_env_page+0x75>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01041e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01041e4:	8b 55 0c             	mov    0xc(%ebp),%edx
f01041e7:	c1 ea 0c             	shr    $0xc,%edx
f01041ea:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01041f0:	c1 e2 02             	shl    $0x2,%edx
f01041f3:	01 d0                	add    %edx,%eax
f01041f5:	8b 00                	mov    (%eax),%eax
f01041f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f01041fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01041fd:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104200:	c1 ea 0c             	shr    $0xc,%edx
f0104203:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104209:	c1 e2 02             	shl    $0x2,%edx
f010420c:	01 d0                	add    %edx,%eax
f010420e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0104214:	83 ec 0c             	sub    $0xc,%esp
f0104217:	ff 75 f4             	pushl  -0xc(%ebp)
f010421a:	e8 ef f8 ff ff       	call   f0103b0e <free_disk_frame>
f010421f:	83 c4 10             	add    $0x10,%esp
f0104222:	eb 04                	jmp    f0104228 <pf_remove_env_page+0x76>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f0104224:	90                   	nop
f0104225:	eb 01                	jmp    f0104228 <pf_remove_env_page+0x76>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f0104227:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104228:	c9                   	leave  
f0104229:	c3                   	ret    

f010422a <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f010422a:	55                   	push   %ebp
f010422b:	89 e5                	mov    %esp,%ebp
f010422d:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104230:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104237:	e9 ee 00 00 00       	jmp    f010432a <pf_free_env+0x100>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f010423c:	8b 45 08             	mov    0x8(%ebp),%eax
f010423f:	8b 40 74             	mov    0x74(%eax),%eax
f0104242:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104245:	c1 e2 02             	shl    $0x2,%edx
f0104248:	01 d0                	add    %edx,%eax
f010424a:	8b 00                	mov    (%eax),%eax
f010424c:	83 e0 01             	and    $0x1,%eax
f010424f:	85 c0                	test   %eax,%eax
f0104251:	0f 84 cf 00 00 00    	je     f0104326 <pf_free_env+0xfc>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f0104257:	8b 45 08             	mov    0x8(%ebp),%eax
f010425a:	8b 40 74             	mov    0x74(%eax),%eax
f010425d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104260:	c1 e2 02             	shl    $0x2,%edx
f0104263:	01 d0                	add    %edx,%eax
f0104265:	8b 00                	mov    (%eax),%eax
f0104267:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010426c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		{
			pt = (uint32*) kheap_virtual_address(pa);
		}
#else
		{
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
f010426f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104272:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0104275:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104278:	c1 e8 0c             	shr    $0xc,%eax
f010427b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010427e:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0104283:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0104286:	72 17                	jb     f010429f <pf_free_env+0x75>
f0104288:	ff 75 e8             	pushl  -0x18(%ebp)
f010428b:	68 9c 40 12 f0       	push   $0xf012409c
f0104290:	68 c8 01 00 00       	push   $0x1c8
f0104295:	68 39 40 12 f0       	push   $0xf0124039
f010429a:	e8 7b c0 ff ff       	call   f010031a <_panic>
f010429f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01042a2:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01042a7:	89 45 e0             	mov    %eax,-0x20(%ebp)
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f01042aa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01042b1:	eb 3a                	jmp    f01042ed <pf_free_env+0xc3>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f01042b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01042b6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01042bd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01042c0:	01 d0                	add    %edx,%eax
f01042c2:	8b 00                	mov    (%eax),%eax
f01042c4:	89 45 dc             	mov    %eax,-0x24(%ebp)
			pt[pteno] = 0;
f01042c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01042ca:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01042d1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01042d4:	01 d0                	add    %edx,%eax
f01042d6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f01042dc:	83 ec 0c             	sub    $0xc,%esp
f01042df:	ff 75 dc             	pushl  -0x24(%ebp)
f01042e2:	e8 27 f8 ff ff       	call   f0103b0e <free_disk_frame>
f01042e7:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f01042ea:	ff 45 f0             	incl   -0x10(%ebp)
f01042ed:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f01042f4:	76 bd                	jbe    f01042b3 <pf_free_env+0x89>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f01042f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01042f9:	8b 40 74             	mov    0x74(%eax),%eax
f01042fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01042ff:	c1 e2 02             	shl    $0x2,%edx
f0104302:	01 d0                	add    %edx,%eax
f0104304:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		{
			kfree(pt);
		}
#else
		{
			decrement_references(to_frame_info(pa));
f010430a:	83 ec 0c             	sub    $0xc,%esp
f010430d:	ff 75 ec             	pushl  -0x14(%ebp)
f0104310:	e8 e9 f4 ff ff       	call   f01037fe <to_frame_info>
f0104315:	83 c4 10             	add    $0x10,%esp
f0104318:	83 ec 0c             	sub    $0xc,%esp
f010431b:	50                   	push   %eax
f010431c:	e8 da 3d 00 00       	call   f01080fb <decrement_references>
f0104321:	83 c4 10             	add    $0x10,%esp
f0104324:	eb 01                	jmp    f0104327 <pf_free_env+0xfd>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f0104326:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104327:	ff 45 f4             	incl   -0xc(%ebp)
f010432a:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104331:	0f 86 05 ff ff ff    	jbe    f010423c <pf_free_env+0x12>
	{
		kfree(ptr_env->disk_env_pgdir);
	}
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
f0104337:	8b 45 08             	mov    0x8(%ebp),%eax
f010433a:	8b 40 78             	mov    0x78(%eax),%eax
f010433d:	83 ec 0c             	sub    $0xc,%esp
f0104340:	50                   	push   %eax
f0104341:	e8 b8 f4 ff ff       	call   f01037fe <to_frame_info>
f0104346:	83 c4 10             	add    $0x10,%esp
f0104349:	83 ec 0c             	sub    $0xc,%esp
f010434c:	50                   	push   %eax
f010434d:	e8 a9 3d 00 00       	call   f01080fb <decrement_references>
f0104352:	83 c4 10             	add    $0x10,%esp
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f0104355:	8b 45 08             	mov    0x8(%ebp),%eax
f0104358:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	ptr_env->disk_env_pgdir_PA = 0;
f010435f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104362:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f0104369:	8b 45 08             	mov    0x8(%ebp),%eax
f010436c:	8b 40 7c             	mov    0x7c(%eax),%eax
f010436f:	85 c0                	test   %eax,%eax
f0104371:	74 48                	je     f01043bb <pf_free_env+0x191>
		return;
	__pf_remove_env_all_tables(ptr_env);
f0104373:	83 ec 0c             	sub    $0xc,%esp
f0104376:	ff 75 08             	pushl  0x8(%ebp)
f0104379:	e8 dd 03 00 00       	call   f010475b <__pf_remove_env_all_tables>
f010437e:	83 c4 10             	add    $0x10,%esp
	{
		kfree(ptr_env->disk_env_tabledir);
	}
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
f0104381:	8b 45 08             	mov    0x8(%ebp),%eax
f0104384:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010438a:	83 ec 0c             	sub    $0xc,%esp
f010438d:	50                   	push   %eax
f010438e:	e8 6b f4 ff ff       	call   f01037fe <to_frame_info>
f0104393:	83 c4 10             	add    $0x10,%esp
f0104396:	83 ec 0c             	sub    $0xc,%esp
f0104399:	50                   	push   %eax
f010439a:	e8 5c 3d 00 00       	call   f01080fb <decrement_references>
f010439f:	83 c4 10             	add    $0x10,%esp
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f01043a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01043a5:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	ptr_env->disk_env_tabledir_PA = 0;
f01043ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01043af:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f01043b6:	00 00 00 
f01043b9:	eb 01                	jmp    f01043bc <pf_free_env+0x192>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f01043bb:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f01043bc:	c9                   	leave  
f01043bd:	c3                   	ret    

f01043be <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f01043be:	55                   	push   %ebp
f01043bf:	89 e5                	mov    %esp,%ebp
f01043c1:	83 ec 18             	sub    $0x18,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f01043c4:	8b 45 08             	mov    0x8(%ebp),%eax
f01043c7:	8b 50 74             	mov    0x74(%eax),%edx
f01043ca:	8b 45 0c             	mov    0xc(%ebp),%eax
f01043cd:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f01043cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01043d2:	8b 00                	mov    (%eax),%eax
f01043d4:	85 c0                	test   %eax,%eax
f01043d6:	0f 85 aa 00 00 00    	jne    f0104486 <get_disk_page_directory+0xc8>
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
		}
#else
		{
			int r;
			struct FrameInfo *p = NULL;
f01043dc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

			if ((r = allocate_frame(&p)) < 0)
f01043e3:	83 ec 0c             	sub    $0xc,%esp
f01043e6:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01043e9:	50                   	push   %eax
f01043ea:	e8 ff 3a 00 00       	call   f0107eee <allocate_frame>
f01043ef:	83 c4 10             	add    $0x10,%esp
f01043f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01043f5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01043f9:	79 08                	jns    f0104403 <get_disk_page_directory+0x45>
				return r;
f01043fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01043fe:	e9 88 00 00 00       	jmp    f010448b <get_disk_page_directory+0xcd>
			p->references = 1;
f0104403:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104406:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)

			//[4] initialize the new environment by the virtual address of the page directory
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
f010440c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010440f:	83 ec 0c             	sub    $0xc,%esp
f0104412:	50                   	push   %eax
f0104413:	e8 d3 f3 ff ff       	call   f01037eb <to_physical_address>
f0104418:	83 c4 10             	add    $0x10,%esp
f010441b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010441e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104421:	c1 e8 0c             	shr    $0xc,%eax
f0104424:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0104427:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f010442c:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f010442f:	72 17                	jb     f0104448 <get_disk_page_directory+0x8a>
f0104431:	ff 75 f0             	pushl  -0x10(%ebp)
f0104434:	68 9c 40 12 f0       	push   $0xf012409c
f0104439:	68 20 02 00 00       	push   $0x220
f010443e:	68 39 40 12 f0       	push   $0xf0124039
f0104443:	e8 d2 be ff ff       	call   f010031a <_panic>
f0104448:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010444b:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104450:	89 c2                	mov    %eax,%edx
f0104452:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104455:	89 10                	mov    %edx,(%eax)
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
f0104457:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010445a:	83 ec 0c             	sub    $0xc,%esp
f010445d:	50                   	push   %eax
f010445e:	e8 88 f3 ff ff       	call   f01037eb <to_physical_address>
f0104463:	83 c4 10             	add    $0x10,%esp
f0104466:	89 c2                	mov    %eax,%edx
f0104468:	8b 45 08             	mov    0x8(%ebp),%eax
f010446b:	89 50 78             	mov    %edx,0x78(%eax)
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f010446e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104471:	8b 00                	mov    (%eax),%eax
f0104473:	83 ec 04             	sub    $0x4,%esp
f0104476:	68 00 10 00 00       	push   $0x1000
f010447b:	6a 00                	push   $0x0
f010447d:	50                   	push   %eax
f010447e:	e8 bc c2 01 00       	call   f012073f <memset>
f0104483:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f0104486:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010448b:	c9                   	leave  
f010448c:	c3                   	ret    

f010448d <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f010448d:	55                   	push   %ebp
f010448e:	89 e5                	mov    %esp,%ebp
f0104490:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f0104493:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f010449a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01044a1:	e9 a6 00 00 00       	jmp    f010454c <pf_calculate_allocated_pages+0xbf>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f01044a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01044a9:	8b 40 74             	mov    0x74(%eax),%eax
f01044ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01044af:	c1 e2 02             	shl    $0x2,%edx
f01044b2:	01 d0                	add    %edx,%eax
f01044b4:	8b 00                	mov    (%eax),%eax
f01044b6:	83 e0 01             	and    $0x1,%eax
f01044b9:	85 c0                	test   %eax,%eax
f01044bb:	0f 84 87 00 00 00    	je     f0104548 <pf_calculate_allocated_pages+0xbb>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f01044c1:	8b 45 08             	mov    0x8(%ebp),%eax
f01044c4:	8b 40 74             	mov    0x74(%eax),%eax
f01044c7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01044ca:	c1 e2 02             	shl    $0x2,%edx
f01044cd:	01 d0                	add    %edx,%eax
f01044cf:	8b 00                	mov    (%eax),%eax
f01044d1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01044d6:	89 45 e8             	mov    %eax,-0x18(%ebp)
		{
			pt = (uint32*) kheap_virtual_address(pa);
		}
#else
		{
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
f01044d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01044dc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01044df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01044e2:	c1 e8 0c             	shr    $0xc,%eax
f01044e5:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01044e8:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f01044ed:	39 45 e0             	cmp    %eax,-0x20(%ebp)
f01044f0:	72 17                	jb     f0104509 <pf_calculate_allocated_pages+0x7c>
f01044f2:	ff 75 e4             	pushl  -0x1c(%ebp)
f01044f5:	68 9c 40 12 f0       	push   $0xf012409c
f01044fa:	68 40 02 00 00       	push   $0x240
f01044ff:	68 39 40 12 f0       	push   $0xf0124039
f0104504:	e8 11 be ff ff       	call   f010031a <_panic>
f0104509:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010450c:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104511:	89 45 dc             	mov    %eax,-0x24(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0104514:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010451b:	eb 20                	jmp    f010453d <pf_calculate_allocated_pages+0xb0>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f010451d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104520:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104527:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010452a:	01 d0                	add    %edx,%eax
f010452c:	8b 00                	mov    (%eax),%eax
f010452e:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if(dfn != 0)
f0104531:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0104535:	74 03                	je     f010453a <pf_calculate_allocated_pages+0xad>
				counter ++;
f0104537:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f010453a:	ff 45 ec             	incl   -0x14(%ebp)
f010453d:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f0104544:	76 d7                	jbe    f010451d <pf_calculate_allocated_pages+0x90>
f0104546:	eb 01                	jmp    f0104549 <pf_calculate_allocated_pages+0xbc>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f0104548:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0104549:	ff 45 f4             	incl   -0xc(%ebp)
f010454c:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104553:	0f 86 4d ff ff ff    	jbe    f01044a6 <pf_calculate_allocated_pages+0x19>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f0104559:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010455c:	c9                   	leave  
f010455d:	c3                   	ret    

f010455e <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f010455e:	55                   	push   %ebp
f010455f:	89 e5                	mov    %esp,%ebp
f0104561:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_spinlock(&DiskFrameLists.dfllock);
f0104564:	83 ec 0c             	sub    $0xc,%esp
f0104567:	68 f0 50 55 f0       	push   $0xf05550f0
f010456c:	e8 2d a2 00 00       	call   f010e79e <acquire_spinlock>
f0104571:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f0104574:	a1 ec 50 55 f0       	mov    0xf05550ec,%eax
f0104579:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f010457c:	83 ec 0c             	sub    $0xc,%esp
f010457f:	68 f0 50 55 f0       	push   $0xf05550f0
f0104584:	e8 9c a2 00 00       	call   f010e825 <release_spinlock>
f0104589:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f010458c:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f010458f:	c9                   	leave  
f0104590:	c3                   	ret    

f0104591 <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f0104591:	55                   	push   %ebp
f0104592:	89 e5                	mov    %esp,%ebp
f0104594:	83 ec 18             	sub    $0x18,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f0104597:	8b 45 08             	mov    0x8(%ebp),%eax
f010459a:	8b 50 7c             	mov    0x7c(%eax),%edx
f010459d:	8b 45 0c             	mov    0xc(%ebp),%eax
f01045a0:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f01045a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01045a5:	8b 00                	mov    (%eax),%eax
f01045a7:	85 c0                	test   %eax,%eax
f01045a9:	0f 85 ad 00 00 00    	jne    f010465c <get_disk_table_directory+0xcb>
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
		}
#else
		{
			int r;
			struct FrameInfo *p = NULL;
f01045af:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

			if ((r = allocate_frame(&p)) < 0)
f01045b6:	83 ec 0c             	sub    $0xc,%esp
f01045b9:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01045bc:	50                   	push   %eax
f01045bd:	e8 2c 39 00 00       	call   f0107eee <allocate_frame>
f01045c2:	83 c4 10             	add    $0x10,%esp
f01045c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01045c8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01045cc:	79 08                	jns    f01045d6 <get_disk_table_directory+0x45>
				return r;
f01045ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01045d1:	e9 8b 00 00 00       	jmp    f0104661 <get_disk_table_directory+0xd0>
			p->references = 1;
f01045d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01045d9:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)

			//[4] initialize the new environment by the virtual address of the page directory
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
f01045df:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01045e2:	83 ec 0c             	sub    $0xc,%esp
f01045e5:	50                   	push   %eax
f01045e6:	e8 00 f2 ff ff       	call   f01037eb <to_physical_address>
f01045eb:	83 c4 10             	add    $0x10,%esp
f01045ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01045f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045f4:	c1 e8 0c             	shr    $0xc,%eax
f01045f7:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01045fa:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f01045ff:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0104602:	72 17                	jb     f010461b <get_disk_table_directory+0x8a>
f0104604:	ff 75 f0             	pushl  -0x10(%ebp)
f0104607:	68 9c 40 12 f0       	push   $0xf012409c
f010460c:	68 83 02 00 00       	push   $0x283
f0104611:	68 39 40 12 f0       	push   $0xf0124039
f0104616:	e8 ff bc ff ff       	call   f010031a <_panic>
f010461b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010461e:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104623:	89 c2                	mov    %eax,%edx
f0104625:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104628:	89 10                	mov    %edx,(%eax)
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
f010462a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010462d:	83 ec 0c             	sub    $0xc,%esp
f0104630:	50                   	push   %eax
f0104631:	e8 b5 f1 ff ff       	call   f01037eb <to_physical_address>
f0104636:	83 c4 10             	add    $0x10,%esp
f0104639:	89 c2                	mov    %eax,%edx
f010463b:	8b 45 08             	mov    0x8(%ebp),%eax
f010463e:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f0104644:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104647:	8b 00                	mov    (%eax),%eax
f0104649:	83 ec 04             	sub    $0x4,%esp
f010464c:	68 00 10 00 00       	push   $0x1000
f0104651:	6a 00                	push   $0x0
f0104653:	50                   	push   %eax
f0104654:	e8 e6 c0 01 00       	call   f012073f <memset>
f0104659:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f010465c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104661:	c9                   	leave  
f0104662:	c3                   	ret    

f0104663 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104663:	55                   	push   %ebp
f0104664:	89 e5                	mov    %esp,%ebp
f0104666:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f0104669:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104670:	76 19                	jbe    f010468b <__pf_write_env_table+0x28>
f0104672:	68 cc 40 12 f0       	push   $0xf01240cc
f0104677:	68 f2 40 12 f0       	push   $0xf01240f2
f010467c:	68 91 02 00 00       	push   $0x291
f0104681:	68 39 40 12 f0       	push   $0xf0124039
f0104686:	e8 8f bc ff ff       	call   f010031a <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f010468b:	8b 45 08             	mov    0x8(%ebp),%eax
f010468e:	83 c0 7c             	add    $0x7c,%eax
f0104691:	83 ec 08             	sub    $0x8,%esp
f0104694:	50                   	push   %eax
f0104695:	ff 75 08             	pushl  0x8(%ebp)
f0104698:	e8 f4 fe ff ff       	call   f0104591 <get_disk_table_directory>
f010469d:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f01046a0:	8b 45 08             	mov    0x8(%ebp),%eax
f01046a3:	8b 40 7c             	mov    0x7c(%eax),%eax
f01046a6:	8b 55 0c             	mov    0xc(%ebp),%edx
f01046a9:	c1 ea 16             	shr    $0x16,%edx
f01046ac:	c1 e2 02             	shl    $0x2,%edx
f01046af:	01 d0                	add    %edx,%eax
f01046b1:	8b 00                	mov    (%eax),%eax
f01046b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f01046b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01046b9:	85 c0                	test   %eax,%eax
f01046bb:	75 31                	jne    f01046ee <__pf_write_env_table+0x8b>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01046bd:	83 ec 0c             	sub    $0xc,%esp
f01046c0:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01046c3:	50                   	push   %eax
f01046c4:	e8 57 f3 ff ff       	call   f0103a20 <allocate_disk_frame>
f01046c9:	83 c4 10             	add    $0x10,%esp
f01046cc:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01046cf:	75 07                	jne    f01046d8 <__pf_write_env_table+0x75>
f01046d1:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01046d6:	eb 2e                	jmp    f0104706 <__pf_write_env_table+0xa3>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f01046d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01046db:	8b 40 7c             	mov    0x7c(%eax),%eax
f01046de:	8b 55 0c             	mov    0xc(%ebp),%edx
f01046e1:	c1 ea 16             	shr    $0x16,%edx
f01046e4:	c1 e2 02             	shl    $0x2,%edx
f01046e7:	01 c2                	add    %eax,%edx
f01046e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01046ec:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f01046ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01046f1:	83 ec 08             	sub    $0x8,%esp
f01046f4:	ff 75 10             	pushl  0x10(%ebp)
f01046f7:	50                   	push   %eax
f01046f8:	e8 76 f1 ff ff       	call   f0103873 <write_disk_page>
f01046fd:	83 c4 10             	add    $0x10,%esp
f0104700:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f0104703:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104706:	c9                   	leave  
f0104707:	c3                   	ret    

f0104708 <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104708:	55                   	push   %ebp
f0104709:	89 e5                	mov    %esp,%ebp
f010470b:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f010470e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104711:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104714:	85 c0                	test   %eax,%eax
f0104716:	75 07                	jne    f010471f <__pf_read_env_table+0x17>
f0104718:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f010471d:	eb 3a                	jmp    f0104759 <__pf_read_env_table+0x51>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f010471f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104722:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104725:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104728:	c1 ea 16             	shr    $0x16,%edx
f010472b:	c1 e2 02             	shl    $0x2,%edx
f010472e:	01 d0                	add    %edx,%eax
f0104730:	8b 00                	mov    (%eax),%eax
f0104732:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104735:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104739:	75 07                	jne    f0104742 <__pf_read_env_table+0x3a>
f010473b:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104740:	eb 17                	jmp    f0104759 <__pf_read_env_table+0x51>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f0104742:	83 ec 08             	sub    $0x8,%esp
f0104745:	ff 75 10             	pushl  0x10(%ebp)
f0104748:	ff 75 f4             	pushl  -0xc(%ebp)
f010474b:	e8 f4 f0 ff ff       	call   f0103844 <read_disk_page>
f0104750:	83 c4 10             	add    $0x10,%esp
f0104753:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f0104756:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104759:	c9                   	leave  
f010475a:	c3                   	ret    

f010475b <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f010475b:	55                   	push   %ebp
f010475c:	89 e5                	mov    %esp,%ebp
f010475e:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104761:	8b 45 08             	mov    0x8(%ebp),%eax
f0104764:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104767:	85 c0                	test   %eax,%eax
f0104769:	74 4c                	je     f01047b7 <__pf_remove_env_all_tables+0x5c>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f010476b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104772:	eb 38                	jmp    f01047ac <__pf_remove_env_all_tables+0x51>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f0104774:	8b 45 08             	mov    0x8(%ebp),%eax
f0104777:	8b 40 7c             	mov    0x7c(%eax),%eax
f010477a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010477d:	c1 e2 02             	shl    $0x2,%edx
f0104780:	01 d0                	add    %edx,%eax
f0104782:	8b 00                	mov    (%eax),%eax
f0104784:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f0104787:	8b 45 08             	mov    0x8(%ebp),%eax
f010478a:	8b 40 7c             	mov    0x7c(%eax),%eax
f010478d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104790:	c1 e2 02             	shl    $0x2,%edx
f0104793:	01 d0                	add    %edx,%eax
f0104795:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f010479b:	83 ec 0c             	sub    $0xc,%esp
f010479e:	ff 75 f0             	pushl  -0x10(%ebp)
f01047a1:	e8 68 f3 ff ff       	call   f0103b0e <free_disk_frame>
f01047a6:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01047a9:	ff 45 f4             	incl   -0xc(%ebp)
f01047ac:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f01047b3:	76 bf                	jbe    f0104774 <__pf_remove_env_all_tables+0x19>
f01047b5:	eb 01                	jmp    f01047b8 <__pf_remove_env_all_tables+0x5d>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f01047b7:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f01047b8:	c9                   	leave  
f01047b9:	c3                   	ret    

f01047ba <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f01047ba:	55                   	push   %ebp
f01047bb:	89 e5                	mov    %esp,%ebp
f01047bd:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f01047c0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01047c4:	75 10                	jne    f01047d6 <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f01047c6:	83 ec 0c             	sub    $0xc,%esp
f01047c9:	68 d0 41 12 f0       	push   $0xf01241d0
f01047ce:	e8 99 c7 ff ff       	call   f0100f6c <cprintf>
f01047d3:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f01047d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01047d9:	8b 40 7c             	mov    0x7c(%eax),%eax
f01047dc:	85 c0                	test   %eax,%eax
f01047de:	74 3d                	je     f010481d <__pf_remove_env_table+0x63>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f01047e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01047e3:	8b 40 7c             	mov    0x7c(%eax),%eax
f01047e6:	8b 55 0c             	mov    0xc(%ebp),%edx
f01047e9:	c1 ea 16             	shr    $0x16,%edx
f01047ec:	c1 e2 02             	shl    $0x2,%edx
f01047ef:	01 d0                	add    %edx,%eax
f01047f1:	8b 00                	mov    (%eax),%eax
f01047f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f01047f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01047f9:	8b 40 7c             	mov    0x7c(%eax),%eax
f01047fc:	8b 55 0c             	mov    0xc(%ebp),%edx
f01047ff:	c1 ea 16             	shr    $0x16,%edx
f0104802:	c1 e2 02             	shl    $0x2,%edx
f0104805:	01 d0                	add    %edx,%eax
f0104807:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f010480d:	83 ec 0c             	sub    $0xc,%esp
f0104810:	ff 75 f4             	pushl  -0xc(%ebp)
f0104813:	e8 f6 f2 ff ff       	call   f0103b0e <free_disk_frame>
f0104818:	83 c4 10             	add    $0x10,%esp
f010481b:	eb 01                	jmp    f010481e <__pf_remove_env_table+0x64>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f010481d:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f010481e:	c9                   	leave  
f010481f:	c3                   	ret    

f0104820 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0104820:	55                   	push   %ebp
f0104821:	89 e5                	mov    %esp,%ebp
f0104823:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0104826:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f010482d:	eb 1f                	jmp    f010484e <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f010482f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104832:	83 ec 04             	sub    $0x4,%esp
f0104835:	6a 08                	push   $0x8
f0104837:	ff 75 08             	pushl  0x8(%ebp)
f010483a:	50                   	push   %eax
f010483b:	e8 39 c6 01 00       	call   f0120e79 <ide_write>
f0104840:	83 c4 10             	add    $0x10,%esp
f0104843:	85 c0                	test   %eax,%eax
f0104845:	75 12                	jne    f0104859 <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0104847:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f010484e:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0104855:	7e d8                	jle    f010482f <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104857:	eb 01                	jmp    f010485a <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0104859:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f010485a:	90                   	nop
f010485b:	c9                   	leave  
f010485c:	c3                   	ret    

f010485d <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f010485d:	55                   	push   %ebp
  pushl %eax
f010485e:	50                   	push   %eax
  pushl %ebx
f010485f:	53                   	push   %ebx
  pushl %ecx
f0104860:	51                   	push   %ecx
  pushl %edx
f0104861:	52                   	push   %edx
  pushl %esi
f0104862:	56                   	push   %esi
  pushl %edi
f0104863:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0104864:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0104868:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f010486c:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f010486e:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0104870:	5f                   	pop    %edi
  popl %esi
f0104871:	5e                   	pop    %esi
  popl %edx
f0104872:	5a                   	pop    %edx
  popl %ecx
f0104873:	59                   	pop    %ecx
  popl %ebx
f0104874:	5b                   	pop    %ebx
  popl %eax
f0104875:	58                   	pop    %eax
  popl %ebp
f0104876:	5d                   	pop    %ebp
  ret
f0104877:	c3                   	ret    

f0104878 <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0104878:	55                   	push   %ebp
f0104879:	89 e5                	mov    %esp,%ebp
f010487b:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f010487e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104881:	0f b6 c0             	movzbl %al,%eax
f0104884:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f010488b:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010488e:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104891:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104894:	ee                   	out    %al,(%dx)
f0104895:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010489c:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010489f:	89 c2                	mov    %eax,%edx
f01048a1:	ec                   	in     (%dx),%al
f01048a2:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f01048a5:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f01048a8:	0f b6 c0             	movzbl %al,%eax
}
f01048ab:	c9                   	leave  
f01048ac:	c3                   	ret    

f01048ad <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f01048ad:	55                   	push   %ebp
f01048ae:	89 e5                	mov    %esp,%ebp
f01048b0:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f01048b3:	8b 45 08             	mov    0x8(%ebp),%eax
f01048b6:	0f b6 c0             	movzbl %al,%eax
f01048b9:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f01048c0:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01048c3:	8a 45 f6             	mov    -0xa(%ebp),%al
f01048c6:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01048c9:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f01048ca:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048cd:	0f b6 c0             	movzbl %al,%eax
f01048d0:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f01048d7:	88 45 f7             	mov    %al,-0x9(%ebp)
f01048da:	8a 45 f7             	mov    -0x9(%ebp),%al
f01048dd:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01048e0:	ee                   	out    %al,(%dx)
}
f01048e1:	90                   	nop
f01048e2:	c9                   	leave  
f01048e3:	c3                   	ret    

f01048e4 <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f01048e4:	55                   	push   %ebp
f01048e5:	89 e5                	mov    %esp,%ebp
f01048e7:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f01048ea:	c7 05 c8 50 55 f0 00 	movl   $0x0,0xf05550c8
f01048f1:	00 00 00 
f01048f4:	c7 05 cc 50 55 f0 00 	movl   $0x0,0xf05550cc
f01048fb:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f01048fe:	83 ec 08             	sub    $0x8,%esp
f0104901:	68 d2 68 10 f0       	push   $0xf01068d2
f0104906:	6a 00                	push   $0x0
f0104908:	e8 a9 87 00 00       	call   f010d0b6 <irq_install_handler>
f010490d:	83 c4 10             	add    $0x10,%esp
}
f0104910:	90                   	nop
f0104911:	c9                   	leave  
f0104912:	c3                   	ret    

f0104913 <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0104913:	55                   	push   %ebp
f0104914:	89 e5                	mov    %esp,%ebp
f0104916:	53                   	push   %ebx
f0104917:	83 ec 24             	sub    $0x24,%esp
f010491a:	8b 45 08             	mov    0x8(%ebp),%eax
f010491d:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104920:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104927:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f010492b:	8a 45 ef             	mov    -0x11(%ebp),%al
f010492e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104931:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104932:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104936:	77 48                	ja     f0104980 <kclock_start+0x6d>
f0104938:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f010493f:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0104943:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104946:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104949:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f010494a:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f010494e:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104953:	99                   	cltd   
f0104954:	f7 fb                	idiv   %ebx
f0104956:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f010495c:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104960:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104965:	99                   	cltd   
f0104966:	f7 fb                	idiv   %ebx
f0104968:	89 c3                	mov    %eax,%ebx
f010496a:	89 c8                	mov    %ecx,%eax
f010496c:	99                   	cltd   
f010496d:	f7 fb                	idiv   %ebx
f010496f:	0f b7 c0             	movzwl %ax,%eax
f0104972:	83 ec 0c             	sub    $0xc,%esp
f0104975:	50                   	push   %eax
f0104976:	e8 b3 01 00 00       	call   f0104b2e <kclock_write_cnt0_LSB_first>
f010497b:	83 c4 10             	add    $0x10,%esp
f010497e:	eb 13                	jmp    f0104993 <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104980:	6a 35                	push   $0x35
f0104982:	68 f4 41 12 f0       	push   $0xf01241f4
f0104987:	6a 41                	push   $0x41
f0104989:	68 50 42 12 f0       	push   $0xf0124250
f010498e:	e8 87 b9 ff ff       	call   f010031a <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104993:	83 ec 0c             	sub    $0xc,%esp
f0104996:	6a 00                	push   $0x0
f0104998:	e8 66 23 00 00       	call   f0106d03 <irq_clear_mask>
f010499d:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f01049a0:	90                   	nop
f01049a1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01049a4:	c9                   	leave  
f01049a5:	c3                   	ret    

f01049a6 <kclock_stop>:

void
kclock_stop(void)
{
f01049a6:	55                   	push   %ebp
f01049a7:	89 e5                	mov    %esp,%ebp
f01049a9:	83 ec 18             	sub    $0x18,%esp
f01049ac:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f01049b3:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f01049b7:	8a 45 f3             	mov    -0xd(%ebp),%al
f01049ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01049bd:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f01049be:	83 ec 0c             	sub    $0xc,%esp
f01049c1:	6a 00                	push   $0x0
f01049c3:	e8 c6 22 00 00       	call   f0106c8e <irq_set_mask>
f01049c8:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f01049cb:	90                   	nop
f01049cc:	c9                   	leave  
f01049cd:	c3                   	ret    

f01049ce <kclock_resume>:

void
kclock_resume(void)
{
f01049ce:	55                   	push   %ebp
f01049cf:	89 e5                	mov    %esp,%ebp
f01049d1:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f01049d4:	e8 f5 01 00 00       	call   f0104bce <kclock_read_cnt0_latch>
f01049d9:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f01049dd:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f01049e2:	77 06                	ja     f01049ea <kclock_resume+0x1c>
	{
		cnt0 = 20;
f01049e4:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f01049ea:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f01049ee:	83 e0 01             	and    $0x1,%eax
f01049f1:	66 85 c0             	test   %ax,%ax
f01049f4:	74 09                	je     f01049ff <kclock_resume+0x31>
		cnt0++;
f01049f6:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f01049fa:	40                   	inc    %eax
f01049fb:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f01049ff:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104a06:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104a0a:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104a0d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104a10:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104a11:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0104a15:	83 ec 0c             	sub    $0xc,%esp
f0104a18:	50                   	push   %eax
f0104a19:	e8 10 01 00 00       	call   f0104b2e <kclock_write_cnt0_LSB_first>
f0104a1e:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104a21:	83 ec 0c             	sub    $0xc,%esp
f0104a24:	6a 00                	push   $0x0
f0104a26:	e8 d8 22 00 00       	call   f0106d03 <irq_clear_mask>
f0104a2b:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0104a2e:	90                   	nop
f0104a2f:	c9                   	leave  
f0104a30:	c3                   	ret    

f0104a31 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0104a31:	55                   	push   %ebp
f0104a32:	89 e5                	mov    %esp,%ebp
f0104a34:	83 ec 28             	sub    $0x28,%esp
f0104a37:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a3a:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104a3d:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104a44:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104a48:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104a4b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a4e:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104a4f:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0104a53:	83 ec 0c             	sub    $0xc,%esp
f0104a56:	50                   	push   %eax
f0104a57:	e8 d2 00 00 00       	call   f0104b2e <kclock_write_cnt0_LSB_first>
f0104a5c:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104a5f:	83 ec 0c             	sub    $0xc,%esp
f0104a62:	6a 00                	push   $0x0
f0104a64:	e8 9a 22 00 00       	call   f0106d03 <irq_clear_mask>
f0104a69:	83 c4 10             	add    $0x10,%esp
}
f0104a6c:	90                   	nop
f0104a6d:	c9                   	leave  
f0104a6e:	c3                   	ret    

f0104a6f <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0104a6f:	55                   	push   %ebp
f0104a70:	89 e5                	mov    %esp,%ebp
f0104a72:	56                   	push   %esi
f0104a73:	53                   	push   %ebx
f0104a74:	83 ec 20             	sub    $0x20,%esp
f0104a77:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a7a:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104a7d:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104a81:	0f 87 8a 00 00 00    	ja     f0104b11 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0104a87:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104a8b:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104a90:	99                   	cltd   
f0104a91:	f7 fe                	idiv   %esi
f0104a93:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104a99:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104a9d:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104aa2:	99                   	cltd   
f0104aa3:	f7 fb                	idiv   %ebx
f0104aa5:	89 c6                	mov    %eax,%esi
f0104aa7:	89 c8                	mov    %ecx,%eax
f0104aa9:	99                   	cltd   
f0104aaa:	f7 fe                	idiv   %esi
f0104aac:	89 c3                	mov    %eax,%ebx
f0104aae:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0104ab2:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104ab7:	99                   	cltd   
f0104ab8:	f7 f9                	idiv   %ecx
f0104aba:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104ac0:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104ac4:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104ac9:	99                   	cltd   
f0104aca:	f7 fe                	idiv   %esi
f0104acc:	89 c6                	mov    %eax,%esi
f0104ace:	89 c8                	mov    %ecx,%eax
f0104ad0:	99                   	cltd   
f0104ad1:	f7 fe                	idiv   %esi
f0104ad3:	25 01 00 00 80       	and    $0x80000001,%eax
f0104ad8:	85 c0                	test   %eax,%eax
f0104ada:	79 05                	jns    f0104ae1 <kclock_set_quantum+0x72>
f0104adc:	48                   	dec    %eax
f0104add:	83 c8 fe             	or     $0xfffffffe,%eax
f0104ae0:	40                   	inc    %eax
f0104ae1:	01 d8                	add    %ebx,%eax
f0104ae3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104ae6:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104aed:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104af1:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104af4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104af7:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0104af8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104afb:	0f b7 c0             	movzwl %ax,%eax
f0104afe:	83 ec 0c             	sub    $0xc,%esp
f0104b01:	50                   	push   %eax
f0104b02:	e8 27 00 00 00       	call   f0104b2e <kclock_write_cnt0_LSB_first>
f0104b07:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f0104b0a:	e8 97 fe ff ff       	call   f01049a6 <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0104b0f:	eb 16                	jmp    f0104b27 <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104b11:	6a 35                	push   $0x35
f0104b13:	68 f4 41 12 f0       	push   $0xf01241f4
f0104b18:	68 ea 00 00 00       	push   $0xea
f0104b1d:	68 50 42 12 f0       	push   $0xf0124250
f0104b22:	e8 f3 b7 ff ff       	call   f010031a <_panic>
	}
}
f0104b27:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104b2a:	5b                   	pop    %ebx
f0104b2b:	5e                   	pop    %esi
f0104b2c:	5d                   	pop    %ebp
f0104b2d:	c3                   	ret    

f0104b2e <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0104b2e:	55                   	push   %ebp
f0104b2f:	89 e5                	mov    %esp,%ebp
f0104b31:	83 ec 28             	sub    $0x28,%esp
f0104b34:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b37:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f0104b3b:	e8 9e 23 00 00       	call   f0106ede <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0104b40:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104b43:	0f b6 c0             	movzbl %al,%eax
f0104b46:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f0104b4d:	88 45 ee             	mov    %al,-0x12(%ebp)
f0104b50:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104b53:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104b56:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0104b57:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104b5a:	66 c1 e8 08          	shr    $0x8,%ax
f0104b5e:	0f b6 c0             	movzbl %al,%eax
f0104b61:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f0104b68:	88 45 ef             	mov    %al,-0x11(%ebp)
f0104b6b:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104b6e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104b71:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0104b72:	e8 b9 23 00 00       	call   f0106f30 <popcli>

}
f0104b77:	90                   	nop
f0104b78:	c9                   	leave  
f0104b79:	c3                   	ret    

f0104b7a <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f0104b7a:	55                   	push   %ebp
f0104b7b:	89 e5                	mov    %esp,%ebp
f0104b7d:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0104b80:	e8 59 23 00 00       	call   f0106ede <pushcli>
f0104b85:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104b8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104b8f:	89 c2                	mov    %eax,%edx
f0104b91:	ec                   	in     (%dx),%al
f0104b92:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0104b95:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104b98:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104b9b:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104ba2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104ba5:	89 c2                	mov    %eax,%edx
f0104ba7:	ec                   	in     (%dx),%al
f0104ba8:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f0104bab:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104bae:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104bb1:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0104bb5:	c1 e0 08             	shl    $0x8,%eax
f0104bb8:	89 c2                	mov    %eax,%edx
f0104bba:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104bbe:	09 d0                	or     %edx,%eax
f0104bc0:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f0104bc4:	e8 67 23 00 00       	call   f0106f30 <popcli>
	return cnt0 ;
f0104bc9:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104bcc:	c9                   	leave  
f0104bcd:	c3                   	ret    

f0104bce <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f0104bce:	55                   	push   %ebp
f0104bcf:	89 e5                	mov    %esp,%ebp
f0104bd1:	83 ec 30             	sub    $0x30,%esp
f0104bd4:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104bdb:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104bde:	89 c2                	mov    %eax,%edx
f0104be0:	ec                   	in     (%dx),%al
f0104be1:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0104be4:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f0104be7:	88 45 ff             	mov    %al,-0x1(%ebp)
f0104bea:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104bf1:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104bf5:	8a 45 dc             	mov    -0x24(%ebp),%al
f0104bf8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104bfb:	ee                   	out    %al,(%dx)
f0104bfc:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104c03:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104c06:	89 c2                	mov    %eax,%edx
f0104c08:	ec                   	in     (%dx),%al
f0104c09:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f0104c0c:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104c0f:	88 45 f3             	mov    %al,-0xd(%ebp)
f0104c12:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104c19:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104c1c:	89 c2                	mov    %eax,%edx
f0104c1e:	ec                   	in     (%dx),%al
f0104c1f:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0104c22:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104c25:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104c28:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f0104c2c:	c1 e0 08             	shl    $0x8,%eax
f0104c2f:	89 c2                	mov    %eax,%edx
f0104c31:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0104c35:	09 d0                	or     %edx,%eax
f0104c37:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f0104c3b:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0104c3f:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0104c46:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104c49:	8a 45 df             	mov    -0x21(%ebp),%al
f0104c4c:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0104c4f:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0104c50:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0104c53:	c9                   	leave  
f0104c54:	c3                   	ret    

f0104c55 <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0104c55:	55                   	push   %ebp
f0104c56:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104c58:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104c5c:	74 1d                	je     f0104c7b <init_queue+0x26>
	{
		LIST_INIT(queue);
f0104c5e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c61:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0104c67:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c6a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104c71:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c74:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f0104c7b:	90                   	nop
f0104c7c:	5d                   	pop    %ebp
f0104c7d:	c3                   	ret    

f0104c7e <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0104c7e:	55                   	push   %ebp
f0104c7f:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104c81:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104c85:	74 08                	je     f0104c8f <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0104c87:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c8a:	8b 40 0c             	mov    0xc(%eax),%eax
f0104c8d:	eb 05                	jmp    f0104c94 <queue_size+0x16>
	}
	else
	{
		return 0;
f0104c8f:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0104c94:	5d                   	pop    %ebp
f0104c95:	c3                   	ret    

f0104c96 <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f0104c96:	55                   	push   %ebp
f0104c97:	89 e5                	mov    %esp,%ebp
f0104c99:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0104c9c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104ca0:	75 16                	jne    f0104cb8 <enqueue+0x22>
f0104ca2:	68 64 42 12 f0       	push   $0xf0124264
f0104ca7:	68 72 42 12 f0       	push   $0xf0124272
f0104cac:	6a 34                	push   $0x34
f0104cae:	68 87 42 12 f0       	push   $0xf0124287
f0104cb3:	e8 62 b6 ff ff       	call   f010031a <_panic>
	if(env != NULL)
f0104cb8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104cbc:	74 66                	je     f0104d24 <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f0104cbe:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104cc2:	75 14                	jne    f0104cd8 <enqueue+0x42>
f0104cc4:	83 ec 04             	sub    $0x4,%esp
f0104cc7:	68 a0 42 12 f0       	push   $0xf01242a0
f0104ccc:	6a 37                	push   $0x37
f0104cce:	68 87 42 12 f0       	push   $0xf0124287
f0104cd3:	e8 42 b6 ff ff       	call   f010031a <_panic>
f0104cd8:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cdb:	8b 10                	mov    (%eax),%edx
f0104cdd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ce0:	89 50 08             	mov    %edx,0x8(%eax)
f0104ce3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104ce6:	8b 40 08             	mov    0x8(%eax),%eax
f0104ce9:	85 c0                	test   %eax,%eax
f0104ceb:	74 0d                	je     f0104cfa <enqueue+0x64>
f0104ced:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cf0:	8b 00                	mov    (%eax),%eax
f0104cf2:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104cf5:	89 50 0c             	mov    %edx,0xc(%eax)
f0104cf8:	eb 09                	jmp    f0104d03 <enqueue+0x6d>
f0104cfa:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cfd:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104d00:	89 50 04             	mov    %edx,0x4(%eax)
f0104d03:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d06:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104d09:	89 10                	mov    %edx,(%eax)
f0104d0b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104d0e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0104d15:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d18:	8b 40 0c             	mov    0xc(%eax),%eax
f0104d1b:	8d 50 01             	lea    0x1(%eax),%edx
f0104d1e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d21:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0104d24:	90                   	nop
f0104d25:	c9                   	leave  
f0104d26:	c3                   	ret    

f0104d27 <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f0104d27:	55                   	push   %ebp
f0104d28:	89 e5                	mov    %esp,%ebp
f0104d2a:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f0104d2d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104d31:	75 0a                	jne    f0104d3d <dequeue+0x16>
f0104d33:	b8 00 00 00 00       	mov    $0x0,%eax
f0104d38:	e9 a0 00 00 00       	jmp    f0104ddd <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f0104d3d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d40:	8b 40 04             	mov    0x4(%eax),%eax
f0104d43:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f0104d46:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104d4a:	0f 84 8a 00 00 00    	je     f0104dda <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f0104d50:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104d54:	75 14                	jne    f0104d6a <dequeue+0x43>
f0104d56:	83 ec 04             	sub    $0x4,%esp
f0104d59:	68 c3 42 12 f0       	push   $0xf01242c3
f0104d5e:	6a 44                	push   $0x44
f0104d60:	68 87 42 12 f0       	push   $0xf0124287
f0104d65:	e8 b0 b5 ff ff       	call   f010031a <_panic>
f0104d6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104d6d:	8b 40 08             	mov    0x8(%eax),%eax
f0104d70:	85 c0                	test   %eax,%eax
f0104d72:	74 11                	je     f0104d85 <dequeue+0x5e>
f0104d74:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104d77:	8b 40 08             	mov    0x8(%eax),%eax
f0104d7a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d7d:	8b 52 0c             	mov    0xc(%edx),%edx
f0104d80:	89 50 0c             	mov    %edx,0xc(%eax)
f0104d83:	eb 0c                	jmp    f0104d91 <dequeue+0x6a>
f0104d85:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104d88:	8b 50 0c             	mov    0xc(%eax),%edx
f0104d8b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d8e:	89 50 04             	mov    %edx,0x4(%eax)
f0104d91:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104d94:	8b 40 0c             	mov    0xc(%eax),%eax
f0104d97:	85 c0                	test   %eax,%eax
f0104d99:	74 11                	je     f0104dac <dequeue+0x85>
f0104d9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104d9e:	8b 40 0c             	mov    0xc(%eax),%eax
f0104da1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104da4:	8b 52 08             	mov    0x8(%edx),%edx
f0104da7:	89 50 08             	mov    %edx,0x8(%eax)
f0104daa:	eb 0b                	jmp    f0104db7 <dequeue+0x90>
f0104dac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104daf:	8b 50 08             	mov    0x8(%eax),%edx
f0104db2:	8b 45 08             	mov    0x8(%ebp),%eax
f0104db5:	89 10                	mov    %edx,(%eax)
f0104db7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104dba:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0104dc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104dc4:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0104dcb:	8b 45 08             	mov    0x8(%ebp),%eax
f0104dce:	8b 40 0c             	mov    0xc(%eax),%eax
f0104dd1:	8d 50 ff             	lea    -0x1(%eax),%edx
f0104dd4:	8b 45 08             	mov    0x8(%ebp),%eax
f0104dd7:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f0104dda:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104ddd:	c9                   	leave  
f0104dde:	c3                   	ret    

f0104ddf <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f0104ddf:	55                   	push   %ebp
f0104de0:	89 e5                	mov    %esp,%ebp
f0104de2:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0104de5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104de9:	75 16                	jne    f0104e01 <remove_from_queue+0x22>
f0104deb:	68 64 42 12 f0       	push   $0xf0124264
f0104df0:	68 72 42 12 f0       	push   $0xf0124272
f0104df5:	6a 4e                	push   $0x4e
f0104df7:	68 87 42 12 f0       	push   $0xf0124287
f0104dfc:	e8 19 b5 ff ff       	call   f010031a <_panic>

	if (e != NULL)
f0104e01:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104e05:	0f 84 8a 00 00 00    	je     f0104e95 <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f0104e0b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104e0f:	75 14                	jne    f0104e25 <remove_from_queue+0x46>
f0104e11:	83 ec 04             	sub    $0x4,%esp
f0104e14:	68 c3 42 12 f0       	push   $0xf01242c3
f0104e19:	6a 52                	push   $0x52
f0104e1b:	68 87 42 12 f0       	push   $0xf0124287
f0104e20:	e8 f5 b4 ff ff       	call   f010031a <_panic>
f0104e25:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104e28:	8b 40 08             	mov    0x8(%eax),%eax
f0104e2b:	85 c0                	test   %eax,%eax
f0104e2d:	74 11                	je     f0104e40 <remove_from_queue+0x61>
f0104e2f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104e32:	8b 40 08             	mov    0x8(%eax),%eax
f0104e35:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104e38:	8b 52 0c             	mov    0xc(%edx),%edx
f0104e3b:	89 50 0c             	mov    %edx,0xc(%eax)
f0104e3e:	eb 0c                	jmp    f0104e4c <remove_from_queue+0x6d>
f0104e40:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104e43:	8b 50 0c             	mov    0xc(%eax),%edx
f0104e46:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e49:	89 50 04             	mov    %edx,0x4(%eax)
f0104e4c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104e4f:	8b 40 0c             	mov    0xc(%eax),%eax
f0104e52:	85 c0                	test   %eax,%eax
f0104e54:	74 11                	je     f0104e67 <remove_from_queue+0x88>
f0104e56:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104e59:	8b 40 0c             	mov    0xc(%eax),%eax
f0104e5c:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104e5f:	8b 52 08             	mov    0x8(%edx),%edx
f0104e62:	89 50 08             	mov    %edx,0x8(%eax)
f0104e65:	eb 0b                	jmp    f0104e72 <remove_from_queue+0x93>
f0104e67:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104e6a:	8b 50 08             	mov    0x8(%eax),%edx
f0104e6d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e70:	89 10                	mov    %edx,(%eax)
f0104e72:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104e75:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0104e7c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104e7f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0104e86:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e89:	8b 40 0c             	mov    0xc(%eax),%eax
f0104e8c:	8d 50 ff             	lea    -0x1(%eax),%edx
f0104e8f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e92:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0104e95:	90                   	nop
f0104e96:	c9                   	leave  
f0104e97:	c3                   	ret    

f0104e98 <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f0104e98:	55                   	push   %ebp
f0104e99:	89 e5                	mov    %esp,%ebp
f0104e9b:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f0104e9e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104ea2:	75 07                	jne    f0104eab <find_env_in_queue+0x13>
f0104ea4:	b8 00 00 00 00       	mov    $0x0,%eax
f0104ea9:	eb 58                	jmp    f0104f03 <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f0104eab:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f0104eb2:	8b 45 08             	mov    0x8(%ebp),%eax
f0104eb5:	8b 00                	mov    (%eax),%eax
f0104eb7:	89 45 fc             	mov    %eax,-0x4(%ebp)
f0104eba:	eb 19                	jmp    f0104ed5 <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f0104ebc:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0104ebf:	8b 40 10             	mov    0x10(%eax),%eax
f0104ec2:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104ec5:	75 05                	jne    f0104ecc <find_env_in_queue+0x34>
		{
			return ptr_env;
f0104ec7:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0104eca:	eb 37                	jmp    f0104f03 <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f0104ecc:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ecf:	8b 40 08             	mov    0x8(%eax),%eax
f0104ed2:	89 45 fc             	mov    %eax,-0x4(%ebp)
f0104ed5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0104ed9:	74 08                	je     f0104ee3 <find_env_in_queue+0x4b>
f0104edb:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0104ede:	8b 40 08             	mov    0x8(%eax),%eax
f0104ee1:	eb 05                	jmp    f0104ee8 <find_env_in_queue+0x50>
f0104ee3:	b8 00 00 00 00       	mov    $0x0,%eax
f0104ee8:	8b 55 08             	mov    0x8(%ebp),%edx
f0104eeb:	89 42 08             	mov    %eax,0x8(%edx)
f0104eee:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ef1:	8b 40 08             	mov    0x8(%eax),%eax
f0104ef4:	85 c0                	test   %eax,%eax
f0104ef6:	75 c4                	jne    f0104ebc <find_env_in_queue+0x24>
f0104ef8:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0104efc:	75 be                	jne    f0104ebc <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f0104efe:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104f03:	c9                   	leave  
f0104f04:	c3                   	ret    

f0104f05 <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f0104f05:	55                   	push   %ebp
f0104f06:	89 e5                	mov    %esp,%ebp
			kfree(quantums);
	}
	release_spinlock(&ProcessQueues.qlock);

#endif
}
f0104f08:	90                   	nop
f0104f09:	5d                   	pop    %ebp
f0104f0a:	c3                   	ret    

f0104f0b <sched_insert_ready0>:

//=================================================
// [2] Insert the given Env in the 1st Ready Queue:
//=================================================
void sched_insert_ready0(struct Env* env)
{
f0104f0b:	55                   	push   %ebp
f0104f0c:	89 e5                	mov    %esp,%ebp
f0104f0e:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0104f11:	83 ec 0c             	sub    $0xc,%esp
f0104f14:	68 60 24 55 f0       	push   $0xf0552460
f0104f19:	e8 99 9a 00 00       	call   f010e9b7 <holding_spinlock>
f0104f1e:	83 c4 10             	add    $0x10,%esp
f0104f21:	85 c0                	test   %eax,%eax
f0104f23:	75 17                	jne    f0104f3c <sched_insert_ready0+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0104f25:	83 ec 04             	sub    $0x4,%esp
f0104f28:	68 e4 42 12 f0       	push   $0xf01242e4
f0104f2d:	68 85 00 00 00       	push   $0x85
f0104f32:	68 87 42 12 f0       	push   $0xf0124287
f0104f37:	e8 de b3 ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0104f3c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f40:	75 19                	jne    f0104f5b <sched_insert_ready0+0x50>
f0104f42:	68 25 43 12 f0       	push   $0xf0124325
f0104f47:	68 72 42 12 f0       	push   $0xf0124272
f0104f4c:	68 88 00 00 00       	push   $0x88
f0104f51:	68 87 42 12 f0       	push   $0xf0124287
f0104f56:	e8 bf b3 ff ff       	call   f010031a <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f0104f5b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f5e:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[0]), env);
f0104f65:	83 ec 08             	sub    $0x8,%esp
f0104f68:	ff 75 08             	pushl  0x8(%ebp)
f0104f6b:	68 f0 24 55 f0       	push   $0xf05524f0
f0104f70:	e8 21 fd ff ff       	call   f0104c96 <enqueue>
f0104f75:	83 c4 10             	add    $0x10,%esp
	}
}
f0104f78:	90                   	nop
f0104f79:	c9                   	leave  
f0104f7a:	c3                   	ret    

f0104f7b <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f0104f7b:	55                   	push   %ebp
f0104f7c:	89 e5                	mov    %esp,%ebp
f0104f7e:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0104f81:	83 ec 0c             	sub    $0xc,%esp
f0104f84:	68 60 24 55 f0       	push   $0xf0552460
f0104f89:	e8 29 9a 00 00       	call   f010e9b7 <holding_spinlock>
f0104f8e:	83 c4 10             	add    $0x10,%esp
f0104f91:	85 c0                	test   %eax,%eax
f0104f93:	75 17                	jne    f0104fac <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0104f95:	83 ec 04             	sub    $0x4,%esp
f0104f98:	68 e4 42 12 f0       	push   $0xf01242e4
f0104f9d:	68 97 00 00 00       	push   $0x97
f0104fa2:	68 87 42 12 f0       	push   $0xf0124287
f0104fa7:	e8 6e b3 ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f0104fac:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104fb0:	74 0b                	je     f0104fbd <sched_remove_ready+0x42>
f0104fb2:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fb5:	8b 40 18             	mov    0x18(%eax),%eax
f0104fb8:	83 f8 01             	cmp    $0x1,%eax
f0104fbb:	74 19                	je     f0104fd6 <sched_remove_ready+0x5b>
f0104fbd:	68 34 43 12 f0       	push   $0xf0124334
f0104fc2:	68 72 42 12 f0       	push   $0xf0124272
f0104fc7:	68 9a 00 00 00       	push   $0x9a
f0104fcc:	68 87 42 12 f0       	push   $0xf0124287
f0104fd1:	e8 44 b3 ff ff       	call   f010031a <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0104fd6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104fdd:	e9 f7 00 00 00       	jmp    f01050d9 <sched_remove_ready+0x15e>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f0104fe2:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fe5:	8b 40 10             	mov    0x10(%eax),%eax
f0104fe8:	89 c2                	mov    %eax,%edx
f0104fea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104fed:	83 c0 09             	add    $0x9,%eax
f0104ff0:	c1 e0 04             	shl    $0x4,%eax
f0104ff3:	05 60 24 55 f0       	add    $0xf0552460,%eax
f0104ff8:	83 ec 08             	sub    $0x8,%esp
f0104ffb:	52                   	push   %edx
f0104ffc:	50                   	push   %eax
f0104ffd:	e8 96 fe ff ff       	call   f0104e98 <find_env_in_queue>
f0105002:	83 c4 10             	add    $0x10,%esp
f0105005:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f0105008:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010500c:	0f 84 c4 00 00 00    	je     f01050d6 <sched_remove_ready+0x15b>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f0105012:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105016:	75 17                	jne    f010502f <sched_remove_ready+0xb4>
f0105018:	83 ec 04             	sub    $0x4,%esp
f010501b:	68 c3 42 12 f0       	push   $0xf01242c3
f0105020:	68 a1 00 00 00       	push   $0xa1
f0105025:	68 87 42 12 f0       	push   $0xf0124287
f010502a:	e8 eb b2 ff ff       	call   f010031a <_panic>
f010502f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105032:	8b 40 08             	mov    0x8(%eax),%eax
f0105035:	85 c0                	test   %eax,%eax
f0105037:	74 11                	je     f010504a <sched_remove_ready+0xcf>
f0105039:	8b 45 08             	mov    0x8(%ebp),%eax
f010503c:	8b 40 08             	mov    0x8(%eax),%eax
f010503f:	8b 55 08             	mov    0x8(%ebp),%edx
f0105042:	8b 52 0c             	mov    0xc(%edx),%edx
f0105045:	89 50 0c             	mov    %edx,0xc(%eax)
f0105048:	eb 17                	jmp    f0105061 <sched_remove_ready+0xe6>
f010504a:	8b 45 08             	mov    0x8(%ebp),%eax
f010504d:	8b 40 0c             	mov    0xc(%eax),%eax
f0105050:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105053:	83 c2 09             	add    $0x9,%edx
f0105056:	c1 e2 04             	shl    $0x4,%edx
f0105059:	81 c2 64 24 55 f0    	add    $0xf0552464,%edx
f010505f:	89 02                	mov    %eax,(%edx)
f0105061:	8b 45 08             	mov    0x8(%ebp),%eax
f0105064:	8b 40 0c             	mov    0xc(%eax),%eax
f0105067:	85 c0                	test   %eax,%eax
f0105069:	74 11                	je     f010507c <sched_remove_ready+0x101>
f010506b:	8b 45 08             	mov    0x8(%ebp),%eax
f010506e:	8b 40 0c             	mov    0xc(%eax),%eax
f0105071:	8b 55 08             	mov    0x8(%ebp),%edx
f0105074:	8b 52 08             	mov    0x8(%edx),%edx
f0105077:	89 50 08             	mov    %edx,0x8(%eax)
f010507a:	eb 17                	jmp    f0105093 <sched_remove_ready+0x118>
f010507c:	8b 45 08             	mov    0x8(%ebp),%eax
f010507f:	8b 40 08             	mov    0x8(%eax),%eax
f0105082:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105085:	83 c2 09             	add    $0x9,%edx
f0105088:	c1 e2 04             	shl    $0x4,%edx
f010508b:	81 c2 60 24 55 f0    	add    $0xf0552460,%edx
f0105091:	89 02                	mov    %eax,(%edx)
f0105093:	8b 45 08             	mov    0x8(%ebp),%eax
f0105096:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010509d:	8b 45 08             	mov    0x8(%ebp),%eax
f01050a0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01050a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050aa:	83 c0 09             	add    $0x9,%eax
f01050ad:	c1 e0 04             	shl    $0x4,%eax
f01050b0:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f01050b5:	8b 00                	mov    (%eax),%eax
f01050b7:	8d 50 ff             	lea    -0x1(%eax),%edx
f01050ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050bd:	83 c0 09             	add    $0x9,%eax
f01050c0:	c1 e0 04             	shl    $0x4,%eax
f01050c3:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f01050c8:	89 10                	mov    %edx,(%eax)
				env->env_status = ENV_UNKNOWN;
f01050ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01050cd:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
				return ;
f01050d4:	eb 14                	jmp    f01050ea <sched_remove_ready+0x16f>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01050d6:	ff 45 f4             	incl   -0xc(%ebp)
f01050d9:	a0 60 51 55 f0       	mov    0xf0555160,%al
f01050de:	0f b6 c0             	movzbl %al,%eax
f01050e1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01050e4:	0f 8f f8 fe ff ff    	jg     f0104fe2 <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f01050ea:	c9                   	leave  
f01050eb:	c3                   	ret    

f01050ec <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f01050ec:	55                   	push   %ebp
f01050ed:	89 e5                	mov    %esp,%ebp
f01050ef:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01050f2:	83 ec 0c             	sub    $0xc,%esp
f01050f5:	68 60 24 55 f0       	push   $0xf0552460
f01050fa:	e8 b8 98 00 00       	call   f010e9b7 <holding_spinlock>
f01050ff:	83 c4 10             	add    $0x10,%esp
f0105102:	85 c0                	test   %eax,%eax
f0105104:	75 17                	jne    f010511d <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105106:	83 ec 04             	sub    $0x4,%esp
f0105109:	68 e4 42 12 f0       	push   $0xf01242e4
f010510e:	68 b0 00 00 00       	push   $0xb0
f0105113:	68 87 42 12 f0       	push   $0xf0124287
f0105118:	e8 fd b1 ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL);
f010511d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105121:	75 19                	jne    f010513c <sched_insert_new+0x50>
f0105123:	68 25 43 12 f0       	push   $0xf0124325
f0105128:	68 72 42 12 f0       	push   $0xf0124272
f010512d:	68 b3 00 00 00       	push   $0xb3
f0105132:	68 87 42 12 f0       	push   $0xf0124287
f0105137:	e8 de b1 ff ff       	call   f010031a <_panic>
	{
		env->env_status = ENV_NEW ;
f010513c:	8b 45 08             	mov    0x8(%ebp),%eax
f010513f:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f0105146:	83 ec 08             	sub    $0x8,%esp
f0105149:	ff 75 08             	pushl  0x8(%ebp)
f010514c:	68 d0 24 55 f0       	push   $0xf05524d0
f0105151:	e8 40 fb ff ff       	call   f0104c96 <enqueue>
f0105156:	83 c4 10             	add    $0x10,%esp
	}
}
f0105159:	90                   	nop
f010515a:	c9                   	leave  
f010515b:	c3                   	ret    

f010515c <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f010515c:	55                   	push   %ebp
f010515d:	89 e5                	mov    %esp,%ebp
f010515f:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105162:	83 ec 0c             	sub    $0xc,%esp
f0105165:	68 60 24 55 f0       	push   $0xf0552460
f010516a:	e8 48 98 00 00       	call   f010e9b7 <holding_spinlock>
f010516f:	83 c4 10             	add    $0x10,%esp
f0105172:	85 c0                	test   %eax,%eax
f0105174:	75 17                	jne    f010518d <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105176:	83 ec 04             	sub    $0x4,%esp
f0105179:	68 e4 42 12 f0       	push   $0xf01242e4
f010517e:	68 c1 00 00 00       	push   $0xc1
f0105183:	68 87 42 12 f0       	push   $0xf0124287
f0105188:	e8 8d b1 ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f010518d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105191:	74 0b                	je     f010519e <sched_remove_new+0x42>
f0105193:	8b 45 08             	mov    0x8(%ebp),%eax
f0105196:	8b 40 18             	mov    0x18(%eax),%eax
f0105199:	83 f8 04             	cmp    $0x4,%eax
f010519c:	74 19                	je     f01051b7 <sched_remove_new+0x5b>
f010519e:	68 60 43 12 f0       	push   $0xf0124360
f01051a3:	68 72 42 12 f0       	push   $0xf0124272
f01051a8:	68 c4 00 00 00       	push   $0xc4
f01051ad:	68 87 42 12 f0       	push   $0xf0124287
f01051b2:	e8 63 b1 ff ff       	call   f010031a <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f01051b7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01051bb:	75 17                	jne    f01051d4 <sched_remove_new+0x78>
f01051bd:	83 ec 04             	sub    $0x4,%esp
f01051c0:	68 c3 42 12 f0       	push   $0xf01242c3
f01051c5:	68 c6 00 00 00       	push   $0xc6
f01051ca:	68 87 42 12 f0       	push   $0xf0124287
f01051cf:	e8 46 b1 ff ff       	call   f010031a <_panic>
f01051d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01051d7:	8b 40 08             	mov    0x8(%eax),%eax
f01051da:	85 c0                	test   %eax,%eax
f01051dc:	74 11                	je     f01051ef <sched_remove_new+0x93>
f01051de:	8b 45 08             	mov    0x8(%ebp),%eax
f01051e1:	8b 40 08             	mov    0x8(%eax),%eax
f01051e4:	8b 55 08             	mov    0x8(%ebp),%edx
f01051e7:	8b 52 0c             	mov    0xc(%edx),%edx
f01051ea:	89 50 0c             	mov    %edx,0xc(%eax)
f01051ed:	eb 0b                	jmp    f01051fa <sched_remove_new+0x9e>
f01051ef:	8b 45 08             	mov    0x8(%ebp),%eax
f01051f2:	8b 40 0c             	mov    0xc(%eax),%eax
f01051f5:	a3 d4 24 55 f0       	mov    %eax,0xf05524d4
f01051fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01051fd:	8b 40 0c             	mov    0xc(%eax),%eax
f0105200:	85 c0                	test   %eax,%eax
f0105202:	74 11                	je     f0105215 <sched_remove_new+0xb9>
f0105204:	8b 45 08             	mov    0x8(%ebp),%eax
f0105207:	8b 40 0c             	mov    0xc(%eax),%eax
f010520a:	8b 55 08             	mov    0x8(%ebp),%edx
f010520d:	8b 52 08             	mov    0x8(%edx),%edx
f0105210:	89 50 08             	mov    %edx,0x8(%eax)
f0105213:	eb 0b                	jmp    f0105220 <sched_remove_new+0xc4>
f0105215:	8b 45 08             	mov    0x8(%ebp),%eax
f0105218:	8b 40 08             	mov    0x8(%eax),%eax
f010521b:	a3 d0 24 55 f0       	mov    %eax,0xf05524d0
f0105220:	8b 45 08             	mov    0x8(%ebp),%eax
f0105223:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010522a:	8b 45 08             	mov    0x8(%ebp),%eax
f010522d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105234:	a1 dc 24 55 f0       	mov    0xf05524dc,%eax
f0105239:	48                   	dec    %eax
f010523a:	a3 dc 24 55 f0       	mov    %eax,0xf05524dc
		env->env_status = ENV_UNKNOWN;
f010523f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105242:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f0105249:	90                   	nop
f010524a:	c9                   	leave  
f010524b:	c3                   	ret    

f010524c <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f010524c:	55                   	push   %ebp
f010524d:	89 e5                	mov    %esp,%ebp
f010524f:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105252:	83 ec 0c             	sub    $0xc,%esp
f0105255:	68 60 24 55 f0       	push   $0xf0552460
f010525a:	e8 58 97 00 00       	call   f010e9b7 <holding_spinlock>
f010525f:	83 c4 10             	add    $0x10,%esp
f0105262:	85 c0                	test   %eax,%eax
f0105264:	75 17                	jne    f010527d <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105266:	83 ec 04             	sub    $0x4,%esp
f0105269:	68 e4 42 12 f0       	push   $0xf01242e4
f010526e:	68 d2 00 00 00       	push   $0xd2
f0105273:	68 87 42 12 f0       	push   $0xf0124287
f0105278:	e8 9d b0 ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL);
f010527d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105281:	75 19                	jne    f010529c <sched_insert_exit+0x50>
f0105283:	68 25 43 12 f0       	push   $0xf0124325
f0105288:	68 72 42 12 f0       	push   $0xf0124272
f010528d:	68 d5 00 00 00       	push   $0xd5
f0105292:	68 87 42 12 f0       	push   $0xf0124287
f0105297:	e8 7e b0 ff ff       	call   f010031a <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f010529c:	e8 af 91 00 00       	call   f010e450 <isBufferingEnabled>
f01052a1:	84 c0                	test   %al,%al
f01052a3:	74 0e                	je     f01052b3 <sched_insert_exit+0x67>
f01052a5:	83 ec 0c             	sub    $0xc,%esp
f01052a8:	ff 75 08             	pushl  0x8(%ebp)
f01052ab:	e8 ef 67 00 00       	call   f010ba9f <cleanup_buffers>
f01052b0:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f01052b3:	8b 45 08             	mov    0x8(%ebp),%eax
f01052b6:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f01052bd:	83 ec 08             	sub    $0x8,%esp
f01052c0:	ff 75 08             	pushl  0x8(%ebp)
f01052c3:	68 e0 24 55 f0       	push   $0xf05524e0
f01052c8:	e8 c9 f9 ff ff       	call   f0104c96 <enqueue>
f01052cd:	83 c4 10             	add    $0x10,%esp
	}
}
f01052d0:	90                   	nop
f01052d1:	c9                   	leave  
f01052d2:	c3                   	ret    

f01052d3 <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f01052d3:	55                   	push   %ebp
f01052d4:	89 e5                	mov    %esp,%ebp
f01052d6:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01052d9:	83 ec 0c             	sub    $0xc,%esp
f01052dc:	68 60 24 55 f0       	push   $0xf0552460
f01052e1:	e8 d1 96 00 00       	call   f010e9b7 <holding_spinlock>
f01052e6:	83 c4 10             	add    $0x10,%esp
f01052e9:	85 c0                	test   %eax,%eax
f01052eb:	75 17                	jne    f0105304 <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01052ed:	83 ec 04             	sub    $0x4,%esp
f01052f0:	68 e4 42 12 f0       	push   $0xf01242e4
f01052f5:	68 e3 00 00 00       	push   $0xe3
f01052fa:	68 87 42 12 f0       	push   $0xf0124287
f01052ff:	e8 16 b0 ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f0105304:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105308:	74 0b                	je     f0105315 <sched_remove_exit+0x42>
f010530a:	8b 45 08             	mov    0x8(%ebp),%eax
f010530d:	8b 40 18             	mov    0x18(%eax),%eax
f0105310:	83 f8 05             	cmp    $0x5,%eax
f0105313:	74 19                	je     f010532e <sched_remove_exit+0x5b>
f0105315:	68 8c 43 12 f0       	push   $0xf012438c
f010531a:	68 72 42 12 f0       	push   $0xf0124272
f010531f:	68 e6 00 00 00       	push   $0xe6
f0105324:	68 87 42 12 f0       	push   $0xf0124287
f0105329:	e8 ec af ff ff       	call   f010031a <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f010532e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105332:	75 17                	jne    f010534b <sched_remove_exit+0x78>
f0105334:	83 ec 04             	sub    $0x4,%esp
f0105337:	68 c3 42 12 f0       	push   $0xf01242c3
f010533c:	68 e8 00 00 00       	push   $0xe8
f0105341:	68 87 42 12 f0       	push   $0xf0124287
f0105346:	e8 cf af ff ff       	call   f010031a <_panic>
f010534b:	8b 45 08             	mov    0x8(%ebp),%eax
f010534e:	8b 40 08             	mov    0x8(%eax),%eax
f0105351:	85 c0                	test   %eax,%eax
f0105353:	74 11                	je     f0105366 <sched_remove_exit+0x93>
f0105355:	8b 45 08             	mov    0x8(%ebp),%eax
f0105358:	8b 40 08             	mov    0x8(%eax),%eax
f010535b:	8b 55 08             	mov    0x8(%ebp),%edx
f010535e:	8b 52 0c             	mov    0xc(%edx),%edx
f0105361:	89 50 0c             	mov    %edx,0xc(%eax)
f0105364:	eb 0b                	jmp    f0105371 <sched_remove_exit+0x9e>
f0105366:	8b 45 08             	mov    0x8(%ebp),%eax
f0105369:	8b 40 0c             	mov    0xc(%eax),%eax
f010536c:	a3 e4 24 55 f0       	mov    %eax,0xf05524e4
f0105371:	8b 45 08             	mov    0x8(%ebp),%eax
f0105374:	8b 40 0c             	mov    0xc(%eax),%eax
f0105377:	85 c0                	test   %eax,%eax
f0105379:	74 11                	je     f010538c <sched_remove_exit+0xb9>
f010537b:	8b 45 08             	mov    0x8(%ebp),%eax
f010537e:	8b 40 0c             	mov    0xc(%eax),%eax
f0105381:	8b 55 08             	mov    0x8(%ebp),%edx
f0105384:	8b 52 08             	mov    0x8(%edx),%edx
f0105387:	89 50 08             	mov    %edx,0x8(%eax)
f010538a:	eb 0b                	jmp    f0105397 <sched_remove_exit+0xc4>
f010538c:	8b 45 08             	mov    0x8(%ebp),%eax
f010538f:	8b 40 08             	mov    0x8(%eax),%eax
f0105392:	a3 e0 24 55 f0       	mov    %eax,0xf05524e0
f0105397:	8b 45 08             	mov    0x8(%ebp),%eax
f010539a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01053a1:	8b 45 08             	mov    0x8(%ebp),%eax
f01053a4:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01053ab:	a1 ec 24 55 f0       	mov    0xf05524ec,%eax
f01053b0:	48                   	dec    %eax
f01053b1:	a3 ec 24 55 f0       	mov    %eax,0xf05524ec
		env->env_status = ENV_UNKNOWN;
f01053b6:	8b 45 08             	mov    0x8(%ebp),%eax
f01053b9:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f01053c0:	90                   	nop
f01053c1:	c9                   	leave  
f01053c2:	c3                   	ret    

f01053c3 <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f01053c3:	55                   	push   %ebp
f01053c4:	89 e5                	mov    %esp,%ebp
f01053c6:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01053c9:	83 ec 0c             	sub    $0xc,%esp
f01053cc:	68 60 24 55 f0       	push   $0xf0552460
f01053d1:	e8 c8 93 00 00       	call   f010e79e <acquire_spinlock>
f01053d6:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f01053d9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01053dd:	75 19                	jne    f01053f8 <sched_new_env+0x35>
f01053df:	68 b7 43 12 f0       	push   $0xf01243b7
f01053e4:	68 72 42 12 f0       	push   $0xf0124272
f01053e9:	68 f6 00 00 00       	push   $0xf6
f01053ee:	68 87 42 12 f0       	push   $0xf0124287
f01053f3:	e8 22 af ff ff       	call   f010031a <_panic>
	{
		sched_insert_new(e);
f01053f8:	83 ec 0c             	sub    $0xc,%esp
f01053fb:	ff 75 08             	pushl  0x8(%ebp)
f01053fe:	e8 e9 fc ff ff       	call   f01050ec <sched_insert_new>
f0105403:	83 c4 10             	add    $0x10,%esp
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105406:	83 ec 0c             	sub    $0xc,%esp
f0105409:	68 60 24 55 f0       	push   $0xf0552460
f010540e:	e8 12 94 00 00       	call   f010e825 <release_spinlock>
f0105413:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f0105416:	90                   	nop
f0105417:	c9                   	leave  
f0105418:	c3                   	ret    

f0105419 <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f0105419:	55                   	push   %ebp
f010541a:	89 e5                	mov    %esp,%ebp
f010541c:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010541f:	83 ec 0c             	sub    $0xc,%esp
f0105422:	68 60 24 55 f0       	push   $0xf0552460
f0105427:	e8 72 93 00 00       	call   f010e79e <acquire_spinlock>
f010542c:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f010542f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105436:	a1 d0 24 55 f0       	mov    0xf05524d0,%eax
f010543b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010543e:	eb 53                	jmp    f0105493 <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f0105440:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105443:	8b 40 10             	mov    0x10(%eax),%eax
f0105446:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105449:	75 40                	jne    f010548b <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f010544b:	83 ec 0c             	sub    $0xc,%esp
f010544e:	ff 75 f4             	pushl  -0xc(%ebp)
f0105451:	e8 06 fd ff ff       	call   f010515c <sched_remove_new>
f0105456:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready0(ptr_env);
f0105459:	83 ec 0c             	sub    $0xc,%esp
f010545c:	ff 75 f4             	pushl  -0xc(%ebp)
f010545f:	e8 a7 fa ff ff       	call   f0104f0b <sched_insert_ready0>
f0105464:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f0105467:	e8 af 19 00 00       	call   f0106e1b <mycpu>
f010546c:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0105472:	85 c0                	test   %eax,%eax
f0105474:	75 46                	jne    f01054bc <sched_run_env+0xa3>
			{
				release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105476:	83 ec 0c             	sub    $0xc,%esp
f0105479:	68 60 24 55 f0       	push   $0xf0552460
f010547e:	e8 a2 93 00 00       	call   f010e825 <release_spinlock>
f0105483:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f0105486:	e8 45 10 00 00       	call   f01064d0 <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010548b:	a1 d8 24 55 f0       	mov    0xf05524d8,%eax
f0105490:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105493:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105497:	74 08                	je     f01054a1 <sched_run_env+0x88>
f0105499:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010549c:	8b 40 08             	mov    0x8(%eax),%eax
f010549f:	eb 05                	jmp    f01054a6 <sched_run_env+0x8d>
f01054a1:	b8 00 00 00 00       	mov    $0x0,%eax
f01054a6:	a3 d8 24 55 f0       	mov    %eax,0xf05524d8
f01054ab:	a1 d8 24 55 f0       	mov    0xf05524d8,%eax
f01054b0:	85 c0                	test   %eax,%eax
f01054b2:	75 8c                	jne    f0105440 <sched_run_env+0x27>
f01054b4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01054b8:	75 86                	jne    f0105440 <sched_run_env+0x27>
f01054ba:	eb 01                	jmp    f01054bd <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f01054bc:	90                   	nop
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01054bd:	83 ec 0c             	sub    $0xc,%esp
f01054c0:	68 60 24 55 f0       	push   $0xf0552460
f01054c5:	e8 5b 93 00 00       	call   f010e825 <release_spinlock>
f01054ca:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f01054cd:	90                   	nop
f01054ce:	c9                   	leave  
f01054cf:	c3                   	ret    

f01054d0 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f01054d0:	55                   	push   %ebp
f01054d1:	89 e5                	mov    %esp,%ebp
f01054d3:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_spinlock(&ProcessQueues.qlock);
f01054d6:	83 ec 0c             	sub    $0xc,%esp
f01054d9:	68 60 24 55 f0       	push   $0xf0552460
f01054de:	e8 d4 94 00 00       	call   f010e9b7 <holding_spinlock>
f01054e3:	83 c4 10             	add    $0x10,%esp
f01054e6:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f01054e9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01054ed:	75 10                	jne    f01054ff <sched_exit_env+0x2f>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f01054ef:	83 ec 0c             	sub    $0xc,%esp
f01054f2:	68 60 24 55 f0       	push   $0xf0552460
f01054f7:	e8 a2 92 00 00       	call   f010e79e <acquire_spinlock>
f01054fc:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f01054ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105506:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f010550d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105511:	75 59                	jne    f010556c <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105513:	a1 d0 24 55 f0       	mov    0xf05524d0,%eax
f0105518:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010551b:	eb 28                	jmp    f0105545 <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f010551d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105520:	8b 40 10             	mov    0x10(%eax),%eax
f0105523:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105526:	75 15                	jne    f010553d <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f0105528:	83 ec 0c             	sub    $0xc,%esp
f010552b:	ff 75 f4             	pushl  -0xc(%ebp)
f010552e:	e8 29 fc ff ff       	call   f010515c <sched_remove_new>
f0105533:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105536:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010553d:	a1 d8 24 55 f0       	mov    0xf05524d8,%eax
f0105542:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105545:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105549:	74 08                	je     f0105553 <sched_exit_env+0x83>
f010554b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010554e:	8b 40 08             	mov    0x8(%eax),%eax
f0105551:	eb 05                	jmp    f0105558 <sched_exit_env+0x88>
f0105553:	b8 00 00 00 00       	mov    $0x0,%eax
f0105558:	a3 d8 24 55 f0       	mov    %eax,0xf05524d8
f010555d:	a1 d8 24 55 f0       	mov    0xf05524d8,%eax
f0105562:	85 c0                	test   %eax,%eax
f0105564:	75 b7                	jne    f010551d <sched_exit_env+0x4d>
f0105566:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010556a:	75 b1                	jne    f010551d <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f010556c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105570:	0f 85 89 01 00 00    	jne    f01056ff <sched_exit_env+0x22f>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105576:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010557d:	e9 69 01 00 00       	jmp    f01056eb <sched_exit_env+0x21b>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105582:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105585:	83 c0 09             	add    $0x9,%eax
f0105588:	c1 e0 04             	shl    $0x4,%eax
f010558b:	05 60 24 55 f0       	add    $0xf0552460,%eax
f0105590:	8b 00                	mov    (%eax),%eax
f0105592:	85 c0                	test   %eax,%eax
f0105594:	0f 84 48 01 00 00    	je     f01056e2 <sched_exit_env+0x212>
			{
				ptr_env=NULL;
f010559a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01055a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01055a4:	83 c0 09             	add    $0x9,%eax
f01055a7:	c1 e0 04             	shl    $0x4,%eax
f01055aa:	05 60 24 55 f0       	add    $0xf0552460,%eax
f01055af:	8b 00                	mov    (%eax),%eax
f01055b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01055b4:	e9 e3 00 00 00       	jmp    f010569c <sched_exit_env+0x1cc>
				{
					if(ptr_env->env_id == envId)
f01055b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01055bc:	8b 40 10             	mov    0x10(%eax),%eax
f01055bf:	3b 45 08             	cmp    0x8(%ebp),%eax
f01055c2:	0f 85 c1 00 00 00    	jne    f0105689 <sched_exit_env+0x1b9>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01055c8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01055cc:	75 17                	jne    f01055e5 <sched_exit_env+0x115>
f01055ce:	83 ec 04             	sub    $0x4,%esp
f01055d1:	68 c3 42 12 f0       	push   $0xf01242c3
f01055d6:	68 44 01 00 00       	push   $0x144
f01055db:	68 87 42 12 f0       	push   $0xf0124287
f01055e0:	e8 35 ad ff ff       	call   f010031a <_panic>
f01055e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01055e8:	8b 40 08             	mov    0x8(%eax),%eax
f01055eb:	85 c0                	test   %eax,%eax
f01055ed:	74 11                	je     f0105600 <sched_exit_env+0x130>
f01055ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01055f2:	8b 40 08             	mov    0x8(%eax),%eax
f01055f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01055f8:	8b 52 0c             	mov    0xc(%edx),%edx
f01055fb:	89 50 0c             	mov    %edx,0xc(%eax)
f01055fe:	eb 17                	jmp    f0105617 <sched_exit_env+0x147>
f0105600:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105603:	8b 40 0c             	mov    0xc(%eax),%eax
f0105606:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105609:	83 c2 09             	add    $0x9,%edx
f010560c:	c1 e2 04             	shl    $0x4,%edx
f010560f:	81 c2 64 24 55 f0    	add    $0xf0552464,%edx
f0105615:	89 02                	mov    %eax,(%edx)
f0105617:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010561a:	8b 40 0c             	mov    0xc(%eax),%eax
f010561d:	85 c0                	test   %eax,%eax
f010561f:	74 11                	je     f0105632 <sched_exit_env+0x162>
f0105621:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105624:	8b 40 0c             	mov    0xc(%eax),%eax
f0105627:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010562a:	8b 52 08             	mov    0x8(%edx),%edx
f010562d:	89 50 08             	mov    %edx,0x8(%eax)
f0105630:	eb 17                	jmp    f0105649 <sched_exit_env+0x179>
f0105632:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105635:	8b 40 08             	mov    0x8(%eax),%eax
f0105638:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010563b:	83 c2 09             	add    $0x9,%edx
f010563e:	c1 e2 04             	shl    $0x4,%edx
f0105641:	81 c2 60 24 55 f0    	add    $0xf0552460,%edx
f0105647:	89 02                	mov    %eax,(%edx)
f0105649:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010564c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105653:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105656:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010565d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105660:	83 c0 09             	add    $0x9,%eax
f0105663:	c1 e0 04             	shl    $0x4,%eax
f0105666:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f010566b:	8b 00                	mov    (%eax),%eax
f010566d:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105670:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105673:	83 c0 09             	add    $0x9,%eax
f0105676:	c1 e0 04             	shl    $0x4,%eax
f0105679:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f010567e:	89 10                	mov    %edx,(%eax)
						found = 1;
f0105680:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105687:	eb 59                	jmp    f01056e2 <sched_exit_env+0x212>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105689:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010568c:	83 c0 09             	add    $0x9,%eax
f010568f:	c1 e0 04             	shl    $0x4,%eax
f0105692:	05 68 24 55 f0       	add    $0xf0552468,%eax
f0105697:	8b 00                	mov    (%eax),%eax
f0105699:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010569c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01056a0:	74 08                	je     f01056aa <sched_exit_env+0x1da>
f01056a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01056a5:	8b 40 08             	mov    0x8(%eax),%eax
f01056a8:	eb 05                	jmp    f01056af <sched_exit_env+0x1df>
f01056aa:	b8 00 00 00 00       	mov    $0x0,%eax
f01056af:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01056b2:	83 c2 09             	add    $0x9,%edx
f01056b5:	c1 e2 04             	shl    $0x4,%edx
f01056b8:	81 c2 68 24 55 f0    	add    $0xf0552468,%edx
f01056be:	89 02                	mov    %eax,(%edx)
f01056c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01056c3:	83 c0 09             	add    $0x9,%eax
f01056c6:	c1 e0 04             	shl    $0x4,%eax
f01056c9:	05 68 24 55 f0       	add    $0xf0552468,%eax
f01056ce:	8b 00                	mov    (%eax),%eax
f01056d0:	85 c0                	test   %eax,%eax
f01056d2:	0f 85 e1 fe ff ff    	jne    f01055b9 <sched_exit_env+0xe9>
f01056d8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01056dc:	0f 85 d7 fe ff ff    	jne    f01055b9 <sched_exit_env+0xe9>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f01056e2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01056e6:	75 16                	jne    f01056fe <sched_exit_env+0x22e>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01056e8:	ff 45 ec             	incl   -0x14(%ebp)
f01056eb:	a0 60 51 55 f0       	mov    0xf0555160,%al
f01056f0:	0f b6 c0             	movzbl %al,%eax
f01056f3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01056f6:	0f 8f 86 fe ff ff    	jg     f0105582 <sched_exit_env+0xb2>
f01056fc:	eb 01                	jmp    f01056ff <sched_exit_env+0x22f>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f01056fe:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f01056ff:	e8 8a 4d 00 00       	call   f010a48e <get_cpu_proc>
f0105704:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0105707:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010570b:	75 19                	jne    f0105726 <sched_exit_env+0x256>
f010570d:	68 bf 43 12 f0       	push   $0xf01243bf
f0105712:	68 72 42 12 f0       	push   $0xf0124272
f0105717:	68 4e 01 00 00       	push   $0x14e
f010571c:	68 87 42 12 f0       	push   $0xf0124287
f0105721:	e8 f4 ab ff ff       	call   f010031a <_panic>
	if (!found)
f0105726:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010572a:	75 18                	jne    f0105744 <sched_exit_env+0x274>
	{
		if (cur_env->env_id == envId)
f010572c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010572f:	8b 40 10             	mov    0x10(%eax),%eax
f0105732:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105735:	75 0d                	jne    f0105744 <sched_exit_env+0x274>
		{
			ptr_env = cur_env;
f0105737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010573a:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f010573d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f0105744:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105748:	74 1e                	je     f0105768 <sched_exit_env+0x298>
	{
		sched_insert_exit(ptr_env);
f010574a:	83 ec 0c             	sub    $0xc,%esp
f010574d:	ff 75 f4             	pushl  -0xc(%ebp)
f0105750:	e8 f7 fa ff ff       	call   f010524c <sched_insert_exit>
f0105755:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f0105758:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010575b:	8b 40 10             	mov    0x10(%eax),%eax
f010575e:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105761:	75 05                	jne    f0105768 <sched_exit_env+0x298>
		{
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0105763:	e8 b3 4e 00 00       	call   f010a61b <sched>
		}
	}
	if (!lock_already_held)
f0105768:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010576c:	75 10                	jne    f010577e <sched_exit_env+0x2ae>
	{
		release_spinlock(&ProcessQueues.qlock);
f010576e:	83 ec 0c             	sub    $0xc,%esp
f0105771:	68 60 24 55 f0       	push   $0xf0552460
f0105776:	e8 aa 90 00 00       	call   f010e825 <release_spinlock>
f010577b:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f010577e:	90                   	nop
f010577f:	c9                   	leave  
f0105780:	c3                   	ret    

f0105781 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0105781:	55                   	push   %ebp
f0105782:	89 e5                	mov    %esp,%ebp
f0105784:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105787:	83 ec 0c             	sub    $0xc,%esp
f010578a:	68 60 24 55 f0       	push   $0xf0552460
f010578f:	e8 0a 90 00 00       	call   f010e79e <acquire_spinlock>
f0105794:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105797:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f010579e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f01057a5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01057a9:	75 79                	jne    f0105824 <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01057ab:	a1 d0 24 55 f0       	mov    0xf05524d0,%eax
f01057b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01057b3:	eb 48                	jmp    f01057fd <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f01057b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01057b8:	8b 40 10             	mov    0x10(%eax),%eax
f01057bb:	3b 45 08             	cmp    0x8(%ebp),%eax
f01057be:	75 35                	jne    f01057f5 <sched_kill_env+0x74>
			{
				cprintf("killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f01057c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01057c3:	8d 50 20             	lea    0x20(%eax),%edx
f01057c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01057c9:	8b 40 10             	mov    0x10(%eax),%eax
f01057cc:	83 ec 04             	sub    $0x4,%esp
f01057cf:	52                   	push   %edx
f01057d0:	50                   	push   %eax
f01057d1:	68 d0 43 12 f0       	push   $0xf01243d0
f01057d6:	e8 91 b7 ff ff       	call   f0100f6c <cprintf>
f01057db:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f01057de:	83 ec 0c             	sub    $0xc,%esp
f01057e1:	ff 75 f4             	pushl  -0xc(%ebp)
f01057e4:	e8 73 f9 ff ff       	call   f010515c <sched_remove_new>
f01057e9:	83 c4 10             	add    $0x10,%esp
				found = 1;
f01057ec:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f01057f3:	eb 2f                	jmp    f0105824 <sched_kill_env+0xa3>
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01057f5:	a1 d8 24 55 f0       	mov    0xf05524d8,%eax
f01057fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01057fd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105801:	74 08                	je     f010580b <sched_kill_env+0x8a>
f0105803:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105806:	8b 40 08             	mov    0x8(%eax),%eax
f0105809:	eb 05                	jmp    f0105810 <sched_kill_env+0x8f>
f010580b:	b8 00 00 00 00       	mov    $0x0,%eax
f0105810:	a3 d8 24 55 f0       	mov    %eax,0xf05524d8
f0105815:	a1 d8 24 55 f0       	mov    0xf05524d8,%eax
f010581a:	85 c0                	test   %eax,%eax
f010581c:	75 97                	jne    f01057b5 <sched_kill_env+0x34>
f010581e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105822:	75 91                	jne    f01057b5 <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0105824:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105828:	0f 85 a7 01 00 00    	jne    f01059d5 <sched_kill_env+0x254>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010582e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105835:	e9 87 01 00 00       	jmp    f01059c1 <sched_kill_env+0x240>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f010583a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010583d:	83 c0 09             	add    $0x9,%eax
f0105840:	c1 e0 04             	shl    $0x4,%eax
f0105843:	05 60 24 55 f0       	add    $0xf0552460,%eax
f0105848:	8b 00                	mov    (%eax),%eax
f010584a:	85 c0                	test   %eax,%eax
f010584c:	0f 84 66 01 00 00    	je     f01059b8 <sched_kill_env+0x237>
			{
				ptr_env=NULL;
f0105852:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105859:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010585c:	83 c0 09             	add    $0x9,%eax
f010585f:	c1 e0 04             	shl    $0x4,%eax
f0105862:	05 60 24 55 f0       	add    $0xf0552460,%eax
f0105867:	8b 00                	mov    (%eax),%eax
f0105869:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010586c:	e9 01 01 00 00       	jmp    f0105972 <sched_kill_env+0x1f1>
				{
					if(ptr_env->env_id == envId)
f0105871:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105874:	8b 40 10             	mov    0x10(%eax),%eax
f0105877:	3b 45 08             	cmp    0x8(%ebp),%eax
f010587a:	0f 85 df 00 00 00    	jne    f010595f <sched_kill_env+0x1de>
					{
						cprintf("killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0105880:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105883:	8d 50 20             	lea    0x20(%eax),%edx
f0105886:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105889:	8b 40 10             	mov    0x10(%eax),%eax
f010588c:	ff 75 ec             	pushl  -0x14(%ebp)
f010588f:	52                   	push   %edx
f0105890:	50                   	push   %eax
f0105891:	68 f8 43 12 f0       	push   $0xf01243f8
f0105896:	e8 d1 b6 ff ff       	call   f0100f6c <cprintf>
f010589b:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010589e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01058a2:	75 17                	jne    f01058bb <sched_kill_env+0x13a>
f01058a4:	83 ec 04             	sub    $0x4,%esp
f01058a7:	68 c3 42 12 f0       	push   $0xf01242c3
f01058ac:	68 91 01 00 00       	push   $0x191
f01058b1:	68 87 42 12 f0       	push   $0xf0124287
f01058b6:	e8 5f aa ff ff       	call   f010031a <_panic>
f01058bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058be:	8b 40 08             	mov    0x8(%eax),%eax
f01058c1:	85 c0                	test   %eax,%eax
f01058c3:	74 11                	je     f01058d6 <sched_kill_env+0x155>
f01058c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058c8:	8b 40 08             	mov    0x8(%eax),%eax
f01058cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01058ce:	8b 52 0c             	mov    0xc(%edx),%edx
f01058d1:	89 50 0c             	mov    %edx,0xc(%eax)
f01058d4:	eb 17                	jmp    f01058ed <sched_kill_env+0x16c>
f01058d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058d9:	8b 40 0c             	mov    0xc(%eax),%eax
f01058dc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01058df:	83 c2 09             	add    $0x9,%edx
f01058e2:	c1 e2 04             	shl    $0x4,%edx
f01058e5:	81 c2 64 24 55 f0    	add    $0xf0552464,%edx
f01058eb:	89 02                	mov    %eax,(%edx)
f01058ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058f0:	8b 40 0c             	mov    0xc(%eax),%eax
f01058f3:	85 c0                	test   %eax,%eax
f01058f5:	74 11                	je     f0105908 <sched_kill_env+0x187>
f01058f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058fa:	8b 40 0c             	mov    0xc(%eax),%eax
f01058fd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105900:	8b 52 08             	mov    0x8(%edx),%edx
f0105903:	89 50 08             	mov    %edx,0x8(%eax)
f0105906:	eb 17                	jmp    f010591f <sched_kill_env+0x19e>
f0105908:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010590b:	8b 40 08             	mov    0x8(%eax),%eax
f010590e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105911:	83 c2 09             	add    $0x9,%edx
f0105914:	c1 e2 04             	shl    $0x4,%edx
f0105917:	81 c2 60 24 55 f0    	add    $0xf0552460,%edx
f010591d:	89 02                	mov    %eax,(%edx)
f010591f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105922:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105929:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010592c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105933:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105936:	83 c0 09             	add    $0x9,%eax
f0105939:	c1 e0 04             	shl    $0x4,%eax
f010593c:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f0105941:	8b 00                	mov    (%eax),%eax
f0105943:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105946:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105949:	83 c0 09             	add    $0x9,%eax
f010594c:	c1 e0 04             	shl    $0x4,%eax
f010594f:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f0105954:	89 10                	mov    %edx,(%eax)
						found = 1;
f0105956:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f010595d:	eb 59                	jmp    f01059b8 <sched_kill_env+0x237>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010595f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105962:	83 c0 09             	add    $0x9,%eax
f0105965:	c1 e0 04             	shl    $0x4,%eax
f0105968:	05 68 24 55 f0       	add    $0xf0552468,%eax
f010596d:	8b 00                	mov    (%eax),%eax
f010596f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105972:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105976:	74 08                	je     f0105980 <sched_kill_env+0x1ff>
f0105978:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010597b:	8b 40 08             	mov    0x8(%eax),%eax
f010597e:	eb 05                	jmp    f0105985 <sched_kill_env+0x204>
f0105980:	b8 00 00 00 00       	mov    $0x0,%eax
f0105985:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105988:	83 c2 09             	add    $0x9,%edx
f010598b:	c1 e2 04             	shl    $0x4,%edx
f010598e:	81 c2 68 24 55 f0    	add    $0xf0552468,%edx
f0105994:	89 02                	mov    %eax,(%edx)
f0105996:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105999:	83 c0 09             	add    $0x9,%eax
f010599c:	c1 e0 04             	shl    $0x4,%eax
f010599f:	05 68 24 55 f0       	add    $0xf0552468,%eax
f01059a4:	8b 00                	mov    (%eax),%eax
f01059a6:	85 c0                	test   %eax,%eax
f01059a8:	0f 85 c3 fe ff ff    	jne    f0105871 <sched_kill_env+0xf0>
f01059ae:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01059b2:	0f 85 b9 fe ff ff    	jne    f0105871 <sched_kill_env+0xf0>
						found = 1;
						break;
					}
				}
			}
			if (found)
f01059b8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01059bc:	75 16                	jne    f01059d4 <sched_kill_env+0x253>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01059be:	ff 45 ec             	incl   -0x14(%ebp)
f01059c1:	a0 60 51 55 f0       	mov    0xf0555160,%al
f01059c6:	0f b6 c0             	movzbl %al,%eax
f01059c9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01059cc:	0f 8f 68 fe ff ff    	jg     f010583a <sched_kill_env+0xb9>
f01059d2:	eb 01                	jmp    f01059d5 <sched_kill_env+0x254>
						break;
					}
				}
			}
			if (found)
				break;
f01059d4:	90                   	nop
		}
	}
	if (!found)
f01059d5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01059d9:	0f 85 80 00 00 00    	jne    f0105a5f <sched_kill_env+0x2de>
	{
		ptr_env=NULL;
f01059df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f01059e6:	a1 e0 24 55 f0       	mov    0xf05524e0,%eax
f01059eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01059ee:	eb 48                	jmp    f0105a38 <sched_kill_env+0x2b7>
		{
			if(ptr_env->env_id == envId)
f01059f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059f3:	8b 40 10             	mov    0x10(%eax),%eax
f01059f6:	3b 45 08             	cmp    0x8(%ebp),%eax
f01059f9:	75 35                	jne    f0105a30 <sched_kill_env+0x2af>
			{
				cprintf("killing[%d] %s from the EXIT queue...", ptr_env->env_id, ptr_env->prog_name);
f01059fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059fe:	8d 50 20             	lea    0x20(%eax),%edx
f0105a01:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a04:	8b 40 10             	mov    0x10(%eax),%eax
f0105a07:	83 ec 04             	sub    $0x4,%esp
f0105a0a:	52                   	push   %edx
f0105a0b:	50                   	push   %eax
f0105a0c:	68 24 44 12 f0       	push   $0xf0124424
f0105a11:	e8 56 b5 ff ff       	call   f0100f6c <cprintf>
f0105a16:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0105a19:	83 ec 0c             	sub    $0xc,%esp
f0105a1c:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a1f:	e8 af f8 ff ff       	call   f01052d3 <sched_remove_exit>
f0105a24:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105a27:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105a2e:	eb 2f                	jmp    f0105a5f <sched_kill_env+0x2de>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105a30:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f0105a35:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105a38:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105a3c:	74 08                	je     f0105a46 <sched_kill_env+0x2c5>
f0105a3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a41:	8b 40 08             	mov    0x8(%eax),%eax
f0105a44:	eb 05                	jmp    f0105a4b <sched_kill_env+0x2ca>
f0105a46:	b8 00 00 00 00       	mov    $0x0,%eax
f0105a4b:	a3 e8 24 55 f0       	mov    %eax,0xf05524e8
f0105a50:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f0105a55:	85 c0                	test   %eax,%eax
f0105a57:	75 97                	jne    f01059f0 <sched_kill_env+0x26f>
f0105a59:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105a5d:	75 91                	jne    f01059f0 <sched_kill_env+0x26f>
				found = 1;
				break;
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105a5f:	83 ec 0c             	sub    $0xc,%esp
f0105a62:	68 60 24 55 f0       	push   $0xf0552460
f0105a67:	e8 b9 8d 00 00       	call   f010e825 <release_spinlock>
f0105a6c:	83 c4 10             	add    $0x10,%esp

	if (found)
f0105a6f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a73:	74 23                	je     f0105a98 <sched_kill_env+0x317>
	{
		env_free(ptr_env);
f0105a75:	83 ec 0c             	sub    $0xc,%esp
f0105a78:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a7b:	e8 c6 49 00 00       	call   f010a446 <env_free>
f0105a80:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0105a83:	83 ec 0c             	sub    $0xc,%esp
f0105a86:	68 4a 44 12 f0       	push   $0xf012444a
f0105a8b:	e8 dc b4 ff ff       	call   f0100f6c <cprintf>
f0105a90:	83 c4 10             	add    $0x10,%esp
			//fos_scheduler();
			sched();
		}
	}

}
f0105a93:	e9 a4 00 00 00       	jmp    f0105b3c <sched_kill_env+0x3bb>
		env_free(ptr_env);
		cprintf("DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0105a98:	e8 f1 49 00 00       	call   f010a48e <get_cpu_proc>
f0105a9d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0105aa0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105aa4:	75 19                	jne    f0105abf <sched_kill_env+0x33e>
f0105aa6:	68 bf 43 12 f0       	push   $0xf01243bf
f0105aab:	68 72 42 12 f0       	push   $0xf0124272
f0105ab0:	68 b3 01 00 00       	push   $0x1b3
f0105ab5:	68 87 42 12 f0       	push   $0xf0124287
f0105aba:	e8 5b a8 ff ff       	call   f010031a <_panic>

		if (cur_env->env_id == envId)
f0105abf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105ac2:	8b 40 10             	mov    0x10(%eax),%eax
f0105ac5:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105ac8:	75 72                	jne    f0105b3c <sched_kill_env+0x3bb>
		{
			ptr_env = cur_env;
f0105aca:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105acd:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0105ad0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ad3:	8b 40 18             	mov    0x18(%eax),%eax
f0105ad6:	83 f8 02             	cmp    $0x2,%eax
f0105ad9:	74 19                	je     f0105af4 <sched_kill_env+0x373>
f0105adb:	68 50 44 12 f0       	push   $0xf0124450
f0105ae0:	68 72 42 12 f0       	push   $0xf0124272
f0105ae5:	68 b8 01 00 00       	push   $0x1b8
f0105aea:	68 87 42 12 f0       	push   $0xf0124287
f0105aef:	e8 26 a8 ff ff       	call   f010031a <_panic>
			cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0105af4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105af7:	8d 50 20             	lea    0x20(%eax),%edx
f0105afa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105afd:	8b 40 10             	mov    0x10(%eax),%eax
f0105b00:	83 ec 04             	sub    $0x4,%esp
f0105b03:	52                   	push   %edx
f0105b04:	50                   	push   %eax
f0105b05:	68 74 44 12 f0       	push   $0xf0124474
f0105b0a:	e8 5d b4 ff ff       	call   f0100f6c <cprintf>
f0105b0f:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0105b12:	83 ec 0c             	sub    $0xc,%esp
f0105b15:	ff 75 f4             	pushl  -0xc(%ebp)
f0105b18:	e8 29 49 00 00       	call   f010a446 <env_free>
f0105b1d:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0105b20:	83 ec 0c             	sub    $0xc,%esp
f0105b23:	68 4a 44 12 f0       	push   $0xf012444a
f0105b28:	e8 3f b4 ff ff       	call   f0100f6c <cprintf>
f0105b2d:	83 c4 10             	add    $0x10,%esp
			found = 1;
f0105b30:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			sched();
f0105b37:	e8 df 4a 00 00       	call   f010a61b <sched>
		}
	}

}
f0105b3c:	90                   	nop
f0105b3d:	c9                   	leave  
f0105b3e:	c3                   	ret    

f0105b3f <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f0105b3f:	55                   	push   %ebp
f0105b40:	89 e5                	mov    %esp,%ebp
f0105b42:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105b45:	83 ec 0c             	sub    $0xc,%esp
f0105b48:	68 60 24 55 f0       	push   $0xf0552460
f0105b4d:	e8 4c 8c 00 00       	call   f010e79e <acquire_spinlock>
f0105b52:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0105b55:	a1 d0 24 55 f0       	mov    0xf05524d0,%eax
f0105b5a:	85 c0                	test   %eax,%eax
f0105b5c:	74 69                	je     f0105bc7 <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f0105b5e:	83 ec 0c             	sub    $0xc,%esp
f0105b61:	68 a0 44 12 f0       	push   $0xf01244a0
f0105b66:	e8 01 b4 ff ff       	call   f0100f6c <cprintf>
f0105b6b:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105b6e:	a1 d0 24 55 f0       	mov    0xf05524d0,%eax
f0105b73:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b76:	eb 26                	jmp    f0105b9e <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105b78:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b7b:	8d 50 20             	lea    0x20(%eax),%edx
f0105b7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b81:	8b 40 10             	mov    0x10(%eax),%eax
f0105b84:	83 ec 04             	sub    $0x4,%esp
f0105b87:	52                   	push   %edx
f0105b88:	50                   	push   %eax
f0105b89:	68 c2 44 12 f0       	push   $0xf01244c2
f0105b8e:	e8 d9 b3 ff ff       	call   f0100f6c <cprintf>
f0105b93:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105b96:	a1 d8 24 55 f0       	mov    0xf05524d8,%eax
f0105b9b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b9e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ba2:	74 08                	je     f0105bac <sched_print_all+0x6d>
f0105ba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ba7:	8b 40 08             	mov    0x8(%eax),%eax
f0105baa:	eb 05                	jmp    f0105bb1 <sched_print_all+0x72>
f0105bac:	b8 00 00 00 00       	mov    $0x0,%eax
f0105bb1:	a3 d8 24 55 f0       	mov    %eax,0xf05524d8
f0105bb6:	a1 d8 24 55 f0       	mov    0xf05524d8,%eax
f0105bbb:	85 c0                	test   %eax,%eax
f0105bbd:	75 b9                	jne    f0105b78 <sched_print_all+0x39>
f0105bbf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105bc3:	75 b3                	jne    f0105b78 <sched_print_all+0x39>
f0105bc5:	eb 10                	jmp    f0105bd7 <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0105bc7:	83 ec 0c             	sub    $0xc,%esp
f0105bca:	68 cc 44 12 f0       	push   $0xf01244cc
f0105bcf:	e8 98 b3 ff ff       	call   f0100f6c <cprintf>
f0105bd4:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0105bd7:	83 ec 0c             	sub    $0xc,%esp
f0105bda:	68 e8 44 12 f0       	push   $0xf01244e8
f0105bdf:	e8 88 b3 ff ff       	call   f0100f6c <cprintf>
f0105be4:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105be7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0105bee:	e9 d7 00 00 00       	jmp    f0105cca <sched_print_all+0x18b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105bf3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105bf6:	83 c0 09             	add    $0x9,%eax
f0105bf9:	c1 e0 04             	shl    $0x4,%eax
f0105bfc:	05 60 24 55 f0       	add    $0xf0552460,%eax
f0105c01:	8b 00                	mov    (%eax),%eax
f0105c03:	85 c0                	test   %eax,%eax
f0105c05:	0f 84 99 00 00 00    	je     f0105ca4 <sched_print_all+0x165>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f0105c0b:	83 ec 08             	sub    $0x8,%esp
f0105c0e:	ff 75 f0             	pushl  -0x10(%ebp)
f0105c11:	68 1c 45 12 f0       	push   $0xf012451c
f0105c16:	e8 51 b3 ff ff       	call   f0100f6c <cprintf>
f0105c1b:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105c1e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105c21:	83 c0 09             	add    $0x9,%eax
f0105c24:	c1 e0 04             	shl    $0x4,%eax
f0105c27:	05 60 24 55 f0       	add    $0xf0552460,%eax
f0105c2c:	8b 00                	mov    (%eax),%eax
f0105c2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105c31:	eb 31                	jmp    f0105c64 <sched_print_all+0x125>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105c33:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c36:	8d 50 20             	lea    0x20(%eax),%edx
f0105c39:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c3c:	8b 40 10             	mov    0x10(%eax),%eax
f0105c3f:	83 ec 04             	sub    $0x4,%esp
f0105c42:	52                   	push   %edx
f0105c43:	50                   	push   %eax
f0105c44:	68 c2 44 12 f0       	push   $0xf01244c2
f0105c49:	e8 1e b3 ff ff       	call   f0100f6c <cprintf>
f0105c4e:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105c51:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105c54:	83 c0 09             	add    $0x9,%eax
f0105c57:	c1 e0 04             	shl    $0x4,%eax
f0105c5a:	05 68 24 55 f0       	add    $0xf0552468,%eax
f0105c5f:	8b 00                	mov    (%eax),%eax
f0105c61:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105c64:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105c68:	74 08                	je     f0105c72 <sched_print_all+0x133>
f0105c6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c6d:	8b 40 08             	mov    0x8(%eax),%eax
f0105c70:	eb 05                	jmp    f0105c77 <sched_print_all+0x138>
f0105c72:	b8 00 00 00 00       	mov    $0x0,%eax
f0105c77:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105c7a:	83 c2 09             	add    $0x9,%edx
f0105c7d:	c1 e2 04             	shl    $0x4,%edx
f0105c80:	81 c2 68 24 55 f0    	add    $0xf0552468,%edx
f0105c86:	89 02                	mov    %eax,(%edx)
f0105c88:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105c8b:	83 c0 09             	add    $0x9,%eax
f0105c8e:	c1 e0 04             	shl    $0x4,%eax
f0105c91:	05 68 24 55 f0       	add    $0xf0552468,%eax
f0105c96:	8b 00                	mov    (%eax),%eax
f0105c98:	85 c0                	test   %eax,%eax
f0105c9a:	75 97                	jne    f0105c33 <sched_print_all+0xf4>
f0105c9c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ca0:	75 91                	jne    f0105c33 <sched_print_all+0xf4>
f0105ca2:	eb 13                	jmp    f0105cb7 <sched_print_all+0x178>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0105ca4:	83 ec 08             	sub    $0x8,%esp
f0105ca7:	ff 75 f0             	pushl  -0x10(%ebp)
f0105caa:	68 44 45 12 f0       	push   $0xf0124544
f0105caf:	e8 b8 b2 ff ff       	call   f0100f6c <cprintf>
f0105cb4:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0105cb7:	83 ec 0c             	sub    $0xc,%esp
f0105cba:	68 e8 44 12 f0       	push   $0xf01244e8
f0105cbf:	e8 a8 b2 ff ff       	call   f0100f6c <cprintf>
f0105cc4:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105cc7:	ff 45 f0             	incl   -0x10(%ebp)
f0105cca:	a0 60 51 55 f0       	mov    0xf0555160,%al
f0105ccf:	0f b6 c0             	movzbl %al,%eax
f0105cd2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0105cd5:	0f 8f 18 ff ff ff    	jg     f0105bf3 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0105cdb:	a1 e0 24 55 f0       	mov    0xf05524e0,%eax
f0105ce0:	85 c0                	test   %eax,%eax
f0105ce2:	74 69                	je     f0105d4d <sched_print_all+0x20e>
	{
		cprintf("The processes in EXIT queue are:\n");
f0105ce4:	83 ec 0c             	sub    $0xc,%esp
f0105ce7:	68 68 45 12 f0       	push   $0xf0124568
f0105cec:	e8 7b b2 ff ff       	call   f0100f6c <cprintf>
f0105cf1:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105cf4:	a1 e0 24 55 f0       	mov    0xf05524e0,%eax
f0105cf9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105cfc:	eb 26                	jmp    f0105d24 <sched_print_all+0x1e5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105cfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d01:	8d 50 20             	lea    0x20(%eax),%edx
f0105d04:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d07:	8b 40 10             	mov    0x10(%eax),%eax
f0105d0a:	83 ec 04             	sub    $0x4,%esp
f0105d0d:	52                   	push   %edx
f0105d0e:	50                   	push   %eax
f0105d0f:	68 c2 44 12 f0       	push   $0xf01244c2
f0105d14:	e8 53 b2 ff ff       	call   f0100f6c <cprintf>
f0105d19:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105d1c:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f0105d21:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d24:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d28:	74 08                	je     f0105d32 <sched_print_all+0x1f3>
f0105d2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d2d:	8b 40 08             	mov    0x8(%eax),%eax
f0105d30:	eb 05                	jmp    f0105d37 <sched_print_all+0x1f8>
f0105d32:	b8 00 00 00 00       	mov    $0x0,%eax
f0105d37:	a3 e8 24 55 f0       	mov    %eax,0xf05524e8
f0105d3c:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f0105d41:	85 c0                	test   %eax,%eax
f0105d43:	75 b9                	jne    f0105cfe <sched_print_all+0x1bf>
f0105d45:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d49:	75 b3                	jne    f0105cfe <sched_print_all+0x1bf>
f0105d4b:	eb 10                	jmp    f0105d5d <sched_print_all+0x21e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0105d4d:	83 ec 0c             	sub    $0xc,%esp
f0105d50:	68 8a 45 12 f0       	push   $0xf012458a
f0105d55:	e8 12 b2 ff ff       	call   f0100f6c <cprintf>
f0105d5a:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105d5d:	83 ec 0c             	sub    $0xc,%esp
f0105d60:	68 60 24 55 f0       	push   $0xf0552460
f0105d65:	e8 bb 8a 00 00       	call   f010e825 <release_spinlock>
f0105d6a:	83 c4 10             	add    $0x10,%esp
}
f0105d6d:	90                   	nop
f0105d6e:	c9                   	leave  
f0105d6f:	c3                   	ret    

f0105d70 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f0105d70:	55                   	push   %ebp
f0105d71:	89 e5                	mov    %esp,%ebp
f0105d73:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105d76:	83 ec 0c             	sub    $0xc,%esp
f0105d79:	68 60 24 55 f0       	push   $0xf0552460
f0105d7e:	e8 1b 8a 00 00       	call   f010e79e <acquire_spinlock>
f0105d83:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105d86:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f0105d8d:	a1 dc 24 55 f0       	mov    0xf05524dc,%eax
f0105d92:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f0105d95:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0105d9c:	eb 24                	jmp    f0105dc2 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f0105d9e:	83 ec 0c             	sub    $0xc,%esp
f0105da1:	68 d0 24 55 f0       	push   $0xf05524d0
f0105da6:	e8 7c ef ff ff       	call   f0104d27 <dequeue>
f0105dab:	83 c4 10             	add    $0x10,%esp
f0105dae:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(ptr_env);
f0105db1:	83 ec 0c             	sub    $0xc,%esp
f0105db4:	ff 75 f0             	pushl  -0x10(%ebp)
f0105db7:	e8 4f f1 ff ff       	call   f0104f0b <sched_insert_ready0>
f0105dbc:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f0105dbf:	ff 45 f4             	incl   -0xc(%ebp)
f0105dc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105dc5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105dc8:	7c d4                	jl     f0105d9e <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready0(ptr_env);
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105dca:	83 ec 0c             	sub    $0xc,%esp
f0105dcd:	68 60 24 55 f0       	push   $0xf0552460
f0105dd2:	e8 4e 8a 00 00       	call   f010e825 <release_spinlock>
f0105dd7:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f0105dda:	e8 3c 10 00 00       	call   f0106e1b <mycpu>
f0105ddf:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0105de5:	85 c0                	test   %eax,%eax
f0105de7:	75 05                	jne    f0105dee <sched_run_all+0x7e>
		fos_scheduler();
f0105de9:	e8 e2 06 00 00       	call   f01064d0 <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f0105dee:	83 ec 04             	sub    $0x4,%esp
f0105df1:	68 a8 45 12 f0       	push   $0xf01245a8
f0105df6:	68 15 02 00 00       	push   $0x215
f0105dfb:	68 87 42 12 f0       	push   $0xf0124287
f0105e00:	e8 15 a5 ff ff       	call   f010031a <_panic>

f0105e05 <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f0105e05:	55                   	push   %ebp
f0105e06:	89 e5                	mov    %esp,%ebp
f0105e08:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105e0b:	83 ec 0c             	sub    $0xc,%esp
f0105e0e:	68 60 24 55 f0       	push   $0xf0552460
f0105e13:	e8 86 89 00 00       	call   f010e79e <acquire_spinlock>
f0105e18:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0105e1b:	a1 d0 24 55 f0       	mov    0xf05524d0,%eax
f0105e20:	85 c0                	test   %eax,%eax
f0105e22:	0f 84 95 00 00 00    	je     f0105ebd <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f0105e28:	83 ec 0c             	sub    $0xc,%esp
f0105e2b:	68 e4 45 12 f0       	push   $0xf01245e4
f0105e30:	e8 37 b1 ff ff       	call   f0100f6c <cprintf>
f0105e35:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105e38:	a1 d0 24 55 f0       	mov    0xf05524d0,%eax
f0105e3d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e40:	eb 52                	jmp    f0105e94 <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0105e42:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e45:	8d 50 20             	lea    0x20(%eax),%edx
f0105e48:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e4b:	8b 40 10             	mov    0x10(%eax),%eax
f0105e4e:	83 ec 04             	sub    $0x4,%esp
f0105e51:	52                   	push   %edx
f0105e52:	50                   	push   %eax
f0105e53:	68 10 46 12 f0       	push   $0xf0124610
f0105e58:	e8 0f b1 ff ff       	call   f0100f6c <cprintf>
f0105e5d:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f0105e60:	83 ec 0c             	sub    $0xc,%esp
f0105e63:	ff 75 f4             	pushl  -0xc(%ebp)
f0105e66:	e8 f1 f2 ff ff       	call   f010515c <sched_remove_new>
f0105e6b:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0105e6e:	83 ec 0c             	sub    $0xc,%esp
f0105e71:	ff 75 f4             	pushl  -0xc(%ebp)
f0105e74:	e8 cd 45 00 00       	call   f010a446 <env_free>
f0105e79:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0105e7c:	83 ec 0c             	sub    $0xc,%esp
f0105e7f:	68 4a 44 12 f0       	push   $0xf012444a
f0105e84:	e8 e3 b0 ff ff       	call   f0100f6c <cprintf>
f0105e89:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105e8c:	a1 d8 24 55 f0       	mov    0xf05524d8,%eax
f0105e91:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e94:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105e98:	74 08                	je     f0105ea2 <sched_kill_all+0x9d>
f0105e9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e9d:	8b 40 08             	mov    0x8(%eax),%eax
f0105ea0:	eb 05                	jmp    f0105ea7 <sched_kill_all+0xa2>
f0105ea2:	b8 00 00 00 00       	mov    $0x0,%eax
f0105ea7:	a3 d8 24 55 f0       	mov    %eax,0xf05524d8
f0105eac:	a1 d8 24 55 f0       	mov    0xf05524d8,%eax
f0105eb1:	85 c0                	test   %eax,%eax
f0105eb3:	75 8d                	jne    f0105e42 <sched_kill_all+0x3d>
f0105eb5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105eb9:	75 87                	jne    f0105e42 <sched_kill_all+0x3d>
f0105ebb:	eb 10                	jmp    f0105ecd <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f0105ebd:	83 ec 0c             	sub    $0xc,%esp
f0105ec0:	68 23 46 12 f0       	push   $0xf0124623
f0105ec5:	e8 a2 b0 ff ff       	call   f0100f6c <cprintf>
f0105eca:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0105ecd:	83 ec 0c             	sub    $0xc,%esp
f0105ed0:	68 e8 44 12 f0       	push   $0xf01244e8
f0105ed5:	e8 92 b0 ff ff       	call   f0100f6c <cprintf>
f0105eda:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105edd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0105ee4:	e9 b8 01 00 00       	jmp    f01060a1 <sched_kill_all+0x29c>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105ee9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105eec:	83 c0 09             	add    $0x9,%eax
f0105eef:	c1 e0 04             	shl    $0x4,%eax
f0105ef2:	05 60 24 55 f0       	add    $0xf0552460,%eax
f0105ef7:	8b 00                	mov    (%eax),%eax
f0105ef9:	85 c0                	test   %eax,%eax
f0105efb:	0f 84 7a 01 00 00    	je     f010607b <sched_kill_all+0x276>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f0105f01:	83 ec 08             	sub    $0x8,%esp
f0105f04:	ff 75 f0             	pushl  -0x10(%ebp)
f0105f07:	68 40 46 12 f0       	push   $0xf0124640
f0105f0c:	e8 5b b0 ff ff       	call   f0100f6c <cprintf>
f0105f11:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f14:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105f17:	83 c0 09             	add    $0x9,%eax
f0105f1a:	c1 e0 04             	shl    $0x4,%eax
f0105f1d:	05 60 24 55 f0       	add    $0xf0552460,%eax
f0105f22:	8b 00                	mov    (%eax),%eax
f0105f24:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f27:	e9 07 01 00 00       	jmp    f0106033 <sched_kill_all+0x22e>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0105f2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f2f:	8d 50 20             	lea    0x20(%eax),%edx
f0105f32:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f35:	8b 40 10             	mov    0x10(%eax),%eax
f0105f38:	83 ec 04             	sub    $0x4,%esp
f0105f3b:	52                   	push   %edx
f0105f3c:	50                   	push   %eax
f0105f3d:	68 10 46 12 f0       	push   $0xf0124610
f0105f42:	e8 25 b0 ff ff       	call   f0100f6c <cprintf>
f0105f47:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105f4a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f4e:	75 17                	jne    f0105f67 <sched_kill_all+0x162>
f0105f50:	83 ec 04             	sub    $0x4,%esp
f0105f53:	68 c3 42 12 f0       	push   $0xf01242c3
f0105f58:	68 37 02 00 00       	push   $0x237
f0105f5d:	68 87 42 12 f0       	push   $0xf0124287
f0105f62:	e8 b3 a3 ff ff       	call   f010031a <_panic>
f0105f67:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f6a:	8b 40 08             	mov    0x8(%eax),%eax
f0105f6d:	85 c0                	test   %eax,%eax
f0105f6f:	74 11                	je     f0105f82 <sched_kill_all+0x17d>
f0105f71:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f74:	8b 40 08             	mov    0x8(%eax),%eax
f0105f77:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105f7a:	8b 52 0c             	mov    0xc(%edx),%edx
f0105f7d:	89 50 0c             	mov    %edx,0xc(%eax)
f0105f80:	eb 17                	jmp    f0105f99 <sched_kill_all+0x194>
f0105f82:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f85:	8b 40 0c             	mov    0xc(%eax),%eax
f0105f88:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f8b:	83 c2 09             	add    $0x9,%edx
f0105f8e:	c1 e2 04             	shl    $0x4,%edx
f0105f91:	81 c2 64 24 55 f0    	add    $0xf0552464,%edx
f0105f97:	89 02                	mov    %eax,(%edx)
f0105f99:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f9c:	8b 40 0c             	mov    0xc(%eax),%eax
f0105f9f:	85 c0                	test   %eax,%eax
f0105fa1:	74 11                	je     f0105fb4 <sched_kill_all+0x1af>
f0105fa3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fa6:	8b 40 0c             	mov    0xc(%eax),%eax
f0105fa9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105fac:	8b 52 08             	mov    0x8(%edx),%edx
f0105faf:	89 50 08             	mov    %edx,0x8(%eax)
f0105fb2:	eb 17                	jmp    f0105fcb <sched_kill_all+0x1c6>
f0105fb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fb7:	8b 40 08             	mov    0x8(%eax),%eax
f0105fba:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105fbd:	83 c2 09             	add    $0x9,%edx
f0105fc0:	c1 e2 04             	shl    $0x4,%edx
f0105fc3:	81 c2 60 24 55 f0    	add    $0xf0552460,%edx
f0105fc9:	89 02                	mov    %eax,(%edx)
f0105fcb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fce:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105fd5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fd8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105fdf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105fe2:	83 c0 09             	add    $0x9,%eax
f0105fe5:	c1 e0 04             	shl    $0x4,%eax
f0105fe8:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f0105fed:	8b 00                	mov    (%eax),%eax
f0105fef:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105ff2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105ff5:	83 c0 09             	add    $0x9,%eax
f0105ff8:	c1 e0 04             	shl    $0x4,%eax
f0105ffb:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f0106000:	89 10                	mov    %edx,(%eax)
				env_free(ptr_env);
f0106002:	83 ec 0c             	sub    $0xc,%esp
f0106005:	ff 75 f4             	pushl  -0xc(%ebp)
f0106008:	e8 39 44 00 00       	call   f010a446 <env_free>
f010600d:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f0106010:	83 ec 0c             	sub    $0xc,%esp
f0106013:	68 4a 44 12 f0       	push   $0xf012444a
f0106018:	e8 4f af ff ff       	call   f0100f6c <cprintf>
f010601d:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106020:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106023:	83 c0 09             	add    $0x9,%eax
f0106026:	c1 e0 04             	shl    $0x4,%eax
f0106029:	05 68 24 55 f0       	add    $0xf0552468,%eax
f010602e:	8b 00                	mov    (%eax),%eax
f0106030:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106033:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106037:	74 08                	je     f0106041 <sched_kill_all+0x23c>
f0106039:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010603c:	8b 40 08             	mov    0x8(%eax),%eax
f010603f:	eb 05                	jmp    f0106046 <sched_kill_all+0x241>
f0106041:	b8 00 00 00 00       	mov    $0x0,%eax
f0106046:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106049:	83 c2 09             	add    $0x9,%edx
f010604c:	c1 e2 04             	shl    $0x4,%edx
f010604f:	81 c2 68 24 55 f0    	add    $0xf0552468,%edx
f0106055:	89 02                	mov    %eax,(%edx)
f0106057:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010605a:	83 c0 09             	add    $0x9,%eax
f010605d:	c1 e0 04             	shl    $0x4,%eax
f0106060:	05 68 24 55 f0       	add    $0xf0552468,%eax
f0106065:	8b 00                	mov    (%eax),%eax
f0106067:	85 c0                	test   %eax,%eax
f0106069:	0f 85 bd fe ff ff    	jne    f0105f2c <sched_kill_all+0x127>
f010606f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106073:	0f 85 b3 fe ff ff    	jne    f0105f2c <sched_kill_all+0x127>
f0106079:	eb 13                	jmp    f010608e <sched_kill_all+0x289>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f010607b:	83 ec 08             	sub    $0x8,%esp
f010607e:	ff 75 f0             	pushl  -0x10(%ebp)
f0106081:	68 44 45 12 f0       	push   $0xf0124544
f0106086:	e8 e1 ae ff ff       	call   f0100f6c <cprintf>
f010608b:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f010608e:	83 ec 0c             	sub    $0xc,%esp
f0106091:	68 e8 44 12 f0       	push   $0xf01244e8
f0106096:	e8 d1 ae ff ff       	call   f0100f6c <cprintf>
f010609b:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f010609e:	ff 45 f0             	incl   -0x10(%ebp)
f01060a1:	a0 60 51 55 f0       	mov    0xf0555160,%al
f01060a6:	0f b6 c0             	movzbl %al,%eax
f01060a9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01060ac:	0f 8f 37 fe ff ff    	jg     f0105ee9 <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f01060b2:	a1 e0 24 55 f0       	mov    0xf05524e0,%eax
f01060b7:	85 c0                	test   %eax,%eax
f01060b9:	0f 84 95 00 00 00    	je     f0106154 <sched_kill_all+0x34f>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f01060bf:	83 ec 0c             	sub    $0xc,%esp
f01060c2:	68 74 46 12 f0       	push   $0xf0124674
f01060c7:	e8 a0 ae ff ff       	call   f0100f6c <cprintf>
f01060cc:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f01060cf:	a1 e0 24 55 f0       	mov    0xf05524e0,%eax
f01060d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01060d7:	eb 52                	jmp    f010612b <sched_kill_all+0x326>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01060d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060dc:	8d 50 20             	lea    0x20(%eax),%edx
f01060df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060e2:	8b 40 10             	mov    0x10(%eax),%eax
f01060e5:	83 ec 04             	sub    $0x4,%esp
f01060e8:	52                   	push   %edx
f01060e9:	50                   	push   %eax
f01060ea:	68 10 46 12 f0       	push   $0xf0124610
f01060ef:	e8 78 ae ff ff       	call   f0100f6c <cprintf>
f01060f4:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f01060f7:	83 ec 0c             	sub    $0xc,%esp
f01060fa:	ff 75 f4             	pushl  -0xc(%ebp)
f01060fd:	e8 d1 f1 ff ff       	call   f01052d3 <sched_remove_exit>
f0106102:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106105:	83 ec 0c             	sub    $0xc,%esp
f0106108:	ff 75 f4             	pushl  -0xc(%ebp)
f010610b:	e8 36 43 00 00       	call   f010a446 <env_free>
f0106110:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0106113:	83 ec 0c             	sub    $0xc,%esp
f0106116:	68 4a 44 12 f0       	push   $0xf012444a
f010611b:	e8 4c ae ff ff       	call   f0100f6c <cprintf>
f0106120:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106123:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f0106128:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010612b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010612f:	74 08                	je     f0106139 <sched_kill_all+0x334>
f0106131:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106134:	8b 40 08             	mov    0x8(%eax),%eax
f0106137:	eb 05                	jmp    f010613e <sched_kill_all+0x339>
f0106139:	b8 00 00 00 00       	mov    $0x0,%eax
f010613e:	a3 e8 24 55 f0       	mov    %eax,0xf05524e8
f0106143:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f0106148:	85 c0                	test   %eax,%eax
f010614a:	75 8d                	jne    f01060d9 <sched_kill_all+0x2d4>
f010614c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106150:	75 87                	jne    f01060d9 <sched_kill_all+0x2d4>
f0106152:	eb 10                	jmp    f0106164 <sched_kill_all+0x35f>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106154:	83 ec 0c             	sub    $0xc,%esp
f0106157:	68 8a 45 12 f0       	push   $0xf012458a
f010615c:	e8 0b ae ff ff       	call   f0100f6c <cprintf>
f0106161:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f0106164:	e8 25 43 00 00       	call   f010a48e <get_cpu_proc>
f0106169:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f010616c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106170:	74 6b                	je     f01061dd <sched_kill_all+0x3d8>
	{
		ptr_env = cur_env;
f0106172:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106175:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f0106178:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010617b:	8b 40 18             	mov    0x18(%eax),%eax
f010617e:	83 f8 02             	cmp    $0x2,%eax
f0106181:	74 19                	je     f010619c <sched_kill_all+0x397>
f0106183:	68 50 44 12 f0       	push   $0xf0124450
f0106188:	68 72 42 12 f0       	push   $0xf0124272
f010618d:	68 57 02 00 00       	push   $0x257
f0106192:	68 87 42 12 f0       	push   $0xf0124287
f0106197:	e8 7e a1 ff ff       	call   f010031a <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010619c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010619f:	8d 50 20             	lea    0x20(%eax),%edx
f01061a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061a5:	8b 40 10             	mov    0x10(%eax),%eax
f01061a8:	83 ec 04             	sub    $0x4,%esp
f01061ab:	52                   	push   %edx
f01061ac:	50                   	push   %eax
f01061ad:	68 74 44 12 f0       	push   $0xf0124474
f01061b2:	e8 b5 ad ff ff       	call   f0100f6c <cprintf>
f01061b7:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f01061ba:	83 ec 0c             	sub    $0xc,%esp
f01061bd:	ff 75 f4             	pushl  -0xc(%ebp)
f01061c0:	e8 81 42 00 00       	call   f010a446 <env_free>
f01061c5:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f01061c8:	83 ec 0c             	sub    $0xc,%esp
f01061cb:	68 4a 44 12 f0       	push   $0xf012444a
f01061d0:	e8 97 ad ff ff       	call   f0100f6c <cprintf>
f01061d5:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f01061d8:	e8 3e 44 00 00       	call   f010a61b <sched>
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01061dd:	83 ec 0c             	sub    $0xc,%esp
f01061e0:	68 60 24 55 f0       	push   $0xf0552460
f01061e5:	e8 3b 86 00 00       	call   f010e825 <release_spinlock>
f01061ea:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f01061ed:	e8 b1 bb ff ff       	call   f0101da3 <get_into_prompt>

f01061f2 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f01061f2:	55                   	push   %ebp
f01061f3:	89 e5                	mov    %esp,%ebp
f01061f5:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01061f8:	83 ec 0c             	sub    $0xc,%esp
f01061fb:	68 60 24 55 f0       	push   $0xf0552460
f0106200:	e8 99 85 00 00       	call   f010e79e <acquire_spinlock>
f0106205:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0106208:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f010620f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106216:	e9 59 01 00 00       	jmp    f0106374 <sched_exit_all_ready_envs+0x182>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f010621b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010621e:	83 c0 09             	add    $0x9,%eax
f0106221:	c1 e0 04             	shl    $0x4,%eax
f0106224:	05 60 24 55 f0       	add    $0xf0552460,%eax
f0106229:	8b 00                	mov    (%eax),%eax
f010622b:	85 c0                	test   %eax,%eax
f010622d:	0f 84 3e 01 00 00    	je     f0106371 <sched_exit_all_ready_envs+0x17f>
		{
			ptr_env=NULL;
f0106233:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010623a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010623d:	83 c0 09             	add    $0x9,%eax
f0106240:	c1 e0 04             	shl    $0x4,%eax
f0106243:	05 60 24 55 f0       	add    $0xf0552460,%eax
f0106248:	8b 00                	mov    (%eax),%eax
f010624a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010624d:	e9 d9 00 00 00       	jmp    f010632b <sched_exit_all_ready_envs+0x139>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0106252:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106256:	75 17                	jne    f010626f <sched_exit_all_ready_envs+0x7d>
f0106258:	83 ec 04             	sub    $0x4,%esp
f010625b:	68 c3 42 12 f0       	push   $0xf01242c3
f0106260:	68 79 02 00 00       	push   $0x279
f0106265:	68 87 42 12 f0       	push   $0xf0124287
f010626a:	e8 ab a0 ff ff       	call   f010031a <_panic>
f010626f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106272:	8b 40 08             	mov    0x8(%eax),%eax
f0106275:	85 c0                	test   %eax,%eax
f0106277:	74 11                	je     f010628a <sched_exit_all_ready_envs+0x98>
f0106279:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010627c:	8b 40 08             	mov    0x8(%eax),%eax
f010627f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106282:	8b 52 0c             	mov    0xc(%edx),%edx
f0106285:	89 50 0c             	mov    %edx,0xc(%eax)
f0106288:	eb 17                	jmp    f01062a1 <sched_exit_all_ready_envs+0xaf>
f010628a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010628d:	8b 40 0c             	mov    0xc(%eax),%eax
f0106290:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106293:	83 c2 09             	add    $0x9,%edx
f0106296:	c1 e2 04             	shl    $0x4,%edx
f0106299:	81 c2 64 24 55 f0    	add    $0xf0552464,%edx
f010629f:	89 02                	mov    %eax,(%edx)
f01062a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062a4:	8b 40 0c             	mov    0xc(%eax),%eax
f01062a7:	85 c0                	test   %eax,%eax
f01062a9:	74 11                	je     f01062bc <sched_exit_all_ready_envs+0xca>
f01062ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062ae:	8b 40 0c             	mov    0xc(%eax),%eax
f01062b1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01062b4:	8b 52 08             	mov    0x8(%edx),%edx
f01062b7:	89 50 08             	mov    %edx,0x8(%eax)
f01062ba:	eb 17                	jmp    f01062d3 <sched_exit_all_ready_envs+0xe1>
f01062bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062bf:	8b 40 08             	mov    0x8(%eax),%eax
f01062c2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062c5:	83 c2 09             	add    $0x9,%edx
f01062c8:	c1 e2 04             	shl    $0x4,%edx
f01062cb:	81 c2 60 24 55 f0    	add    $0xf0552460,%edx
f01062d1:	89 02                	mov    %eax,(%edx)
f01062d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062d6:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01062dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062e0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01062e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01062ea:	83 c0 09             	add    $0x9,%eax
f01062ed:	c1 e0 04             	shl    $0x4,%eax
f01062f0:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f01062f5:	8b 00                	mov    (%eax),%eax
f01062f7:	8d 50 ff             	lea    -0x1(%eax),%edx
f01062fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01062fd:	83 c0 09             	add    $0x9,%eax
f0106300:	c1 e0 04             	shl    $0x4,%eax
f0106303:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f0106308:	89 10                	mov    %edx,(%eax)
				sched_insert_exit(ptr_env);
f010630a:	83 ec 0c             	sub    $0xc,%esp
f010630d:	ff 75 f4             	pushl  -0xc(%ebp)
f0106310:	e8 37 ef ff ff       	call   f010524c <sched_insert_exit>
f0106315:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106318:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010631b:	83 c0 09             	add    $0x9,%eax
f010631e:	c1 e0 04             	shl    $0x4,%eax
f0106321:	05 68 24 55 f0       	add    $0xf0552468,%eax
f0106326:	8b 00                	mov    (%eax),%eax
f0106328:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010632b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010632f:	74 08                	je     f0106339 <sched_exit_all_ready_envs+0x147>
f0106331:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106334:	8b 40 08             	mov    0x8(%eax),%eax
f0106337:	eb 05                	jmp    f010633e <sched_exit_all_ready_envs+0x14c>
f0106339:	b8 00 00 00 00       	mov    $0x0,%eax
f010633e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106341:	83 c2 09             	add    $0x9,%edx
f0106344:	c1 e2 04             	shl    $0x4,%edx
f0106347:	81 c2 68 24 55 f0    	add    $0xf0552468,%edx
f010634d:	89 02                	mov    %eax,(%edx)
f010634f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106352:	83 c0 09             	add    $0x9,%eax
f0106355:	c1 e0 04             	shl    $0x4,%eax
f0106358:	05 68 24 55 f0       	add    $0xf0552468,%eax
f010635d:	8b 00                	mov    (%eax),%eax
f010635f:	85 c0                	test   %eax,%eax
f0106361:	0f 85 eb fe ff ff    	jne    f0106252 <sched_exit_all_ready_envs+0x60>
f0106367:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010636b:	0f 85 e1 fe ff ff    	jne    f0106252 <sched_exit_all_ready_envs+0x60>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106371:	ff 45 f0             	incl   -0x10(%ebp)
f0106374:	a0 60 51 55 f0       	mov    0xf0555160,%al
f0106379:	0f b6 c0             	movzbl %al,%eax
f010637c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010637f:	0f 8f 96 fe ff ff    	jg     f010621b <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106385:	83 ec 0c             	sub    $0xc,%esp
f0106388:	68 60 24 55 f0       	push   $0xf0552460
f010638d:	e8 93 84 00 00       	call   f010e825 <release_spinlock>
f0106392:	83 c4 10             	add    $0x10,%esp
}
f0106395:	90                   	nop
f0106396:	c9                   	leave  
f0106397:	c3                   	ret    

f0106398 <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f0106398:	55                   	push   %ebp
f0106399:	89 e5                	mov    %esp,%ebp
	return ticks;
f010639b:	a1 c8 50 55 f0       	mov    0xf05550c8,%eax
f01063a0:	8b 15 cc 50 55 f0    	mov    0xf05550cc,%edx
}
f01063a6:	5d                   	pop    %ebp
f01063a7:	c3                   	ret    

f01063a8 <env_get_nice>:
int env_get_nice(struct Env* e)
{
f01063a8:	55                   	push   %ebp
f01063a9:	89 e5                	mov    %esp,%ebp
f01063ab:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01063ae:	83 ec 04             	sub    $0x4,%esp
f01063b1:	68 a0 46 12 f0       	push   $0xf01246a0
f01063b6:	68 8c 02 00 00       	push   $0x28c
f01063bb:	68 87 42 12 f0       	push   $0xf0124287
f01063c0:	e8 55 9f ff ff       	call   f010031a <_panic>

f01063c5 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f01063c5:	55                   	push   %ebp
f01063c6:	89 e5                	mov    %esp,%ebp
f01063c8:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_set_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01063cb:	83 ec 04             	sub    $0x4,%esp
f01063ce:	68 a0 46 12 f0       	push   $0xf01246a0
f01063d3:	68 94 02 00 00       	push   $0x294
f01063d8:	68 87 42 12 f0       	push   $0xf0124287
f01063dd:	e8 38 9f ff ff       	call   f010031a <_panic>

f01063e2 <env_get_recent_cpu>:
}

int env_get_recent_cpu(struct Env* e)
{
f01063e2:	55                   	push   %ebp
f01063e3:	89 e5                	mov    %esp,%ebp
f01063e5:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_recent_cpu
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01063e8:	83 ec 04             	sub    $0x4,%esp
f01063eb:	68 a0 46 12 f0       	push   $0xf01246a0
f01063f0:	68 9c 02 00 00       	push   $0x29c
f01063f5:	68 87 42 12 f0       	push   $0xf0124287
f01063fa:	e8 1b 9f ff ff       	call   f010031a <_panic>

f01063ff <get_load_average>:
}
int get_load_average()
{
f01063ff:	55                   	push   %ebp
f0106400:	89 e5                	mov    %esp,%ebp
f0106402:	83 ec 08             	sub    $0x8,%esp
	//return 1;
	//[PROJECT] BSD Scheduler - get_load_average
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106405:	83 ec 04             	sub    $0x4,%esp
f0106408:	68 a0 46 12 f0       	push   $0xf01246a0
f010640d:	68 a4 02 00 00       	push   $0x2a4
f0106412:	68 87 42 12 f0       	push   $0xf0124287
f0106417:	e8 fe 9e ff ff       	call   f010031a <_panic>

f010641c <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){if(scheduler_method == SCH_RR) return 1; return 0;}
f010641c:	55                   	push   %ebp
f010641d:	89 e5                	mov    %esp,%ebp
f010641f:	a1 14 4f 55 f0       	mov    0xf0554f14,%eax
f0106424:	85 c0                	test   %eax,%eax
f0106426:	75 07                	jne    f010642f <isSchedMethodRR+0x13>
f0106428:	b8 01 00 00 00       	mov    $0x1,%eax
f010642d:	eb 05                	jmp    f0106434 <isSchedMethodRR+0x18>
f010642f:	b8 00 00 00 00       	mov    $0x0,%eax
f0106434:	5d                   	pop    %ebp
f0106435:	c3                   	ret    

f0106436 <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){if(scheduler_method == SCH_MLFQ) return 1; return 0;}
f0106436:	55                   	push   %ebp
f0106437:	89 e5                	mov    %esp,%ebp
f0106439:	a1 14 4f 55 f0       	mov    0xf0554f14,%eax
f010643e:	83 f8 01             	cmp    $0x1,%eax
f0106441:	75 07                	jne    f010644a <isSchedMethodMLFQ+0x14>
f0106443:	b8 01 00 00 00       	mov    $0x1,%eax
f0106448:	eb 05                	jmp    f010644f <isSchedMethodMLFQ+0x19>
f010644a:	b8 00 00 00 00       	mov    $0x0,%eax
f010644f:	5d                   	pop    %ebp
f0106450:	c3                   	ret    

f0106451 <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){if(scheduler_method == SCH_BSD) return 1; return 0;}
f0106451:	55                   	push   %ebp
f0106452:	89 e5                	mov    %esp,%ebp
f0106454:	a1 14 4f 55 f0       	mov    0xf0554f14,%eax
f0106459:	83 f8 02             	cmp    $0x2,%eax
f010645c:	75 07                	jne    f0106465 <isSchedMethodBSD+0x14>
f010645e:	b8 01 00 00 00       	mov    $0x1,%eax
f0106463:	eb 05                	jmp    f010646a <isSchedMethodBSD+0x19>
f0106465:	b8 00 00 00 00       	mov    $0x0,%eax
f010646a:	5d                   	pop    %ebp
f010646b:	c3                   	ret    

f010646c <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f010646c:	55                   	push   %ebp
f010646d:	89 e5                	mov    %esp,%ebp
f010646f:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f0106472:	c7 05 e8 4b 55 f0 00 	movl   $0x0,0xf0554be8
f0106479:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f010647c:	83 ec 0c             	sub    $0xc,%esp
f010647f:	6a 0a                	push   $0xa
f0106481:	e8 6d 02 00 00       	call   f01066f3 <sched_init_RR>
f0106486:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f0106489:	83 ec 0c             	sub    $0xc,%esp
f010648c:	68 d0 24 55 f0       	push   $0xf05524d0
f0106491:	e8 bf e7 ff ff       	call   f0104c55 <init_queue>
f0106496:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f0106499:	83 ec 0c             	sub    $0xc,%esp
f010649c:	68 e0 24 55 f0       	push   $0xf05524e0
f01064a1:	e8 af e7 ff ff       	call   f0104c55 <init_queue>
f01064a6:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f01064a9:	e8 6d 09 00 00       	call   f0106e1b <mycpu>
f01064ae:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f01064b5:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_spinlock(&ProcessQueues.qlock, "process queues lock");
f01064b8:	83 ec 08             	sub    $0x8,%esp
f01064bb:	68 b4 46 12 f0       	push   $0xf01246b4
f01064c0:	68 60 24 55 f0       	push   $0xf0552460
f01064c5:	e8 a3 82 00 00       	call   f010e76d <init_spinlock>
f01064ca:	83 c4 10             	add    $0x10,%esp
}
f01064cd:	90                   	nop
f01064ce:	c9                   	leave  
f01064cf:	c3                   	ret    

f01064d0 <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f01064d0:	55                   	push   %ebp
f01064d1:	89 e5                	mov    %esp,%ebp
f01064d3:	53                   	push   %ebx
f01064d4:	83 ec 24             	sub    $0x24,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01064d7:	9c                   	pushf  
f01064d8:	58                   	pop    %eax
f01064d9:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f01064dc:	8b 45 d8             	mov    -0x28(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f01064df:	25 00 02 00 00       	and    $0x200,%eax
f01064e4:	85 c0                	test   %eax,%eax
f01064e6:	74 14                	je     f01064fc <fos_scheduler+0x2c>
		panic("fos_scheduler: called while the interrupt is enabled!");
f01064e8:	83 ec 04             	sub    $0x4,%esp
f01064eb:	68 c8 46 12 f0       	push   $0xf01246c8
f01064f0:	6a 37                	push   $0x37
f01064f2:	68 fe 46 12 f0       	push   $0xf01246fe
f01064f7:	e8 1e 9e ff ff       	call   f010031a <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f01064fc:	e8 1a 09 00 00       	call   f0106e1b <mycpu>
f0106501:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f0106504:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106507:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f010650e:	00 00 00 

	chk1();
f0106511:	e8 00 92 01 00       	call   f011f716 <chk1>
	c->scheduler_status = SCH_STARTED;
f0106516:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106519:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f0106520:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f0106523:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f010652a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f0106531:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_spinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f0106532:	83 ec 0c             	sub    $0xc,%esp
f0106535:	68 60 24 55 f0       	push   $0xf0552460
f010653a:	e8 5f 82 00 00       	call   f010e79e <acquire_spinlock>
f010653f:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f0106542:	a1 14 4f 55 f0       	mov    0xf0554f14,%eax
f0106547:	8b 04 85 64 99 17 f0 	mov    -0xfe8669c(,%eax,4),%eax
f010654e:	ff d0                	call   *%eax
f0106550:	89 45 e8             	mov    %eax,-0x18(%ebp)

			//temporarily set the curenv by the next env JUST for checking the scheduler
			//Then: reset it again
			struct Env* old_curenv = get_cpu_proc();
f0106553:	e8 36 3f 00 00       	call   f010a48e <get_cpu_proc>
f0106558:	89 45 e0             	mov    %eax,-0x20(%ebp)
			set_cpu_proc(next_env) ;
f010655b:	83 ec 0c             	sub    $0xc,%esp
f010655e:	ff 75 e8             	pushl  -0x18(%ebp)
f0106561:	e8 51 3f 00 00       	call   f010a4b7 <set_cpu_proc>
f0106566:	83 c4 10             	add    $0x10,%esp
			chk2(next_env) ;
f0106569:	83 ec 0c             	sub    $0xc,%esp
f010656c:	ff 75 e8             	pushl  -0x18(%ebp)
f010656f:	e8 a8 91 01 00       	call   f011f71c <chk2>
f0106574:	83 c4 10             	add    $0x10,%esp
			set_cpu_proc(old_curenv) ;
f0106577:	83 ec 0c             	sub    $0xc,%esp
f010657a:	ff 75 e0             	pushl  -0x20(%ebp)
f010657d:	e8 35 3f 00 00       	call   f010a4b7 <set_cpu_proc>
f0106582:	83 c4 10             	add    $0x10,%esp

			//sched_print_all();

			if(next_env != NULL)
f0106585:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106589:	0f 84 d6 00 00 00    	je     f0106665 <fos_scheduler+0x195>
				/*2024: Replaced by context_switch()*/
				//env_run(next_env);

				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f010658f:	83 ec 0c             	sub    $0xc,%esp
f0106592:	ff 75 e8             	pushl  -0x18(%ebp)
f0106595:	e8 1d 3f 00 00       	call   f010a4b7 <set_cpu_proc>
f010659a:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f010659d:	83 ec 0c             	sub    $0xc,%esp
f01065a0:	ff 75 e8             	pushl  -0x18(%ebp)
f01065a3:	e8 96 41 00 00       	call   f010a73e <switchuvm>
f01065a8:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f01065ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01065ae:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f01065b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01065b8:	8b 40 04             	mov    0x4(%eax),%eax
f01065bb:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01065be:	83 c2 04             	add    $0x4,%edx
f01065c1:	83 ec 08             	sub    $0x8,%esp
f01065c4:	50                   	push   %eax
f01065c5:	52                   	push   %edx
f01065c6:	e8 92 e2 ff ff       	call   f010485d <context_switch>
f01065cb:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01065ce:	9c                   	pushf  
f01065cf:	58                   	pop    %eax
f01065d0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f01065d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax

				//ensure that the scheduler is invoked while interrupt is disabled
				if (read_eflags() & FL_IF)
f01065d6:	25 00 02 00 00       	and    $0x200,%eax
f01065db:	85 c0                	test   %eax,%eax
f01065dd:	74 14                	je     f01065f3 <fos_scheduler+0x123>
					panic("fos_scheduler: invoked while the interrupt is enabled!");
f01065df:	83 ec 04             	sub    $0x4,%esp
f01065e2:	68 10 47 12 f0       	push   $0xf0124710
f01065e7:	6a 74                	push   $0x74
f01065e9:	68 fe 46 12 f0       	push   $0xf01246fe
f01065ee:	e8 27 9d ff ff       	call   f010031a <_panic>

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f01065f3:	e8 ae e3 ff ff       	call   f01049a6 <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, curenv == NULL? 0 : curenv->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f01065f8:	e8 91 3e 00 00       	call   f010a48e <get_cpu_proc>
f01065fd:	89 c2                	mov    %eax,%edx
f01065ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106602:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f0106608:	39 c2                	cmp    %eax,%edx
f010660a:	74 16                	je     f0106622 <fos_scheduler+0x152>
f010660c:	68 47 47 12 f0       	push   $0xf0124747
f0106611:	68 61 47 12 f0       	push   $0xf0124761
f0106616:	6a 7d                	push   $0x7d
f0106618:	68 fe 46 12 f0       	push   $0xf01246fe
f010661d:	e8 f8 9c ff ff       	call   f010031a <_panic>
				int status = c->proc->env_status ;
f0106622:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106625:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010662b:	8b 40 18             	mov    0x18(%eax),%eax
f010662e:	89 45 dc             	mov    %eax,-0x24(%ebp)
				assert(status != ENV_RUNNING);
f0106631:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
f0106635:	75 16                	jne    f010664d <fos_scheduler+0x17d>
f0106637:	68 76 47 12 f0       	push   $0xf0124776
f010663c:	68 61 47 12 f0       	push   $0xf0124761
f0106641:	6a 7f                	push   $0x7f
f0106643:	68 fe 46 12 f0       	push   $0xf01246fe
f0106648:	e8 cd 9c ff ff       	call   f010031a <_panic>
				if (status == ENV_READY)
f010664d:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f0106651:	74 12                	je     f0106665 <fos_scheduler+0x195>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f0106653:	e8 cf 40 00 00       	call   f010a727 <switchkvm>
					set_cpu_proc(NULL);
f0106658:	83 ec 0c             	sub    $0xc,%esp
f010665b:	6a 00                	push   $0x0
f010665d:	e8 55 3e 00 00       	call   f010a4b7 <set_cpu_proc>
f0106662:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f0106665:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106669:	0f 85 d3 fe ff ff    	jne    f0106542 <fos_scheduler+0x72>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f010666f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f0106676:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010667d:	eb 4d                	jmp    f01066cc <fos_scheduler+0x1fc>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f010667f:	8b 0d 10 1a 55 f0    	mov    0xf0551a10,%ecx
f0106685:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106688:	89 d0                	mov    %edx,%eax
f010668a:	c1 e0 06             	shl    $0x6,%eax
f010668d:	29 d0                	sub    %edx,%eax
f010668f:	c1 e0 02             	shl    $0x2,%eax
f0106692:	01 d0                	add    %edx,%eax
f0106694:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f010669b:	01 d8                	add    %ebx,%eax
f010669d:	c1 e0 03             	shl    $0x3,%eax
f01066a0:	01 d0                	add    %edx,%eax
f01066a2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01066a9:	29 c2                	sub    %eax,%edx
f01066ab:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f01066b2:	89 c2                	mov    %eax,%edx
f01066b4:	89 d0                	mov    %edx,%eax
f01066b6:	01 c8                	add    %ecx,%eax
f01066b8:	8b 40 18             	mov    0x18(%eax),%eax
f01066bb:	83 f8 03             	cmp    $0x3,%eax
f01066be:	75 09                	jne    f01066c9 <fos_scheduler+0x1f9>
			{
				is_any_blocked = 1;
f01066c0:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f01066c7:	eb 0b                	jmp    f01066d4 <fos_scheduler+0x204>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f01066c9:	ff 45 f0             	incl   -0x10(%ebp)
f01066cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01066cf:	83 f8 07             	cmp    $0x7,%eax
f01066d2:	76 ab                	jbe    f010667f <fos_scheduler+0x1af>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_spinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f01066d4:	83 ec 0c             	sub    $0xc,%esp
f01066d7:	68 60 24 55 f0       	push   $0xf0552460
f01066dc:	e8 44 81 00 00       	call   f010e825 <release_spinlock>
f01066e1:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);

	} while (is_any_blocked > 0);
f01066e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01066e8:	0f 8f 43 fe ff ff    	jg     f0106531 <fos_scheduler+0x61>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f01066ee:	e8 b0 b6 ff ff       	call   f0101da3 <get_into_prompt>

f01066f3 <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f01066f3:	55                   	push   %ebp
f01066f4:	89 e5                	mov    %esp,%ebp
f01066f6:	83 ec 28             	sub    $0x28,%esp
f01066f9:	8b 45 08             	mov    0x8(%ebp),%eax
f01066fc:	88 45 e4             	mov    %al,-0x1c(%ebp)

	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f01066ff:	c6 05 60 51 55 f0 01 	movb   $0x1,0xf0555160
	//cprintf("sizeof(struct Env_Queue) = %x\n", sizeof(struct Env_Queue));
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
	//cprintf("num_of_ready_queues * sizeof(uint8) = %x\n", num_of_ready_queues * sizeof(uint8));

#endif
	quantums[0] = quantum;
f0106706:	8a 45 e4             	mov    -0x1c(%ebp),%al
f0106709:	a2 e4 4d 55 f0       	mov    %al,0xf0554de4
	kclock_set_quantum(quantums[0]);
f010670e:	a0 e4 4d 55 f0       	mov    0xf0554de4,%al
f0106713:	0f b6 c0             	movzbl %al,%eax
f0106716:	83 ec 0c             	sub    $0xc,%esp
f0106719:	50                   	push   %eax
f010671a:	e8 50 e3 ff ff       	call   f0104a6f <kclock_set_quantum>
f010671f:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f0106722:	83 ec 0c             	sub    $0xc,%esp
f0106725:	68 f0 24 55 f0       	push   $0xf05524f0
f010672a:	e8 26 e5 ff ff       	call   f0104c55 <init_queue>
f010672f:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f0106732:	e8 97 e4 ff ff       	call   f0104bce <kclock_read_cnt0_latch>
f0106737:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f010673b:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f010673f:	83 ec 08             	sub    $0x8,%esp
f0106742:	50                   	push   %eax
f0106743:	68 8c 47 12 f0       	push   $0xf012478c
f0106748:	e8 1f a8 ff ff       	call   f0100f6c <cprintf>
f010674d:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f0106750:	e8 c6 06 00 00       	call   f0106e1b <mycpu>
f0106755:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f010675c:	00 00 00 
	scheduler_method = SCH_RR;
f010675f:	c7 05 14 4f 55 f0 00 	movl   $0x0,0xf0554f14
f0106766:	00 00 00 
	//=========================================
	//=========================================
}
f0106769:	90                   	nop
f010676a:	c9                   	leave  
f010676b:	c3                   	ret    

f010676c <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f010676c:	55                   	push   %ebp
f010676d:	89 e5                	mov    %esp,%ebp
f010676f:	83 ec 18             	sub    $0x18,%esp
f0106772:	8b 45 08             	mov    0x8(%ebp),%eax
f0106775:	88 45 f4             	mov    %al,-0xc(%ebp)
	//=========================================
	//DON'T CHANGE THESE LINES=================
	sched_delete_ready_queues();
f0106778:	e8 88 e7 ff ff       	call   f0104f05 <sched_delete_ready_queues>
	//=========================================
	//=========================================
	//[PROJECT] MLFQ Scheduler - sched_init_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010677d:	83 ec 04             	sub    $0x4,%esp
f0106780:	68 b4 47 12 f0       	push   $0xf01247b4
f0106785:	68 ce 00 00 00       	push   $0xce
f010678a:	68 fe 46 12 f0       	push   $0xf01246fe
f010678f:	e8 86 9b ff ff       	call   f010031a <_panic>

f0106794 <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0106794:	55                   	push   %ebp
f0106795:	89 e5                	mov    %esp,%ebp
f0106797:	83 ec 18             	sub    $0x18,%esp
f010679a:	8b 55 08             	mov    0x8(%ebp),%edx
f010679d:	8b 45 0c             	mov    0xc(%ebp),%eax
f01067a0:	88 55 f4             	mov    %dl,-0xc(%ebp)
f01067a3:	88 45 f0             	mov    %al,-0x10(%ebp)
	//[PROJECT] BSD Scheduler - sched_init_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01067a6:	83 ec 04             	sub    $0x4,%esp
f01067a9:	68 b4 47 12 f0       	push   $0xf01247b4
f01067ae:	68 e4 00 00 00       	push   $0xe4
f01067b3:	68 fe 46 12 f0       	push   $0xf01246fe
f01067b8:	e8 5d 9b ff ff       	call   f010031a <_panic>

f01067bd <fos_scheduler_RR>:

//=========================
// [6] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f01067bd:	55                   	push   %ebp
f01067be:	89 e5                	mov    %esp,%ebp
f01067c0:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01067c3:	83 ec 0c             	sub    $0xc,%esp
f01067c6:	68 60 24 55 f0       	push   $0xf0552460
f01067cb:	e8 e7 81 00 00       	call   f010e9b7 <holding_spinlock>
f01067d0:	83 c4 10             	add    $0x10,%esp
f01067d3:	85 c0                	test   %eax,%eax
f01067d5:	75 17                	jne    f01067ee <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f01067d7:	83 ec 04             	sub    $0x4,%esp
f01067da:	68 c8 47 12 f0       	push   $0xf01247c8
f01067df:	68 fe 00 00 00       	push   $0xfe
f01067e4:	68 fe 46 12 f0       	push   $0xf01246fe
f01067e9:	e8 2c 9b ff ff       	call   f010031a <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f01067ee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f01067f5:	e8 94 3c 00 00       	call   f010a48e <get_cpu_proc>
f01067fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f01067fd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106801:	74 13                	je     f0106816 <fos_scheduler_RR+0x59>
	{
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0106803:	83 ec 08             	sub    $0x8,%esp
f0106806:	ff 75 f0             	pushl  -0x10(%ebp)
f0106809:	68 f0 24 55 f0       	push   $0xf05524f0
f010680e:	e8 83 e4 ff ff       	call   f0104c96 <enqueue>
f0106813:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0106816:	83 ec 0c             	sub    $0xc,%esp
f0106819:	68 f0 24 55 f0       	push   $0xf05524f0
f010681e:	e8 04 e5 ff ff       	call   f0104d27 <dequeue>
f0106823:	83 c4 10             	add    $0x10,%esp
f0106826:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0106829:	a0 e4 4d 55 f0       	mov    0xf0554de4,%al
f010682e:	0f b6 c0             	movzbl %al,%eax
f0106831:	83 ec 0c             	sub    $0xc,%esp
f0106834:	50                   	push   %eax
f0106835:	e8 35 e2 ff ff       	call   f0104a6f <kclock_set_quantum>
f010683a:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f010683d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106840:	c9                   	leave  
f0106841:	c3                   	ret    

f0106842 <fos_scheduler_MLFQ>:

//=========================
// [6] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0106842:	55                   	push   %ebp
f0106843:	89 e5                	mov    %esp,%ebp
f0106845:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106848:	83 ec 0c             	sub    $0xc,%esp
f010684b:	68 60 24 55 f0       	push   $0xf0552460
f0106850:	e8 62 81 00 00       	call   f010e9b7 <holding_spinlock>
f0106855:	83 c4 10             	add    $0x10,%esp
f0106858:	85 c0                	test   %eax,%eax
f010685a:	75 17                	jne    f0106873 <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f010685c:	83 ec 04             	sub    $0x4,%esp
f010685f:	68 14 48 12 f0       	push   $0xf0124814
f0106864:	68 1d 01 00 00       	push   $0x11d
f0106869:	68 fe 46 12 f0       	push   $0xf01246fe
f010686e:	e8 a7 9a ff ff       	call   f010031a <_panic>
	/****************************************************************************************/

	//[PROJECT] MLFQ Scheduler - fos_scheduler_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106873:	83 ec 04             	sub    $0x4,%esp
f0106876:	68 b4 47 12 f0       	push   $0xf01247b4
f010687b:	68 23 01 00 00       	push   $0x123
f0106880:	68 fe 46 12 f0       	push   $0xf01246fe
f0106885:	e8 90 9a ff ff       	call   f010031a <_panic>

f010688a <fos_scheduler_BSD>:

//=========================
// [7] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f010688a:	55                   	push   %ebp
f010688b:	89 e5                	mov    %esp,%ebp
f010688d:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106890:	83 ec 0c             	sub    $0xc,%esp
f0106893:	68 60 24 55 f0       	push   $0xf0552460
f0106898:	e8 1a 81 00 00       	call   f010e9b7 <holding_spinlock>
f010689d:	83 c4 10             	add    $0x10,%esp
f01068a0:	85 c0                	test   %eax,%eax
f01068a2:	75 17                	jne    f01068bb <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f01068a4:	83 ec 04             	sub    $0x4,%esp
f01068a7:	68 64 48 12 f0       	push   $0xf0124864
f01068ac:	68 2e 01 00 00       	push   $0x12e
f01068b1:	68 fe 46 12 f0       	push   $0xf01246fe
f01068b6:	e8 5f 9a ff ff       	call   f010031a <_panic>
	/****************************************************************************************/

	//[PROJECT] BSD Scheduler - fos_scheduler_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01068bb:	83 ec 04             	sub    $0x4,%esp
f01068be:	68 b4 47 12 f0       	push   $0xf01247b4
f01068c3:	68 34 01 00 00       	push   $0x134
f01068c8:	68 fe 46 12 f0       	push   $0xf01246fe
f01068cd:	e8 48 9a ff ff       	call   f010031a <_panic>

f01068d2 <clock_interrupt_handler>:
//========================================
// [8] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f01068d2:	55                   	push   %ebp
f01068d3:	89 e5                	mov    %esp,%ebp
f01068d5:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodBSD())
f01068d8:	e8 74 fb ff ff       	call   f0106451 <isSchedMethodBSD>
f01068dd:	85 c0                	test   %eax,%eax
f01068df:	74 17                	je     f01068f8 <clock_interrupt_handler+0x26>
	{
		//[PROJECT] BSD Scheduler - clock_interrupt_handler
		//Your code is here
		//Comment the following line
		panic("Not implemented yet");
f01068e1:	83 ec 04             	sub    $0x4,%esp
f01068e4:	68 b4 47 12 f0       	push   $0xf01247b4
f01068e9:	68 43 01 00 00       	push   $0x143
f01068ee:	68 fe 46 12 f0       	push   $0xf01246fe
f01068f3:	e8 22 9a ff ff       	call   f010031a <_panic>
	}



	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f01068f8:	a1 c8 50 55 f0       	mov    0xf05550c8,%eax
f01068fd:	8b 15 cc 50 55 f0    	mov    0xf05550cc,%edx
f0106903:	83 c0 01             	add    $0x1,%eax
f0106906:	83 d2 00             	adc    $0x0,%edx
f0106909:	a3 c8 50 55 f0       	mov    %eax,0xf05550c8
f010690e:	89 15 cc 50 55 f0    	mov    %edx,0xf05550cc
	struct Env* p = get_cpu_proc();
f0106914:	e8 75 3b 00 00       	call   f010a48e <get_cpu_proc>
f0106919:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p == NULL)
f010691c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106920:	74 30                	je     f0106952 <clock_interrupt_handler+0x80>
	{
	}
	else
	{
		p->nClocks++ ;
f0106922:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106925:	8b 80 68 da 01 00    	mov    0x1da68(%eax),%eax
f010692b:	8d 50 01             	lea    0x1(%eax),%edx
f010692e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106931:	89 90 68 da 01 00    	mov    %edx,0x1da68(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0106937:	83 ec 0c             	sub    $0xc,%esp
f010693a:	6a 01                	push   $0x1
f010693c:	e8 4c 7a 00 00       	call   f010e38d <isPageReplacmentAlgorithmLRU>
f0106941:	83 c4 10             	add    $0x10,%esp
f0106944:	85 c0                	test   %eax,%eax
f0106946:	74 05                	je     f010694d <clock_interrupt_handler+0x7b>
		{
			update_WS_time_stamps();
f0106948:	e8 08 00 00 00       	call   f0106955 <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f010694d:	e8 6a 3c 00 00       	call   f010a5bc <yield>
	}
	/*****************************************/
}
f0106952:	90                   	nop
f0106953:	c9                   	leave  
f0106954:	c3                   	ret    

f0106955 <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f0106955:	55                   	push   %ebp
f0106956:	89 e5                	mov    %esp,%ebp
f0106958:	53                   	push   %ebx
f0106959:	83 ec 34             	sub    $0x34,%esp
	struct Env *curr_env_ptr = get_cpu_proc();
f010695c:	e8 2d 3b 00 00       	call   f010a48e <get_cpu_proc>
f0106961:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(curr_env_ptr != NULL)
f0106964:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106968:	0f 84 9d 01 00 00    	je     f0106b0b <update_WS_time_stamps+0x1b6>
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
			{
#else
				for (i = 0 ; i < (curr_env_ptr->page_WS_max_size); i++)
f010696e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0106975:	e9 99 00 00 00       	jmp    f0106a13 <update_WS_time_stamps+0xbe>
				{
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
f010697a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010697d:	89 d0                	mov    %edx,%eax
f010697f:	01 c0                	add    %eax,%eax
f0106981:	01 d0                	add    %edx,%eax
f0106983:	c1 e0 03             	shl    $0x3,%eax
f0106986:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010698c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010698f:	01 d0                	add    %edx,%eax
f0106991:	83 c0 08             	add    $0x8,%eax
f0106994:	89 45 e8             	mov    %eax,-0x18(%ebp)
					if( wse->empty == 1)
f0106997:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010699a:	8a 40 04             	mov    0x4(%eax),%al
f010699d:	3c 01                	cmp    $0x1,%al
f010699f:	74 6e                	je     f0106a0f <update_WS_time_stamps+0xba>
						continue;
#endif
					//update the time if the page was referenced
					uint32 page_va = wse->virtual_address ;
f01069a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01069a4:	8b 00                	mov    (%eax),%eax
f01069a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					uint32 perm = pt_get_page_permissions(curr_env_ptr->env_page_directory, page_va) ;
f01069a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01069ac:	8b 40 64             	mov    0x64(%eax),%eax
f01069af:	83 ec 08             	sub    $0x8,%esp
f01069b2:	ff 75 e4             	pushl  -0x1c(%ebp)
f01069b5:	50                   	push   %eax
f01069b6:	e8 4f 1f 00 00       	call   f010890a <pt_get_page_permissions>
f01069bb:	83 c4 10             	add    $0x10,%esp
f01069be:	89 45 e0             	mov    %eax,-0x20(%ebp)
					uint32 oldTimeStamp = wse->time_stamp;
f01069c1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01069c4:	8b 40 08             	mov    0x8(%eax),%eax
f01069c7:	89 45 dc             	mov    %eax,-0x24(%ebp)

					if (perm & PERM_USED)
f01069ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01069cd:	83 e0 20             	and    $0x20,%eax
f01069d0:	85 c0                	test   %eax,%eax
f01069d2:	74 2b                	je     f01069ff <update_WS_time_stamps+0xaa>
					{
						wse->time_stamp = (oldTimeStamp>>2) | 0x80000000;
f01069d4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01069d7:	c1 e8 02             	shr    $0x2,%eax
f01069da:	0d 00 00 00 80       	or     $0x80000000,%eax
f01069df:	89 c2                	mov    %eax,%edx
f01069e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01069e4:	89 50 08             	mov    %edx,0x8(%eax)
						pt_set_page_permissions(curr_env_ptr->env_page_directory, page_va, 0 , PERM_USED) ;
f01069e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01069ea:	8b 40 64             	mov    0x64(%eax),%eax
f01069ed:	6a 20                	push   $0x20
f01069ef:	6a 00                	push   $0x0
f01069f1:	ff 75 e4             	pushl  -0x1c(%ebp)
f01069f4:	50                   	push   %eax
f01069f5:	e8 4c 1e 00 00       	call   f0108846 <pt_set_page_permissions>
f01069fa:	83 c4 10             	add    $0x10,%esp
f01069fd:	eb 11                	jmp    f0106a10 <update_WS_time_stamps+0xbb>
					}
					else
					{
						wse->time_stamp = (oldTimeStamp>>2);
f01069ff:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0106a02:	c1 e8 02             	shr    $0x2,%eax
f0106a05:	89 c2                	mov    %eax,%edx
f0106a07:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106a0a:	89 50 08             	mov    %edx,0x8(%eax)
f0106a0d:	eb 01                	jmp    f0106a10 <update_WS_time_stamps+0xbb>
#else
				for (i = 0 ; i < (curr_env_ptr->page_WS_max_size); i++)
				{
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
					if( wse->empty == 1)
						continue;
f0106a0f:	90                   	nop
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
			{
#else
				for (i = 0 ; i < (curr_env_ptr->page_WS_max_size); i++)
f0106a10:	ff 45 f4             	incl   -0xc(%ebp)
f0106a13:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106a16:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f0106a1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106a1f:	39 c2                	cmp    %eax,%edx
f0106a21:	0f 87 53 ff ff ff    	ja     f010697a <update_WS_time_stamps+0x25>
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106a27:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106a2e:	e9 ce 00 00 00       	jmp    f0106b01 <update_WS_time_stamps+0x1ac>
				{
					if( curr_env_ptr->__ptr_tws[t].empty != 1)
f0106a33:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106a36:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106a39:	89 d0                	mov    %edx,%eax
f0106a3b:	01 c0                	add    %eax,%eax
f0106a3d:	01 d0                	add    %edx,%eax
f0106a3f:	c1 e0 03             	shl    $0x3,%eax
f0106a42:	01 c8                	add    %ecx,%eax
f0106a44:	05 60 d5 01 00       	add    $0x1d560,%eax
f0106a49:	8a 00                	mov    (%eax),%al
f0106a4b:	3c 01                	cmp    $0x1,%al
f0106a4d:	0f 84 ab 00 00 00    	je     f0106afe <update_WS_time_stamps+0x1a9>
					{
						//update the time if the page was referenced
						uint32 table_va = curr_env_ptr->__ptr_tws[t].virtual_address;
f0106a53:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106a56:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106a59:	89 d0                	mov    %edx,%eax
f0106a5b:	01 c0                	add    %eax,%eax
f0106a5d:	01 d0                	add    %edx,%eax
f0106a5f:	c1 e0 03             	shl    $0x3,%eax
f0106a62:	01 c8                	add    %ecx,%eax
f0106a64:	05 5c d5 01 00       	add    $0x1d55c,%eax
f0106a69:	8b 00                	mov    (%eax),%eax
f0106a6b:	89 45 d8             	mov    %eax,-0x28(%ebp)
						uint32 oldTimeStamp = curr_env_ptr->__ptr_tws[t].time_stamp;
f0106a6e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106a71:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106a74:	89 d0                	mov    %edx,%eax
f0106a76:	01 c0                	add    %eax,%eax
f0106a78:	01 d0                	add    %edx,%eax
f0106a7a:	c1 e0 03             	shl    $0x3,%eax
f0106a7d:	01 c8                	add    %ecx,%eax
f0106a7f:	05 64 d5 01 00       	add    $0x1d564,%eax
f0106a84:	8b 00                	mov    (%eax),%eax
f0106a86:	89 45 d4             	mov    %eax,-0x2c(%ebp)

						if (pd_is_table_used(curr_env_ptr->env_page_directory, table_va))
f0106a89:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106a8c:	8b 40 64             	mov    0x64(%eax),%eax
f0106a8f:	83 ec 08             	sub    $0x8,%esp
f0106a92:	ff 75 d8             	pushl  -0x28(%ebp)
f0106a95:	50                   	push   %eax
f0106a96:	e8 4b 1f 00 00       	call   f01089e6 <pd_is_table_used>
f0106a9b:	83 c4 10             	add    $0x10,%esp
f0106a9e:	85 c0                	test   %eax,%eax
f0106aa0:	74 3c                	je     f0106ade <update_WS_time_stamps+0x189>
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106aa2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0106aa5:	c1 e8 02             	shr    $0x2,%eax
f0106aa8:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106aad:	89 c1                	mov    %eax,%ecx
f0106aaf:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106ab2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106ab5:	89 d0                	mov    %edx,%eax
f0106ab7:	01 c0                	add    %eax,%eax
f0106ab9:	01 d0                	add    %edx,%eax
f0106abb:	c1 e0 03             	shl    $0x3,%eax
f0106abe:	01 d8                	add    %ebx,%eax
f0106ac0:	05 64 d5 01 00       	add    $0x1d564,%eax
f0106ac5:	89 08                	mov    %ecx,(%eax)
							pd_set_table_unused(curr_env_ptr->env_page_directory, table_va);
f0106ac7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106aca:	8b 40 64             	mov    0x64(%eax),%eax
f0106acd:	83 ec 08             	sub    $0x8,%esp
f0106ad0:	ff 75 d8             	pushl  -0x28(%ebp)
f0106ad3:	50                   	push   %eax
f0106ad4:	e8 31 1f 00 00       	call   f0108a0a <pd_set_table_unused>
f0106ad9:	83 c4 10             	add    $0x10,%esp
f0106adc:	eb 20                	jmp    f0106afe <update_WS_time_stamps+0x1a9>
						}
						else
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2);
f0106ade:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0106ae1:	c1 e8 02             	shr    $0x2,%eax
f0106ae4:	89 c1                	mov    %eax,%ecx
f0106ae6:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106ae9:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106aec:	89 d0                	mov    %edx,%eax
f0106aee:	01 c0                	add    %eax,%eax
f0106af0:	01 d0                	add    %edx,%eax
f0106af2:	c1 e0 03             	shl    $0x3,%eax
f0106af5:	01 d8                	add    %ebx,%eax
f0106af7:	05 64 d5 01 00       	add    $0x1d564,%eax
f0106afc:	89 08                	mov    %ecx,(%eax)
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106afe:	ff 45 f0             	incl   -0x10(%ebp)
f0106b01:	83 7d f0 31          	cmpl   $0x31,-0x10(%ebp)
f0106b05:	0f 8e 28 ff ff ff    	jle    f0106a33 <update_WS_time_stamps+0xde>
						}
					}
				}
			}
		}
	}
f0106b0b:	90                   	nop
f0106b0c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106b0f:	c9                   	leave  
f0106b10:	c3                   	ret    

f0106b11 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f0106b11:	55                   	push   %ebp
f0106b12:	89 e5                	mov    %esp,%ebp
f0106b14:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0106b17:	c7 05 0c 1a 55 f0 01 	movl   $0x1,0xf0551a0c
f0106b1e:	00 00 00 
f0106b21:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0106b28:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106b2c:	8a 45 b2             	mov    -0x4e(%ebp),%al
f0106b2f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106b32:	ee                   	out    %al,(%dx)
f0106b33:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0106b3a:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f0106b3e:	8a 45 b3             	mov    -0x4d(%ebp),%al
f0106b41:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106b44:	ee                   	out    %al,(%dx)
f0106b45:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0106b4c:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f0106b50:	8a 45 b4             	mov    -0x4c(%ebp),%al
f0106b53:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106b56:	ee                   	out    %al,(%dx)
f0106b57:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f0106b5e:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f0106b62:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0106b65:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0106b68:	ee                   	out    %al,(%dx)
f0106b69:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f0106b70:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0106b74:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0106b77:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0106b7a:	ee                   	out    %al,(%dx)
f0106b7b:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f0106b82:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f0106b86:	8a 45 b7             	mov    -0x49(%ebp),%al
f0106b89:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0106b8c:	ee                   	out    %al,(%dx)
f0106b8d:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f0106b94:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f0106b98:	8a 45 b8             	mov    -0x48(%ebp),%al
f0106b9b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0106b9e:	ee                   	out    %al,(%dx)
f0106b9f:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f0106ba6:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f0106baa:	8a 45 b9             	mov    -0x47(%ebp),%al
f0106bad:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0106bb0:	ee                   	out    %al,(%dx)
f0106bb1:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f0106bb8:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f0106bbc:	8a 45 ba             	mov    -0x46(%ebp),%al
f0106bbf:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0106bc2:	ee                   	out    %al,(%dx)
f0106bc3:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f0106bca:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f0106bce:	8a 45 bb             	mov    -0x45(%ebp),%al
f0106bd1:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0106bd4:	ee                   	out    %al,(%dx)
f0106bd5:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f0106bdc:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f0106be0:	8a 45 bc             	mov    -0x44(%ebp),%al
f0106be3:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0106be6:	ee                   	out    %al,(%dx)
f0106be7:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f0106bee:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f0106bf2:	8a 45 bd             	mov    -0x43(%ebp),%al
f0106bf5:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0106bf8:	ee                   	out    %al,(%dx)
f0106bf9:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f0106c00:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0106c04:	8a 45 be             	mov    -0x42(%ebp),%al
f0106c07:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0106c0a:	ee                   	out    %al,(%dx)
f0106c0b:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f0106c12:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0106c16:	8a 45 bf             	mov    -0x41(%ebp),%al
f0106c19:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0106c1c:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0106c1d:	66 a1 70 99 17 f0    	mov    0xf0179970,%ax
f0106c23:	66 83 f8 ff          	cmp    $0xffff,%ax
f0106c27:	74 15                	je     f0106c3e <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f0106c29:	66 a1 70 99 17 f0    	mov    0xf0179970,%ax
f0106c2f:	0f b7 c0             	movzwl %ax,%eax
f0106c32:	83 ec 0c             	sub    $0xc,%esp
f0106c35:	50                   	push   %eax
f0106c36:	e8 06 00 00 00       	call   f0106c41 <irq_setmask_8259A>
f0106c3b:	83 c4 10             	add    $0x10,%esp
}
f0106c3e:	90                   	nop
f0106c3f:	c9                   	leave  
f0106c40:	c3                   	ret    

f0106c41 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f0106c41:	55                   	push   %ebp
f0106c42:	89 e5                	mov    %esp,%ebp
f0106c44:	83 ec 14             	sub    $0x14,%esp
f0106c47:	8b 45 08             	mov    0x8(%ebp),%eax
f0106c4a:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f0106c4e:	a1 0c 1a 55 f0       	mov    0xf0551a0c,%eax
f0106c53:	85 c0                	test   %eax,%eax
f0106c55:	74 34                	je     f0106c8b <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0106c57:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c5a:	0f b6 c0             	movzbl %al,%eax
f0106c5d:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0106c64:	88 45 f6             	mov    %al,-0xa(%ebp)
f0106c67:	8a 45 f6             	mov    -0xa(%ebp),%al
f0106c6a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0106c6d:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f0106c6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c71:	66 c1 e8 08          	shr    $0x8,%ax
f0106c75:	0f b6 c0             	movzbl %al,%eax
f0106c78:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f0106c7f:	88 45 f7             	mov    %al,-0x9(%ebp)
f0106c82:	8a 45 f7             	mov    -0x9(%ebp),%al
f0106c85:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0106c88:	ee                   	out    %al,(%dx)
f0106c89:	eb 01                	jmp    f0106c8c <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f0106c8b:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f0106c8c:	c9                   	leave  
f0106c8d:	c3                   	ret    

f0106c8e <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f0106c8e:	55                   	push   %ebp
f0106c8f:	89 e5                	mov    %esp,%ebp
f0106c91:	53                   	push   %ebx
f0106c92:	83 ec 14             	sub    $0x14,%esp
f0106c95:	8b 45 08             	mov    0x8(%ebp),%eax
f0106c98:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106c9b:	a1 0c 1a 55 f0       	mov    0xf0551a0c,%eax
f0106ca0:	85 c0                	test   %eax,%eax
f0106ca2:	74 58                	je     f0106cfc <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106ca4:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106ca8:	77 08                	ja     f0106cb2 <irq_set_mask+0x24>
		port = PIC1_DATA;
f0106caa:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106cb0:	eb 0a                	jmp    f0106cbc <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0106cb2:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106cb8:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f0106cbc:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106cc0:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106cc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cc6:	89 c2                	mov    %eax,%edx
f0106cc8:	ec                   	in     (%dx),%al
f0106cc9:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0106ccc:	8a 45 ee             	mov    -0x12(%ebp),%al
f0106ccf:	88 c2                	mov    %al,%dl
f0106cd1:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0106cd5:	bb 01 00 00 00       	mov    $0x1,%ebx
f0106cda:	88 c1                	mov    %al,%cl
f0106cdc:	d3 e3                	shl    %cl,%ebx
f0106cde:	89 d8                	mov    %ebx,%eax
f0106ce0:	09 d0                	or     %edx,%eax
f0106ce2:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0106ce5:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0106ce9:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0106ced:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0106cf0:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106cf3:	8a 45 ef             	mov    -0x11(%ebp),%al
f0106cf6:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106cf9:	ee                   	out    %al,(%dx)
f0106cfa:	eb 01                	jmp    f0106cfd <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0106cfc:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f0106cfd:	83 c4 14             	add    $0x14,%esp
f0106d00:	5b                   	pop    %ebx
f0106d01:	5d                   	pop    %ebp
f0106d02:	c3                   	ret    

f0106d03 <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f0106d03:	55                   	push   %ebp
f0106d04:	89 e5                	mov    %esp,%ebp
f0106d06:	53                   	push   %ebx
f0106d07:	83 ec 14             	sub    $0x14,%esp
f0106d0a:	8b 45 08             	mov    0x8(%ebp),%eax
f0106d0d:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106d10:	a1 0c 1a 55 f0       	mov    0xf0551a0c,%eax
f0106d15:	85 c0                	test   %eax,%eax
f0106d17:	74 5a                	je     f0106d73 <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106d19:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106d1d:	77 08                	ja     f0106d27 <irq_clear_mask+0x24>
		port = PIC1_DATA;
f0106d1f:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106d25:	eb 0a                	jmp    f0106d31 <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0106d27:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106d2d:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f0106d31:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106d35:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106d38:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106d3b:	89 c2                	mov    %eax,%edx
f0106d3d:	ec                   	in     (%dx),%al
f0106d3e:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0106d41:	8a 45 ee             	mov    -0x12(%ebp),%al
f0106d44:	88 c2                	mov    %al,%dl
f0106d46:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0106d4a:	bb 01 00 00 00       	mov    $0x1,%ebx
f0106d4f:	88 c1                	mov    %al,%cl
f0106d51:	d3 e3                	shl    %cl,%ebx
f0106d53:	89 d8                	mov    %ebx,%eax
f0106d55:	f7 d0                	not    %eax
f0106d57:	21 d0                	and    %edx,%eax
f0106d59:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0106d5c:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0106d60:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0106d64:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0106d67:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106d6a:	8a 45 ef             	mov    -0x11(%ebp),%al
f0106d6d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d70:	ee                   	out    %al,(%dx)
f0106d71:	eb 01                	jmp    f0106d74 <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0106d73:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f0106d74:	83 c4 14             	add    $0x14,%esp
f0106d77:	5b                   	pop    %ebx
f0106d78:	5d                   	pop    %ebp
f0106d79:	c3                   	ret    

f0106d7a <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f0106d7a:	55                   	push   %ebp
f0106d7b:	89 e5                	mov    %esp,%ebp
f0106d7d:	53                   	push   %ebx
f0106d7e:	83 ec 14             	sub    $0x14,%esp
f0106d81:	8b 45 08             	mov    0x8(%ebp),%eax
f0106d84:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106d87:	a1 0c 1a 55 f0       	mov    0xf0551a0c,%eax
f0106d8c:	85 c0                	test   %eax,%eax
f0106d8e:	75 07                	jne    f0106d97 <irq_get_mask+0x1d>
		return -1;
f0106d90:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0106d95:	eb 45                	jmp    f0106ddc <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106d97:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106d9b:	77 08                	ja     f0106da5 <irq_get_mask+0x2b>
		port = PIC1_DATA;
f0106d9d:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106da3:	eb 0a                	jmp    f0106daf <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f0106da5:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106dab:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f0106daf:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106db3:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106db6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106db9:	89 c2                	mov    %eax,%edx
f0106dbb:	ec                   	in     (%dx),%al
f0106dbc:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f0106dbf:	8a 45 f3             	mov    -0xd(%ebp),%al
f0106dc2:	88 c2                	mov    %al,%dl
f0106dc4:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0106dc8:	bb 01 00 00 00       	mov    $0x1,%ebx
f0106dcd:	88 c1                	mov    %al,%cl
f0106dcf:	d3 e3                	shl    %cl,%ebx
f0106dd1:	89 d8                	mov    %ebx,%eax
f0106dd3:	21 d0                	and    %edx,%eax
f0106dd5:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f0106dd8:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f0106ddc:	83 c4 14             	add    $0x14,%esp
f0106ddf:	5b                   	pop    %ebx
f0106de0:	5d                   	pop    %ebp
f0106de1:	c3                   	ret    

f0106de2 <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f0106de2:	55                   	push   %ebp
f0106de3:	89 e5                	mov    %esp,%ebp
f0106de5:	83 ec 14             	sub    $0x14,%esp
f0106de8:	8b 45 08             	mov    0x8(%ebp),%eax
f0106deb:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f0106dee:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f0106df2:	76 12                	jbe    f0106e06 <pic_sendEOI+0x24>
f0106df4:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f0106dfb:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106dff:	8a 45 f7             	mov    -0x9(%ebp),%al
f0106e02:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0106e05:	ee                   	out    %al,(%dx)
f0106e06:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f0106e0d:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f0106e11:	8a 45 f6             	mov    -0xa(%ebp),%al
f0106e14:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0106e17:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f0106e18:	90                   	nop
f0106e19:	c9                   	leave  
f0106e1a:	c3                   	ret    

f0106e1b <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f0106e1b:	55                   	push   %ebp
f0106e1c:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f0106e1e:	b8 00 4c 55 f0       	mov    $0xf0554c00,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f0106e23:	5d                   	pop    %ebp
f0106e24:	c3                   	ret    

f0106e25 <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f0106e25:	55                   	push   %ebp
f0106e26:	89 e5                	mov    %esp,%ebp
f0106e28:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f0106e2b:	e8 eb ff ff ff       	call   f0106e1b <mycpu>
f0106e30:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f0106e33:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e36:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0106e3d:	00 00 00 
  c->ncli = 0;
f0106e40:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e43:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0106e4a:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106e4d:	9c                   	pushf  
f0106e4e:	58                   	pop    %eax
f0106e4f:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0106e52:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f0106e55:	25 00 02 00 00       	and    $0x200,%eax
f0106e5a:	85 c0                	test   %eax,%eax
f0106e5c:	0f 95 c0             	setne  %al
f0106e5f:	0f b6 d0             	movzbl %al,%edx
f0106e62:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e65:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f0106e6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e6e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f0106e75:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e78:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f0106e7f:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f0106e82:	8b 45 08             	mov    0x8(%ebp),%eax
f0106e85:	40                   	inc    %eax
f0106e86:	c1 e0 0f             	shl    $0xf,%eax
f0106e89:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f0106e8e:	29 c2                	sub    %eax,%edx
f0106e90:	89 d0                	mov    %edx,%eax
f0106e92:	89 c2                	mov    %eax,%edx
f0106e94:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e97:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f0106e9a:	e8 18 01 00 00       	call   f0106fb7 <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f0106e9f:	e8 49 50 00 00       	call   f010beed <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f0106ea4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ea7:	83 c0 0c             	add    $0xc,%eax
f0106eaa:	83 ec 04             	sub    $0x4,%esp
f0106ead:	6a 68                	push   $0x68
f0106eaf:	6a 00                	push   $0x0
f0106eb1:	50                   	push   %eax
f0106eb2:	e8 88 98 01 00       	call   f012073f <memset>
f0106eb7:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f0106eba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ebd:	05 a4 00 00 00       	add    $0xa4,%eax
f0106ec2:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0106ec5:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f0106ecc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106ecf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106ed2:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106ed5:	f0 87 02             	lock xchg %eax,(%edx)
f0106ed8:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f0106edb:	90                   	nop
f0106edc:	c9                   	leave  
f0106edd:	c3                   	ret    

f0106ede <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f0106ede:	55                   	push   %ebp
f0106edf:	89 e5                	mov    %esp,%ebp
f0106ee1:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106ee4:	9c                   	pushf  
f0106ee5:	58                   	pop    %eax
f0106ee6:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f0106ee9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f0106eec:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0106eef:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f0106ef0:	e8 26 ff ff ff       	call   f0106e1b <mycpu>
f0106ef5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f0106ef8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106efb:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0106f01:	85 c0                	test   %eax,%eax
f0106f03:	75 13                	jne    f0106f18 <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f0106f05:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0106f08:	25 00 02 00 00       	and    $0x200,%eax
f0106f0d:	89 c2                	mov    %eax,%edx
f0106f0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f12:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f0106f18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f1b:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0106f21:	8d 50 01             	lea    0x1(%eax),%edx
f0106f24:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f27:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f0106f2d:	90                   	nop
f0106f2e:	c9                   	leave  
f0106f2f:	c3                   	ret    

f0106f30 <popcli>:

void popcli(void)
{
f0106f30:	55                   	push   %ebp
f0106f31:	89 e5                	mov    %esp,%ebp
f0106f33:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106f36:	9c                   	pushf  
f0106f37:	58                   	pop    %eax
f0106f38:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0106f3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f0106f3e:	25 00 02 00 00       	and    $0x200,%eax
f0106f43:	85 c0                	test   %eax,%eax
f0106f45:	74 14                	je     f0106f5b <popcli+0x2b>
    panic("popcli - interruptible");
f0106f47:	83 ec 04             	sub    $0x4,%esp
f0106f4a:	68 b1 48 12 f0       	push   $0xf01248b1
f0106f4f:	6a 5e                	push   $0x5e
f0106f51:	68 c8 48 12 f0       	push   $0xf01248c8
f0106f56:	e8 bf 93 ff ff       	call   f010031a <_panic>
  struct cpu* c = mycpu();
f0106f5b:	e8 bb fe ff ff       	call   f0106e1b <mycpu>
f0106f60:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f0106f63:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f66:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0106f6c:	8d 50 ff             	lea    -0x1(%eax),%edx
f0106f6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f72:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f0106f78:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f7b:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0106f81:	85 c0                	test   %eax,%eax
f0106f83:	79 14                	jns    f0106f99 <popcli+0x69>
    panic("popcli");
f0106f85:	83 ec 04             	sub    $0x4,%esp
f0106f88:	68 d7 48 12 f0       	push   $0xf01248d7
f0106f8d:	6a 61                	push   $0x61
f0106f8f:	68 c8 48 12 f0       	push   $0xf01248c8
f0106f94:	e8 81 93 ff ff       	call   f010031a <_panic>
  if(c->ncli == 0 && c->intena)
f0106f99:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f9c:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0106fa2:	85 c0                	test   %eax,%eax
f0106fa4:	75 0e                	jne    f0106fb4 <popcli+0x84>
f0106fa6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fa9:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0106faf:	85 c0                	test   %eax,%eax
f0106fb1:	74 01                	je     f0106fb4 <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f0106fb3:	fb                   	sti    
    sti();
}
f0106fb4:	90                   	nop
f0106fb5:	c9                   	leave  
f0106fb6:	c3                   	ret    

f0106fb7 <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f0106fb7:	55                   	push   %ebp
f0106fb8:	89 e5                	mov    %esp,%ebp
f0106fba:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f0106fbd:	e8 1c ff ff ff       	call   f0106ede <pushcli>

	c = mycpu();
f0106fc2:	e8 54 fe ff ff       	call   f0106e1b <mycpu>
f0106fc7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f0106fca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fcd:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f0106fd4:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f0106fdb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fde:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f0106fe4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fe7:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f0106fed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ff0:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f0106ff7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ffa:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107000:	83 e2 f0             	and    $0xfffffff0,%edx
f0107003:	83 ca 0a             	or     $0xa,%edx
f0107006:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010700c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010700f:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107015:	83 ca 10             	or     $0x10,%edx
f0107018:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010701e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107021:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107027:	83 e2 9f             	and    $0xffffff9f,%edx
f010702a:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107030:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107033:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107039:	83 ca 80             	or     $0xffffff80,%edx
f010703c:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107042:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107045:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010704b:	83 ca 0f             	or     $0xf,%edx
f010704e:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107054:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107057:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010705d:	83 e2 ef             	and    $0xffffffef,%edx
f0107060:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107066:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107069:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010706f:	83 e2 df             	and    $0xffffffdf,%edx
f0107072:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107078:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010707b:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107081:	83 ca 40             	or     $0x40,%edx
f0107084:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010708a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010708d:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107093:	83 ca 80             	or     $0xffffff80,%edx
f0107096:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010709c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010709f:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f01070a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070a9:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f01070b0:	ff ff 
f01070b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070b5:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f01070bc:	00 00 
f01070be:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070c1:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f01070c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070cb:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01070d1:	83 e2 f0             	and    $0xfffffff0,%edx
f01070d4:	83 ca 02             	or     $0x2,%edx
f01070d7:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01070dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070e0:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01070e6:	83 ca 10             	or     $0x10,%edx
f01070e9:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01070ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070f2:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01070f8:	83 e2 9f             	and    $0xffffff9f,%edx
f01070fb:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107101:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107104:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f010710a:	83 ca 80             	or     $0xffffff80,%edx
f010710d:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107113:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107116:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010711c:	83 ca 0f             	or     $0xf,%edx
f010711f:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107125:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107128:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010712e:	83 e2 ef             	and    $0xffffffef,%edx
f0107131:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107137:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010713a:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107140:	83 e2 df             	and    $0xffffffdf,%edx
f0107143:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107149:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010714c:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107152:	83 ca 40             	or     $0x40,%edx
f0107155:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010715b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010715e:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107164:	83 ca 80             	or     $0xffffff80,%edx
f0107167:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010716d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107170:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f0107177:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010717a:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f0107181:	ff ff 
f0107183:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107186:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f010718d:	00 00 
f010718f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107192:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f0107199:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010719c:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01071a2:	83 e2 f0             	and    $0xfffffff0,%edx
f01071a5:	83 ca 0a             	or     $0xa,%edx
f01071a8:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01071ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071b1:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01071b7:	83 ca 10             	or     $0x10,%edx
f01071ba:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01071c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071c3:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01071c9:	83 ca 60             	or     $0x60,%edx
f01071cc:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01071d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071d5:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01071db:	83 ca 80             	or     $0xffffff80,%edx
f01071de:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01071e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071e7:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01071ed:	83 ca 0f             	or     $0xf,%edx
f01071f0:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01071f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071f9:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01071ff:	83 e2 ef             	and    $0xffffffef,%edx
f0107202:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107208:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010720b:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107211:	83 e2 df             	and    $0xffffffdf,%edx
f0107214:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010721a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010721d:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107223:	83 ca 40             	or     $0x40,%edx
f0107226:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010722c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010722f:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107235:	83 ca 80             	or     $0xffffff80,%edx
f0107238:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010723e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107241:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f0107248:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010724b:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f0107252:	ff ff 
f0107254:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107257:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f010725e:	00 00 
f0107260:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107263:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f010726a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010726d:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107273:	83 e2 f0             	and    $0xfffffff0,%edx
f0107276:	83 ca 02             	or     $0x2,%edx
f0107279:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f010727f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107282:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107288:	83 ca 10             	or     $0x10,%edx
f010728b:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107291:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107294:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010729a:	83 ca 60             	or     $0x60,%edx
f010729d:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01072a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072a6:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01072ac:	83 ca 80             	or     $0xffffff80,%edx
f01072af:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01072b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072b8:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01072be:	83 ca 0f             	or     $0xf,%edx
f01072c1:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01072c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072ca:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01072d0:	83 e2 ef             	and    $0xffffffef,%edx
f01072d3:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01072d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072dc:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01072e2:	83 e2 df             	and    $0xffffffdf,%edx
f01072e5:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01072eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072ee:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01072f4:	83 ca 40             	or     $0x40,%edx
f01072f7:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01072fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107300:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0107306:	83 ca 80             	or     $0xffffff80,%edx
f0107309:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f010730f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107312:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f0107319:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010731c:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f0107323:	00 00 00 
f0107326:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010732d:	00 00 00 

	popcli();	//enable interrupt
f0107330:	e8 fb fb ff ff       	call   f0106f30 <popcli>


}
f0107335:	90                   	nop
f0107336:	c9                   	leave  
f0107337:	c3                   	ret    

f0107338 <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f0107338:	55                   	push   %ebp
f0107339:	89 e5                	mov    %esp,%ebp
f010733b:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f010733e:	83 ec 08             	sub    $0x8,%esp
f0107341:	68 00 10 00 00       	push   $0x1000
f0107346:	68 00 10 00 00       	push   $0x1000
f010734b:	e8 35 02 00 00       	call   f0107585 <boot_allocate_space>
f0107350:	83 c4 10             	add    $0x10,%esp
f0107353:	a3 dc 50 55 f0       	mov    %eax,0xf05550dc
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107358:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f010735d:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107360:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0107367:	77 14                	ja     f010737d <initialize_kernel_VM+0x45>
f0107369:	ff 75 e0             	pushl  -0x20(%ebp)
f010736c:	68 e0 48 12 f0       	push   $0xf01248e0
f0107371:	6a 57                	push   $0x57
f0107373:	68 14 49 12 f0       	push   $0xf0124914
f0107378:	e8 9d 8f ff ff       	call   f010031a <_panic>
f010737d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107380:	05 00 00 00 10       	add    $0x10000000,%eax
f0107385:	a3 e4 51 55 f0       	mov    %eax,0xf05551e4
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f010738a:	c7 45 dc 00 10 17 f0 	movl   $0xf0171000,-0x24(%ebp)
f0107391:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107398:	77 14                	ja     f01073ae <initialize_kernel_VM+0x76>
f010739a:	ff 75 dc             	pushl  -0x24(%ebp)
f010739d:	68 e0 48 12 f0       	push   $0xf01248e0
f01073a2:	6a 63                	push   $0x63
f01073a4:	68 14 49 12 f0       	push   $0xf0124914
f01073a9:	e8 6c 8f ff ff       	call   f010031a <_panic>
f01073ae:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01073b1:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01073b7:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f01073bc:	83 ec 0c             	sub    $0xc,%esp
f01073bf:	6a 02                	push   $0x2
f01073c1:	52                   	push   %edx
f01073c2:	68 00 80 00 00       	push   $0x8000
f01073c7:	68 00 80 bf ef       	push   $0xefbf8000
f01073cc:	50                   	push   %eax
f01073cd:	e8 27 02 00 00       	call   f01075f9 <boot_map_range>
f01073d2:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01073d5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01073dc:	eb 24                	jmp    f0107402 <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f01073de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073e1:	40                   	inc    %eax
f01073e2:	c1 e0 0f             	shl    $0xf,%eax
f01073e5:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f01073ea:	29 c2                	sub    %eax,%edx
f01073ec:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f01073f1:	6a 01                	push   $0x1
f01073f3:	6a 00                	push   $0x0
f01073f5:	52                   	push   %edx
f01073f6:	50                   	push   %eax
f01073f7:	e8 4a 14 00 00       	call   f0108846 <pt_set_page_permissions>
f01073fc:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01073ff:	ff 45 f4             	incl   -0xc(%ebp)
f0107402:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107406:	7e d6                	jle    f01073de <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f0107408:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f010740f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f0107416:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010741d:	eb 25                	jmp    f0107444 <initialize_kernel_VM+0x10c>
	{
		++nTables;
f010741f:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f0107422:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107425:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f010742a:	83 ec 04             	sub    $0x4,%esp
f010742d:	6a 01                	push   $0x1
f010742f:	52                   	push   %edx
f0107430:	50                   	push   %eax
f0107431:	e8 37 02 00 00       	call   f010766d <boot_get_page_table>
f0107436:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f0107439:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f0107440:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f0107444:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107448:	72 d5                	jb     f010741f <initialize_kernel_VM+0xe7>
f010744a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010744e:	77 06                	ja     f0107456 <initialize_kernel_VM+0x11e>
f0107450:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f0107454:	76 c9                	jbe    f010741f <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f0107456:	8b 15 b8 4c 55 f0    	mov    0xf0554cb8,%edx
f010745c:	89 d0                	mov    %edx,%eax
f010745e:	01 c0                	add    %eax,%eax
f0107460:	01 d0                	add    %edx,%eax
f0107462:	c1 e0 03             	shl    $0x3,%eax
f0107465:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f0107468:	83 ec 08             	sub    $0x8,%esp
f010746b:	68 00 10 00 00       	push   $0x1000
f0107470:	ff 75 d8             	pushl  -0x28(%ebp)
f0107473:	e8 0d 01 00 00       	call   f0107585 <boot_allocate_space>
f0107478:	83 c4 10             	add    $0x10,%esp
f010747b:	a3 20 4f 55 f0       	mov    %eax,0xf0554f20
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f0107480:	c7 45 d4 00 c0 30 00 	movl   $0x30c000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f0107487:	83 ec 08             	sub    $0x8,%esp
f010748a:	68 00 10 00 00       	push   $0x1000
f010748f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0107492:	e8 ee 00 00 00       	call   f0107585 <boot_allocate_space>
f0107497:	83 c4 10             	add    $0x10,%esp
f010749a:	a3 c0 22 55 f0       	mov    %eax,0xf05522c0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f010749f:	e8 32 05 00 00       	call   f01079d6 <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f01074a4:	83 ec 0c             	sub    $0xc,%esp
f01074a7:	6a 08                	push   $0x8
f01074a9:	e8 3a 78 01 00       	call   f011ece8 <nearest_pow2_ceil>
f01074ae:	83 c4 10             	add    $0x10,%esp
f01074b1:	83 ec 04             	sub    $0x4,%esp
f01074b4:	50                   	push   %eax
f01074b5:	6a 08                	push   $0x8
f01074b7:	68 34 49 12 f0       	push   $0xf0124934
f01074bc:	e8 ab 9a ff ff       	call   f0100f6c <cprintf>
f01074c1:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f01074c4:	c7 45 d0 60 d3 0e 00 	movl   $0xed360,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f01074cb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01074ce:	83 ec 08             	sub    $0x8,%esp
f01074d1:	68 00 10 00 00       	push   $0x1000
f01074d6:	50                   	push   %eax
f01074d7:	e8 a9 00 00 00       	call   f0107585 <boot_allocate_space>
f01074dc:	83 c4 10             	add    $0x10,%esp
f01074df:	a3 10 1a 55 f0       	mov    %eax,0xf0551a10
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f01074e4:	a1 10 1a 55 f0       	mov    0xf0551a10,%eax
f01074e9:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01074ec:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f01074f3:	77 17                	ja     f010750c <initialize_kernel_VM+0x1d4>
f01074f5:	ff 75 cc             	pushl  -0x34(%ebp)
f01074f8:	68 e0 48 12 f0       	push   $0xf01248e0
f01074fd:	68 b1 00 00 00       	push   $0xb1
f0107502:	68 14 49 12 f0       	push   $0xf0124914
f0107507:	e8 0e 8e ff ff       	call   f010031a <_panic>
f010750c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010750f:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f0107515:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0107518:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f010751d:	83 ec 0c             	sub    $0xc,%esp
f0107520:	6a 04                	push   $0x4
f0107522:	51                   	push   %ecx
f0107523:	52                   	push   %edx
f0107524:	68 00 00 c0 ee       	push   $0xeec00000
f0107529:	50                   	push   %eax
f010752a:	e8 ca 00 00 00       	call   f01075f9 <boot_map_range>
f010752f:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f0107532:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0107537:	05 ec 0e 00 00       	add    $0xeec,%eax
f010753c:	8b 15 dc 50 55 f0    	mov    0xf05550dc,%edx
f0107542:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f0107548:	8b 12                	mov    (%edx),%edx
f010754a:	83 ca 05             	or     $0x5,%edx
f010754d:	89 10                	mov    %edx,(%eax)
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#else
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f010754f:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0107554:	83 ec 0c             	sub    $0xc,%esp
f0107557:	6a 02                	push   $0x2
f0107559:	6a 00                	push   $0x0
f010755b:	68 ff ff ff 0f       	push   $0xfffffff
f0107560:	68 00 00 00 f0       	push   $0xf0000000
f0107565:	50                   	push   %eax
f0107566:	e8 8e 00 00 00       	call   f01075f9 <boot_map_range>
f010756b:	83 c4 20             	add    $0x20,%esp
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f010756e:	e8 18 85 01 00       	call   f011fa8b <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f0107573:	c7 05 e0 4b 55 f0 19 	movl   $0x19,0xf0554be0
f010757a:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f010757d:	e8 20 03 00 00       	call   f01078a2 <turn_on_paging>
}
f0107582:	90                   	nop
f0107583:	c9                   	leave  
f0107584:	c3                   	ret    

f0107585 <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f0107585:	55                   	push   %ebp
f0107586:	89 e5                	mov    %esp,%ebp
f0107588:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f010758b:	a1 d8 50 55 f0       	mov    0xf05550d8,%eax
f0107590:	85 c0                	test   %eax,%eax
f0107592:	75 0a                	jne    f010759e <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f0107594:	c7 05 d8 50 55 f0 a8 	movl   $0xf05779a8,0xf05550d8
f010759b:	79 57 f0 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f010759e:	8b 45 0c             	mov    0xc(%ebp),%eax
f01075a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01075a4:	a1 d8 50 55 f0       	mov    0xf05550d8,%eax
f01075a9:	89 c2                	mov    %eax,%edx
f01075ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075ae:	01 d0                	add    %edx,%eax
f01075b0:	48                   	dec    %eax
f01075b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01075b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01075b7:	ba 00 00 00 00       	mov    $0x0,%edx
f01075bc:	f7 75 f4             	divl   -0xc(%ebp)
f01075bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01075c2:	29 d0                	sub    %edx,%eax
f01075c4:	a3 d8 50 55 f0       	mov    %eax,0xf05550d8

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f01075c9:	a1 d8 50 55 f0       	mov    0xf05550d8,%eax
f01075ce:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f01075d1:	8b 15 d8 50 55 f0    	mov    0xf05550d8,%edx
f01075d7:	8b 45 08             	mov    0x8(%ebp),%eax
f01075da:	01 d0                	add    %edx,%eax
f01075dc:	a3 d8 50 55 f0       	mov    %eax,0xf05550d8

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f01075e1:	83 ec 04             	sub    $0x4,%esp
f01075e4:	ff 75 08             	pushl  0x8(%ebp)
f01075e7:	6a 00                	push   $0x0
f01075e9:	ff 75 ec             	pushl  -0x14(%ebp)
f01075ec:	e8 4e 91 01 00       	call   f012073f <memset>
f01075f1:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f01075f4:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f01075f7:	c9                   	leave  
f01075f8:	c3                   	ret    

f01075f9 <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f01075f9:	55                   	push   %ebp
f01075fa:	89 e5                	mov    %esp,%ebp
f01075fc:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f01075ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107606:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010760d:	eb 53                	jmp    f0107662 <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f010760f:	83 ec 04             	sub    $0x4,%esp
f0107612:	6a 01                	push   $0x1
f0107614:	ff 75 0c             	pushl  0xc(%ebp)
f0107617:	ff 75 08             	pushl  0x8(%ebp)
f010761a:	e8 4e 00 00 00       	call   f010766d <boot_get_page_table>
f010761f:	83 c4 10             	add    $0x10,%esp
f0107622:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f0107625:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107628:	c1 e8 0c             	shr    $0xc,%eax
f010762b:	25 ff 03 00 00       	and    $0x3ff,%eax
f0107630:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f0107633:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107636:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010763d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107640:	01 c2                	add    %eax,%edx
f0107642:	8b 45 18             	mov    0x18(%ebp),%eax
f0107645:	0b 45 14             	or     0x14(%ebp),%eax
f0107648:	83 c8 01             	or     $0x1,%eax
f010764b:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f010764d:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f0107654:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f010765b:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0107662:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107665:	3b 45 10             	cmp    0x10(%ebp),%eax
f0107668:	72 a5                	jb     f010760f <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f010766a:	90                   	nop
f010766b:	c9                   	leave  
f010766c:	c3                   	ret    

f010766d <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f010766d:	55                   	push   %ebp
f010766e:	89 e5                	mov    %esp,%ebp
f0107670:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f0107673:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107676:	c1 e8 16             	shr    $0x16,%eax
f0107679:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f010767c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010767f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107686:	8b 45 08             	mov    0x8(%ebp),%eax
f0107689:	01 d0                	add    %edx,%eax
f010768b:	8b 00                	mov    (%eax),%eax
f010768d:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f0107690:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107693:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107698:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f010769b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010769e:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01076a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01076a4:	c1 e8 0c             	shr    $0xc,%eax
f01076a7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01076aa:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f01076af:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01076b2:	72 17                	jb     f01076cb <boot_get_page_table+0x5e>
f01076b4:	ff 75 e8             	pushl  -0x18(%ebp)
f01076b7:	68 5c 49 12 f0       	push   $0xf012495c
f01076bc:	68 33 01 00 00       	push   $0x133
f01076c1:	68 14 49 12 f0       	push   $0xf0124914
f01076c6:	e8 4f 8c ff ff       	call   f010031a <_panic>
f01076cb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01076ce:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01076d3:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f01076d6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01076da:	75 72                	jne    f010774e <boot_get_page_table+0xe1>
	{
		if (create)
f01076dc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01076e0:	74 65                	je     f0107747 <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f01076e2:	83 ec 08             	sub    $0x8,%esp
f01076e5:	68 00 10 00 00       	push   $0x1000
f01076ea:	68 00 10 00 00       	push   $0x1000
f01076ef:	e8 91 fe ff ff       	call   f0107585 <boot_allocate_space>
f01076f4:	83 c4 10             	add    $0x10,%esp
f01076f7:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f01076fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01076fd:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0107700:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107707:	77 17                	ja     f0107720 <boot_get_page_table+0xb3>
f0107709:	ff 75 dc             	pushl  -0x24(%ebp)
f010770c:	68 e0 48 12 f0       	push   $0xf01248e0
f0107711:	68 39 01 00 00       	push   $0x139
f0107716:	68 14 49 12 f0       	push   $0xf0124914
f010771b:	e8 fa 8b ff ff       	call   f010031a <_panic>
f0107720:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107723:	05 00 00 00 10       	add    $0x10000000,%eax
f0107728:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f010772b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010772e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107735:	8b 45 08             	mov    0x8(%ebp),%eax
f0107738:	01 d0                	add    %edx,%eax
f010773a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010773d:	83 ca 03             	or     $0x3,%edx
f0107740:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f0107742:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107745:	eb 0a                	jmp    f0107751 <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f0107747:	b8 00 00 00 00       	mov    $0x0,%eax
f010774c:	eb 03                	jmp    f0107751 <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f010774e:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0107751:	c9                   	leave  
f0107752:	c3                   	ret    

f0107753 <nvram_read>:


int nvram_read(int r)
{
f0107753:	55                   	push   %ebp
f0107754:	89 e5                	mov    %esp,%ebp
f0107756:	53                   	push   %ebx
f0107757:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f010775a:	8b 45 08             	mov    0x8(%ebp),%eax
f010775d:	83 ec 0c             	sub    $0xc,%esp
f0107760:	50                   	push   %eax
f0107761:	e8 12 d1 ff ff       	call   f0104878 <mc146818_read>
f0107766:	83 c4 10             	add    $0x10,%esp
f0107769:	89 c3                	mov    %eax,%ebx
f010776b:	8b 45 08             	mov    0x8(%ebp),%eax
f010776e:	40                   	inc    %eax
f010776f:	83 ec 0c             	sub    $0xc,%esp
f0107772:	50                   	push   %eax
f0107773:	e8 00 d1 ff ff       	call   f0104878 <mc146818_read>
f0107778:	83 c4 10             	add    $0x10,%esp
f010777b:	c1 e0 08             	shl    $0x8,%eax
f010777e:	09 d8                	or     %ebx,%eax
}
f0107780:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107783:	c9                   	leave  
f0107784:	c3                   	ret    

f0107785 <detect_memory>:

void detect_memory()
{
f0107785:	55                   	push   %ebp
f0107786:	89 e5                	mov    %esp,%ebp
f0107788:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f010778b:	83 ec 0c             	sub    $0xc,%esp
f010778e:	6a 15                	push   $0x15
f0107790:	e8 be ff ff ff       	call   f0107753 <nvram_read>
f0107795:	83 c4 10             	add    $0x10,%esp
f0107798:	c1 e0 0a             	shl    $0xa,%eax
f010779b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010779e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01077a1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01077a6:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f01077a9:	83 ec 0c             	sub    $0xc,%esp
f01077ac:	6a 17                	push   $0x17
f01077ae:	e8 a0 ff ff ff       	call   f0107753 <nvram_read>
f01077b3:	83 c4 10             	add    $0x10,%esp
f01077b6:	c1 e0 0a             	shl    $0xa,%eax
f01077b9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01077bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01077bf:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01077c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f01077c7:	83 ec 0c             	sub    $0xc,%esp
f01077ca:	6a 34                	push   $0x34
f01077cc:	e8 82 ff ff ff       	call   f0107753 <nvram_read>
f01077d1:	83 c4 10             	add    $0x10,%esp
f01077d4:	c1 e0 10             	shl    $0x10,%eax
f01077d7:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01077da:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01077dd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01077e2:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f01077e5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01077e9:	74 18                	je     f0107803 <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f01077eb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01077ee:	05 00 00 00 01       	add    $0x1000000,%eax
f01077f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f01077f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077f9:	2d 00 00 10 00       	sub    $0x100000,%eax
f01077fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107801:	eb 19                	jmp    f010781c <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0107803:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107807:	74 0d                	je     f0107816 <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f0107809:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010780c:	05 00 00 10 00       	add    $0x100000,%eax
f0107811:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107814:	eb 06                	jmp    f010781c <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0107816:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107819:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f010781c:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	if(USE_KHEAP == 0 && maxpa > kernel_virtual_area)
f0107823:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107826:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0107829:	76 32                	jbe    f010785d <detect_memory+0xd8>
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
f010782b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010782e:	c1 e8 0a             	shr    $0xa,%eax
f0107831:	89 c2                	mov    %eax,%edx
f0107833:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107836:	c1 e8 0a             	shr    $0xa,%eax
f0107839:	83 ec 04             	sub    $0x4,%esp
f010783c:	52                   	push   %edx
f010783d:	50                   	push   %eax
f010783e:	68 8c 49 12 f0       	push   $0xf012498c
f0107843:	e8 24 97 ff ff       	call   f0100f6c <cprintf>
f0107848:	83 c4 10             	add    $0x10,%esp
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
f010784b:	83 ec 0c             	sub    $0xc,%esp
f010784e:	68 d4 49 12 f0       	push   $0xf01249d4
f0107853:	e8 14 97 ff ff       	call   f0100f6c <cprintf>
f0107858:	83 c4 10             	add    $0x10,%esp
		while(1);
f010785b:	eb fe                	jmp    f010785b <detect_memory+0xd6>
	}
	number_of_frames = maxpa / PAGE_SIZE;
f010785d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107860:	c1 e8 0c             	shr    $0xc,%eax
f0107863:	a3 b8 4c 55 f0       	mov    %eax,0xf0554cb8

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f0107868:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010786b:	c1 e8 0a             	shr    $0xa,%eax
f010786e:	83 ec 08             	sub    $0x8,%esp
f0107871:	50                   	push   %eax
f0107872:	68 6c 4a 12 f0       	push   $0xf0124a6c
f0107877:	e8 f0 96 ff ff       	call   f0100f6c <cprintf>
f010787c:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f010787f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107882:	c1 e8 0a             	shr    $0xa,%eax
f0107885:	89 c2                	mov    %eax,%edx
f0107887:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010788a:	c1 e8 0a             	shr    $0xa,%eax
f010788d:	83 ec 04             	sub    $0x4,%esp
f0107890:	52                   	push   %edx
f0107891:	50                   	push   %eax
f0107892:	68 8f 4a 12 f0       	push   $0xf0124a8f
f0107897:	e8 d0 96 ff ff       	call   f0100f6c <cprintf>
f010789c:	83 c4 10             	add    $0x10,%esp
}
f010789f:	90                   	nop
f01078a0:	c9                   	leave  
f01078a1:	c3                   	ret    

f01078a2 <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f01078a2:	55                   	push   %ebp
f01078a3:	89 e5                	mov    %esp,%ebp
f01078a5:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f01078a8:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f01078af:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f01078b6:	eb 24                	jmp    f01078dc <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f01078b8:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f01078bd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01078c0:	c1 e2 02             	shl    $0x2,%edx
f01078c3:	01 c2                	add    %eax,%edx
f01078c5:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f01078ca:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01078cd:	c1 e1 02             	shl    $0x2,%ecx
f01078d0:	01 c8                	add    %ecx,%eax
f01078d2:	8b 00                	mov    (%eax),%eax
f01078d4:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f01078d6:	ff 45 f4             	incl   -0xc(%ebp)
f01078d9:	ff 45 f0             	incl   -0x10(%ebp)
f01078dc:	a1 d8 50 55 f0       	mov    0xf05550d8,%eax
f01078e1:	c1 e8 16             	shr    $0x16,%eax
f01078e4:	89 c2                	mov    %eax,%edx
f01078e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078e9:	39 c2                	cmp    %eax,%edx
f01078eb:	77 cb                	ja     f01078b8 <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f01078ed:	a1 e4 51 55 f0       	mov    0xf05551e4,%eax
f01078f2:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01078f5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01078f8:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f01078fb:	0f 20 c0             	mov    %cr0,%eax
f01078fe:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0107901:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f0107904:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f0107907:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f010790e:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f0107912:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107915:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f0107918:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010791b:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f010791e:	e8 bb f5 ff ff       	call   f0106ede <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0107923:	e8 f3 f4 ff ff       	call   f0106e1b <mycpu>
f0107928:	83 c0 74             	add    $0x74,%eax
f010792b:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010792e:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0107935:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107938:	48                   	dec    %eax
f0107939:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f010793d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107940:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0107944:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107947:	c1 e8 10             	shr    $0x10,%eax
f010794a:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f010794e:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0107951:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0107954:	e8 d7 f5 ff ff       	call   f0106f30 <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0107959:	b8 23 00 00 00       	mov    $0x23,%eax
f010795e:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0107960:	b8 23 00 00 00       	mov    $0x23,%eax
f0107965:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0107967:	b8 10 00 00 00       	mov    $0x10,%eax
f010796c:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f010796e:	b8 10 00 00 00       	mov    $0x10,%eax
f0107973:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0107975:	b8 10 00 00 00       	mov    $0x10,%eax
f010797a:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f010797c:	ea 83 79 10 f0 08 00 	ljmp   $0x8,$0xf0107983
	asm volatile("lldt %%ax" :: "a" (0));
f0107983:	b8 00 00 00 00       	mov    $0x0,%eax
f0107988:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f010798b:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0107992:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107999:	eb 19                	jmp    f01079b4 <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f010799b:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f01079a0:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01079a3:	c1 e2 02             	shl    $0x2,%edx
f01079a6:	01 d0                	add    %edx,%eax
f01079a8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f01079ae:	ff 45 ec             	incl   -0x14(%ebp)
f01079b1:	ff 45 e8             	incl   -0x18(%ebp)
f01079b4:	a1 d8 50 55 f0       	mov    0xf05550d8,%eax
f01079b9:	c1 e8 16             	shr    $0x16,%eax
f01079bc:	89 c2                	mov    %eax,%edx
f01079be:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01079c1:	39 c2                	cmp    %eax,%edx
f01079c3:	77 d6                	ja     f010799b <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f01079c5:	a1 e4 51 55 f0       	mov    0xf05551e4,%eax
f01079ca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01079cd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01079d0:	0f 22 d8             	mov    %eax,%cr3

}
f01079d3:	90                   	nop
f01079d4:	c9                   	leave  
f01079d5:	c3                   	ret    

f01079d6 <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f01079d6:	55                   	push   %ebp
f01079d7:	89 e5                	mov    %esp,%ebp
f01079d9:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f01079dc:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f01079e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01079e4:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f01079eb:	77 17                	ja     f0107a04 <setup_listing_to_all_page_tables_entries+0x2e>
f01079ed:	ff 75 f4             	pushl  -0xc(%ebp)
f01079f0:	68 e0 48 12 f0       	push   $0xf01248e0
f01079f5:	68 cf 01 00 00       	push   $0x1cf
f01079fa:	68 14 49 12 f0       	push   $0xf0124914
f01079ff:	e8 16 89 ff ff       	call   f010031a <_panic>
f0107a04:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a07:	05 00 00 00 10       	add    $0x10000000,%eax
f0107a0c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f0107a0f:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0107a14:	05 fc 0e 00 00       	add    $0xefc,%eax
f0107a19:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107a1c:	83 ca 03             	or     $0x3,%edx
f0107a1f:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0107a21:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0107a26:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f0107a2c:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0107a31:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107a34:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f0107a3b:	77 17                	ja     f0107a54 <setup_listing_to_all_page_tables_entries+0x7e>
f0107a3d:	ff 75 ec             	pushl  -0x14(%ebp)
f0107a40:	68 e0 48 12 f0       	push   $0xf01248e0
f0107a45:	68 d4 01 00 00       	push   $0x1d4
f0107a4a:	68 14 49 12 f0       	push   $0xf0124914
f0107a4f:	e8 c6 88 ff ff       	call   f010031a <_panic>
f0107a54:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107a57:	05 00 00 00 10       	add    $0x10000000,%eax
f0107a5c:	83 c8 05             	or     $0x5,%eax
f0107a5f:	89 02                	mov    %eax,(%edx)

}
f0107a61:	90                   	nop
f0107a62:	c9                   	leave  
f0107a63:	c3                   	ret    

f0107a64 <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0107a64:	55                   	push   %ebp
f0107a65:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0107a67:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a6a:	8b 15 20 4f 55 f0    	mov    0xf0554f20,%edx
f0107a70:	29 d0                	sub    %edx,%eax
f0107a72:	c1 f8 03             	sar    $0x3,%eax
f0107a75:	89 c2                	mov    %eax,%edx
f0107a77:	89 d0                	mov    %edx,%eax
f0107a79:	c1 e0 02             	shl    $0x2,%eax
f0107a7c:	01 d0                	add    %edx,%eax
f0107a7e:	c1 e0 02             	shl    $0x2,%eax
f0107a81:	01 d0                	add    %edx,%eax
f0107a83:	c1 e0 02             	shl    $0x2,%eax
f0107a86:	01 d0                	add    %edx,%eax
f0107a88:	89 c1                	mov    %eax,%ecx
f0107a8a:	c1 e1 08             	shl    $0x8,%ecx
f0107a8d:	01 c8                	add    %ecx,%eax
f0107a8f:	89 c1                	mov    %eax,%ecx
f0107a91:	c1 e1 10             	shl    $0x10,%ecx
f0107a94:	01 c8                	add    %ecx,%eax
f0107a96:	01 c0                	add    %eax,%eax
f0107a98:	01 d0                	add    %edx,%eax
}
f0107a9a:	5d                   	pop    %ebp
f0107a9b:	c3                   	ret    

f0107a9c <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0107a9c:	55                   	push   %ebp
f0107a9d:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0107a9f:	ff 75 08             	pushl  0x8(%ebp)
f0107aa2:	e8 bd ff ff ff       	call   f0107a64 <to_frame_number>
f0107aa7:	83 c4 04             	add    $0x4,%esp
f0107aaa:	c1 e0 0c             	shl    $0xc,%eax
}
f0107aad:	c9                   	leave  
f0107aae:	c3                   	ret    

f0107aaf <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0107aaf:	55                   	push   %ebp
f0107ab0:	89 e5                	mov    %esp,%ebp
f0107ab2:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0107ab5:	8b 45 08             	mov    0x8(%ebp),%eax
f0107ab8:	c1 e8 0c             	shr    $0xc,%eax
f0107abb:	89 c2                	mov    %eax,%edx
f0107abd:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0107ac2:	39 c2                	cmp    %eax,%edx
f0107ac4:	72 14                	jb     f0107ada <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0107ac6:	83 ec 04             	sub    $0x4,%esp
f0107ac9:	68 ac 4a 12 f0       	push   $0xf0124aac
f0107ace:	6a 55                	push   $0x55
f0107ad0:	68 d1 4a 12 f0       	push   $0xf0124ad1
f0107ad5:	e8 40 88 ff ff       	call   f010031a <_panic>
	return &frames_info[PPN(physical_address)];
f0107ada:	8b 15 20 4f 55 f0    	mov    0xf0554f20,%edx
f0107ae0:	8b 45 08             	mov    0x8(%ebp),%eax
f0107ae3:	c1 e8 0c             	shr    $0xc,%eax
f0107ae6:	89 c1                	mov    %eax,%ecx
f0107ae8:	89 c8                	mov    %ecx,%eax
f0107aea:	01 c0                	add    %eax,%eax
f0107aec:	01 c8                	add    %ecx,%eax
f0107aee:	c1 e0 03             	shl    $0x3,%eax
f0107af1:	01 d0                	add    %edx,%eax
}
f0107af3:	c9                   	leave  
f0107af4:	c3                   	ret    

f0107af5 <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f0107af5:	55                   	push   %ebp
f0107af6:	89 e5                	mov    %esp,%ebp
f0107af8:	83 ec 10             	sub    $0x10,%esp
f0107afb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107afe:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0107b01:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0107b04:	0f 01 38             	invlpg (%eax)
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(virtual_address);
}
f0107b07:	90                   	nop
f0107b08:	c9                   	leave  
f0107b09:	c3                   	ret    

f0107b0a <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f0107b0a:	55                   	push   %ebp
f0107b0b:	89 e5                	mov    %esp,%ebp
f0107b0d:	53                   	push   %ebx
f0107b0e:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f0107b11:	c7 05 20 25 55 f0 00 	movl   $0x0,0xf0552520
f0107b18:	00 00 00 
f0107b1b:	c7 05 24 25 55 f0 00 	movl   $0x0,0xf0552524
f0107b22:	00 00 00 
f0107b25:	c7 05 2c 25 55 f0 00 	movl   $0x0,0xf055252c
f0107b2c:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f0107b2f:	c7 05 30 25 55 f0 00 	movl   $0x0,0xf0552530
f0107b36:	00 00 00 
f0107b39:	c7 05 34 25 55 f0 00 	movl   $0x0,0xf0552534
f0107b40:	00 00 00 
f0107b43:	c7 05 3c 25 55 f0 00 	movl   $0x0,0xf055253c
f0107b4a:	00 00 00 

	//Initialize the corresponding lock
	init_spinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f0107b4d:	83 ec 08             	sub    $0x8,%esp
f0107b50:	68 eb 4a 12 f0       	push   $0xf0124aeb
f0107b55:	68 40 25 55 f0       	push   $0xf0552540
f0107b5a:	e8 0e 6c 00 00       	call   f010e76d <init_spinlock>
f0107b5f:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0107b62:	a1 20 4f 55 f0       	mov    0xf0554f20,%eax
f0107b67:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f0107b6d:	a1 20 4f 55 f0       	mov    0xf0554f20,%eax
f0107b72:	83 c0 18             	add    $0x18,%eax
f0107b75:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f0107b7b:	a1 20 4f 55 f0       	mov    0xf0554f20,%eax
f0107b80:	83 c0 30             	add    $0x30,%eax
f0107b83:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0107b89:	c7 05 b4 4f 55 f0 00 	movl   $0xf0001000,0xf0554fb4
f0107b90:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0107b93:	c7 05 64 51 55 f0 00 	movl   $0xf0002000,0xf0555164
f0107b9a:	20 00 f0 
	i =0;
f0107b9d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0107ba4:	eb 1f                	jmp    f0107bc5 <initialize_paging+0xbb>
	{
		ptr_zero_page[i]=0;
f0107ba6:	8b 15 b4 4f 55 f0    	mov    0xf0554fb4,%edx
f0107bac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107baf:	01 d0                	add    %edx,%eax
f0107bb1:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f0107bb4:	8b 15 64 51 55 f0    	mov    0xf0555164,%edx
f0107bba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107bbd:	01 d0                	add    %edx,%eax
f0107bbf:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f0107bc2:	ff 45 f4             	incl   -0xc(%ebp)
f0107bc5:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0107bcc:	7e d8                	jle    f0107ba6 <initialize_paging+0x9c>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f0107bce:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0107bd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107bd8:	05 ff ff 09 00       	add    $0x9ffff,%eax
f0107bdd:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107be0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107be3:	ba 00 00 00 00       	mov    $0x0,%edx
f0107be8:	f7 75 f0             	divl   -0x10(%ebp)
f0107beb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107bee:	29 d0                	sub    %edx,%eax
f0107bf0:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107bf3:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0107bfa:	e9 e8 00 00 00       	jmp    f0107ce7 <initialize_paging+0x1dd>
	{

		initialize_frame_info(&(frames_info[i]));
f0107bff:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107c05:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107c08:	89 d0                	mov    %edx,%eax
f0107c0a:	01 c0                	add    %eax,%eax
f0107c0c:	01 d0                	add    %edx,%eax
f0107c0e:	c1 e0 03             	shl    $0x3,%eax
f0107c11:	01 c8                	add    %ecx,%eax
f0107c13:	83 ec 0c             	sub    $0xc,%esp
f0107c16:	50                   	push   %eax
f0107c17:	e8 b7 02 00 00       	call   f0107ed3 <initialize_frame_info>
f0107c1c:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0107c1f:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107c25:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107c28:	89 d0                	mov    %edx,%eax
f0107c2a:	01 c0                	add    %eax,%eax
f0107c2c:	01 d0                	add    %edx,%eax
f0107c2e:	c1 e0 03             	shl    $0x3,%eax
f0107c31:	01 c8                	add    %ecx,%eax
f0107c33:	85 c0                	test   %eax,%eax
f0107c35:	75 14                	jne    f0107c4b <initialize_paging+0x141>
f0107c37:	83 ec 04             	sub    $0x4,%esp
f0107c3a:	68 fc 4a 12 f0       	push   $0xf0124afc
f0107c3f:	6a 60                	push   $0x60
f0107c41:	68 1f 4b 12 f0       	push   $0xf0124b1f
f0107c46:	e8 cf 86 ff ff       	call   f010031a <_panic>
f0107c4b:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107c51:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107c54:	89 d0                	mov    %edx,%eax
f0107c56:	01 c0                	add    %eax,%eax
f0107c58:	01 d0                	add    %edx,%eax
f0107c5a:	c1 e0 03             	shl    $0x3,%eax
f0107c5d:	01 c8                	add    %ecx,%eax
f0107c5f:	8b 15 20 25 55 f0    	mov    0xf0552520,%edx
f0107c65:	89 10                	mov    %edx,(%eax)
f0107c67:	8b 00                	mov    (%eax),%eax
f0107c69:	85 c0                	test   %eax,%eax
f0107c6b:	74 1f                	je     f0107c8c <initialize_paging+0x182>
f0107c6d:	8b 15 20 25 55 f0    	mov    0xf0552520,%edx
f0107c73:	8b 1d 20 4f 55 f0    	mov    0xf0554f20,%ebx
f0107c79:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107c7c:	89 c8                	mov    %ecx,%eax
f0107c7e:	01 c0                	add    %eax,%eax
f0107c80:	01 c8                	add    %ecx,%eax
f0107c82:	c1 e0 03             	shl    $0x3,%eax
f0107c85:	01 d8                	add    %ebx,%eax
f0107c87:	89 42 04             	mov    %eax,0x4(%edx)
f0107c8a:	eb 19                	jmp    f0107ca5 <initialize_paging+0x19b>
f0107c8c:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107c92:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107c95:	89 d0                	mov    %edx,%eax
f0107c97:	01 c0                	add    %eax,%eax
f0107c99:	01 d0                	add    %edx,%eax
f0107c9b:	c1 e0 03             	shl    $0x3,%eax
f0107c9e:	01 c8                	add    %ecx,%eax
f0107ca0:	a3 24 25 55 f0       	mov    %eax,0xf0552524
f0107ca5:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107cab:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107cae:	89 d0                	mov    %edx,%eax
f0107cb0:	01 c0                	add    %eax,%eax
f0107cb2:	01 d0                	add    %edx,%eax
f0107cb4:	c1 e0 03             	shl    $0x3,%eax
f0107cb7:	01 c8                	add    %ecx,%eax
f0107cb9:	a3 20 25 55 f0       	mov    %eax,0xf0552520
f0107cbe:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107cc4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107cc7:	89 d0                	mov    %edx,%eax
f0107cc9:	01 c0                	add    %eax,%eax
f0107ccb:	01 d0                	add    %edx,%eax
f0107ccd:	c1 e0 03             	shl    $0x3,%eax
f0107cd0:	01 c8                	add    %ecx,%eax
f0107cd2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0107cd9:	a1 2c 25 55 f0       	mov    0xf055252c,%eax
f0107cde:	40                   	inc    %eax
f0107cdf:	a3 2c 25 55 f0       	mov    %eax,0xf055252c
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107ce4:	ff 45 f4             	incl   -0xc(%ebp)
f0107ce7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107cea:	85 c0                	test   %eax,%eax
f0107cec:	79 05                	jns    f0107cf3 <initialize_paging+0x1e9>
f0107cee:	05 ff 0f 00 00       	add    $0xfff,%eax
f0107cf3:	c1 f8 0c             	sar    $0xc,%eax
f0107cf6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0107cf9:	0f 8f 00 ff ff ff    	jg     f0107bff <initialize_paging+0xf5>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107cff:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f0107d06:	eb 1d                	jmp    f0107d25 <initialize_paging+0x21b>
	{
		frames_info[i].references = 1;
f0107d08:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107d0e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107d11:	89 d0                	mov    %edx,%eax
f0107d13:	01 c0                	add    %eax,%eax
f0107d15:	01 d0                	add    %edx,%eax
f0107d17:	c1 e0 03             	shl    $0x3,%eax
f0107d1a:	01 c8                	add    %ecx,%eax
f0107d1c:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107d22:	ff 45 f4             	incl   -0xc(%ebp)
f0107d25:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0107d2c:	7e da                	jle    f0107d08 <initialize_paging+0x1fe>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f0107d2e:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0107d35:	a1 d8 50 55 f0       	mov    0xf05550d8,%eax
f0107d3a:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107d3d:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0107d44:	77 14                	ja     f0107d5a <initialize_paging+0x250>
f0107d46:	ff 75 e0             	pushl  -0x20(%ebp)
f0107d49:	68 3c 4b 12 f0       	push   $0xf0124b3c
f0107d4e:	6a 68                	push   $0x68
f0107d50:	68 1f 4b 12 f0       	push   $0xf0124b1f
f0107d55:	e8 c0 85 ff ff       	call   f010031a <_panic>
f0107d5a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107d5d:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0107d63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107d66:	01 d0                	add    %edx,%eax
f0107d68:	48                   	dec    %eax
f0107d69:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0107d6c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107d6f:	ba 00 00 00 00       	mov    $0x0,%edx
f0107d74:	f7 75 e4             	divl   -0x1c(%ebp)
f0107d77:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107d7a:	29 d0                	sub    %edx,%eax
f0107d7c:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0107d7f:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f0107d86:	eb 1d                	jmp    f0107da5 <initialize_paging+0x29b>
	{
		frames_info[i].references = 1;
f0107d88:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107d8e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107d91:	89 d0                	mov    %edx,%eax
f0107d93:	01 c0                	add    %eax,%eax
f0107d95:	01 d0                	add    %edx,%eax
f0107d97:	c1 e0 03             	shl    $0x3,%eax
f0107d9a:	01 c8                	add    %ecx,%eax
f0107d9c:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0107da2:	ff 45 f4             	incl   -0xc(%ebp)
f0107da5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107da8:	85 c0                	test   %eax,%eax
f0107daa:	79 05                	jns    f0107db1 <initialize_paging+0x2a7>
f0107dac:	05 ff 0f 00 00       	add    $0xfff,%eax
f0107db1:	c1 f8 0c             	sar    $0xc,%eax
f0107db4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0107db7:	7f cf                	jg     f0107d88 <initialize_paging+0x27e>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0107db9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107dbc:	85 c0                	test   %eax,%eax
f0107dbe:	79 05                	jns    f0107dc5 <initialize_paging+0x2bb>
f0107dc0:	05 ff 0f 00 00       	add    $0xfff,%eax
f0107dc5:	c1 f8 0c             	sar    $0xc,%eax
f0107dc8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107dcb:	e9 e8 00 00 00       	jmp    f0107eb8 <initialize_paging+0x3ae>
	{
		initialize_frame_info(&(frames_info[i]));
f0107dd0:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107dd6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107dd9:	89 d0                	mov    %edx,%eax
f0107ddb:	01 c0                	add    %eax,%eax
f0107ddd:	01 d0                	add    %edx,%eax
f0107ddf:	c1 e0 03             	shl    $0x3,%eax
f0107de2:	01 c8                	add    %ecx,%eax
f0107de4:	83 ec 0c             	sub    $0xc,%esp
f0107de7:	50                   	push   %eax
f0107de8:	e8 e6 00 00 00       	call   f0107ed3 <initialize_frame_info>
f0107ded:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0107df0:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107df6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107df9:	89 d0                	mov    %edx,%eax
f0107dfb:	01 c0                	add    %eax,%eax
f0107dfd:	01 d0                	add    %edx,%eax
f0107dff:	c1 e0 03             	shl    $0x3,%eax
f0107e02:	01 c8                	add    %ecx,%eax
f0107e04:	85 c0                	test   %eax,%eax
f0107e06:	75 14                	jne    f0107e1c <initialize_paging+0x312>
f0107e08:	83 ec 04             	sub    $0x4,%esp
f0107e0b:	68 fc 4a 12 f0       	push   $0xf0124afc
f0107e10:	6a 74                	push   $0x74
f0107e12:	68 1f 4b 12 f0       	push   $0xf0124b1f
f0107e17:	e8 fe 84 ff ff       	call   f010031a <_panic>
f0107e1c:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107e22:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107e25:	89 d0                	mov    %edx,%eax
f0107e27:	01 c0                	add    %eax,%eax
f0107e29:	01 d0                	add    %edx,%eax
f0107e2b:	c1 e0 03             	shl    $0x3,%eax
f0107e2e:	01 c8                	add    %ecx,%eax
f0107e30:	8b 15 20 25 55 f0    	mov    0xf0552520,%edx
f0107e36:	89 10                	mov    %edx,(%eax)
f0107e38:	8b 00                	mov    (%eax),%eax
f0107e3a:	85 c0                	test   %eax,%eax
f0107e3c:	74 1f                	je     f0107e5d <initialize_paging+0x353>
f0107e3e:	8b 15 20 25 55 f0    	mov    0xf0552520,%edx
f0107e44:	8b 1d 20 4f 55 f0    	mov    0xf0554f20,%ebx
f0107e4a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107e4d:	89 c8                	mov    %ecx,%eax
f0107e4f:	01 c0                	add    %eax,%eax
f0107e51:	01 c8                	add    %ecx,%eax
f0107e53:	c1 e0 03             	shl    $0x3,%eax
f0107e56:	01 d8                	add    %ebx,%eax
f0107e58:	89 42 04             	mov    %eax,0x4(%edx)
f0107e5b:	eb 19                	jmp    f0107e76 <initialize_paging+0x36c>
f0107e5d:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107e63:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107e66:	89 d0                	mov    %edx,%eax
f0107e68:	01 c0                	add    %eax,%eax
f0107e6a:	01 d0                	add    %edx,%eax
f0107e6c:	c1 e0 03             	shl    $0x3,%eax
f0107e6f:	01 c8                	add    %ecx,%eax
f0107e71:	a3 24 25 55 f0       	mov    %eax,0xf0552524
f0107e76:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107e7c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107e7f:	89 d0                	mov    %edx,%eax
f0107e81:	01 c0                	add    %eax,%eax
f0107e83:	01 d0                	add    %edx,%eax
f0107e85:	c1 e0 03             	shl    $0x3,%eax
f0107e88:	01 c8                	add    %ecx,%eax
f0107e8a:	a3 20 25 55 f0       	mov    %eax,0xf0552520
f0107e8f:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107e95:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107e98:	89 d0                	mov    %edx,%eax
f0107e9a:	01 c0                	add    %eax,%eax
f0107e9c:	01 d0                	add    %edx,%eax
f0107e9e:	c1 e0 03             	shl    $0x3,%eax
f0107ea1:	01 c8                	add    %ecx,%eax
f0107ea3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0107eaa:	a1 2c 25 55 f0       	mov    0xf055252c,%eax
f0107eaf:	40                   	inc    %eax
f0107eb0:	a3 2c 25 55 f0       	mov    %eax,0xf055252c
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0107eb5:	ff 45 f4             	incl   -0xc(%ebp)
f0107eb8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107ebb:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0107ec0:	39 c2                	cmp    %eax,%edx
f0107ec2:	0f 82 08 ff ff ff    	jb     f0107dd0 <initialize_paging+0x2c6>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f0107ec8:	e8 ef b9 ff ff       	call   f01038bc <initialize_disk_page_file>
}
f0107ecd:	90                   	nop
f0107ece:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107ed1:	c9                   	leave  
f0107ed2:	c3                   	ret    

f0107ed3 <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f0107ed3:	55                   	push   %ebp
f0107ed4:	89 e5                	mov    %esp,%ebp
f0107ed6:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f0107ed9:	83 ec 04             	sub    $0x4,%esp
f0107edc:	6a 18                	push   $0x18
f0107ede:	6a 00                	push   $0x0
f0107ee0:	ff 75 08             	pushl  0x8(%ebp)
f0107ee3:	e8 57 88 01 00       	call   f012073f <memset>
f0107ee8:	83 c4 10             	add    $0x10,%esp
}
f0107eeb:	90                   	nop
f0107eec:	c9                   	leave  
f0107eed:	c3                   	ret    

f0107eee <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f0107eee:	55                   	push   %ebp
f0107eef:	89 e5                	mov    %esp,%ebp
f0107ef1:	83 ec 18             	sub    $0x18,%esp
	//cprintf("allocate_frame...\n");

	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f0107ef4:	83 ec 0c             	sub    $0xc,%esp
f0107ef7:	68 40 25 55 f0       	push   $0xf0552540
f0107efc:	e8 b6 6a 00 00       	call   f010e9b7 <holding_spinlock>
f0107f01:	83 c4 10             	add    $0x10,%esp
f0107f04:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f0107f07:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107f0b:	75 10                	jne    f0107f1d <allocate_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0107f0d:	83 ec 0c             	sub    $0xc,%esp
f0107f10:	68 40 25 55 f0       	push   $0xf0552540
f0107f15:	e8 84 68 00 00       	call   f010e79e <acquire_spinlock>
f0107f1a:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f0107f1d:	8b 15 20 25 55 f0    	mov    0xf0552520,%edx
f0107f23:	8b 45 08             	mov    0x8(%ebp),%eax
f0107f26:	89 10                	mov    %edx,(%eax)
	int c = 0;
f0107f28:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (*ptr_frame_info == NULL)
f0107f2f:	8b 45 08             	mov    0x8(%ebp),%eax
f0107f32:	8b 00                	mov    (%eax),%eax
f0107f34:	85 c0                	test   %eax,%eax
f0107f36:	75 17                	jne    f0107f4f <allocate_frame+0x61>
	{
		//[PROJECT] Free RAM when it's FULL
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f0107f38:	83 ec 04             	sub    $0x4,%esp
f0107f3b:	68 70 4b 12 f0       	push   $0xf0124b70
f0107f40:	68 a2 00 00 00       	push   $0xa2
f0107f45:	68 1f 4b 12 f0       	push   $0xf0124b1f
f0107f4a:	e8 cb 83 ff ff       	call   f010031a <_panic>
		// When allocating new frame, if there's no free frame, then you should:
		//	1-	If any process has exited (those with status ENV_EXIT), then remove one or more of these exited processes from the main memory
		//	2-	otherwise, free at least 1 frame from the user working set by applying the FIFO algorithm
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f0107f4f:	8b 45 08             	mov    0x8(%ebp),%eax
f0107f52:	8b 00                	mov    (%eax),%eax
f0107f54:	85 c0                	test   %eax,%eax
f0107f56:	75 17                	jne    f0107f6f <allocate_frame+0x81>
f0107f58:	83 ec 04             	sub    $0x4,%esp
f0107f5b:	68 bd 4b 12 f0       	push   $0xf0124bbd
f0107f60:	68 a8 00 00 00       	push   $0xa8
f0107f65:	68 1f 4b 12 f0       	push   $0xf0124b1f
f0107f6a:	e8 ab 83 ff ff       	call   f010031a <_panic>
f0107f6f:	8b 45 08             	mov    0x8(%ebp),%eax
f0107f72:	8b 00                	mov    (%eax),%eax
f0107f74:	8b 00                	mov    (%eax),%eax
f0107f76:	85 c0                	test   %eax,%eax
f0107f78:	74 14                	je     f0107f8e <allocate_frame+0xa0>
f0107f7a:	8b 45 08             	mov    0x8(%ebp),%eax
f0107f7d:	8b 00                	mov    (%eax),%eax
f0107f7f:	8b 00                	mov    (%eax),%eax
f0107f81:	8b 55 08             	mov    0x8(%ebp),%edx
f0107f84:	8b 12                	mov    (%edx),%edx
f0107f86:	8b 52 04             	mov    0x4(%edx),%edx
f0107f89:	89 50 04             	mov    %edx,0x4(%eax)
f0107f8c:	eb 0d                	jmp    f0107f9b <allocate_frame+0xad>
f0107f8e:	8b 45 08             	mov    0x8(%ebp),%eax
f0107f91:	8b 00                	mov    (%eax),%eax
f0107f93:	8b 40 04             	mov    0x4(%eax),%eax
f0107f96:	a3 24 25 55 f0       	mov    %eax,0xf0552524
f0107f9b:	8b 45 08             	mov    0x8(%ebp),%eax
f0107f9e:	8b 00                	mov    (%eax),%eax
f0107fa0:	8b 40 04             	mov    0x4(%eax),%eax
f0107fa3:	85 c0                	test   %eax,%eax
f0107fa5:	74 13                	je     f0107fba <allocate_frame+0xcc>
f0107fa7:	8b 45 08             	mov    0x8(%ebp),%eax
f0107faa:	8b 00                	mov    (%eax),%eax
f0107fac:	8b 40 04             	mov    0x4(%eax),%eax
f0107faf:	8b 55 08             	mov    0x8(%ebp),%edx
f0107fb2:	8b 12                	mov    (%edx),%edx
f0107fb4:	8b 12                	mov    (%edx),%edx
f0107fb6:	89 10                	mov    %edx,(%eax)
f0107fb8:	eb 0c                	jmp    f0107fc6 <allocate_frame+0xd8>
f0107fba:	8b 45 08             	mov    0x8(%ebp),%eax
f0107fbd:	8b 00                	mov    (%eax),%eax
f0107fbf:	8b 00                	mov    (%eax),%eax
f0107fc1:	a3 20 25 55 f0       	mov    %eax,0xf0552520
f0107fc6:	8b 45 08             	mov    0x8(%ebp),%eax
f0107fc9:	8b 00                	mov    (%eax),%eax
f0107fcb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0107fd1:	8b 45 08             	mov    0x8(%ebp),%eax
f0107fd4:	8b 00                	mov    (%eax),%eax
f0107fd6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0107fdd:	a1 2c 25 55 f0       	mov    0xf055252c,%eax
f0107fe2:	48                   	dec    %eax
f0107fe3:	a3 2c 25 55 f0       	mov    %eax,0xf055252c

	/******************* PAGE BUFFERING CODE *******************
	 ***********************************************************/
	if((*ptr_frame_info)->isBuffered)
f0107fe8:	8b 45 08             	mov    0x8(%ebp),%eax
f0107feb:	8b 00                	mov    (%eax),%eax
f0107fed:	8a 40 14             	mov    0x14(%eax),%al
f0107ff0:	84 c0                	test   %al,%al
f0107ff2:	74 20                	je     f0108014 <allocate_frame+0x126>
	{
		pt_clear_page_table_entry((*ptr_frame_info)->proc->env_page_directory,(*ptr_frame_info)->bufferedVA);
f0107ff4:	8b 45 08             	mov    0x8(%ebp),%eax
f0107ff7:	8b 00                	mov    (%eax),%eax
f0107ff9:	8b 50 10             	mov    0x10(%eax),%edx
f0107ffc:	8b 45 08             	mov    0x8(%ebp),%eax
f0107fff:	8b 00                	mov    (%eax),%eax
f0108001:	8b 40 0c             	mov    0xc(%eax),%eax
f0108004:	8b 40 64             	mov    0x64(%eax),%eax
f0108007:	83 ec 08             	sub    $0x8,%esp
f010800a:	52                   	push   %edx
f010800b:	50                   	push   %eax
f010800c:	e8 42 09 00 00       	call   f0108953 <pt_clear_page_table_entry>
f0108011:	83 c4 10             	add    $0x10,%esp
		//pt_set_page_permissions((*ptr_frame_info)->environment->env_pgdir, (*ptr_frame_info)->va, 0, PERM_BUFFERED);
	}
	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f0108014:	8b 45 08             	mov    0x8(%ebp),%eax
f0108017:	8b 00                	mov    (%eax),%eax
f0108019:	83 ec 0c             	sub    $0xc,%esp
f010801c:	50                   	push   %eax
f010801d:	e8 b1 fe ff ff       	call   f0107ed3 <initialize_frame_info>
f0108022:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f0108025:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108029:	75 10                	jne    f010803b <allocate_frame+0x14d>
	{
		release_spinlock(&MemFrameLists.mfllock);
f010802b:	83 ec 0c             	sub    $0xc,%esp
f010802e:	68 40 25 55 f0       	push   $0xf0552540
f0108033:	e8 ed 67 00 00       	call   f010e825 <release_spinlock>
f0108038:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f010803b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108040:	c9                   	leave  
f0108041:	c3                   	ret    

f0108042 <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f0108042:	55                   	push   %ebp
f0108043:	89 e5                	mov    %esp,%ebp
f0108045:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f0108048:	83 ec 0c             	sub    $0xc,%esp
f010804b:	68 40 25 55 f0       	push   $0xf0552540
f0108050:	e8 62 69 00 00       	call   f010e9b7 <holding_spinlock>
f0108055:	83 c4 10             	add    $0x10,%esp
f0108058:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f010805b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010805f:	75 10                	jne    f0108071 <free_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108061:	83 ec 0c             	sub    $0xc,%esp
f0108064:	68 40 25 55 f0       	push   $0xf0552540
f0108069:	e8 30 67 00 00       	call   f010e79e <acquire_spinlock>
f010806e:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f0108071:	83 ec 0c             	sub    $0xc,%esp
f0108074:	ff 75 08             	pushl  0x8(%ebp)
f0108077:	e8 57 fe ff ff       	call   f0107ed3 <initialize_frame_info>
f010807c:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f010807f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108083:	75 17                	jne    f010809c <free_frame+0x5a>
f0108085:	83 ec 04             	sub    $0x4,%esp
f0108088:	68 fc 4a 12 f0       	push   $0xf0124afc
f010808d:	68 cf 00 00 00       	push   $0xcf
f0108092:	68 1f 4b 12 f0       	push   $0xf0124b1f
f0108097:	e8 7e 82 ff ff       	call   f010031a <_panic>
f010809c:	8b 15 20 25 55 f0    	mov    0xf0552520,%edx
f01080a2:	8b 45 08             	mov    0x8(%ebp),%eax
f01080a5:	89 10                	mov    %edx,(%eax)
f01080a7:	8b 45 08             	mov    0x8(%ebp),%eax
f01080aa:	8b 00                	mov    (%eax),%eax
f01080ac:	85 c0                	test   %eax,%eax
f01080ae:	74 0d                	je     f01080bd <free_frame+0x7b>
f01080b0:	a1 20 25 55 f0       	mov    0xf0552520,%eax
f01080b5:	8b 55 08             	mov    0x8(%ebp),%edx
f01080b8:	89 50 04             	mov    %edx,0x4(%eax)
f01080bb:	eb 08                	jmp    f01080c5 <free_frame+0x83>
f01080bd:	8b 45 08             	mov    0x8(%ebp),%eax
f01080c0:	a3 24 25 55 f0       	mov    %eax,0xf0552524
f01080c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01080c8:	a3 20 25 55 f0       	mov    %eax,0xf0552520
f01080cd:	8b 45 08             	mov    0x8(%ebp),%eax
f01080d0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01080d7:	a1 2c 25 55 f0       	mov    0xf055252c,%eax
f01080dc:	40                   	inc    %eax
f01080dd:	a3 2c 25 55 f0       	mov    %eax,0xf055252c
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f01080e2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01080e6:	75 10                	jne    f01080f8 <free_frame+0xb6>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01080e8:	83 ec 0c             	sub    $0xc,%esp
f01080eb:	68 40 25 55 f0       	push   $0xf0552540
f01080f0:	e8 30 67 00 00       	call   f010e825 <release_spinlock>
f01080f5:	83 c4 10             	add    $0x10,%esp
	}
}
f01080f8:	90                   	nop
f01080f9:	c9                   	leave  
f01080fa:	c3                   	ret    

f01080fb <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f01080fb:	55                   	push   %ebp
f01080fc:	89 e5                	mov    %esp,%ebp
f01080fe:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f0108101:	8b 45 08             	mov    0x8(%ebp),%eax
f0108104:	8b 40 08             	mov    0x8(%eax),%eax
f0108107:	48                   	dec    %eax
f0108108:	8b 55 08             	mov    0x8(%ebp),%edx
f010810b:	66 89 42 08          	mov    %ax,0x8(%edx)
f010810f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108112:	8b 40 08             	mov    0x8(%eax),%eax
f0108115:	66 85 c0             	test   %ax,%ax
f0108118:	75 0e                	jne    f0108128 <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f010811a:	83 ec 0c             	sub    $0xc,%esp
f010811d:	ff 75 08             	pushl  0x8(%ebp)
f0108120:	e8 1d ff ff ff       	call   f0108042 <free_frame>
f0108125:	83 c4 10             	add    $0x10,%esp
}
f0108128:	90                   	nop
f0108129:	c9                   	leave  
f010812a:	c3                   	ret    

f010812b <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f010812b:	55                   	push   %ebp
f010812c:	89 e5                	mov    %esp,%ebp
f010812e:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108131:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108134:	c1 e8 16             	shr    $0x16,%eax
f0108137:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010813e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108141:	01 d0                	add    %edx,%eax
f0108143:	8b 00                	mov    (%eax),%eax
f0108145:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f0108148:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010814b:	83 e0 01             	and    $0x1,%eax
f010814e:	85 c0                	test   %eax,%eax
f0108150:	74 4e                	je     f01081a0 <get_page_table+0x75>
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108152:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108155:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010815a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010815d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108160:	c1 e8 0c             	shr    $0xc,%eax
f0108163:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108166:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f010816b:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f010816e:	72 17                	jb     f0108187 <get_page_table+0x5c>
f0108170:	ff 75 f0             	pushl  -0x10(%ebp)
f0108173:	68 dc 4b 12 f0       	push   $0xf0124bdc
f0108178:	68 fb 00 00 00       	push   $0xfb
f010817d:	68 1f 4b 12 f0       	push   $0xf0124b1f
f0108182:	e8 93 81 ff ff       	call   f010031a <_panic>
f0108187:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010818a:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010818f:	89 c2                	mov    %eax,%edx
f0108191:	8b 45 10             	mov    0x10(%ebp),%eax
f0108194:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f0108196:	b8 00 00 00 00       	mov    $0x0,%eax
f010819b:	e9 8f 00 00 00       	jmp    f010822f <get_page_table+0x104>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f01081a0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01081a4:	74 7b                	je     f0108221 <get_page_table+0xf6>
f01081a6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01081a9:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f01081ac:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01081af:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f01081b2:	83 ec 0c             	sub    $0xc,%esp
f01081b5:	6a 00                	push   $0x0
f01081b7:	e8 b6 62 00 00       	call   f010e472 <fault_handler>
f01081bc:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01081bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01081c2:	c1 e8 16             	shr    $0x16,%eax
f01081c5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01081cc:	8b 45 08             	mov    0x8(%ebp),%eax
f01081cf:	01 d0                	add    %edx,%eax
f01081d1:	8b 00                	mov    (%eax),%eax
f01081d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01081d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081d9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01081de:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01081e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01081e4:	c1 e8 0c             	shr    $0xc,%eax
f01081e7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01081ea:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f01081ef:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01081f2:	72 17                	jb     f010820b <get_page_table+0xe0>
f01081f4:	ff 75 e8             	pushl  -0x18(%ebp)
f01081f7:	68 dc 4b 12 f0       	push   $0xf0124bdc
f01081fc:	68 13 01 00 00       	push   $0x113
f0108201:	68 1f 4b 12 f0       	push   $0xf0124b1f
f0108206:	e8 0f 81 ff ff       	call   f010031a <_panic>
f010820b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010820e:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108213:	89 c2                	mov    %eax,%edx
f0108215:	8b 45 10             	mov    0x10(%ebp),%eax
f0108218:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f010821a:	b8 00 00 00 00       	mov    $0x0,%eax
f010821f:	eb 0e                	jmp    f010822f <get_page_table+0x104>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f0108221:	8b 45 10             	mov    0x10(%ebp),%eax
f0108224:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f010822a:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f010822f:	c9                   	leave  
f0108230:	c3                   	ret    

f0108231 <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f0108231:	55                   	push   %ebp
f0108232:	89 e5                	mov    %esp,%ebp
f0108234:	83 ec 18             	sub    $0x18,%esp
	memset(ptr_page_table , 0, PAGE_SIZE);
	tlbflush();

#else
	uint32 * ptr_page_table ;
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
f0108237:	83 ec 04             	sub    $0x4,%esp
f010823a:	8d 45 f4             	lea    -0xc(%ebp),%eax
f010823d:	50                   	push   %eax
f010823e:	ff 75 0c             	pushl  0xc(%ebp)
f0108241:	ff 75 08             	pushl  0x8(%ebp)
f0108244:	e8 08 00 00 00       	call   f0108251 <__static_cpt>
f0108249:	83 c4 10             	add    $0x10,%esp
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f010824c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010824f:	c9                   	leave  
f0108250:	c3                   	ret    

f0108251 <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f0108251:	55                   	push   %ebp
f0108252:	89 e5                	mov    %esp,%ebp
f0108254:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f0108257:	83 ec 0c             	sub    $0xc,%esp
f010825a:	8d 45 e0             	lea    -0x20(%ebp),%eax
f010825d:	50                   	push   %eax
f010825e:	e8 8b fc ff ff       	call   f0107eee <allocate_frame>
f0108263:	83 c4 10             	add    $0x10,%esp
f0108266:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f0108269:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010826c:	83 ec 0c             	sub    $0xc,%esp
f010826f:	50                   	push   %eax
f0108270:	e8 27 f8 ff ff       	call   f0107a9c <to_physical_address>
f0108275:	83 c4 10             	add    $0x10,%esp
f0108278:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f010827b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010827e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108281:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108284:	c1 e8 0c             	shr    $0xc,%eax
f0108287:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010828a:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f010828f:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f0108292:	72 17                	jb     f01082ab <__static_cpt+0x5a>
f0108294:	ff 75 ec             	pushl  -0x14(%ebp)
f0108297:	68 dc 4b 12 f0       	push   $0xf0124bdc
f010829c:	68 4e 01 00 00       	push   $0x14e
f01082a1:	68 1f 4b 12 f0       	push   $0xf0124b1f
f01082a6:	e8 6f 80 ff ff       	call   f010031a <_panic>
f01082ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01082ae:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01082b3:	89 c2                	mov    %eax,%edx
f01082b5:	8b 45 10             	mov    0x10(%ebp),%eax
f01082b8:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f01082ba:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01082bd:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f01082c3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01082c6:	c1 e8 16             	shr    $0x16,%eax
f01082c9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01082d0:	8b 45 08             	mov    0x8(%ebp),%eax
f01082d3:	01 d0                	add    %edx,%eax
f01082d5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01082d8:	83 ca 07             	or     $0x7,%edx
f01082db:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f01082dd:	8b 45 10             	mov    0x10(%ebp),%eax
f01082e0:	8b 00                	mov    (%eax),%eax
f01082e2:	83 ec 04             	sub    $0x4,%esp
f01082e5:	68 00 10 00 00       	push   $0x1000
f01082ea:	6a 00                	push   $0x0
f01082ec:	50                   	push   %eax
f01082ed:	e8 4d 84 01 00       	call   f012073f <memset>
f01082f2:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01082f5:	0f 20 d8             	mov    %cr3,%eax
f01082f8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01082fb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01082fe:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f0108301:	90                   	nop
f0108302:	c9                   	leave  
f0108303:	c3                   	ret    

f0108304 <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0108304:	55                   	push   %ebp
f0108305:	89 e5                	mov    %esp,%ebp
f0108307:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f010830a:	ff 75 0c             	pushl  0xc(%ebp)
f010830d:	e8 8a f7 ff ff       	call   f0107a9c <to_physical_address>
f0108312:	83 c4 04             	add    $0x4,%esp
f0108315:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f0108318:	83 ec 04             	sub    $0x4,%esp
f010831b:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010831e:	50                   	push   %eax
f010831f:	ff 75 10             	pushl  0x10(%ebp)
f0108322:	ff 75 08             	pushl  0x8(%ebp)
f0108325:	e8 01 fe ff ff       	call   f010812b <get_page_table>
f010832a:	83 c4 10             	add    $0x10,%esp
f010832d:	83 f8 01             	cmp    $0x1,%eax
f0108330:	75 15                	jne    f0108347 <map_frame+0x43>
			uint32* ptr_page_table2 =NULL;
			//cprintf("======> After the table created at %x\n\n", get_page_table(ptr_page_directory, virtual_address,&ptr_page_table2));
		}
#else
		{
			__static_cpt(ptr_page_directory, (uint32)virtual_address, &ptr_page_table);
f0108332:	83 ec 04             	sub    $0x4,%esp
f0108335:	8d 45 e8             	lea    -0x18(%ebp),%eax
f0108338:	50                   	push   %eax
f0108339:	ff 75 10             	pushl  0x10(%ebp)
f010833c:	ff 75 08             	pushl  0x8(%ebp)
f010833f:	e8 0d ff ff ff       	call   f0108251 <__static_cpt>
f0108344:	83 c4 10             	add    $0x10,%esp
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f0108347:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010834a:	8b 55 10             	mov    0x10(%ebp),%edx
f010834d:	c1 ea 0c             	shr    $0xc,%edx
f0108350:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108356:	c1 e2 02             	shl    $0x2,%edx
f0108359:	01 d0                	add    %edx,%eax
f010835b:	8b 00                	mov    (%eax),%eax
f010835d:	89 45 f0             	mov    %eax,-0x10(%ebp)

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f0108360:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108363:	83 e0 01             	and    $0x1,%eax
f0108366:	85 c0                	test   %eax,%eax
f0108368:	74 25                	je     f010838f <map_frame+0x8b>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f010836a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010836d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108372:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0108375:	75 07                	jne    f010837e <map_frame+0x7a>
			return 0;
f0108377:	b8 00 00 00 00       	mov    $0x0,%eax
f010837c:	eb 68                	jmp    f01083e6 <map_frame+0xe2>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f010837e:	83 ec 08             	sub    $0x8,%esp
f0108381:	ff 75 10             	pushl  0x10(%ebp)
f0108384:	ff 75 08             	pushl  0x8(%ebp)
f0108387:	e8 d2 00 00 00       	call   f010845e <unmap_frame>
f010838c:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f010838f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108392:	8b 40 08             	mov    0x8(%eax),%eax
f0108395:	40                   	inc    %eax
f0108396:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108399:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * [DONE] map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f010839d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01083a0:	8b 55 10             	mov    0x10(%ebp),%edx
f01083a3:	c1 ea 0c             	shr    $0xc,%edx
f01083a6:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01083ac:	c1 e2 02             	shl    $0x2,%edx
f01083af:	01 d0                	add    %edx,%eax
f01083b1:	8b 00                	mov    (%eax),%eax
f01083b3:	25 00 0e 00 00       	and    $0xe00,%eax
f01083b8:	89 45 ec             	mov    %eax,-0x14(%ebp)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f01083bb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01083be:	8b 55 10             	mov    0x10(%ebp),%edx
f01083c1:	c1 ea 0c             	shr    $0xc,%edx
f01083c4:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01083ca:	c1 e2 02             	shl    $0x2,%edx
f01083cd:	01 c2                	add    %eax,%edx
f01083cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083d2:	0b 45 ec             	or     -0x14(%ebp),%eax
f01083d5:	89 c1                	mov    %eax,%ecx
f01083d7:	8b 45 14             	mov    0x14(%ebp),%eax
f01083da:	09 c8                	or     %ecx,%eax
f01083dc:	83 c8 01             	or     $0x1,%eax
f01083df:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f01083e1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01083e6:	c9                   	leave  
f01083e7:	c3                   	ret    

f01083e8 <get_frame_info>:
// Return 0 if there is no frame mapped at virtual_address.
//
// Hint: implement using get_page_table() and get_frame_info().
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f01083e8:	55                   	push   %ebp
f01083e9:	89 e5                	mov    %esp,%ebp
f01083eb:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	//cprintf(".gfi .1\n %x, %x, %x, \n", ptr_page_directory, virtual_address, ptr_page_table);
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f01083ee:	83 ec 04             	sub    $0x4,%esp
f01083f1:	ff 75 10             	pushl  0x10(%ebp)
f01083f4:	ff 75 0c             	pushl  0xc(%ebp)
f01083f7:	ff 75 08             	pushl  0x8(%ebp)
f01083fa:	e8 2c fd ff ff       	call   f010812b <get_page_table>
f01083ff:	83 c4 10             	add    $0x10,%esp
f0108402:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf(".gfi .15\n");
	if((*ptr_page_table) != 0)
f0108405:	8b 45 10             	mov    0x10(%ebp),%eax
f0108408:	8b 00                	mov    (%eax),%eax
f010840a:	85 c0                	test   %eax,%eax
f010840c:	74 49                	je     f0108457 <get_frame_info+0x6f>
	{
		uint32 index_page_table = PTX(virtual_address);
f010840e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108411:	c1 e8 0c             	shr    $0xc,%eax
f0108414:	25 ff 03 00 00       	and    $0x3ff,%eax
f0108419:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf(".gfi .2\n");
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f010841c:	8b 45 10             	mov    0x10(%ebp),%eax
f010841f:	8b 00                	mov    (%eax),%eax
f0108421:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108424:	c1 e2 02             	shl    $0x2,%edx
f0108427:	01 d0                	add    %edx,%eax
f0108429:	8b 00                	mov    (%eax),%eax
f010842b:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		//if( page_table_entry != 0)
		if( (page_table_entry & ~0xFFF) != 0)
f010842e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108431:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108436:	85 c0                	test   %eax,%eax
f0108438:	74 16                	je     f0108450 <get_frame_info+0x68>
		{
			//cprintf(".gfi .3\n");
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f010843a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010843d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108442:	83 ec 0c             	sub    $0xc,%esp
f0108445:	50                   	push   %eax
f0108446:	e8 64 f6 ff ff       	call   f0107aaf <to_frame_info>
f010844b:	83 c4 10             	add    $0x10,%esp
f010844e:	eb 0c                	jmp    f010845c <get_frame_info+0x74>
		}
		return 0;
f0108450:	b8 00 00 00 00       	mov    $0x0,%eax
f0108455:	eb 05                	jmp    f010845c <get_frame_info+0x74>
	}
	return 0;
f0108457:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010845c:	c9                   	leave  
f010845d:	c3                   	ret    

f010845e <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f010845e:	55                   	push   %ebp
f010845f:	89 e5                	mov    %esp,%ebp
f0108461:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f0108464:	83 ec 04             	sub    $0x4,%esp
f0108467:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010846a:	50                   	push   %eax
f010846b:	ff 75 0c             	pushl  0xc(%ebp)
f010846e:	ff 75 08             	pushl  0x8(%ebp)
f0108471:	e8 72 ff ff ff       	call   f01083e8 <get_frame_info>
f0108476:	83 c4 10             	add    $0x10,%esp
f0108479:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f010847c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108480:	74 7d                	je     f01084ff <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0108482:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108485:	8a 40 14             	mov    0x14(%eax),%al
f0108488:	84 c0                	test   %al,%al
f010848a:	74 1c                	je     f01084a8 <unmap_frame+0x4a>
f010848c:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108493:	77 13                	ja     f01084a8 <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f0108495:	83 ec 08             	sub    $0x8,%esp
f0108498:	ff 75 0c             	pushl  0xc(%ebp)
f010849b:	68 0c 4c 12 f0       	push   $0xf0124c0c
f01084a0:	e8 c7 8a ff ff       	call   f0100f6c <cprintf>
f01084a5:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f01084a8:	83 ec 0c             	sub    $0xc,%esp
f01084ab:	ff 75 f4             	pushl  -0xc(%ebp)
f01084ae:	e8 48 fc ff ff       	call   f01080fb <decrement_references>
f01084b3:	83 c4 10             	add    $0x10,%esp

		/*********************************************************************************/
		/*NEW'23 el7:)
		 * [DONE] unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f01084b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01084b9:	8b 55 0c             	mov    0xc(%ebp),%edx
f01084bc:	c1 ea 0c             	shr    $0xc,%edx
f01084bf:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01084c5:	c1 e2 02             	shl    $0x2,%edx
f01084c8:	01 d0                	add    %edx,%eax
f01084ca:	8b 00                	mov    (%eax),%eax
f01084cc:	25 00 0e 00 00       	and    $0xe00,%eax
f01084d1:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f01084d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01084d7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01084da:	c1 ea 0c             	shr    $0xc,%edx
f01084dd:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01084e3:	c1 e2 02             	shl    $0x2,%edx
f01084e6:	01 c2                	add    %eax,%edx
f01084e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01084eb:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f01084ed:	8b 45 0c             	mov    0xc(%ebp),%eax
f01084f0:	83 ec 08             	sub    $0x8,%esp
f01084f3:	50                   	push   %eax
f01084f4:	ff 75 08             	pushl  0x8(%ebp)
f01084f7:	e8 f9 f5 ff ff       	call   f0107af5 <tlb_invalidate>
f01084fc:	83 c4 10             	add    $0x10,%esp
	}
}
f01084ff:	90                   	nop
f0108500:	c9                   	leave  
f0108501:	c3                   	ret    

f0108502 <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0108502:	55                   	push   %ebp
f0108503:	89 e5                	mov    %esp,%ebp
f0108505:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108508:	ff 75 0c             	pushl  0xc(%ebp)
f010850b:	e8 8c f5 ff ff       	call   f0107a9c <to_physical_address>
f0108510:	83 c4 04             	add    $0x4,%esp
f0108513:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108516:	8b 45 10             	mov    0x10(%ebp),%eax
f0108519:	c1 e8 16             	shr    $0x16,%eax
f010851c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108523:	8b 45 08             	mov    0x8(%ebp),%eax
f0108526:	01 d0                	add    %edx,%eax
f0108528:	8b 00                	mov    (%eax),%eax
f010852a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f010852d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108530:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108535:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108538:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010853b:	c1 e8 0c             	shr    $0xc,%eax
f010853e:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108541:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0108546:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f0108549:	72 17                	jb     f0108562 <loadtime_map_frame+0x60>
f010854b:	ff 75 ec             	pushl  -0x14(%ebp)
f010854e:	68 dc 4b 12 f0       	push   $0xf0124bdc
f0108553:	68 f9 01 00 00       	push   $0x1f9
f0108558:	68 1f 4b 12 f0       	push   $0xf0124b1f
f010855d:	e8 b8 7d ff ff       	call   f010031a <_panic>
f0108562:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108565:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010856a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f010856d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0108571:	75 15                	jne    f0108588 <loadtime_map_frame+0x86>
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
		}
#else
		{
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
f0108573:	83 ec 04             	sub    $0x4,%esp
f0108576:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0108579:	50                   	push   %eax
f010857a:	ff 75 10             	pushl  0x10(%ebp)
f010857d:	ff 75 08             	pushl  0x8(%ebp)
f0108580:	e8 cc fc ff ff       	call   f0108251 <__static_cpt>
f0108585:	83 c4 10             	add    $0x10,%esp
		}
#endif
	}

	ptr_frame_info->references++;
f0108588:	8b 45 0c             	mov    0xc(%ebp),%eax
f010858b:	8b 40 08             	mov    0x8(%eax),%eax
f010858e:	40                   	inc    %eax
f010858f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108592:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f0108596:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108599:	8b 55 10             	mov    0x10(%ebp),%edx
f010859c:	c1 ea 0c             	shr    $0xc,%edx
f010859f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01085a5:	c1 e2 02             	shl    $0x2,%edx
f01085a8:	01 c2                	add    %eax,%edx
f01085aa:	8b 45 14             	mov    0x14(%ebp),%eax
f01085ad:	0b 45 f4             	or     -0xc(%ebp),%eax
f01085b0:	83 c8 01             	or     $0x1,%eax
f01085b3:	89 02                	mov    %eax,(%edx)

	return 0;
f01085b5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01085ba:	c9                   	leave  
f01085bb:	c3                   	ret    

f01085bc <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f01085bc:	55                   	push   %ebp
f01085bd:	89 e5                	mov    %esp,%ebp
f01085bf:	57                   	push   %edi
f01085c0:	56                   	push   %esi
f01085c1:	53                   	push   %ebx
f01085c2:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f01085c5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f01085cc:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f01085d3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_spinlock(&MemFrameLists.mfllock);
f01085da:	83 ec 0c             	sub    $0xc,%esp
f01085dd:	68 40 25 55 f0       	push   $0xf0552540
f01085e2:	e8 d0 63 00 00       	call   f010e9b7 <holding_spinlock>
f01085e7:	83 c4 10             	add    $0x10,%esp
f01085ea:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f01085ed:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01085f1:	75 10                	jne    f0108603 <calculate_available_frames+0x47>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01085f3:	83 ec 0c             	sub    $0xc,%esp
f01085f6:	68 40 25 55 f0       	push   $0xf0552540
f01085fb:	e8 9e 61 00 00       	call   f010e79e <acquire_spinlock>
f0108600:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f0108603:	a1 20 25 55 f0       	mov    0xf0552520,%eax
f0108608:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010860b:	eb 1a                	jmp    f0108627 <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f010860d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108610:	8a 40 14             	mov    0x14(%eax),%al
f0108613:	84 c0                	test   %al,%al
f0108615:	74 05                	je     f010861c <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f0108617:	ff 45 dc             	incl   -0x24(%ebp)
f010861a:	eb 03                	jmp    f010861f <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f010861c:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_spinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f010861f:	a1 28 25 55 f0       	mov    0xf0552528,%eax
f0108624:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108627:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010862b:	74 07                	je     f0108634 <calculate_available_frames+0x78>
f010862d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108630:	8b 00                	mov    (%eax),%eax
f0108632:	eb 05                	jmp    f0108639 <calculate_available_frames+0x7d>
f0108634:	b8 00 00 00 00       	mov    $0x0,%eax
f0108639:	a3 28 25 55 f0       	mov    %eax,0xf0552528
f010863e:	a1 28 25 55 f0       	mov    0xf0552528,%eax
f0108643:	85 c0                	test   %eax,%eax
f0108645:	75 c6                	jne    f010860d <calculate_available_frames+0x51>
f0108647:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010864b:	75 c0                	jne    f010860d <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f010864d:	a1 3c 25 55 f0       	mov    0xf055253c,%eax
f0108652:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f0108655:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0108659:	75 10                	jne    f010866b <calculate_available_frames+0xaf>
	{
		release_spinlock(&MemFrameLists.mfllock);
f010865b:	83 ec 0c             	sub    $0xc,%esp
f010865e:	68 40 25 55 f0       	push   $0xf0552540
f0108663:	e8 bd 61 00 00       	call   f010e825 <release_spinlock>
f0108668:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f010866b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010866e:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f0108671:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108674:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f0108677:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010867a:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f010867d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108680:	89 c3                	mov    %eax,%ebx
f0108682:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0108685:	ba 03 00 00 00       	mov    $0x3,%edx
f010868a:	89 df                	mov    %ebx,%edi
f010868c:	89 c6                	mov    %eax,%esi
f010868e:	89 d1                	mov    %edx,%ecx
f0108690:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f0108692:	8b 45 08             	mov    0x8(%ebp),%eax
f0108695:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108698:	5b                   	pop    %ebx
f0108699:	5e                   	pop    %esi
f010869a:	5f                   	pop    %edi
f010869b:	5d                   	pop    %ebp
f010869c:	c2 04 00             	ret    $0x4

f010869f <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init(uint32 numOfElements)
{
f010869f:	55                   	push   %ebp
f01086a0:	89 e5                	mov    %esp,%ebp
f01086a2:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
	init_spinlock(&AllShares.shareslock, "shares lock");
#else
	panic("not handled when KERN HEAP is disabled");
f01086a5:	83 ec 04             	sub    $0x4,%esp
f01086a8:	68 3c 4c 12 f0       	push   $0xf0124c3c
f01086ad:	6a 1e                	push   $0x1e
f01086af:	68 64 4c 12 f0       	push   $0xf0124c64
f01086b4:	e8 61 7c ff ff       	call   f010031a <_panic>

f01086b9 <create_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* create_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f01086b9:	55                   	push   %ebp
f01086ba:	89 e5                	mov    %esp,%ebp
f01086bc:	83 ec 18             	sub    $0x18,%esp
f01086bf:	8b 45 14             	mov    0x14(%ebp),%eax
f01086c2:	88 45 f4             	mov    %al,-0xc(%ebp)
	//[PROJECT'24.MS2]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("create_share is not implemented yet");
f01086c5:	83 ec 04             	sub    $0x4,%esp
f01086c8:	68 88 4c 12 f0       	push   $0xf0124c88
f01086cd:	6a 32                	push   $0x32
f01086cf:	68 64 4c 12 f0       	push   $0xf0124c64
f01086d4:	e8 41 7c ff ff       	call   f010031a <_panic>

f01086d9 <get_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* get_share(int32 ownerID, char* name)
{
f01086d9:	55                   	push   %ebp
f01086da:	89 e5                	mov    %esp,%ebp
f01086dc:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("get_share is not implemented yet");
f01086df:	83 ec 04             	sub    $0x4,%esp
f01086e2:	68 ac 4c 12 f0       	push   $0xf0124cac
f01086e7:	6a 42                	push   $0x42
f01086e9:	68 64 4c 12 f0       	push   $0xf0124c64
f01086ee:	e8 27 7c ff ff       	call   f010031a <_panic>

f01086f3 <free_share>:
// [3] Delete Share Object:
//=========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f01086f3:	55                   	push   %ebp
f01086f4:	89 e5                	mov    %esp,%ebp
f01086f6:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] BONUS
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("free_share is not implemented yet");
f01086f9:	83 ec 04             	sub    $0x4,%esp
f01086fc:	68 d0 4c 12 f0       	push   $0xf0124cd0
f0108701:	6a 50                	push   $0x50
f0108703:	68 64 4c 12 f0       	push   $0xf0124c64
f0108708:	e8 0d 7c ff ff       	call   f010031a <_panic>

f010870d <create_frames_storage>:
//===========================
// [4] Create frames_storage:
//===========================
// Create the frames_storage and initialize it by 0
inline struct FrameInfo** create_frames_storage(int numOfFrames)
{
f010870d:	55                   	push   %ebp
f010870e:	89 e5                	mov    %esp,%ebp
f0108710:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("create_frames_storage is not implemented yet");
f0108713:	83 ec 04             	sub    $0x4,%esp
f0108716:	68 f4 4c 12 f0       	push   $0xf0124cf4
f010871b:	6a 5c                	push   $0x5c
f010871d:	68 64 4c 12 f0       	push   $0xf0124c64
f0108722:	e8 f3 7b ff ff       	call   f010031a <_panic>

f0108727 <createSharedObject>:

//=========================
// [5] Create Share Object:
//=========================
int createSharedObject(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f0108727:	55                   	push   %ebp
f0108728:	89 e5                	mov    %esp,%ebp
f010872a:	83 ec 18             	sub    $0x18,%esp
f010872d:	8b 45 14             	mov    0x14(%ebp),%eax
f0108730:	88 45 f4             	mov    %al,-0xc(%ebp)
	//[PROJECT'24.MS2]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("createSharedObject is not implemented yet");
f0108733:	83 ec 04             	sub    $0x4,%esp
f0108736:	68 24 4d 12 f0       	push   $0xf0124d24
f010873b:	6a 68                	push   $0x68
f010873d:	68 64 4c 12 f0       	push   $0xf0124c64
f0108742:	e8 d3 7b ff ff       	call   f010031a <_panic>

f0108747 <getSizeOfSharedObject>:

//==============================
// [6] Get Size of Share Object:
//==============================
int getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f0108747:	55                   	push   %ebp
f0108748:	89 e5                	mov    %esp,%ebp
f010874a:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = get_share(ownerID, shareName);
f010874d:	83 ec 08             	sub    $0x8,%esp
f0108750:	ff 75 0c             	pushl  0xc(%ebp)
f0108753:	ff 75 08             	pushl  0x8(%ebp)
f0108756:	e8 7e ff ff ff       	call   f01086d9 <get_share>
f010875b:	83 c4 10             	add    $0x10,%esp
f010875e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f0108761:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108765:	75 07                	jne    f010876e <getSizeOfSharedObject+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f0108767:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f010876c:	eb 06                	jmp    f0108774 <getSizeOfSharedObject+0x2d>
	else
		return ptr_share->size;
f010876e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108771:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f0108774:	c9                   	leave  
f0108775:	c3                   	ret    

f0108776 <getSharedObject>:

//======================
// [7] Get Share Object:
//======================
int getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f0108776:	55                   	push   %ebp
f0108777:	89 e5                	mov    %esp,%ebp
f0108779:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("getSharedObject is not implemented yet");
f010877c:	83 ec 04             	sub    $0x4,%esp
f010877f:	68 50 4d 12 f0       	push   $0xf0124d50
f0108784:	68 89 00 00 00       	push   $0x89
f0108789:	68 64 4c 12 f0       	push   $0xf0124c64
f010878e:	e8 87 7b ff ff       	call   f010031a <_panic>

f0108793 <freeSharedObject>:

//===================
// Free Share Object:
//===================
int freeSharedObject(int32 sharedObjectID, void *startVA)
{
f0108793:	55                   	push   %ebp
f0108794:	89 e5                	mov    %esp,%ebp
f0108796:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] BONUS
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("freeSharedObject is not implemented yet");
f0108799:	83 ec 04             	sub    $0x4,%esp
f010879c:	68 78 4d 12 f0       	push   $0xf0124d78
f01087a1:	68 9a 00 00 00       	push   $0x9a
f01087a6:	68 64 4c 12 f0       	push   $0xf0124c64
f01087ab:	e8 6a 7b ff ff       	call   f010031a <_panic>

f01087b0 <initialize_kheap_dynamic_allocator>:
//Remember: call the initialize_dynamic_allocator(..) to complete the initialization
//Return:
//	On success: 0
//	Otherwise (if no memory OR initial size exceed the given limit): E_NO_MEM
int initialize_kheap_dynamic_allocator(uint32 daStart, uint32 initSizeToAllocate, uint32 daLimit)
{
f01087b0:	55                   	push   %ebp
f01087b1:	89 e5                	mov    %esp,%ebp
f01087b3:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] [USER HEAP - KERNEL SIDE] initialize_kheap_dynamic_allocator
	// Write your code here, remove the panic and write your code
	panic("initialize_kheap_dynamic_allocator() is not implemented yet...!!");
f01087b6:	83 ec 04             	sub    $0x4,%esp
f01087b9:	68 a0 4d 12 f0       	push   $0xf0124da0
f01087be:	6a 11                	push   $0x11
f01087c0:	68 e1 4d 12 f0       	push   $0xf0124de1
f01087c5:	e8 50 7b ff ff       	call   f010031a <_panic>

f01087ca <sbrk>:
}

void* sbrk(int numOfPages)
{
f01087ca:	55                   	push   %ebp
f01087cb:	89 e5                	mov    %esp,%ebp
	 * 	1) Allocating additional pages for a kernel dynamic allocator will fail if the free frames are exhausted
	 * 		or the break exceed the limit of the dynamic allocator. If sbrk fails, kernel should panic(...)
	 */

	//MS2: COMMENT THIS LINE BEFORE START CODING====
	return (void*)-1 ;
f01087cd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	//====================================================

	//[PROJECT'24.MS2] Implement this function
	// Write your code here, remove the panic and write your code
	panic("sbrk() is not implemented yet...!!");
}
f01087d2:	5d                   	pop    %ebp
f01087d3:	c3                   	ret    

f01087d4 <kmalloc>:


void* kmalloc(unsigned int size)
{
f01087d4:	55                   	push   %ebp
f01087d5:	89 e5                	mov    %esp,%ebp
f01087d7:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] Implement this function
	// Write your code here, remove the panic and write your code
	kpanic_into_prompt("kmalloc() is not implemented yet...!!");
f01087da:	83 ec 04             	sub    $0x4,%esp
f01087dd:	68 f4 4d 12 f0       	push   $0xf0124df4
f01087e2:	6a 2e                	push   $0x2e
f01087e4:	68 e1 4d 12 f0       	push   $0xf0124de1
f01087e9:	e8 57 7c ff ff       	call   f0100445 <_panic_into_prompt>

f01087ee <kfree>:
	// use "isKHeapPlacementStrategyFIRSTFIT() ..." functions to check the current strategy

}

void kfree(void* virtual_address)
{
f01087ee:	55                   	push   %ebp
f01087ef:	89 e5                	mov    %esp,%ebp
f01087f1:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] Implement this function
	// Write your code here, remove the panic and write your code
	panic("kfree() is not implemented yet...!!");
f01087f4:	83 ec 04             	sub    $0x4,%esp
f01087f7:	68 1c 4e 12 f0       	push   $0xf0124e1c
f01087fc:	6a 38                	push   $0x38
f01087fe:	68 e1 4d 12 f0       	push   $0xf0124de1
f0108803:	e8 12 7b ff ff       	call   f010031a <_panic>

f0108808 <kheap_virtual_address>:
	//refer to the project presentation and documentation for details

}

unsigned int kheap_virtual_address(unsigned int physical_address)
{
f0108808:	55                   	push   %ebp
f0108809:	89 e5                	mov    %esp,%ebp
f010880b:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] [KERNEL HEAP] kheap_virtual_address
	// Write your code here, remove the panic and write your code
	panic("kheap_virtual_address() is not implemented yet...!!");
f010880e:	83 ec 04             	sub    $0x4,%esp
f0108811:	68 40 4e 12 f0       	push   $0xf0124e40
f0108816:	6a 43                	push   $0x43
f0108818:	68 e1 4d 12 f0       	push   $0xf0124de1
f010881d:	e8 f8 7a ff ff       	call   f010031a <_panic>

f0108822 <kheap_physical_address>:

	//EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================
}

unsigned int kheap_physical_address(unsigned int virtual_address)
{
f0108822:	55                   	push   %ebp
f0108823:	89 e5                	mov    %esp,%ebp
f0108825:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] [KERNEL HEAP] kheap_physical_address
	// Write your code here, remove the panic and write your code
	panic("kheap_physical_address() is not implemented yet...!!");
f0108828:	83 ec 04             	sub    $0x4,%esp
f010882b:	68 74 4e 12 f0       	push   $0xf0124e74
f0108830:	6a 4f                	push   $0x4f
f0108832:	68 e1 4d 12 f0       	push   $0xf0124de1
f0108837:	e8 de 7a ff ff       	call   f010031a <_panic>

f010883c <krealloc>:

//	A call with virtual_address = null is equivalent to kmalloc().
//	A call with new_size = zero is equivalent to kfree().

void *krealloc(void *virtual_address, uint32 new_size)
{
f010883c:	55                   	push   %ebp
f010883d:	89 e5                	mov    %esp,%ebp
	//[PROJECT'24.MS2 BONUS2] Kernel Heap Realloc
	// Write your code here, remove the panic and write your code
	return NULL;
f010883f:	b8 00 00 00 00       	mov    $0x0,%eax
	panic("krealloc() is not implemented yet...!!");
}
f0108844:	5d                   	pop    %ebp
f0108845:	c3                   	ret    

f0108846 <pt_set_page_permissions>:
 */
#include "memory_manager.h"

/*[2.1] PAGE TABLE ENTRIES MANIPULATION */
inline void pt_set_page_permissions(uint32* page_directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f0108846:	55                   	push   %ebp
f0108847:	89 e5                	mov    %esp,%ebp
f0108849:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f010884c:	83 ec 04             	sub    $0x4,%esp
f010884f:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0108852:	50                   	push   %eax
f0108853:	ff 75 0c             	pushl  0xc(%ebp)
f0108856:	ff 75 08             	pushl  0x8(%ebp)
f0108859:	e8 cd f8 ff ff       	call   f010812b <get_page_table>
f010885e:	83 c4 10             	add    $0x10,%esp
f0108861:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0108864:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108867:	85 c0                	test   %eax,%eax
f0108869:	74 64                	je     f01088cf <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f010886b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010886e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108871:	c1 ea 0c             	shr    $0xc,%edx
f0108874:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010887a:	c1 e2 02             	shl    $0x2,%edx
f010887d:	01 c2                	add    %eax,%edx
f010887f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108882:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0108885:	c1 e9 0c             	shr    $0xc,%ecx
f0108888:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010888e:	c1 e1 02             	shl    $0x2,%ecx
f0108891:	01 c8                	add    %ecx,%eax
f0108893:	8b 00                	mov    (%eax),%eax
f0108895:	0b 45 10             	or     0x10(%ebp),%eax
f0108898:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f010889a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010889d:	8b 55 0c             	mov    0xc(%ebp),%edx
f01088a0:	c1 ea 0c             	shr    $0xc,%edx
f01088a3:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01088a9:	c1 e2 02             	shl    $0x2,%edx
f01088ac:	01 d0                	add    %edx,%eax
f01088ae:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01088b1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f01088b4:	c1 e9 0c             	shr    $0xc,%ecx
f01088b7:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f01088bd:	c1 e1 02             	shl    $0x2,%ecx
f01088c0:	01 ca                	add    %ecx,%edx
f01088c2:	8b 12                	mov    (%edx),%edx
f01088c4:	8b 4d 14             	mov    0x14(%ebp),%ecx
f01088c7:	f7 d1                	not    %ecx
f01088c9:	21 ca                	and    %ecx,%edx
f01088cb:	89 10                	mov    %edx,(%eax)
f01088cd:	eb 27                	jmp    f01088f6 <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f01088cf:	83 ec 08             	sub    $0x8,%esp
f01088d2:	ff 75 0c             	pushl  0xc(%ebp)
f01088d5:	68 ac 4e 12 f0       	push   $0xf0124eac
f01088da:	e8 8d 86 ff ff       	call   f0100f6c <cprintf>
f01088df:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f01088e2:	83 ec 04             	sub    $0x4,%esp
f01088e5:	68 d4 4e 12 f0       	push   $0xf0124ed4
f01088ea:	6a 1c                	push   $0x1c
f01088ec:	68 48 4f 12 f0       	push   $0xf0124f48
f01088f1:	e8 24 7a ff ff       	call   f010031a <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f01088f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01088f9:	83 ec 08             	sub    $0x8,%esp
f01088fc:	50                   	push   %eax
f01088fd:	6a 00                	push   $0x0
f01088ff:	e8 f1 f1 ff ff       	call   f0107af5 <tlb_invalidate>
f0108904:	83 c4 10             	add    $0x10,%esp
}
f0108907:	90                   	nop
f0108908:	c9                   	leave  
f0108909:	c3                   	ret    

f010890a <pt_get_page_permissions>:

inline int pt_get_page_permissions(uint32* page_directory, uint32 virtual_address )
{
f010890a:	55                   	push   %ebp
f010890b:	89 e5                	mov    %esp,%ebp
f010890d:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0108910:	83 ec 04             	sub    $0x4,%esp
f0108913:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0108916:	50                   	push   %eax
f0108917:	ff 75 0c             	pushl  0xc(%ebp)
f010891a:	ff 75 08             	pushl  0x8(%ebp)
f010891d:	e8 09 f8 ff ff       	call   f010812b <get_page_table>
f0108922:	83 c4 10             	add    $0x10,%esp
f0108925:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, return the permissions
	if (ptr_page_table != NULL)
f0108928:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010892b:	85 c0                	test   %eax,%eax
f010892d:	74 1d                	je     f010894c <pt_get_page_permissions+0x42>
	{
		//cprintf("va=%x perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
		return (ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
f010892f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108932:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108935:	c1 ea 0c             	shr    $0xc,%edx
f0108938:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010893e:	c1 e2 02             	shl    $0x2,%edx
f0108941:	01 d0                	add    %edx,%eax
f0108943:	8b 00                	mov    (%eax),%eax
f0108945:	25 ff 0f 00 00       	and    $0xfff,%eax
f010894a:	eb 05                	jmp    f0108951 <pt_get_page_permissions+0x47>
	}
	//[3] Else, return -1
	else
	{
		//cprintf("va=%x not exist and has no page table\n", virtual_address);
		return -1;
f010894c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
f0108951:	c9                   	leave  
f0108952:	c3                   	ret    

f0108953 <pt_clear_page_table_entry>:

inline void pt_clear_page_table_entry(uint32* page_directory, uint32 virtual_address)
{
f0108953:	55                   	push   %ebp
f0108954:	89 e5                	mov    %esp,%ebp
f0108956:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0108959:	83 ec 04             	sub    $0x4,%esp
f010895c:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010895f:	50                   	push   %eax
f0108960:	ff 75 0c             	pushl  0xc(%ebp)
f0108963:	ff 75 08             	pushl  0x8(%ebp)
f0108966:	e8 c0 f7 ff ff       	call   f010812b <get_page_table>
f010896b:	83 c4 10             	add    $0x10,%esp
f010896e:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0108971:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108974:	85 c0                	test   %eax,%eax
f0108976:	74 46                	je     f01089be <pt_clear_page_table_entry+0x6b>
	{
		cprintf("va=%x before clearing has perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)]);
f0108978:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010897b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010897e:	c1 ea 0c             	shr    $0xc,%edx
f0108981:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108987:	c1 e2 02             	shl    $0x2,%edx
f010898a:	01 d0                	add    %edx,%eax
f010898c:	8b 00                	mov    (%eax),%eax
f010898e:	83 ec 04             	sub    $0x4,%esp
f0108991:	50                   	push   %eax
f0108992:	ff 75 0c             	pushl  0xc(%ebp)
f0108995:	68 64 4f 12 f0       	push   $0xf0124f64
f010899a:	e8 cd 85 ff ff       	call   f0100f6c <cprintf>
f010899f:	83 c4 10             	add    $0x10,%esp
		ptr_page_table[PTX(virtual_address)] = 0;
f01089a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01089a5:	8b 55 0c             	mov    0xc(%ebp),%edx
f01089a8:	c1 ea 0c             	shr    $0xc,%edx
f01089ab:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01089b1:	c1 e2 02             	shl    $0x2,%edx
f01089b4:	01 d0                	add    %edx,%eax
f01089b6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01089bc:	eb 14                	jmp    f01089d2 <pt_clear_page_table_entry+0x7f>
	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_clear_page_table_entry() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f01089be:	83 ec 04             	sub    $0x4,%esp
f01089c1:	68 8c 4f 12 f0       	push   $0xf0124f8c
f01089c6:	6a 47                	push   $0x47
f01089c8:	68 48 4f 12 f0       	push   $0xf0124f48
f01089cd:	e8 48 79 ff ff       	call   f010031a <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f01089d2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01089d5:	83 ec 08             	sub    $0x8,%esp
f01089d8:	50                   	push   %eax
f01089d9:	6a 00                	push   $0x0
f01089db:	e8 15 f1 ff ff       	call   f0107af5 <tlb_invalidate>
f01089e0:	83 c4 10             	add    $0x10,%esp
}
f01089e3:	90                   	nop
f01089e4:	c9                   	leave  
f01089e5:	c3                   	ret    

f01089e6 <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* page_directory, uint32 virtual_address)
{
f01089e6:	55                   	push   %ebp
f01089e7:	89 e5                	mov    %esp,%ebp
	return ( (page_directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f01089e9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01089ec:	c1 e8 16             	shr    $0x16,%eax
f01089ef:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01089f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01089f9:	01 d0                	add    %edx,%eax
f01089fb:	8b 00                	mov    (%eax),%eax
f01089fd:	83 e0 20             	and    $0x20,%eax
f0108a00:	85 c0                	test   %eax,%eax
f0108a02:	0f 95 c0             	setne  %al
f0108a05:	0f b6 c0             	movzbl %al,%eax
}
f0108a08:	5d                   	pop    %ebp
f0108a09:	c3                   	ret    

f0108a0a <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* page_directory, uint32 virtual_address)
{
f0108a0a:	55                   	push   %ebp
f0108a0b:	89 e5                	mov    %esp,%ebp
f0108a0d:	83 ec 08             	sub    $0x8,%esp
	page_directory[PDX(virtual_address)] &= (~PERM_USED);
f0108a10:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108a13:	c1 e8 16             	shr    $0x16,%eax
f0108a16:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108a1d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a20:	01 d0                	add    %edx,%eax
f0108a22:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108a25:	c1 ea 16             	shr    $0x16,%edx
f0108a28:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f0108a2f:	8b 55 08             	mov    0x8(%ebp),%edx
f0108a32:	01 ca                	add    %ecx,%edx
f0108a34:	8b 12                	mov    (%edx),%edx
f0108a36:	83 e2 df             	and    $0xffffffdf,%edx
f0108a39:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0108a3b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108a3e:	83 ec 08             	sub    $0x8,%esp
f0108a41:	50                   	push   %eax
f0108a42:	6a 00                	push   $0x0
f0108a44:	e8 ac f0 ff ff       	call   f0107af5 <tlb_invalidate>
f0108a49:	83 c4 10             	add    $0x10,%esp
}
f0108a4c:	90                   	nop
f0108a4d:	c9                   	leave  
f0108a4e:	c3                   	ret    

f0108a4f <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* page_directory, uint32 virtual_address)
{
f0108a4f:	55                   	push   %ebp
f0108a50:	89 e5                	mov    %esp,%ebp
f0108a52:	83 ec 10             	sub    $0x10,%esp
	page_directory[PDX(virtual_address)] = 0 ;
f0108a55:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108a58:	c1 e8 16             	shr    $0x16,%eax
f0108a5b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108a62:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a65:	01 d0                	add    %edx,%eax
f0108a67:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0108a6d:	0f 20 d8             	mov    %cr3,%eax
f0108a70:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0108a73:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0108a76:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f0108a79:	90                   	nop
f0108a7a:	c9                   	leave  
f0108a7b:	c3                   	ret    

f0108a7c <env_page_ws_get_size>:
		}
	}
}
#else
inline uint32 env_page_ws_get_size(struct Env *e)
{
f0108a7c:	55                   	push   %ebp
f0108a7d:	89 e5                	mov    %esp,%ebp
f0108a7f:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f0108a82:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0108a89:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<e->page_WS_max_size; i++) if(e->ptr_pageWorkingSet[i].empty == 0) counter++;
f0108a90:	eb 22                	jmp    f0108ab4 <env_page_ws_get_size+0x38>
f0108a92:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108a95:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0108a98:	89 d0                	mov    %edx,%eax
f0108a9a:	01 c0                	add    %eax,%eax
f0108a9c:	01 d0                	add    %edx,%eax
f0108a9e:	c1 e0 03             	shl    $0x3,%eax
f0108aa1:	01 c8                	add    %ecx,%eax
f0108aa3:	05 8c 00 00 00       	add    $0x8c,%eax
f0108aa8:	8a 00                	mov    (%eax),%al
f0108aaa:	84 c0                	test   %al,%al
f0108aac:	75 03                	jne    f0108ab1 <env_page_ws_get_size+0x35>
f0108aae:	ff 45 f8             	incl   -0x8(%ebp)
f0108ab1:	ff 45 fc             	incl   -0x4(%ebp)
f0108ab4:	8b 45 08             	mov    0x8(%ebp),%eax
f0108ab7:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f0108abd:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0108ac0:	39 c2                	cmp    %eax,%edx
f0108ac2:	77 ce                	ja     f0108a92 <env_page_ws_get_size+0x16>
	return counter;
f0108ac4:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f0108ac7:	c9                   	leave  
f0108ac8:	c3                   	ret    

f0108ac9 <env_page_ws_invalidate>:

inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0108ac9:	55                   	push   %ebp
f0108aca:	89 e5                	mov    %esp,%ebp
f0108acc:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f0108acf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<e->page_WS_max_size; i++)
f0108ad6:	eb 4e                	jmp    f0108b26 <env_page_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->ptr_pageWorkingSet[i].virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f0108ad8:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108adb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108ade:	89 d0                	mov    %edx,%eax
f0108ae0:	01 c0                	add    %eax,%eax
f0108ae2:	01 d0                	add    %edx,%eax
f0108ae4:	c1 e0 03             	shl    $0x3,%eax
f0108ae7:	01 c8                	add    %ecx,%eax
f0108ae9:	05 88 00 00 00       	add    $0x88,%eax
f0108aee:	8b 00                	mov    (%eax),%eax
f0108af0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108af3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108af6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108afb:	89 c2                	mov    %eax,%edx
f0108afd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108b00:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108b03:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108b06:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108b0b:	39 c2                	cmp    %eax,%edx
f0108b0d:	75 14                	jne    f0108b23 <env_page_ws_invalidate+0x5a>
		{
			env_page_ws_clear_entry(e, i);
f0108b0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b12:	83 ec 08             	sub    $0x8,%esp
f0108b15:	50                   	push   %eax
f0108b16:	ff 75 08             	pushl  0x8(%ebp)
f0108b19:	e8 ce 00 00 00       	call   f0108bec <env_page_ws_clear_entry>
f0108b1e:	83 c4 10             	add    $0x10,%esp
			break;
f0108b21:	eb 13                	jmp    f0108b36 <env_page_ws_invalidate+0x6d>
}

inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<e->page_WS_max_size; i++)
f0108b23:	ff 45 f4             	incl   -0xc(%ebp)
f0108b26:	8b 45 08             	mov    0x8(%ebp),%eax
f0108b29:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f0108b2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b32:	39 c2                	cmp    %eax,%edx
f0108b34:	77 a2                	ja     f0108ad8 <env_page_ws_invalidate+0xf>
		{
			env_page_ws_clear_entry(e, i);
			break;
		}
	}
}
f0108b36:	90                   	nop
f0108b37:	c9                   	leave  
f0108b38:	c3                   	ret    

f0108b39 <env_page_ws_set_entry>:

inline void env_page_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f0108b39:	55                   	push   %ebp
f0108b3a:	89 e5                	mov    %esp,%ebp
f0108b3c:	53                   	push   %ebx
f0108b3d:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < e->page_WS_max_size);
f0108b40:	8b 45 08             	mov    0x8(%ebp),%eax
f0108b43:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0108b49:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0108b4c:	77 19                	ja     f0108b67 <env_page_ws_set_entry+0x2e>
f0108b4e:	68 04 50 12 f0       	push   $0xf0125004
f0108b53:	68 3a 50 12 f0       	push   $0xf012503a
f0108b58:	68 a7 00 00 00       	push   $0xa7
f0108b5d:	68 50 50 12 f0       	push   $0xf0125050
f0108b62:	e8 b3 77 ff ff       	call   f010031a <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f0108b67:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f0108b6e:	76 19                	jbe    f0108b89 <env_page_ws_set_entry+0x50>
f0108b70:	68 70 50 12 f0       	push   $0xf0125070
f0108b75:	68 3a 50 12 f0       	push   $0xf012503a
f0108b7a:	68 a8 00 00 00       	push   $0xa8
f0108b7f:	68 50 50 12 f0       	push   $0xf0125050
f0108b84:	e8 91 77 ff ff       	call   f010031a <_panic>
	e->ptr_pageWorkingSet[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE);
f0108b89:	8b 45 10             	mov    0x10(%ebp),%eax
f0108b8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108b8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b92:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108b97:	89 c1                	mov    %eax,%ecx
f0108b99:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0108b9c:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108b9f:	89 d0                	mov    %edx,%eax
f0108ba1:	01 c0                	add    %eax,%eax
f0108ba3:	01 d0                	add    %edx,%eax
f0108ba5:	c1 e0 03             	shl    $0x3,%eax
f0108ba8:	01 d8                	add    %ebx,%eax
f0108baa:	05 88 00 00 00       	add    $0x88,%eax
f0108baf:	89 08                	mov    %ecx,(%eax)
	e->ptr_pageWorkingSet[entry_index].empty = 0;
f0108bb1:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108bb4:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108bb7:	89 d0                	mov    %edx,%eax
f0108bb9:	01 c0                	add    %eax,%eax
f0108bbb:	01 d0                	add    %edx,%eax
f0108bbd:	c1 e0 03             	shl    $0x3,%eax
f0108bc0:	01 c8                	add    %ecx,%eax
f0108bc2:	05 8c 00 00 00       	add    $0x8c,%eax
f0108bc7:	c6 00 00             	movb   $0x0,(%eax)

	e->ptr_pageWorkingSet[entry_index].time_stamp = 0x80000000;
f0108bca:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108bcd:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108bd0:	89 d0                	mov    %edx,%eax
f0108bd2:	01 c0                	add    %eax,%eax
f0108bd4:	01 d0                	add    %edx,%eax
f0108bd6:	c1 e0 03             	shl    $0x3,%eax
f0108bd9:	01 c8                	add    %ecx,%eax
f0108bdb:	05 90 00 00 00       	add    $0x90,%eax
f0108be0:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	//e->ptr_pageWorkingSet[entry_index].time_stamp = time;
	return;
f0108be6:	90                   	nop
}
f0108be7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108bea:	c9                   	leave  
f0108beb:	c3                   	ret    

f0108bec <env_page_ws_clear_entry>:

inline void env_page_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f0108bec:	55                   	push   %ebp
f0108bed:	89 e5                	mov    %esp,%ebp
f0108bef:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < (e->page_WS_max_size));
f0108bf2:	8b 45 08             	mov    0x8(%ebp),%eax
f0108bf5:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0108bfb:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0108bfe:	77 19                	ja     f0108c19 <env_page_ws_clear_entry+0x2d>
f0108c00:	68 a4 50 12 f0       	push   $0xf01250a4
f0108c05:	68 3a 50 12 f0       	push   $0xf012503a
f0108c0a:	68 b3 00 00 00       	push   $0xb3
f0108c0f:	68 50 50 12 f0       	push   $0xf0125050
f0108c14:	e8 01 77 ff ff       	call   f010031a <_panic>
	e->ptr_pageWorkingSet[entry_index].virtual_address = 0;
f0108c19:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108c1c:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108c1f:	89 d0                	mov    %edx,%eax
f0108c21:	01 c0                	add    %eax,%eax
f0108c23:	01 d0                	add    %edx,%eax
f0108c25:	c1 e0 03             	shl    $0x3,%eax
f0108c28:	01 c8                	add    %ecx,%eax
f0108c2a:	05 88 00 00 00       	add    $0x88,%eax
f0108c2f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->ptr_pageWorkingSet[entry_index].empty = 1;
f0108c35:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108c38:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108c3b:	89 d0                	mov    %edx,%eax
f0108c3d:	01 c0                	add    %eax,%eax
f0108c3f:	01 d0                	add    %edx,%eax
f0108c41:	c1 e0 03             	shl    $0x3,%eax
f0108c44:	01 c8                	add    %ecx,%eax
f0108c46:	05 8c 00 00 00       	add    $0x8c,%eax
f0108c4b:	c6 00 01             	movb   $0x1,(%eax)
	e->ptr_pageWorkingSet[entry_index].time_stamp = 0;
f0108c4e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108c51:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108c54:	89 d0                	mov    %edx,%eax
f0108c56:	01 c0                	add    %eax,%eax
f0108c58:	01 d0                	add    %edx,%eax
f0108c5a:	c1 e0 03             	shl    $0x3,%eax
f0108c5d:	01 c8                	add    %ecx,%eax
f0108c5f:	05 90 00 00 00       	add    $0x90,%eax
f0108c64:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f0108c6a:	90                   	nop
f0108c6b:	c9                   	leave  
f0108c6c:	c3                   	ret    

f0108c6d <env_page_ws_get_virtual_address>:

inline uint32 env_page_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f0108c6d:	55                   	push   %ebp
f0108c6e:	89 e5                	mov    %esp,%ebp
f0108c70:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < (e->page_WS_max_size));
f0108c73:	8b 45 08             	mov    0x8(%ebp),%eax
f0108c76:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0108c7c:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0108c7f:	77 19                	ja     f0108c9a <env_page_ws_get_virtual_address+0x2d>
f0108c81:	68 a4 50 12 f0       	push   $0xf01250a4
f0108c86:	68 3a 50 12 f0       	push   $0xf012503a
f0108c8b:	68 bb 00 00 00       	push   $0xbb
f0108c90:	68 50 50 12 f0       	push   $0xf0125050
f0108c95:	e8 80 76 ff ff       	call   f010031a <_panic>
	return ROUNDDOWN(e->ptr_pageWorkingSet[entry_index].virtual_address,PAGE_SIZE);
f0108c9a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108c9d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108ca0:	89 d0                	mov    %edx,%eax
f0108ca2:	01 c0                	add    %eax,%eax
f0108ca4:	01 d0                	add    %edx,%eax
f0108ca6:	c1 e0 03             	shl    $0x3,%eax
f0108ca9:	01 c8                	add    %ecx,%eax
f0108cab:	05 88 00 00 00       	add    $0x88,%eax
f0108cb0:	8b 00                	mov    (%eax),%eax
f0108cb2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108cb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108cb8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f0108cbd:	c9                   	leave  
f0108cbe:	c3                   	ret    

f0108cbf <env_page_ws_get_time_stamp>:

inline uint32 env_page_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f0108cbf:	55                   	push   %ebp
f0108cc0:	89 e5                	mov    %esp,%ebp
f0108cc2:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < (e->page_WS_max_size));
f0108cc5:	8b 45 08             	mov    0x8(%ebp),%eax
f0108cc8:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0108cce:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0108cd1:	77 19                	ja     f0108cec <env_page_ws_get_time_stamp+0x2d>
f0108cd3:	68 a4 50 12 f0       	push   $0xf01250a4
f0108cd8:	68 3a 50 12 f0       	push   $0xf012503a
f0108cdd:	68 c1 00 00 00       	push   $0xc1
f0108ce2:	68 50 50 12 f0       	push   $0xf0125050
f0108ce7:	e8 2e 76 ff ff       	call   f010031a <_panic>
	return e->ptr_pageWorkingSet[entry_index].time_stamp;
f0108cec:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108cef:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108cf2:	89 d0                	mov    %edx,%eax
f0108cf4:	01 c0                	add    %eax,%eax
f0108cf6:	01 d0                	add    %edx,%eax
f0108cf8:	c1 e0 03             	shl    $0x3,%eax
f0108cfb:	01 c8                	add    %ecx,%eax
f0108cfd:	05 90 00 00 00       	add    $0x90,%eax
f0108d02:	8b 00                	mov    (%eax),%eax
}
f0108d04:	c9                   	leave  
f0108d05:	c3                   	ret    

f0108d06 <env_page_ws_is_entry_empty>:

inline uint32 env_page_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f0108d06:	55                   	push   %ebp
f0108d07:	89 e5                	mov    %esp,%ebp
	return e->ptr_pageWorkingSet[entry_index].empty;
f0108d09:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108d0c:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108d0f:	89 d0                	mov    %edx,%eax
f0108d11:	01 c0                	add    %eax,%eax
f0108d13:	01 d0                	add    %edx,%eax
f0108d15:	c1 e0 03             	shl    $0x3,%eax
f0108d18:	01 c8                	add    %ecx,%eax
f0108d1a:	05 8c 00 00 00       	add    $0x8c,%eax
f0108d1f:	8a 00                	mov    (%eax),%al
f0108d21:	0f b6 c0             	movzbl %al,%eax
}
f0108d24:	5d                   	pop    %ebp
f0108d25:	c3                   	ret    

f0108d26 <env_page_ws_print>:

void env_page_ws_print(struct Env *e)
{
f0108d26:	55                   	push   %ebp
f0108d27:	89 e5                	mov    %esp,%ebp
f0108d29:	53                   	push   %ebx
f0108d2a:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0108d2d:	83 ec 0c             	sub    $0xc,%esp
f0108d30:	6a 02                	push   $0x2
f0108d32:	e8 56 56 00 00       	call   f010e38d <isPageReplacmentAlgorithmLRU>
f0108d37:	83 c4 10             	add    $0x10,%esp
f0108d3a:	85 c0                	test   %eax,%eax
f0108d3c:	0f 84 fe 00 00 00    	je     f0108e40 <env_page_ws_print+0x11a>
	{
		int i = 0;
f0108d42:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f0108d49:	83 ec 0c             	sub    $0xc,%esp
f0108d4c:	68 dc 50 12 f0       	push   $0xf01250dc
f0108d51:	e8 16 82 ff ff       	call   f0100f6c <cprintf>
f0108d56:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0108d59:	8b 45 08             	mov    0x8(%ebp),%eax
f0108d5c:	8b 80 10 da 01 00    	mov    0x1da10(%eax),%eax
f0108d62:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108d65:	eb 2c                	jmp    f0108d93 <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f0108d67:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108d6a:	8b 10                	mov    (%eax),%edx
f0108d6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d6f:	8d 48 01             	lea    0x1(%eax),%ecx
f0108d72:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0108d75:	83 ec 04             	sub    $0x4,%esp
f0108d78:	52                   	push   %edx
f0108d79:	50                   	push   %eax
f0108d7a:	68 f6 50 12 f0       	push   $0xf01250f6
f0108d7f:	e8 e8 81 ff ff       	call   f0100f6c <cprintf>
f0108d84:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0108d87:	8b 45 08             	mov    0x8(%ebp),%eax
f0108d8a:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f0108d90:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108d93:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0108d97:	74 08                	je     f0108da1 <env_page_ws_print+0x7b>
f0108d99:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108d9c:	8b 40 10             	mov    0x10(%eax),%eax
f0108d9f:	eb 05                	jmp    f0108da6 <env_page_ws_print+0x80>
f0108da1:	b8 00 00 00 00       	mov    $0x0,%eax
f0108da6:	8b 55 08             	mov    0x8(%ebp),%edx
f0108da9:	89 82 18 da 01 00    	mov    %eax,0x1da18(%edx)
f0108daf:	8b 45 08             	mov    0x8(%ebp),%eax
f0108db2:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f0108db8:	85 c0                	test   %eax,%eax
f0108dba:	75 ab                	jne    f0108d67 <env_page_ws_print+0x41>
f0108dbc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0108dc0:	75 a5                	jne    f0108d67 <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f0108dc2:	83 ec 0c             	sub    $0xc,%esp
f0108dc5:	68 fe 50 12 f0       	push   $0xf01250fe
f0108dca:	e8 9d 81 ff ff       	call   f0100f6c <cprintf>
f0108dcf:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0108dd2:	8b 45 08             	mov    0x8(%ebp),%eax
f0108dd5:	8b 80 20 da 01 00    	mov    0x1da20(%eax),%eax
f0108ddb:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108dde:	eb 2c                	jmp    f0108e0c <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f0108de0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108de3:	8b 10                	mov    (%eax),%edx
f0108de5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108de8:	8d 48 01             	lea    0x1(%eax),%ecx
f0108deb:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0108dee:	83 ec 04             	sub    $0x4,%esp
f0108df1:	52                   	push   %edx
f0108df2:	50                   	push   %eax
f0108df3:	68 f6 50 12 f0       	push   $0xf01250f6
f0108df8:	e8 6f 81 ff ff       	call   f0100f6c <cprintf>
f0108dfd:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0108e00:	8b 45 08             	mov    0x8(%ebp),%eax
f0108e03:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f0108e09:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108e0c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0108e10:	74 08                	je     f0108e1a <env_page_ws_print+0xf4>
f0108e12:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108e15:	8b 40 10             	mov    0x10(%eax),%eax
f0108e18:	eb 05                	jmp    f0108e1f <env_page_ws_print+0xf9>
f0108e1a:	b8 00 00 00 00       	mov    $0x0,%eax
f0108e1f:	8b 55 08             	mov    0x8(%ebp),%edx
f0108e22:	89 82 28 da 01 00    	mov    %eax,0x1da28(%edx)
f0108e28:	8b 45 08             	mov    0x8(%ebp),%eax
f0108e2b:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f0108e31:	85 c0                	test   %eax,%eax
f0108e33:	75 ab                	jne    f0108de0 <env_page_ws_print+0xba>
f0108e35:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0108e39:	75 a5                	jne    f0108de0 <env_page_ws_print+0xba>
				cprintf(" <--");
			}
			cprintf("\n");
		}
	}
}
f0108e3b:	e9 9f 01 00 00       	jmp    f0108fdf <env_page_ws_print+0x2b9>
		}
	}
	else
	{
		uint32 i;
		cprintf("PAGE WS:\n");
f0108e40:	83 ec 0c             	sub    $0xc,%esp
f0108e43:	68 19 51 12 f0       	push   $0xf0125119
f0108e48:	e8 1f 81 ff ff       	call   f0100f6c <cprintf>
f0108e4d:	83 c4 10             	add    $0x10,%esp
		for(i=0; i< (e->page_WS_max_size); i++ )
f0108e50:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0108e57:	e9 71 01 00 00       	jmp    f0108fcd <env_page_ws_print+0x2a7>
		{
			if (e->ptr_pageWorkingSet[i].empty)
f0108e5c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108e5f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0108e62:	89 d0                	mov    %edx,%eax
f0108e64:	01 c0                	add    %eax,%eax
f0108e66:	01 d0                	add    %edx,%eax
f0108e68:	c1 e0 03             	shl    $0x3,%eax
f0108e6b:	01 c8                	add    %ecx,%eax
f0108e6d:	05 8c 00 00 00       	add    $0x8c,%eax
f0108e72:	8a 00                	mov    (%eax),%al
f0108e74:	84 c0                	test   %al,%al
f0108e76:	74 43                	je     f0108ebb <env_page_ws_print+0x195>
			{
				cprintf("EMPTY LOCATION");
f0108e78:	83 ec 0c             	sub    $0xc,%esp
f0108e7b:	68 23 51 12 f0       	push   $0xf0125123
f0108e80:	e8 e7 80 ff ff       	call   f0100f6c <cprintf>
f0108e85:	83 c4 10             	add    $0x10,%esp
				if(i==e->page_last_WS_index )
f0108e88:	8b 45 08             	mov    0x8(%ebp),%eax
f0108e8b:	8b 80 58 d5 01 00    	mov    0x1d558(%eax),%eax
f0108e91:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0108e94:	75 10                	jne    f0108ea6 <env_page_ws_print+0x180>
				{
					cprintf("		<--");
f0108e96:	83 ec 0c             	sub    $0xc,%esp
f0108e99:	68 32 51 12 f0       	push   $0xf0125132
f0108e9e:	e8 c9 80 ff ff       	call   f0100f6c <cprintf>
f0108ea3:	83 c4 10             	add    $0x10,%esp
				}
				cprintf("\n");
f0108ea6:	83 ec 0c             	sub    $0xc,%esp
f0108ea9:	68 38 51 12 f0       	push   $0xf0125138
f0108eae:	e8 b9 80 ff ff       	call   f0100f6c <cprintf>
f0108eb3:	83 c4 10             	add    $0x10,%esp
				continue;
f0108eb6:	e9 0f 01 00 00       	jmp    f0108fca <env_page_ws_print+0x2a4>
			}
			uint32 virtual_address = e->ptr_pageWorkingSet[i].virtual_address;
f0108ebb:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108ebe:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0108ec1:	89 d0                	mov    %edx,%eax
f0108ec3:	01 c0                	add    %eax,%eax
f0108ec5:	01 d0                	add    %edx,%eax
f0108ec7:	c1 e0 03             	shl    $0x3,%eax
f0108eca:	01 c8                	add    %ecx,%eax
f0108ecc:	05 88 00 00 00       	add    $0x88,%eax
f0108ed1:	8b 00                	mov    (%eax),%eax
f0108ed3:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 time_stamp = e->ptr_pageWorkingSet[i].time_stamp;
f0108ed6:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108ed9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0108edc:	89 d0                	mov    %edx,%eax
f0108ede:	01 c0                	add    %eax,%eax
f0108ee0:	01 d0                	add    %edx,%eax
f0108ee2:	c1 e0 03             	shl    $0x3,%eax
f0108ee5:	01 c8                	add    %ecx,%eax
f0108ee7:	05 90 00 00 00       	add    $0x90,%eax
f0108eec:	8b 00                	mov    (%eax),%eax
f0108eee:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f0108ef1:	8b 45 08             	mov    0x8(%ebp),%eax
f0108ef4:	8b 40 64             	mov    0x64(%eax),%eax
f0108ef7:	83 ec 08             	sub    $0x8,%esp
f0108efa:	ff 75 e8             	pushl  -0x18(%ebp)
f0108efd:	50                   	push   %eax
f0108efe:	e8 07 fa ff ff       	call   f010890a <pt_get_page_permissions>
f0108f03:	83 c4 10             	add    $0x10,%esp
f0108f06:	89 45 e0             	mov    %eax,-0x20(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f0108f09:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108f0c:	83 e0 40             	and    $0x40,%eax
f0108f0f:	85 c0                	test   %eax,%eax
f0108f11:	0f 95 c0             	setne  %al
f0108f14:	88 45 df             	mov    %al,-0x21(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f0108f17:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108f1a:	83 e0 20             	and    $0x20,%eax
f0108f1d:	85 c0                	test   %eax,%eax
f0108f1f:	0f 95 c0             	setne  %al
f0108f22:	88 45 de             	mov    %al,-0x22(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f0108f25:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108f28:	25 00 02 00 00       	and    $0x200,%eax
f0108f2d:	85 c0                	test   %eax,%eax
f0108f2f:	0f 95 c0             	setne  %al
f0108f32:	88 45 dd             	mov    %al,-0x23(%ebp)


			cprintf("address @ %d = %x",i, e->ptr_pageWorkingSet[i].virtual_address);
f0108f35:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108f38:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0108f3b:	89 d0                	mov    %edx,%eax
f0108f3d:	01 c0                	add    %eax,%eax
f0108f3f:	01 d0                	add    %edx,%eax
f0108f41:	c1 e0 03             	shl    $0x3,%eax
f0108f44:	01 c8                	add    %ecx,%eax
f0108f46:	05 88 00 00 00       	add    $0x88,%eax
f0108f4b:	8b 00                	mov    (%eax),%eax
f0108f4d:	83 ec 04             	sub    $0x4,%esp
f0108f50:	50                   	push   %eax
f0108f51:	ff 75 ec             	pushl  -0x14(%ebp)
f0108f54:	68 3a 51 12 f0       	push   $0xf012513a
f0108f59:	e8 0e 80 ff ff       	call   f0100f6c <cprintf>
f0108f5e:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d", isUsed, isModified, isBuffered, time_stamp, e->ptr_pageWorkingSet[i].sweeps_counter) ;
f0108f61:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108f64:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0108f67:	89 d0                	mov    %edx,%eax
f0108f69:	01 c0                	add    %eax,%eax
f0108f6b:	01 d0                	add    %edx,%eax
f0108f6d:	c1 e0 03             	shl    $0x3,%eax
f0108f70:	01 c8                	add    %ecx,%eax
f0108f72:	05 94 00 00 00       	add    $0x94,%eax
f0108f77:	8b 18                	mov    (%eax),%ebx
f0108f79:	0f be 4d dd          	movsbl -0x23(%ebp),%ecx
f0108f7d:	0f be 55 df          	movsbl -0x21(%ebp),%edx
f0108f81:	0f be 45 de          	movsbl -0x22(%ebp),%eax
f0108f85:	83 ec 08             	sub    $0x8,%esp
f0108f88:	53                   	push   %ebx
f0108f89:	ff 75 e4             	pushl  -0x1c(%ebp)
f0108f8c:	51                   	push   %ecx
f0108f8d:	52                   	push   %edx
f0108f8e:	50                   	push   %eax
f0108f8f:	68 4c 51 12 f0       	push   $0xf012514c
f0108f94:	e8 d3 7f ff ff       	call   f0100f6c <cprintf>
f0108f99:	83 c4 20             	add    $0x20,%esp

			if(i==e->page_last_WS_index )
f0108f9c:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f9f:	8b 80 58 d5 01 00    	mov    0x1d558(%eax),%eax
f0108fa5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0108fa8:	75 10                	jne    f0108fba <env_page_ws_print+0x294>
			{
				cprintf(" <--");
f0108faa:	83 ec 0c             	sub    $0xc,%esp
f0108fad:	68 93 51 12 f0       	push   $0xf0125193
f0108fb2:	e8 b5 7f ff ff       	call   f0100f6c <cprintf>
f0108fb7:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f0108fba:	83 ec 0c             	sub    $0xc,%esp
f0108fbd:	68 38 51 12 f0       	push   $0xf0125138
f0108fc2:	e8 a5 7f ff ff       	call   f0100f6c <cprintf>
f0108fc7:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		uint32 i;
		cprintf("PAGE WS:\n");
		for(i=0; i< (e->page_WS_max_size); i++ )
f0108fca:	ff 45 ec             	incl   -0x14(%ebp)
f0108fcd:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fd0:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0108fd6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0108fd9:	0f 87 7d fe ff ff    	ja     f0108e5c <env_page_ws_print+0x136>
				cprintf(" <--");
			}
			cprintf("\n");
		}
	}
}
f0108fdf:	90                   	nop
f0108fe0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108fe3:	c9                   	leave  
f0108fe4:	c3                   	ret    

f0108fe5 <env_table_ws_print>:
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f0108fe5:	55                   	push   %ebp
f0108fe6:	89 e5                	mov    %esp,%ebp
f0108fe8:	53                   	push   %ebx
f0108fe9:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f0108fec:	83 ec 0c             	sub    $0xc,%esp
f0108fef:	68 98 51 12 f0       	push   $0xf0125198
f0108ff4:	e8 73 7f ff ff       	call   f0100f6c <cprintf>
f0108ff9:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f0108ffc:	83 ec 0c             	sub    $0xc,%esp
f0108fff:	68 cd 51 12 f0       	push   $0xf01251cd
f0109004:	e8 63 7f ff ff       	call   f0100f6c <cprintf>
f0109009:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010900c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0109013:	e9 16 01 00 00       	jmp    f010912e <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f0109018:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010901b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010901e:	89 d0                	mov    %edx,%eax
f0109020:	01 c0                	add    %eax,%eax
f0109022:	01 d0                	add    %edx,%eax
f0109024:	c1 e0 03             	shl    $0x3,%eax
f0109027:	01 c8                	add    %ecx,%eax
f0109029:	05 60 d5 01 00       	add    $0x1d560,%eax
f010902e:	8a 00                	mov    (%eax),%al
f0109030:	84 c0                	test   %al,%al
f0109032:	74 43                	je     f0109077 <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f0109034:	83 ec 0c             	sub    $0xc,%esp
f0109037:	68 23 51 12 f0       	push   $0xf0125123
f010903c:	e8 2b 7f ff ff       	call   f0100f6c <cprintf>
f0109041:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f0109044:	8b 45 08             	mov    0x8(%ebp),%eax
f0109047:	8b 80 0c da 01 00    	mov    0x1da0c(%eax),%eax
f010904d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0109050:	75 10                	jne    f0109062 <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f0109052:	83 ec 0c             	sub    $0xc,%esp
f0109055:	68 32 51 12 f0       	push   $0xf0125132
f010905a:	e8 0d 7f ff ff       	call   f0100f6c <cprintf>
f010905f:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f0109062:	83 ec 0c             	sub    $0xc,%esp
f0109065:	68 38 51 12 f0       	push   $0xf0125138
f010906a:	e8 fd 7e ff ff       	call   f0100f6c <cprintf>
f010906f:	83 c4 10             	add    $0x10,%esp
			continue;
f0109072:	e9 b4 00 00 00       	jmp    f010912b <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f0109077:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010907a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010907d:	89 d0                	mov    %edx,%eax
f010907f:	01 c0                	add    %eax,%eax
f0109081:	01 d0                	add    %edx,%eax
f0109083:	c1 e0 03             	shl    $0x3,%eax
f0109086:	01 c8                	add    %ecx,%eax
f0109088:	05 5c d5 01 00       	add    $0x1d55c,%eax
f010908d:	8b 00                	mov    (%eax),%eax
f010908f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f0109092:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109095:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109098:	89 d0                	mov    %edx,%eax
f010909a:	01 c0                	add    %eax,%eax
f010909c:	01 d0                	add    %edx,%eax
f010909e:	c1 e0 03             	shl    $0x3,%eax
f01090a1:	01 c8                	add    %ecx,%eax
f01090a3:	05 5c d5 01 00       	add    $0x1d55c,%eax
f01090a8:	8b 00                	mov    (%eax),%eax
f01090aa:	83 ec 04             	sub    $0x4,%esp
f01090ad:	50                   	push   %eax
f01090ae:	ff 75 f4             	pushl  -0xc(%ebp)
f01090b1:	68 d8 51 12 f0       	push   $0xf01251d8
f01090b6:	e8 b1 7e ff ff       	call   f0100f6c <cprintf>
f01090bb:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f01090be:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01090c1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01090c4:	89 d0                	mov    %edx,%eax
f01090c6:	01 c0                	add    %eax,%eax
f01090c8:	01 d0                	add    %edx,%eax
f01090ca:	c1 e0 03             	shl    $0x3,%eax
f01090cd:	01 c8                	add    %ecx,%eax
f01090cf:	05 64 d5 01 00       	add    $0x1d564,%eax
f01090d4:	8b 18                	mov    (%eax),%ebx
f01090d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01090d9:	8b 40 64             	mov    0x64(%eax),%eax
f01090dc:	83 ec 08             	sub    $0x8,%esp
f01090df:	ff 75 f0             	pushl  -0x10(%ebp)
f01090e2:	50                   	push   %eax
f01090e3:	e8 fe f8 ff ff       	call   f01089e6 <pd_is_table_used>
f01090e8:	83 c4 10             	add    $0x10,%esp
f01090eb:	83 ec 04             	sub    $0x4,%esp
f01090ee:	53                   	push   %ebx
f01090ef:	50                   	push   %eax
f01090f0:	68 f0 51 12 f0       	push   $0xf01251f0
f01090f5:	e8 72 7e ff ff       	call   f0100f6c <cprintf>
f01090fa:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f01090fd:	8b 45 08             	mov    0x8(%ebp),%eax
f0109100:	8b 80 0c da 01 00    	mov    0x1da0c(%eax),%eax
f0109106:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0109109:	75 10                	jne    f010911b <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f010910b:	83 ec 0c             	sub    $0xc,%esp
f010910e:	68 93 51 12 f0       	push   $0xf0125193
f0109113:	e8 54 7e ff ff       	call   f0100f6c <cprintf>
f0109118:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f010911b:	83 ec 0c             	sub    $0xc,%esp
f010911e:	68 38 51 12 f0       	push   $0xf0125138
f0109123:	e8 44 7e ff ff       	call   f0100f6c <cprintf>
f0109128:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010912b:	ff 45 f4             	incl   -0xc(%ebp)
f010912e:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f0109132:	0f 86 e0 fe ff ff    	jbe    f0109018 <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f0109138:	90                   	nop
f0109139:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010913c:	c9                   	leave  
f010913d:	c3                   	ret    

f010913e <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f010913e:	55                   	push   %ebp
f010913f:	89 e5                	mov    %esp,%ebp
f0109141:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f0109144:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010914b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f0109152:	eb 22                	jmp    f0109176 <env_table_ws_get_size+0x38>
f0109154:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109157:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010915a:	89 d0                	mov    %edx,%eax
f010915c:	01 c0                	add    %eax,%eax
f010915e:	01 d0                	add    %edx,%eax
f0109160:	c1 e0 03             	shl    $0x3,%eax
f0109163:	01 c8                	add    %ecx,%eax
f0109165:	05 60 d5 01 00       	add    $0x1d560,%eax
f010916a:	8a 00                	mov    (%eax),%al
f010916c:	84 c0                	test   %al,%al
f010916e:	75 03                	jne    f0109173 <env_table_ws_get_size+0x35>
f0109170:	ff 45 f8             	incl   -0x8(%ebp)
f0109173:	ff 45 fc             	incl   -0x4(%ebp)
f0109176:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f010917a:	7e d8                	jle    f0109154 <env_table_ws_get_size+0x16>
	return counter;
f010917c:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f010917f:	c9                   	leave  
f0109180:	c3                   	ret    

f0109181 <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0109181:	55                   	push   %ebp
f0109182:	89 e5                	mov    %esp,%ebp
f0109184:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f0109187:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f010918e:	eb 4e                	jmp    f01091de <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f0109190:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109193:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109196:	89 d0                	mov    %edx,%eax
f0109198:	01 c0                	add    %eax,%eax
f010919a:	01 d0                	add    %edx,%eax
f010919c:	c1 e0 03             	shl    $0x3,%eax
f010919f:	01 c8                	add    %ecx,%eax
f01091a1:	05 5c d5 01 00       	add    $0x1d55c,%eax
f01091a6:	8b 00                	mov    (%eax),%eax
f01091a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01091ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01091ae:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f01091b3:	89 c2                	mov    %eax,%edx
f01091b5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01091b8:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01091bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01091be:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f01091c3:	39 c2                	cmp    %eax,%edx
f01091c5:	75 14                	jne    f01091db <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f01091c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01091ca:	83 ec 08             	sub    $0x8,%esp
f01091cd:	50                   	push   %eax
f01091ce:	ff 75 08             	pushl  0x8(%ebp)
f01091d1:	e8 bc 00 00 00       	call   f0109292 <env_table_ws_clear_entry>
f01091d6:	83 c4 10             	add    $0x10,%esp
			break;
f01091d9:	eb 09                	jmp    f01091e4 <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f01091db:	ff 45 f4             	incl   -0xc(%ebp)
f01091de:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f01091e2:	7e ac                	jle    f0109190 <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f01091e4:	90                   	nop
f01091e5:	c9                   	leave  
f01091e6:	c3                   	ret    

f01091e7 <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f01091e7:	55                   	push   %ebp
f01091e8:	89 e5                	mov    %esp,%ebp
f01091ea:	53                   	push   %ebx
f01091eb:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f01091ee:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f01091f2:	76 19                	jbe    f010920d <env_table_ws_set_entry+0x26>
f01091f4:	68 14 52 12 f0       	push   $0xf0125214
f01091f9:	68 3a 50 12 f0       	push   $0xf012503a
f01091fe:	68 37 01 00 00       	push   $0x137
f0109203:	68 50 50 12 f0       	push   $0xf0125050
f0109208:	e8 0d 71 ff ff       	call   f010031a <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f010920d:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f0109214:	76 19                	jbe    f010922f <env_table_ws_set_entry+0x48>
f0109216:	68 70 50 12 f0       	push   $0xf0125070
f010921b:	68 3a 50 12 f0       	push   $0xf012503a
f0109220:	68 38 01 00 00       	push   $0x138
f0109225:	68 50 50 12 f0       	push   $0xf0125050
f010922a:	e8 eb 70 ff ff       	call   f010031a <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f010922f:	8b 45 10             	mov    0x10(%ebp),%eax
f0109232:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109235:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109238:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010923d:	89 c1                	mov    %eax,%ecx
f010923f:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0109242:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109245:	89 d0                	mov    %edx,%eax
f0109247:	01 c0                	add    %eax,%eax
f0109249:	01 d0                	add    %edx,%eax
f010924b:	c1 e0 03             	shl    $0x3,%eax
f010924e:	01 d8                	add    %ebx,%eax
f0109250:	05 5c d5 01 00       	add    $0x1d55c,%eax
f0109255:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f0109257:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010925a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010925d:	89 d0                	mov    %edx,%eax
f010925f:	01 c0                	add    %eax,%eax
f0109261:	01 d0                	add    %edx,%eax
f0109263:	c1 e0 03             	shl    $0x3,%eax
f0109266:	01 c8                	add    %ecx,%eax
f0109268:	05 60 d5 01 00       	add    $0x1d560,%eax
f010926d:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x80000000;
f0109270:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109273:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109276:	89 d0                	mov    %edx,%eax
f0109278:	01 c0                	add    %eax,%eax
f010927a:	01 d0                	add    %edx,%eax
f010927c:	c1 e0 03             	shl    $0x3,%eax
f010927f:	01 c8                	add    %ecx,%eax
f0109281:	05 64 d5 01 00       	add    $0x1d564,%eax
f0109286:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	return;
f010928c:	90                   	nop
}
f010928d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109290:	c9                   	leave  
f0109291:	c3                   	ret    

f0109292 <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f0109292:	55                   	push   %ebp
f0109293:	89 e5                	mov    %esp,%ebp
f0109295:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f0109298:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010929c:	76 19                	jbe    f01092b7 <env_table_ws_clear_entry+0x25>
f010929e:	68 14 52 12 f0       	push   $0xf0125214
f01092a3:	68 3a 50 12 f0       	push   $0xf012503a
f01092a8:	68 43 01 00 00       	push   $0x143
f01092ad:	68 50 50 12 f0       	push   $0xf0125050
f01092b2:	e8 63 70 ff ff       	call   f010031a <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f01092b7:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01092ba:	8b 55 0c             	mov    0xc(%ebp),%edx
f01092bd:	89 d0                	mov    %edx,%eax
f01092bf:	01 c0                	add    %eax,%eax
f01092c1:	01 d0                	add    %edx,%eax
f01092c3:	c1 e0 03             	shl    $0x3,%eax
f01092c6:	01 c8                	add    %ecx,%eax
f01092c8:	05 5c d5 01 00       	add    $0x1d55c,%eax
f01092cd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f01092d3:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01092d6:	8b 55 0c             	mov    0xc(%ebp),%edx
f01092d9:	89 d0                	mov    %edx,%eax
f01092db:	01 c0                	add    %eax,%eax
f01092dd:	01 d0                	add    %edx,%eax
f01092df:	c1 e0 03             	shl    $0x3,%eax
f01092e2:	01 c8                	add    %ecx,%eax
f01092e4:	05 60 d5 01 00       	add    $0x1d560,%eax
f01092e9:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f01092ec:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01092ef:	8b 55 0c             	mov    0xc(%ebp),%edx
f01092f2:	89 d0                	mov    %edx,%eax
f01092f4:	01 c0                	add    %eax,%eax
f01092f6:	01 d0                	add    %edx,%eax
f01092f8:	c1 e0 03             	shl    $0x3,%eax
f01092fb:	01 c8                	add    %ecx,%eax
f01092fd:	05 64 d5 01 00       	add    $0x1d564,%eax
f0109302:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f0109308:	90                   	nop
f0109309:	c9                   	leave  
f010930a:	c3                   	ret    

f010930b <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f010930b:	55                   	push   %ebp
f010930c:	89 e5                	mov    %esp,%ebp
f010930e:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f0109311:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f0109315:	76 19                	jbe    f0109330 <env_table_ws_get_virtual_address+0x25>
f0109317:	68 14 52 12 f0       	push   $0xf0125214
f010931c:	68 3a 50 12 f0       	push   $0xf012503a
f0109321:	68 4b 01 00 00       	push   $0x14b
f0109326:	68 50 50 12 f0       	push   $0xf0125050
f010932b:	e8 ea 6f ff ff       	call   f010031a <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f0109330:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109333:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109336:	89 d0                	mov    %edx,%eax
f0109338:	01 c0                	add    %eax,%eax
f010933a:	01 d0                	add    %edx,%eax
f010933c:	c1 e0 03             	shl    $0x3,%eax
f010933f:	01 c8                	add    %ecx,%eax
f0109341:	05 5c d5 01 00       	add    $0x1d55c,%eax
f0109346:	8b 00                	mov    (%eax),%eax
f0109348:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010934b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010934e:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f0109353:	c9                   	leave  
f0109354:	c3                   	ret    

f0109355 <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f0109355:	55                   	push   %ebp
f0109356:	89 e5                	mov    %esp,%ebp
f0109358:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010935b:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010935f:	76 19                	jbe    f010937a <env_table_ws_get_time_stamp+0x25>
f0109361:	68 14 52 12 f0       	push   $0xf0125214
f0109366:	68 3a 50 12 f0       	push   $0xf012503a
f010936b:	68 52 01 00 00       	push   $0x152
f0109370:	68 50 50 12 f0       	push   $0xf0125050
f0109375:	e8 a0 6f ff ff       	call   f010031a <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f010937a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010937d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109380:	89 d0                	mov    %edx,%eax
f0109382:	01 c0                	add    %eax,%eax
f0109384:	01 d0                	add    %edx,%eax
f0109386:	c1 e0 03             	shl    $0x3,%eax
f0109389:	01 c8                	add    %ecx,%eax
f010938b:	05 64 d5 01 00       	add    $0x1d564,%eax
f0109390:	8b 00                	mov    (%eax),%eax
}
f0109392:	c9                   	leave  
f0109393:	c3                   	ret    

f0109394 <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f0109394:	55                   	push   %ebp
f0109395:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f0109397:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010939a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010939d:	89 d0                	mov    %edx,%eax
f010939f:	01 c0                	add    %eax,%eax
f01093a1:	01 d0                	add    %edx,%eax
f01093a3:	c1 e0 03             	shl    $0x3,%eax
f01093a6:	01 c8                	add    %ecx,%eax
f01093a8:	05 60 d5 01 00       	add    $0x1d560,%eax
f01093ad:	8a 00                	mov    (%eax),%al
f01093af:	0f b6 c0             	movzbl %al,%eax
}
f01093b2:	5d                   	pop    %ebp
f01093b3:	c3                   	ret    

f01093b4 <double_WS_Size>:
///=================================================================================================
///=================================================================================================
///=================================================================================================

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f01093b4:	55                   	push   %ebp
f01093b5:	89 e5                	mov    %esp,%ebp
f01093b7:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f01093ba:	83 ec 04             	sub    $0x4,%esp
f01093bd:	68 45 52 12 f0       	push   $0xf0125245
f01093c2:	68 62 01 00 00       	push   $0x162
f01093c7:	68 50 50 12 f0       	push   $0xf0125050
f01093cc:	e8 49 6f ff ff       	call   f010031a <_panic>

f01093d1 <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f01093d1:	55                   	push   %ebp
f01093d2:	89 e5                	mov    %esp,%ebp
f01093d4:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f01093d7:	83 ec 04             	sub    $0x4,%esp
f01093da:	68 45 52 12 f0       	push   $0xf0125245
f01093df:	68 67 01 00 00       	push   $0x167
f01093e4:	68 50 50 12 f0       	push   $0xf0125050
f01093e9:	e8 2c 6f ff ff       	call   f010031a <_panic>

f01093ee <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f01093ee:	55                   	push   %ebp
f01093ef:	89 e5                	mov    %esp,%ebp
f01093f1:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] cut_paste_pages
	// Write your code here, remove the panic and write your code
	panic("cut_paste_pages() is not implemented yet...!!");
f01093f4:	83 ec 04             	sub    $0x4,%esp
f01093f7:	68 58 52 12 f0       	push   $0xf0125258
f01093fc:	6a 21                	push   $0x21
f01093fe:	68 86 52 12 f0       	push   $0xf0125286
f0109403:	e8 12 6f ff ff       	call   f010031a <_panic>

f0109408 <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f0109408:	55                   	push   %ebp
f0109409:	89 e5                	mov    %esp,%ebp
f010940b:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] copy_paste_chunk
	// Write your code here, remove the //panic and write your code
	panic("copy_paste_chunk() is not implemented yet...!!");
f010940e:	83 ec 04             	sub    $0x4,%esp
f0109411:	68 a4 52 12 f0       	push   $0xf01252a4
f0109416:	6a 34                	push   $0x34
f0109418:	68 86 52 12 f0       	push   $0xf0125286
f010941d:	e8 f8 6e ff ff       	call   f010031a <_panic>

f0109422 <share_chunk>:
//	It should set the permissions of the second range by the given perms
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, share the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f0109422:	55                   	push   %ebp
f0109423:	89 e5                	mov    %esp,%ebp
f0109425:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] share_chunk
	// Write your code here, remove the //panic and write your code
	panic("share_chunk() is not implemented yet...!!");
f0109428:	83 ec 04             	sub    $0x4,%esp
f010942b:	68 d4 52 12 f0       	push   $0xf01252d4
f0109430:	6a 44                	push   $0x44
f0109432:	68 86 52 12 f0       	push   $0xf0125286
f0109437:	e8 de 6e ff ff       	call   f010031a <_panic>

f010943c <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f010943c:	55                   	push   %ebp
f010943d:	89 e5                	mov    %esp,%ebp
f010943f:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] allocate_chunk
	// Write your code here, remove the //panic and write your code
	panic("allocate_chunk() is not implemented yet...!!");
f0109442:	83 ec 04             	sub    $0x4,%esp
f0109445:	68 00 53 12 f0       	push   $0xf0125300
f010944a:	6a 52                	push   $0x52
f010944c:	68 86 52 12 f0       	push   $0xf0125286
f0109451:	e8 c4 6e ff ff       	call   f010031a <_panic>

f0109456 <calculate_allocated_space>:

//=====================================
// 5) CALCULATE ALLOCATED SPACE IN RAM:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f0109456:	55                   	push   %ebp
f0109457:	89 e5                	mov    %esp,%ebp
f0109459:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_allocated_space
	// Write your code here, remove the panic and write your code
	panic("calculate_allocated_space() is not implemented yet...!!");
f010945c:	83 ec 04             	sub    $0x4,%esp
f010945f:	68 30 53 12 f0       	push   $0xf0125330
f0109464:	6a 5c                	push   $0x5c
f0109466:	68 86 52 12 f0       	push   $0xf0125286
f010946b:	e8 aa 6e ff ff       	call   f010031a <_panic>

f0109470 <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f0109470:	55                   	push   %ebp
f0109471:	89 e5                	mov    %esp,%ebp
f0109473:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_required_frames
	// Write your code here, remove the panic and write your code
	panic("calculate_required_frames() is not implemented yet...!!");
f0109476:	83 ec 04             	sub    $0x4,%esp
f0109479:	68 68 53 12 f0       	push   $0xf0125368
f010947e:	6a 69                	push   $0x69
f0109480:	68 86 52 12 f0       	push   $0xf0125286
f0109485:	e8 90 6e ff ff       	call   f010031a <_panic>

f010948a <sys_sbrk>:

//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
void* sys_sbrk(int numOfPages)
{
f010948a:	55                   	push   %ebp
f010948b:	89 e5                	mov    %esp,%ebp
f010948d:	83 ec 18             	sub    $0x18,%esp
	 * 		or the break exceed the limit of the dynamic allocator. If sys_sbrk fails, the net effect should
	 * 		be that sys_sbrk returns (void*) -1 and that the segment break and the process heap are unaffected.
	 * 		You might have to undo any operations you have done so far in this case.
	 */

	struct Env* env = get_cpu_proc(); //the current running Environment to adjust its break limit
f0109490:	e8 f9 0f 00 00       	call   f010a48e <get_cpu_proc>
f0109495:	89 45 f4             	mov    %eax,-0xc(%ebp)

	/*====================================*/
	/*Remove this line before start coding*/
	return (void*)-1 ;
f0109498:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	/*====================================*/

	//[PROJECT'24.MS2] Implement this function

}
f010949d:	c9                   	leave  
f010949e:	c3                   	ret    

f010949f <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010949f:	55                   	push   %ebp
f01094a0:	89 e5                	mov    %esp,%ebp
f01094a2:	83 ec 08             	sub    $0x8,%esp
	/*====================================*/
	/*Remove this line before start coding*/
	inctst();
f01094a5:	e8 9e 56 01 00       	call   f011eb48 <inctst>
	return;
f01094aa:	90                   	nop
	/*====================================*/

	//[PROJECT'24.MS2] [USER HEAP - KERNEL SIDE] allocate_user_mem
	// Write your code here, remove the panic and write your code
	panic("allocate_user_mem() is not implemented yet...!!");
}
f01094ab:	c9                   	leave  
f01094ac:	c3                   	ret    

f01094ad <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f01094ad:	55                   	push   %ebp
f01094ae:	89 e5                	mov    %esp,%ebp
f01094b0:	83 ec 08             	sub    $0x8,%esp
	/*====================================*/
	/*Remove this line before start coding*/
	inctst();
f01094b3:	e8 90 56 01 00       	call   f011eb48 <inctst>
	return;
f01094b8:	90                   	nop
	/*====================================*/

	//[PROJECT'24.MS2] [USER HEAP - KERNEL SIDE] free_user_mem
	// Write your code here, remove the panic and write your code
	panic("free_user_mem() is not implemented yet...!!");
}
f01094b9:	c9                   	leave  
f01094ba:	c3                   	ret    

f01094bb <__free_user_mem_with_buffering>:

//=====================================
// 2) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f01094bb:	55                   	push   %ebp
f01094bc:	89 e5                	mov    %esp,%ebp
f01094be:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f01094c1:	83 ec 04             	sub    $0x4,%esp
f01094c4:	68 a0 53 12 f0       	push   $0xf01253a0
f01094c9:	68 bc 00 00 00       	push   $0xbc
f01094ce:	68 86 52 12 f0       	push   $0xf0125286
f01094d3:	e8 42 6e ff ff       	call   f010031a <_panic>

f01094d8 <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f01094d8:	55                   	push   %ebp
f01094d9:	89 e5                	mov    %esp,%ebp
f01094db:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [USER HEAP - KERNEL SIDE] move_user_mem
	//your code is here, remove the panic and write your code
	panic("move_user_mem() is not implemented yet...!!");
f01094de:	83 ec 04             	sub    $0x4,%esp
f01094e1:	68 e0 53 12 f0       	push   $0xf01253e0
f01094e6:	68 c6 00 00 00       	push   $0xc6
f01094eb:	68 86 52 12 f0       	push   $0xf0125286
f01094f0:	e8 25 6e ff ff       	call   f010031a <_panic>

f01094f5 <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f01094f5:	55                   	push   %ebp
f01094f6:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f01094f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01094fb:	8b 15 20 4f 55 f0    	mov    0xf0554f20,%edx
f0109501:	29 d0                	sub    %edx,%eax
f0109503:	c1 f8 03             	sar    $0x3,%eax
f0109506:	89 c2                	mov    %eax,%edx
f0109508:	89 d0                	mov    %edx,%eax
f010950a:	c1 e0 02             	shl    $0x2,%eax
f010950d:	01 d0                	add    %edx,%eax
f010950f:	c1 e0 02             	shl    $0x2,%eax
f0109512:	01 d0                	add    %edx,%eax
f0109514:	c1 e0 02             	shl    $0x2,%eax
f0109517:	01 d0                	add    %edx,%eax
f0109519:	89 c1                	mov    %eax,%ecx
f010951b:	c1 e1 08             	shl    $0x8,%ecx
f010951e:	01 c8                	add    %ecx,%eax
f0109520:	89 c1                	mov    %eax,%ecx
f0109522:	c1 e1 10             	shl    $0x10,%ecx
f0109525:	01 c8                	add    %ecx,%eax
f0109527:	01 c0                	add    %eax,%eax
f0109529:	01 d0                	add    %edx,%eax
}
f010952b:	5d                   	pop    %ebp
f010952c:	c3                   	ret    

f010952d <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010952d:	55                   	push   %ebp
f010952e:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0109530:	ff 75 08             	pushl  0x8(%ebp)
f0109533:	e8 bd ff ff ff       	call   f01094f5 <to_frame_number>
f0109538:	83 c4 04             	add    $0x4,%esp
f010953b:	c1 e0 0c             	shl    $0xc,%eax
}
f010953e:	c9                   	leave  
f010953f:	c3                   	ret    

f0109540 <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f0109540:	55                   	push   %ebp
f0109541:	89 e5                	mov    %esp,%ebp
f0109543:	56                   	push   %esi
f0109544:	53                   	push   %ebx
f0109545:	83 ec 10             	sub    $0x10,%esp
	int iEnv = NENV-1;
f0109548:	c7 45 f4 07 00 00 00 	movl   $0x7,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f010954f:	e9 28 02 00 00       	jmp    f010977c <env_init+0x23c>
	{
		envs[iEnv].env_status = ENV_FREE;
f0109554:	8b 0d 10 1a 55 f0    	mov    0xf0551a10,%ecx
f010955a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010955d:	89 d0                	mov    %edx,%eax
f010955f:	c1 e0 06             	shl    $0x6,%eax
f0109562:	29 d0                	sub    %edx,%eax
f0109564:	c1 e0 02             	shl    $0x2,%eax
f0109567:	01 d0                	add    %edx,%eax
f0109569:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f0109570:	01 d8                	add    %ebx,%eax
f0109572:	c1 e0 03             	shl    $0x3,%eax
f0109575:	01 d0                	add    %edx,%eax
f0109577:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010957e:	29 c2                	sub    %eax,%edx
f0109580:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f0109587:	89 c2                	mov    %eax,%edx
f0109589:	89 d0                	mov    %edx,%eax
f010958b:	01 c8                	add    %ecx,%eax
f010958d:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f0109594:	8b 0d 10 1a 55 f0    	mov    0xf0551a10,%ecx
f010959a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010959d:	89 d0                	mov    %edx,%eax
f010959f:	c1 e0 06             	shl    $0x6,%eax
f01095a2:	29 d0                	sub    %edx,%eax
f01095a4:	c1 e0 02             	shl    $0x2,%eax
f01095a7:	01 d0                	add    %edx,%eax
f01095a9:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f01095b0:	01 d8                	add    %ebx,%eax
f01095b2:	c1 e0 03             	shl    $0x3,%eax
f01095b5:	01 d0                	add    %edx,%eax
f01095b7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01095be:	29 c2                	sub    %eax,%edx
f01095c0:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f01095c7:	89 c2                	mov    %eax,%edx
f01095c9:	89 d0                	mov    %edx,%eax
f01095cb:	01 c8                	add    %ecx,%eax
f01095cd:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f01095d4:	8b 0d 10 1a 55 f0    	mov    0xf0551a10,%ecx
f01095da:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01095dd:	89 d0                	mov    %edx,%eax
f01095df:	c1 e0 06             	shl    $0x6,%eax
f01095e2:	29 d0                	sub    %edx,%eax
f01095e4:	c1 e0 02             	shl    $0x2,%eax
f01095e7:	01 d0                	add    %edx,%eax
f01095e9:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f01095f0:	01 d8                	add    %ebx,%eax
f01095f2:	c1 e0 03             	shl    $0x3,%eax
f01095f5:	01 d0                	add    %edx,%eax
f01095f7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01095fe:	29 c2                	sub    %eax,%edx
f0109600:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f0109607:	89 c2                	mov    %eax,%edx
f0109609:	89 d0                	mov    %edx,%eax
f010960b:	01 c8                	add    %ecx,%eax
f010960d:	85 c0                	test   %eax,%eax
f010960f:	75 14                	jne    f0109625 <env_init+0xe5>
f0109611:	83 ec 04             	sub    $0x4,%esp
f0109614:	68 0c 54 12 f0       	push   $0xf012540c
f0109619:	6a 64                	push   $0x64
f010961b:	68 2f 54 12 f0       	push   $0xf012542f
f0109620:	e8 f5 6c ff ff       	call   f010031a <_panic>
f0109625:	8b 0d 10 1a 55 f0    	mov    0xf0551a10,%ecx
f010962b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010962e:	89 d0                	mov    %edx,%eax
f0109630:	c1 e0 06             	shl    $0x6,%eax
f0109633:	29 d0                	sub    %edx,%eax
f0109635:	c1 e0 02             	shl    $0x2,%eax
f0109638:	01 d0                	add    %edx,%eax
f010963a:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f0109641:	01 d8                	add    %ebx,%eax
f0109643:	c1 e0 03             	shl    $0x3,%eax
f0109646:	01 d0                	add    %edx,%eax
f0109648:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010964f:	29 c2                	sub    %eax,%edx
f0109651:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f0109658:	89 c2                	mov    %eax,%edx
f010965a:	89 d0                	mov    %edx,%eax
f010965c:	01 c8                	add    %ecx,%eax
f010965e:	8b 15 14 1a 55 f0    	mov    0xf0551a14,%edx
f0109664:	89 50 08             	mov    %edx,0x8(%eax)
f0109667:	8b 40 08             	mov    0x8(%eax),%eax
f010966a:	85 c0                	test   %eax,%eax
f010966c:	74 44                	je     f01096b2 <env_init+0x172>
f010966e:	8b 0d 14 1a 55 f0    	mov    0xf0551a14,%ecx
f0109674:	8b 1d 10 1a 55 f0    	mov    0xf0551a10,%ebx
f010967a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010967d:	89 d0                	mov    %edx,%eax
f010967f:	c1 e0 06             	shl    $0x6,%eax
f0109682:	29 d0                	sub    %edx,%eax
f0109684:	c1 e0 02             	shl    $0x2,%eax
f0109687:	01 d0                	add    %edx,%eax
f0109689:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
f0109690:	01 f0                	add    %esi,%eax
f0109692:	c1 e0 03             	shl    $0x3,%eax
f0109695:	01 d0                	add    %edx,%eax
f0109697:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010969e:	29 c2                	sub    %eax,%edx
f01096a0:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f01096a7:	89 c2                	mov    %eax,%edx
f01096a9:	89 d0                	mov    %edx,%eax
f01096ab:	01 d8                	add    %ebx,%eax
f01096ad:	89 41 0c             	mov    %eax,0xc(%ecx)
f01096b0:	eb 3e                	jmp    f01096f0 <env_init+0x1b0>
f01096b2:	8b 0d 10 1a 55 f0    	mov    0xf0551a10,%ecx
f01096b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01096bb:	89 d0                	mov    %edx,%eax
f01096bd:	c1 e0 06             	shl    $0x6,%eax
f01096c0:	29 d0                	sub    %edx,%eax
f01096c2:	c1 e0 02             	shl    $0x2,%eax
f01096c5:	01 d0                	add    %edx,%eax
f01096c7:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f01096ce:	01 d8                	add    %ebx,%eax
f01096d0:	c1 e0 03             	shl    $0x3,%eax
f01096d3:	01 d0                	add    %edx,%eax
f01096d5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01096dc:	29 c2                	sub    %eax,%edx
f01096de:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f01096e5:	89 c2                	mov    %eax,%edx
f01096e7:	89 d0                	mov    %edx,%eax
f01096e9:	01 c8                	add    %ecx,%eax
f01096eb:	a3 18 1a 55 f0       	mov    %eax,0xf0551a18
f01096f0:	8b 0d 10 1a 55 f0    	mov    0xf0551a10,%ecx
f01096f6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01096f9:	89 d0                	mov    %edx,%eax
f01096fb:	c1 e0 06             	shl    $0x6,%eax
f01096fe:	29 d0                	sub    %edx,%eax
f0109700:	c1 e0 02             	shl    $0x2,%eax
f0109703:	01 d0                	add    %edx,%eax
f0109705:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f010970c:	01 d8                	add    %ebx,%eax
f010970e:	c1 e0 03             	shl    $0x3,%eax
f0109711:	01 d0                	add    %edx,%eax
f0109713:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010971a:	29 c2                	sub    %eax,%edx
f010971c:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f0109723:	89 c2                	mov    %eax,%edx
f0109725:	89 d0                	mov    %edx,%eax
f0109727:	01 c8                	add    %ecx,%eax
f0109729:	a3 14 1a 55 f0       	mov    %eax,0xf0551a14
f010972e:	8b 0d 10 1a 55 f0    	mov    0xf0551a10,%ecx
f0109734:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109737:	89 d0                	mov    %edx,%eax
f0109739:	c1 e0 06             	shl    $0x6,%eax
f010973c:	29 d0                	sub    %edx,%eax
f010973e:	c1 e0 02             	shl    $0x2,%eax
f0109741:	01 d0                	add    %edx,%eax
f0109743:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f010974a:	01 d8                	add    %ebx,%eax
f010974c:	c1 e0 03             	shl    $0x3,%eax
f010974f:	01 d0                	add    %edx,%eax
f0109751:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109758:	29 c2                	sub    %eax,%edx
f010975a:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f0109761:	89 c2                	mov    %eax,%edx
f0109763:	89 d0                	mov    %edx,%eax
f0109765:	01 c8                	add    %ecx,%eax
f0109767:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010976e:	a1 20 1a 55 f0       	mov    0xf0551a20,%eax
f0109773:	40                   	inc    %eax
f0109774:	a3 20 1a 55 f0       	mov    %eax,0xf0551a20
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f0109779:	ff 4d f4             	decl   -0xc(%ebp)
f010977c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109780:	0f 89 ce fd ff ff    	jns    f0109554 <env_init+0x14>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f0109786:	90                   	nop
f0109787:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010978a:	5b                   	pop    %ebx
f010978b:	5e                   	pop    %esi
f010978c:	5d                   	pop    %ebp
f010978d:	c3                   	ret    

f010978e <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010978e:	55                   	push   %ebp
f010978f:	89 e5                	mov    %esp,%ebp
f0109791:	57                   	push   %edi
f0109792:	56                   	push   %esi
f0109793:	53                   	push   %ebx
f0109794:	81 ec fc 00 00 00    	sub    $0xfc,%esp
	//[1] get pointer to the start of the "user_program_name" program in memory
	// Hint: use "get_user_program_info" function,
	// you should set the following "ptr_program_start" by the start address of the user program
	uint8* ptr_program_start = 0;
f010979a:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)

	struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f01097a1:	83 ec 0c             	sub    $0xc,%esp
f01097a4:	ff 75 08             	pushl  0x8(%ebp)
f01097a7:	e8 c8 24 00 00       	call   f010bc74 <get_user_program_info>
f01097ac:	83 c4 10             	add    $0x10,%esp
f01097af:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	if(ptr_user_program_info == 0)
f01097b2:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f01097b6:	75 0a                	jne    f01097c2 <env_create+0x34>
	{
		return NULL;
f01097b8:	b8 00 00 00 00       	mov    $0x0,%eax
f01097bd:	e9 2a 0c 00 00       	jmp    f010a3ec <env_create+0xc5e>
	}
	ptr_program_start = ptr_user_program_info->ptr_start ;
f01097c2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01097c5:	8b 40 08             	mov    0x8(%eax),%eax
f01097c8:	89 45 b8             	mov    %eax,-0x48(%ebp)

	//[2] allocate new environment, (from the free environment list)
	//if there's no one, return NULL
	// Hint: use "allocate_environment" function
	struct Env* e = NULL;
f01097cb:	c7 85 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebp)
f01097d2:	00 00 00 
	if(allocate_environment(&e) < 0)
f01097d5:	83 ec 0c             	sub    $0xc,%esp
f01097d8:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
f01097de:	50                   	push   %eax
f01097df:	e8 23 11 00 00       	call   f010a907 <allocate_environment>
f01097e4:	83 c4 10             	add    $0x10,%esp
f01097e7:	85 c0                	test   %eax,%eax
f01097e9:	79 0a                	jns    f01097f5 <env_create+0x67>
	{
		return NULL;
f01097eb:	b8 00 00 00 00       	mov    $0x0,%eax
f01097f0:	e9 f7 0b 00 00       	jmp    f010a3ec <env_create+0xc5e>
	}

	//[2.5 - 2012] Set program name inside the environment
	//e->prog_name = ptr_user_program_info->name ;
	//2017: changed to fixed size array to be abale to access it from user side
	if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f01097f5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01097f8:	8b 00                	mov    (%eax),%eax
f01097fa:	83 ec 0c             	sub    $0xc,%esp
f01097fd:	50                   	push   %eax
f01097fe:	e8 4e 6d 01 00       	call   f0120551 <strlen>
f0109803:	83 c4 10             	add    $0x10,%esp
f0109806:	83 f8 3f             	cmp    $0x3f,%eax
f0109809:	7f 1d                	jg     f0109828 <env_create+0x9a>
		strcpy(e->prog_name, ptr_user_program_info->name);
f010980b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010980e:	8b 00                	mov    (%eax),%eax
f0109810:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f0109816:	83 c2 20             	add    $0x20,%edx
f0109819:	83 ec 08             	sub    $0x8,%esp
f010981c:	50                   	push   %eax
f010981d:	52                   	push   %edx
f010981e:	e8 7d 6d 01 00       	call   f01205a0 <strcpy>
f0109823:	83 c4 10             	add    $0x10,%esp
f0109826:	eb 1d                	jmp    f0109845 <env_create+0xb7>
	else
		strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f0109828:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010982b:	8b 00                	mov    (%eax),%eax
f010982d:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f0109833:	83 c2 20             	add    $0x20,%edx
f0109836:	83 ec 04             	sub    $0x4,%esp
f0109839:	6a 3f                	push   $0x3f
f010983b:	50                   	push   %eax
f010983c:	52                   	push   %edx
f010983d:	e8 8c 6d 01 00       	call   f01205ce <strncpy>
f0109842:	83 c4 10             	add    $0x10,%esp
		phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
	}
#else
	{
		int r;
		struct FrameInfo *p = NULL;
f0109845:	c7 85 3c ff ff ff 00 	movl   $0x0,-0xc4(%ebp)
f010984c:	00 00 00 

		allocate_frame(&p) ;
f010984f:	83 ec 0c             	sub    $0xc,%esp
f0109852:	8d 85 3c ff ff ff    	lea    -0xc4(%ebp),%eax
f0109858:	50                   	push   %eax
f0109859:	e8 90 e6 ff ff       	call   f0107eee <allocate_frame>
f010985e:	83 c4 10             	add    $0x10,%esp
		p->references = 1;
f0109861:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0109867:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)

		ptr_user_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
f010986d:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0109873:	83 ec 0c             	sub    $0xc,%esp
f0109876:	50                   	push   %eax
f0109877:	e8 b1 fc ff ff       	call   f010952d <to_physical_address>
f010987c:	83 c4 10             	add    $0x10,%esp
f010987f:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0109882:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0109885:	c1 e8 0c             	shr    $0xc,%eax
f0109888:	89 45 ac             	mov    %eax,-0x54(%ebp)
f010988b:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0109890:	39 45 ac             	cmp    %eax,-0x54(%ebp)
f0109893:	72 17                	jb     f01098ac <env_create+0x11e>
f0109895:	ff 75 b0             	pushl  -0x50(%ebp)
f0109898:	68 4c 54 12 f0       	push   $0xf012544c
f010989d:	68 9c 00 00 00       	push   $0x9c
f01098a2:	68 2f 54 12 f0       	push   $0xf012542f
f01098a7:	e8 6e 6a ff ff       	call   f010031a <_panic>
f01098ac:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01098af:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01098b4:	89 45 a8             	mov    %eax,-0x58(%ebp)
		phys_user_page_directory = to_physical_address(p);
f01098b7:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f01098bd:	83 ec 0c             	sub    $0xc,%esp
f01098c0:	50                   	push   %eax
f01098c1:	e8 67 fc ff ff       	call   f010952d <to_physical_address>
f01098c6:	83 c4 10             	add    $0x10,%esp
f01098c9:	89 45 a4             	mov    %eax,-0x5c(%ebp)
#endif
	//[4] initialize the new environment by the virtual address of the page directory
	// Hint: use "initialize_environment" function

	//2016
	e->page_WS_max_size = page_WS_size;
f01098cc:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f01098d2:	8b 55 0c             	mov    0xc(%ebp),%edx
f01098d5:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

	//2020
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f01098db:	83 ec 0c             	sub    $0xc,%esp
f01098de:	6a 02                	push   $0x2
f01098e0:	e8 a8 4a 00 00       	call   f010e38d <isPageReplacmentAlgorithmLRU>
f01098e5:	83 c4 10             	add    $0x10,%esp
f01098e8:	85 c0                	test   %eax,%eax
f01098ea:	74 21                	je     f010990d <env_create+0x17f>
	{
		e->SecondListSize = LRU_second_list_size;
f01098ec:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f01098f2:	8b 55 10             	mov    0x10(%ebp),%edx
f01098f5:	89 90 34 da 01 00    	mov    %edx,0x1da34(%eax)
		e->ActiveListSize = page_WS_size - LRU_second_list_size;
f01098fb:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109901:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109904:	2b 55 10             	sub    0x10(%ebp),%edx
f0109907:	89 90 30 da 01 00    	mov    %edx,0x1da30(%eax)
	}

	//2018
	if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f010990d:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0109911:	75 12                	jne    f0109925 <env_create+0x197>
		e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f0109913:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109919:	c7 80 3c da 01 00 0a 	movl   $0xa,0x1da3c(%eax)
f0109920:	00 00 00 
f0109923:	eb 0f                	jmp    f0109934 <env_create+0x1a6>
	else
		e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f0109925:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010992b:	8b 55 14             	mov    0x14(%ebp),%edx
f010992e:	89 90 3c da 01 00    	mov    %edx,0x1da3c(%eax)

	initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f0109934:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010993a:	83 ec 04             	sub    $0x4,%esp
f010993d:	ff 75 a4             	pushl  -0x5c(%ebp)
f0109940:	ff 75 a8             	pushl  -0x58(%ebp)
f0109943:	50                   	push   %eax
f0109944:	e8 76 18 00 00       	call   f010b1bf <initialize_environment>
f0109949:	83 c4 10             	add    $0x10,%esp
	//	3- uint32 size_in_memory: actual size required by this segment in memory
	// 	usually size_in_file < or = size_in_memory
	//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

	//[5] 2024: Disable the interrupt before switching the directories
	pushcli();
f010994c:	e8 8d d5 ff ff       	call   f0106ede <pushcli>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0109951:	0f 20 d8             	mov    %cr3,%eax
f0109954:	89 45 98             	mov    %eax,-0x68(%ebp)
	return val;
f0109957:	8b 45 98             	mov    -0x68(%ebp),%eax
	{
		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f010995a:	89 45 9c             	mov    %eax,-0x64(%ebp)
		lcr3(e->env_cr3) ;
f010995d:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109963:	8b 40 68             	mov    0x68(%eax),%eax
f0109966:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010996c:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0109972:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f0109975:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		int segment_counter=0;
f010997c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f0109983:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109989:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010998f:	48                   	dec    %eax
f0109990:	89 45 dc             	mov    %eax,-0x24(%ebp)
		uint32 lastTableNumber=0xffffffff;
f0109993:	c7 85 38 ff ff ff ff 	movl   $0xffffffff,-0xc8(%ebp)
f010999a:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010999d:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
f01099a3:	83 ec 08             	sub    $0x8,%esp
f01099a6:	ff 75 b8             	pushl  -0x48(%ebp)
f01099a9:	50                   	push   %eax
f01099aa:	e8 d7 1f 00 00       	call   f010b986 <PROGRAM_SEGMENT_FIRST>
f01099af:	83 c4 0c             	add    $0xc,%esp
f01099b2:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01099b8:	8d 95 f8 fe ff ff    	lea    -0x108(%ebp),%edx
f01099be:	b9 05 00 00 00       	mov    $0x5,%ecx
f01099c3:	89 c7                	mov    %eax,%edi
f01099c5:	89 d6                	mov    %edx,%esi
f01099c7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01099c9:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01099cf:	89 45 d8             	mov    %eax,-0x28(%ebp)
f01099d2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01099d5:	8b 40 10             	mov    0x10(%eax),%eax
f01099d8:	83 f8 ff             	cmp    $0xffffffff,%eax
f01099db:	75 07                	jne    f01099e4 <env_create+0x256>
f01099dd:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f01099e4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01099e7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01099ea:	e9 24 03 00 00       	jmp    f0109d13 <env_create+0x585>
		{
			segment_counter++;
f01099ef:	ff 45 e0             	incl   -0x20(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f01099f2:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01099f9:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f01099fc:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109a02:	83 ec 0c             	sub    $0xc,%esp
f0109a05:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f0109a0b:	52                   	push   %edx
f0109a0c:	ff 75 dc             	pushl  -0x24(%ebp)
f0109a0f:	8d 95 20 ff ff ff    	lea    -0xe0(%ebp),%edx
f0109a15:	52                   	push   %edx
f0109a16:	ff 75 e4             	pushl  -0x1c(%ebp)
f0109a19:	50                   	push   %eax
f0109a1a:	e8 a6 0f 00 00       	call   f010a9c5 <program_segment_alloc_map_copy_workingset>
f0109a1f:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f0109a22:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0109a28:	29 45 dc             	sub    %eax,-0x24(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f0109a2b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109a2e:	8b 00                	mov    (%eax),%eax
f0109a30:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f0109a33:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109a36:	8b 40 0c             	mov    0xc(%eax),%eax
f0109a39:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f0109a3c:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109a3f:	89 45 8c             	mov    %eax,-0x74(%ebp)
f0109a42:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0109a45:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109a4a:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f0109a4d:	c7 45 84 00 10 00 00 	movl   $0x1000,-0x7c(%ebp)
f0109a54:	8b 55 90             	mov    -0x70(%ebp),%edx
f0109a57:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0109a5a:	01 d0                	add    %edx,%eax
f0109a5c:	48                   	dec    %eax
f0109a5d:	89 45 80             	mov    %eax,-0x80(%ebp)
f0109a60:	8b 45 80             	mov    -0x80(%ebp),%eax
f0109a63:	ba 00 00 00 00       	mov    $0x0,%edx
f0109a68:	f7 75 84             	divl   -0x7c(%ebp)
f0109a6b:	8b 45 80             	mov    -0x80(%ebp),%eax
f0109a6e:	29 d0                	sub    %edx,%eax
f0109a70:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f0109a76:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109a79:	2b 45 88             	sub    -0x78(%ebp),%eax
f0109a7c:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			memset(ptr_temp_page , 0, PAGE_SIZE);
f0109a82:	a1 64 51 55 f0       	mov    0xf0555164,%eax
f0109a87:	83 ec 04             	sub    $0x4,%esp
f0109a8a:	68 00 10 00 00       	push   $0x1000
f0109a8f:	6a 00                	push   $0x0
f0109a91:	50                   	push   %eax
f0109a92:	e8 a8 6c 01 00       	call   f012073f <memset>
f0109a97:	83 c4 10             	add    $0x10,%esp
			uint8 *src_ptr =  (uint8*) dataSrc_va;
f0109a9a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0109a9d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f0109aa0:	8b 15 64 51 55 f0    	mov    0xf0555164,%edx
f0109aa6:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0109aac:	01 d0                	add    %edx,%eax
f0109aae:	89 45 d0             	mov    %eax,-0x30(%ebp)
			int i;
			for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f0109ab1:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109ab4:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0109ab7:	eb 13                	jmp    f0109acc <env_create+0x33e>
			{
				*dst_ptr = *src_ptr ;
f0109ab9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109abc:	8a 10                	mov    (%eax),%dl
f0109abe:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109ac1:	88 10                	mov    %dl,(%eax)

			memset(ptr_temp_page , 0, PAGE_SIZE);
			uint8 *src_ptr =  (uint8*) dataSrc_va;
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f0109ac3:	ff 45 cc             	incl   -0x34(%ebp)
f0109ac6:	ff 45 d4             	incl   -0x2c(%ebp)
f0109ac9:	ff 45 d0             	incl   -0x30(%ebp)
f0109acc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109acf:	3b 85 7c ff ff ff    	cmp    -0x84(%ebp),%eax
f0109ad5:	72 e2                	jb     f0109ab9 <env_create+0x32b>
			{
				*dst_ptr = *src_ptr ;
			}

			if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f0109ad7:	8b 15 64 51 55 f0    	mov    0xf0555164,%edx
f0109add:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109ae3:	83 ec 04             	sub    $0x4,%esp
f0109ae6:	52                   	push   %edx
f0109ae7:	ff 75 88             	pushl  -0x78(%ebp)
f0109aea:	50                   	push   %eax
f0109aeb:	e8 76 a3 ff ff       	call   f0103e66 <pf_add_env_page>
f0109af0:	83 c4 10             	add    $0x10,%esp
f0109af3:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0109af6:	75 17                	jne    f0109b0f <env_create+0x381>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f0109af8:	83 ec 04             	sub    $0x4,%esp
f0109afb:	68 7c 54 12 f0       	push   $0xf012547c
f0109b00:	68 f2 00 00 00       	push   $0xf2
f0109b05:	68 2f 54 12 f0       	push   $0xf012542f
f0109b0a:	e8 0b 68 ff ff       	call   f010031a <_panic>
			//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");


			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f0109b0f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109b12:	8b 50 04             	mov    0x4(%eax),%edx
f0109b15:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109b18:	01 d0                	add    %edx,%eax
f0109b1a:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0109b20:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0109b26:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109b2b:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f0109b31:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109b34:	8b 50 04             	mov    0x4(%eax),%edx
f0109b37:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109b3a:	01 d0                	add    %edx,%eax
f0109b3c:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f0109b42:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f0109b48:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0109b4b:	eb 43                	jmp    f0109b90 <env_create+0x402>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f0109b4d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0109b50:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109b56:	83 ec 04             	sub    $0x4,%esp
f0109b59:	ff 75 d4             	pushl  -0x2c(%ebp)
f0109b5c:	52                   	push   %edx
f0109b5d:	50                   	push   %eax
f0109b5e:	e8 03 a3 ff ff       	call   f0103e66 <pf_add_env_page>
f0109b63:	83 c4 10             	add    $0x10,%esp
f0109b66:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0109b69:	75 17                	jne    f0109b82 <env_create+0x3f4>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f0109b6b:	83 ec 04             	sub    $0x4,%esp
f0109b6e:	68 7c 54 12 f0       	push   $0xf012547c
f0109b73:	68 ff 00 00 00       	push   $0xff
f0109b78:	68 2f 54 12 f0       	push   $0xf012542f
f0109b7d:	e8 98 67 ff ff       	call   f010031a <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f0109b82:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f0109b89:	81 45 d4 00 10 00 00 	addl   $0x1000,-0x2c(%ebp)
f0109b90:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109b93:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f0109b99:	72 b2                	jb     f0109b4d <env_create+0x3bf>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f0109b9b:	a1 64 51 55 f0       	mov    0xf0555164,%eax
f0109ba0:	89 45 d0             	mov    %eax,-0x30(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f0109ba3:	83 ec 04             	sub    $0x4,%esp
f0109ba6:	68 00 10 00 00       	push   $0x1000
f0109bab:	6a 00                	push   $0x0
f0109bad:	ff 75 d0             	pushl  -0x30(%ebp)
f0109bb0:	e8 8a 6b 01 00       	call   f012073f <memset>
f0109bb5:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f0109bb8:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0109bbe:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0109bc1:	eb 13                	jmp    f0109bd6 <env_create+0x448>
			{
				*dst_ptr = *src_ptr;
f0109bc3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109bc6:	8a 10                	mov    (%eax),%dl
f0109bc8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109bcb:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f0109bcd:	ff 45 cc             	incl   -0x34(%ebp)
f0109bd0:	ff 45 d4             	incl   -0x2c(%ebp)
f0109bd3:	ff 45 d0             	incl   -0x30(%ebp)
f0109bd6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109bd9:	3b 85 6c ff ff ff    	cmp    -0x94(%ebp),%eax
f0109bdf:	72 e2                	jb     f0109bc3 <env_create+0x435>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f0109be1:	8b 15 64 51 55 f0    	mov    0xf0555164,%edx
f0109be7:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109bed:	83 ec 04             	sub    $0x4,%esp
f0109bf0:	52                   	push   %edx
f0109bf1:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
f0109bf7:	50                   	push   %eax
f0109bf8:	e8 69 a2 ff ff       	call   f0103e66 <pf_add_env_page>
f0109bfd:	83 c4 10             	add    $0x10,%esp
f0109c00:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0109c03:	75 17                	jne    f0109c1c <env_create+0x48e>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f0109c05:	83 ec 04             	sub    $0x4,%esp
f0109c08:	68 7c 54 12 f0       	push   $0xf012547c
f0109c0d:	68 0e 01 00 00       	push   $0x10e
f0109c12:	68 2f 54 12 f0       	push   $0xf012542f
f0109c17:	e8 fe 66 ff ff       	call   f010031a <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f0109c1c:	c7 85 68 ff ff ff 00 	movl   $0x1000,-0x98(%ebp)
f0109c23:	10 00 00 
f0109c26:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109c29:	8b 50 04             	mov    0x4(%eax),%edx
f0109c2c:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109c2f:	01 c2                	add    %eax,%edx
f0109c31:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f0109c37:	01 d0                	add    %edx,%eax
f0109c39:	48                   	dec    %eax
f0109c3a:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
f0109c40:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0109c46:	ba 00 00 00 00       	mov    $0x0,%edx
f0109c4b:	f7 b5 68 ff ff ff    	divl   -0x98(%ebp)
f0109c51:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0109c57:	29 d0                	sub    %edx,%eax
f0109c59:	89 45 c8             	mov    %eax,-0x38(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f0109c5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109c5f:	8b 50 08             	mov    0x8(%eax),%edx
f0109c62:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109c65:	01 d0                	add    %edx,%eax
f0109c67:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109c6a:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f0109c70:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f0109c77:	eb 41                	jmp    f0109cba <env_create+0x52c>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f0109c79:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109c7f:	83 ec 04             	sub    $0x4,%esp
f0109c82:	6a 01                	push   $0x1
f0109c84:	ff 75 c8             	pushl  -0x38(%ebp)
f0109c87:	50                   	push   %eax
f0109c88:	e8 ab a0 ff ff       	call   f0103d38 <pf_add_empty_env_page>
f0109c8d:	83 c4 10             	add    $0x10,%esp
f0109c90:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0109c93:	75 17                	jne    f0109cac <env_create+0x51e>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f0109c95:	83 ec 04             	sub    $0x4,%esp
f0109c98:	68 7c 54 12 f0       	push   $0xf012547c
f0109c9d:	68 1b 01 00 00       	push   $0x11b
f0109ca2:	68 2f 54 12 f0       	push   $0xf012542f
f0109ca7:	e8 6e 66 ff ff       	call   f010031a <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f0109cac:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f0109cb3:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f0109cba:	c7 85 5c ff ff ff 00 	movl   $0x1000,-0xa4(%ebp)
f0109cc1:	10 00 00 
f0109cc4:	8b 95 60 ff ff ff    	mov    -0xa0(%ebp),%edx
f0109cca:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f0109cd0:	01 d0                	add    %edx,%eax
f0109cd2:	48                   	dec    %eax
f0109cd3:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
f0109cd9:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0109cdf:	ba 00 00 00 00       	mov    $0x0,%edx
f0109ce4:	f7 b5 5c ff ff ff    	divl   -0xa4(%ebp)
f0109cea:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0109cf0:	29 d0                	sub    %edx,%eax
f0109cf2:	89 c2                	mov    %eax,%edx
f0109cf4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109cf7:	39 c2                	cmp    %eax,%edx
f0109cf9:	0f 87 7a ff ff ff    	ja     f0109c79 <env_create+0x4eb>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f0109cff:	83 ec 08             	sub    $0x8,%esp
f0109d02:	ff 75 b8             	pushl  -0x48(%ebp)
f0109d05:	ff 75 e4             	pushl  -0x1c(%ebp)
f0109d08:	e8 6e 1b 00 00       	call   f010b87b <PROGRAM_SEGMENT_NEXT>
f0109d0d:	83 c4 10             	add    $0x10,%esp
f0109d10:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109d13:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0109d17:	0f 85 d2 fc ff ff    	jne    f01099ef <env_create+0x261>
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
		}
#else
		int i=0;
f0109d1d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		for(;i<(e->page_WS_max_size); i++)
f0109d24:	e9 a0 00 00 00       	jmp    f0109dc9 <env_create+0x63b>
		{
			if(e->ptr_pageWorkingSet[i].empty == 0)
f0109d29:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f0109d2f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0109d32:	89 d0                	mov    %edx,%eax
f0109d34:	01 c0                	add    %eax,%eax
f0109d36:	01 d0                	add    %edx,%eax
f0109d38:	c1 e0 03             	shl    $0x3,%eax
f0109d3b:	01 c8                	add    %ecx,%eax
f0109d3d:	05 8c 00 00 00       	add    $0x8c,%eax
f0109d42:	8a 00                	mov    (%eax),%al
f0109d44:	84 c0                	test   %al,%al
f0109d46:	75 7e                	jne    f0109dc6 <env_create+0x638>
			{
				uint32 virtual_address = e->ptr_pageWorkingSet[i].virtual_address;
f0109d48:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f0109d4e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0109d51:	89 d0                	mov    %edx,%eax
f0109d53:	01 c0                	add    %eax,%eax
f0109d55:	01 d0                	add    %edx,%eax
f0109d57:	c1 e0 03             	shl    $0x3,%eax
f0109d5a:	01 c8                	add    %ecx,%eax
f0109d5c:	05 88 00 00 00       	add    $0x88,%eax
f0109d61:	8b 00                	mov    (%eax),%eax
f0109d63:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
				uint32* ptr_page_table;

				//Here, page tables of all working set pages should be exist in memory
				//So, get_page_table should return the existing table
				get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f0109d69:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109d6f:	8b 40 64             	mov    0x64(%eax),%eax
f0109d72:	83 ec 04             	sub    $0x4,%esp
f0109d75:	8d 95 1c ff ff ff    	lea    -0xe4(%ebp),%edx
f0109d7b:	52                   	push   %edx
f0109d7c:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
f0109d82:	50                   	push   %eax
f0109d83:	e8 a3 e3 ff ff       	call   f010812b <get_page_table>
f0109d88:	83 c4 10             	add    $0x10,%esp
				ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f0109d8b:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
f0109d91:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
f0109d97:	c1 ea 0c             	shr    $0xc,%edx
f0109d9a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109da0:	c1 e2 02             	shl    $0x2,%edx
f0109da3:	01 d0                	add    %edx,%eax
f0109da5:	8b 95 1c ff ff ff    	mov    -0xe4(%ebp),%edx
f0109dab:	8b 8d 54 ff ff ff    	mov    -0xac(%ebp),%ecx
f0109db1:	c1 e9 0c             	shr    $0xc,%ecx
f0109db4:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109dba:	c1 e1 02             	shl    $0x2,%ecx
f0109dbd:	01 ca                	add    %ecx,%edx
f0109dbf:	8b 12                	mov    (%edx),%edx
f0109dc1:	83 e2 bf             	and    $0xffffffbf,%edx
f0109dc4:	89 10                	mov    %edx,(%eax)
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
		}
#else
		int i=0;
		for(;i<(e->page_WS_max_size); i++)
f0109dc6:	ff 45 c4             	incl   -0x3c(%ebp)
f0109dc9:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109dcf:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f0109dd5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109dd8:	39 c2                	cmp    %eax,%edx
f0109dda:	0f 87 49 ff ff ff    	ja     f0109d29 <env_create+0x59b>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f0109de0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0109de3:	8b 50 08             	mov    0x8(%eax),%edx
f0109de6:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109dec:	83 ec 08             	sub    $0x8,%esp
f0109def:	52                   	push   %edx
f0109df0:	50                   	push   %eax
f0109df1:	e8 45 1a 00 00       	call   f010b83b <set_environment_entry_point>
f0109df6:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f0109df9:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109dff:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f0109e06:	c7 85 50 ff ff ff 00 	movl   $0xeebfd000,-0xb0(%ebp)
f0109e0d:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f0109e10:	c7 45 c0 00 d0 bf ee 	movl   $0xeebfd000,-0x40(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f0109e17:	e9 27 05 00 00       	jmp    f010a343 <env_create+0xbb5>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f0109e1c:	c7 85 18 ff ff ff 00 	movl   $0x0,-0xe8(%ebp)
f0109e23:	00 00 00 
			allocate_frame(&pp);
f0109e26:	83 ec 0c             	sub    $0xc,%esp
f0109e29:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f0109e2f:	50                   	push   %eax
f0109e30:	e8 b9 e0 ff ff       	call   f0107eee <allocate_frame>
f0109e35:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f0109e38:	8b 95 18 ff ff ff    	mov    -0xe8(%ebp),%edx
f0109e3e:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109e44:	8b 40 64             	mov    0x64(%eax),%eax
f0109e47:	6a 06                	push   $0x6
f0109e49:	ff 75 c0             	pushl  -0x40(%ebp)
f0109e4c:	52                   	push   %edx
f0109e4d:	50                   	push   %eax
f0109e4e:	e8 af e6 ff ff       	call   f0108502 <loadtime_map_frame>
f0109e53:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f0109e56:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0109e59:	83 ec 04             	sub    $0x4,%esp
f0109e5c:	68 00 10 00 00       	push   $0x1000
f0109e61:	6a 00                	push   $0x0
f0109e63:	50                   	push   %eax
f0109e64:	e8 d6 68 01 00       	call   f012073f <memset>
f0109e69:	83 c4 10             	add    $0x10,%esp
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
					}
				}
#else
				env_page_ws_set_entry(e, e->page_last_WS_index, (uint32) stackVa) ;
f0109e6c:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109e72:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f0109e78:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109e7e:	83 ec 04             	sub    $0x4,%esp
f0109e81:	ff 75 c0             	pushl  -0x40(%ebp)
f0109e84:	52                   	push   %edx
f0109e85:	50                   	push   %eax
f0109e86:	e8 ae ec ff ff       	call   f0108b39 <env_page_ws_set_entry>
f0109e8b:	83 c4 10             	add    $0x10,%esp
				uint32 lastWSIndex = e->page_last_WS_index ++;
f0109e8e:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f0109e94:	8b 82 58 d5 01 00    	mov    0x1d558(%edx),%eax
f0109e9a:	8d 48 01             	lea    0x1(%eax),%ecx
f0109e9d:	89 8a 58 d5 01 00    	mov    %ecx,0x1d558(%edx)
f0109ea3:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
				e->page_last_WS_index %= (e->page_WS_max_size);
f0109ea9:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f0109eaf:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109eb5:	8b 80 58 d5 01 00    	mov    0x1d558(%eax),%eax
f0109ebb:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f0109ec1:	8b 9a 84 00 00 00    	mov    0x84(%edx),%ebx
f0109ec7:	ba 00 00 00 00       	mov    $0x0,%edx
f0109ecc:	f7 f3                	div    %ebx
f0109ece:	89 d0                	mov    %edx,%eax
f0109ed0:	89 81 58 d5 01 00    	mov    %eax,0x1d558(%ecx)

				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0109ed6:	83 ec 0c             	sub    $0xc,%esp
f0109ed9:	6a 02                	push   $0x2
f0109edb:	e8 ad 44 00 00       	call   f010e38d <isPageReplacmentAlgorithmLRU>
f0109ee0:	83 c4 10             	add    $0x10,%esp
f0109ee3:	85 c0                	test   %eax,%eax
f0109ee5:	0f 84 34 04 00 00    	je     f010a31f <env_create+0xb91>
				{
					LIST_REMOVE(&(e->PageWorkingSetList), &(e->ptr_pageWorkingSet[lastWSIndex]));
f0109eeb:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f0109ef1:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f0109ef7:	89 d0                	mov    %edx,%eax
f0109ef9:	01 c0                	add    %eax,%eax
f0109efb:	01 d0                	add    %edx,%eax
f0109efd:	c1 e0 03             	shl    $0x3,%eax
f0109f00:	83 e8 80             	sub    $0xffffff80,%eax
f0109f03:	01 c8                	add    %ecx,%eax
f0109f05:	83 c0 08             	add    $0x8,%eax
f0109f08:	85 c0                	test   %eax,%eax
f0109f0a:	75 17                	jne    f0109f23 <env_create+0x795>
f0109f0c:	83 ec 04             	sub    $0x4,%esp
f0109f0f:	68 c1 54 12 f0       	push   $0xf01254c1
f0109f14:	68 7a 01 00 00       	push   $0x17a
f0109f19:	68 2f 54 12 f0       	push   $0xf012542f
f0109f1e:	e8 f7 63 ff ff       	call   f010031a <_panic>
f0109f23:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f0109f29:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f0109f2f:	89 d0                	mov    %edx,%eax
f0109f31:	01 c0                	add    %eax,%eax
f0109f33:	01 d0                	add    %edx,%eax
f0109f35:	c1 e0 03             	shl    $0x3,%eax
f0109f38:	01 c8                	add    %ecx,%eax
f0109f3a:	05 98 00 00 00       	add    $0x98,%eax
f0109f3f:	8b 00                	mov    (%eax),%eax
f0109f41:	85 c0                	test   %eax,%eax
f0109f43:	74 41                	je     f0109f86 <env_create+0x7f8>
f0109f45:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f0109f4b:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f0109f51:	89 d0                	mov    %edx,%eax
f0109f53:	01 c0                	add    %eax,%eax
f0109f55:	01 d0                	add    %edx,%eax
f0109f57:	c1 e0 03             	shl    $0x3,%eax
f0109f5a:	01 c8                	add    %ecx,%eax
f0109f5c:	05 98 00 00 00       	add    $0x98,%eax
f0109f61:	8b 10                	mov    (%eax),%edx
f0109f63:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f0109f69:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f0109f6f:	89 c8                	mov    %ecx,%eax
f0109f71:	01 c0                	add    %eax,%eax
f0109f73:	01 c8                	add    %ecx,%eax
f0109f75:	c1 e0 03             	shl    $0x3,%eax
f0109f78:	01 d8                	add    %ebx,%eax
f0109f7a:	05 9c 00 00 00       	add    $0x9c,%eax
f0109f7f:	8b 00                	mov    (%eax),%eax
f0109f81:	89 42 14             	mov    %eax,0x14(%edx)
f0109f84:	eb 2a                	jmp    f0109fb0 <env_create+0x822>
f0109f86:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f0109f8c:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f0109f92:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f0109f98:	89 c8                	mov    %ecx,%eax
f0109f9a:	01 c0                	add    %eax,%eax
f0109f9c:	01 c8                	add    %ecx,%eax
f0109f9e:	c1 e0 03             	shl    $0x3,%eax
f0109fa1:	01 d8                	add    %ebx,%eax
f0109fa3:	05 9c 00 00 00       	add    $0x9c,%eax
f0109fa8:	8b 00                	mov    (%eax),%eax
f0109faa:	89 82 4c d5 01 00    	mov    %eax,0x1d54c(%edx)
f0109fb0:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f0109fb6:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f0109fbc:	89 d0                	mov    %edx,%eax
f0109fbe:	01 c0                	add    %eax,%eax
f0109fc0:	01 d0                	add    %edx,%eax
f0109fc2:	c1 e0 03             	shl    $0x3,%eax
f0109fc5:	01 c8                	add    %ecx,%eax
f0109fc7:	05 9c 00 00 00       	add    $0x9c,%eax
f0109fcc:	8b 00                	mov    (%eax),%eax
f0109fce:	85 c0                	test   %eax,%eax
f0109fd0:	74 41                	je     f010a013 <env_create+0x885>
f0109fd2:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f0109fd8:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f0109fde:	89 d0                	mov    %edx,%eax
f0109fe0:	01 c0                	add    %eax,%eax
f0109fe2:	01 d0                	add    %edx,%eax
f0109fe4:	c1 e0 03             	shl    $0x3,%eax
f0109fe7:	01 c8                	add    %ecx,%eax
f0109fe9:	05 9c 00 00 00       	add    $0x9c,%eax
f0109fee:	8b 10                	mov    (%eax),%edx
f0109ff0:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f0109ff6:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f0109ffc:	89 c8                	mov    %ecx,%eax
f0109ffe:	01 c0                	add    %eax,%eax
f010a000:	01 c8                	add    %ecx,%eax
f010a002:	c1 e0 03             	shl    $0x3,%eax
f010a005:	01 d8                	add    %ebx,%eax
f010a007:	05 98 00 00 00       	add    $0x98,%eax
f010a00c:	8b 00                	mov    (%eax),%eax
f010a00e:	89 42 10             	mov    %eax,0x10(%edx)
f010a011:	eb 2a                	jmp    f010a03d <env_create+0x8af>
f010a013:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a019:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a01f:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a025:	89 c8                	mov    %ecx,%eax
f010a027:	01 c0                	add    %eax,%eax
f010a029:	01 c8                	add    %ecx,%eax
f010a02b:	c1 e0 03             	shl    $0x3,%eax
f010a02e:	01 d8                	add    %ebx,%eax
f010a030:	05 98 00 00 00       	add    $0x98,%eax
f010a035:	8b 00                	mov    (%eax),%eax
f010a037:	89 82 48 d5 01 00    	mov    %eax,0x1d548(%edx)
f010a03d:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a043:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a049:	89 d0                	mov    %edx,%eax
f010a04b:	01 c0                	add    %eax,%eax
f010a04d:	01 d0                	add    %edx,%eax
f010a04f:	c1 e0 03             	shl    $0x3,%eax
f010a052:	01 c8                	add    %ecx,%eax
f010a054:	05 98 00 00 00       	add    $0x98,%eax
f010a059:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010a05f:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a065:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a06b:	89 d0                	mov    %edx,%eax
f010a06d:	01 c0                	add    %eax,%eax
f010a06f:	01 d0                	add    %edx,%eax
f010a071:	c1 e0 03             	shl    $0x3,%eax
f010a074:	01 c8                	add    %ecx,%eax
f010a076:	05 9c 00 00 00       	add    $0x9c,%eax
f010a07b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010a081:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a087:	8b 90 54 d5 01 00    	mov    0x1d554(%eax),%edx
f010a08d:	4a                   	dec    %edx
f010a08e:	89 90 54 d5 01 00    	mov    %edx,0x1d554(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010a094:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a09a:	8b 90 1c da 01 00    	mov    0x1da1c(%eax),%edx
f010a0a0:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a0a6:	8b 80 30 da 01 00    	mov    0x1da30(%eax),%eax
f010a0ac:	39 c2                	cmp    %eax,%edx
f010a0ae:	0f 83 38 01 00 00    	jae    f010a1ec <env_create+0xa5e>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), &(e->ptr_pageWorkingSet[lastWSIndex]));
f010a0b4:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a0ba:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a0c0:	89 d0                	mov    %edx,%eax
f010a0c2:	01 c0                	add    %eax,%eax
f010a0c4:	01 d0                	add    %edx,%eax
f010a0c6:	c1 e0 03             	shl    $0x3,%eax
f010a0c9:	83 e8 80             	sub    $0xffffff80,%eax
f010a0cc:	01 c8                	add    %ecx,%eax
f010a0ce:	83 c0 08             	add    $0x8,%eax
f010a0d1:	85 c0                	test   %eax,%eax
f010a0d3:	75 17                	jne    f010a0ec <env_create+0x95e>
f010a0d5:	83 ec 04             	sub    $0x4,%esp
f010a0d8:	68 0c 54 12 f0       	push   $0xf012540c
f010a0dd:	68 7f 01 00 00       	push   $0x17f
f010a0e2:	68 2f 54 12 f0       	push   $0xf012542f
f010a0e7:	e8 2e 62 ff ff       	call   f010031a <_panic>
f010a0ec:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a0f2:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a0f8:	8b 88 10 da 01 00    	mov    0x1da10(%eax),%ecx
f010a0fe:	8b 9d 4c ff ff ff    	mov    -0xb4(%ebp),%ebx
f010a104:	89 d8                	mov    %ebx,%eax
f010a106:	01 c0                	add    %eax,%eax
f010a108:	01 d8                	add    %ebx,%eax
f010a10a:	c1 e0 03             	shl    $0x3,%eax
f010a10d:	01 d0                	add    %edx,%eax
f010a10f:	05 98 00 00 00       	add    $0x98,%eax
f010a114:	89 08                	mov    %ecx,(%eax)
f010a116:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a11c:	89 c8                	mov    %ecx,%eax
f010a11e:	01 c0                	add    %eax,%eax
f010a120:	01 c8                	add    %ecx,%eax
f010a122:	c1 e0 03             	shl    $0x3,%eax
f010a125:	01 d0                	add    %edx,%eax
f010a127:	05 98 00 00 00       	add    $0x98,%eax
f010a12c:	8b 00                	mov    (%eax),%eax
f010a12e:	85 c0                	test   %eax,%eax
f010a130:	74 2e                	je     f010a160 <env_create+0x9d2>
f010a132:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a138:	8b 90 10 da 01 00    	mov    0x1da10(%eax),%edx
f010a13e:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a144:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a14a:	89 c8                	mov    %ecx,%eax
f010a14c:	01 c0                	add    %eax,%eax
f010a14e:	01 c8                	add    %ecx,%eax
f010a150:	c1 e0 03             	shl    $0x3,%eax
f010a153:	83 e8 80             	sub    $0xffffff80,%eax
f010a156:	01 d8                	add    %ebx,%eax
f010a158:	83 c0 08             	add    $0x8,%eax
f010a15b:	89 42 14             	mov    %eax,0x14(%edx)
f010a15e:	eb 29                	jmp    f010a189 <env_create+0x9fb>
f010a160:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a166:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a16c:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a172:	89 c8                	mov    %ecx,%eax
f010a174:	01 c0                	add    %eax,%eax
f010a176:	01 c8                	add    %ecx,%eax
f010a178:	c1 e0 03             	shl    $0x3,%eax
f010a17b:	83 e8 80             	sub    $0xffffff80,%eax
f010a17e:	01 d8                	add    %ebx,%eax
f010a180:	83 c0 08             	add    $0x8,%eax
f010a183:	89 82 14 da 01 00    	mov    %eax,0x1da14(%edx)
f010a189:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a18f:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a195:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a19b:	89 c8                	mov    %ecx,%eax
f010a19d:	01 c0                	add    %eax,%eax
f010a19f:	01 c8                	add    %ecx,%eax
f010a1a1:	c1 e0 03             	shl    $0x3,%eax
f010a1a4:	83 e8 80             	sub    $0xffffff80,%eax
f010a1a7:	01 d8                	add    %ebx,%eax
f010a1a9:	83 c0 08             	add    $0x8,%eax
f010a1ac:	89 82 10 da 01 00    	mov    %eax,0x1da10(%edx)
f010a1b2:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a1b8:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a1be:	89 d0                	mov    %edx,%eax
f010a1c0:	01 c0                	add    %eax,%eax
f010a1c2:	01 d0                	add    %edx,%eax
f010a1c4:	c1 e0 03             	shl    $0x3,%eax
f010a1c7:	01 c8                	add    %ecx,%eax
f010a1c9:	05 9c 00 00 00       	add    $0x9c,%eax
f010a1ce:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010a1d4:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a1da:	8b 90 1c da 01 00    	mov    0x1da1c(%eax),%edx
f010a1e0:	42                   	inc    %edx
f010a1e1:	89 90 1c da 01 00    	mov    %edx,0x1da1c(%eax)
f010a1e7:	e9 33 01 00 00       	jmp    f010a31f <env_create+0xb91>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), &(e->ptr_pageWorkingSet[lastWSIndex]));
f010a1ec:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a1f2:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a1f8:	89 d0                	mov    %edx,%eax
f010a1fa:	01 c0                	add    %eax,%eax
f010a1fc:	01 d0                	add    %edx,%eax
f010a1fe:	c1 e0 03             	shl    $0x3,%eax
f010a201:	83 e8 80             	sub    $0xffffff80,%eax
f010a204:	01 c8                	add    %ecx,%eax
f010a206:	83 c0 08             	add    $0x8,%eax
f010a209:	85 c0                	test   %eax,%eax
f010a20b:	75 17                	jne    f010a224 <env_create+0xa96>
f010a20d:	83 ec 04             	sub    $0x4,%esp
f010a210:	68 0c 54 12 f0       	push   $0xf012540c
f010a215:	68 83 01 00 00       	push   $0x183
f010a21a:	68 2f 54 12 f0       	push   $0xf012542f
f010a21f:	e8 f6 60 ff ff       	call   f010031a <_panic>
f010a224:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a22a:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a230:	8b 88 20 da 01 00    	mov    0x1da20(%eax),%ecx
f010a236:	8b 9d 4c ff ff ff    	mov    -0xb4(%ebp),%ebx
f010a23c:	89 d8                	mov    %ebx,%eax
f010a23e:	01 c0                	add    %eax,%eax
f010a240:	01 d8                	add    %ebx,%eax
f010a242:	c1 e0 03             	shl    $0x3,%eax
f010a245:	01 d0                	add    %edx,%eax
f010a247:	05 98 00 00 00       	add    $0x98,%eax
f010a24c:	89 08                	mov    %ecx,(%eax)
f010a24e:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a254:	89 c8                	mov    %ecx,%eax
f010a256:	01 c0                	add    %eax,%eax
f010a258:	01 c8                	add    %ecx,%eax
f010a25a:	c1 e0 03             	shl    $0x3,%eax
f010a25d:	01 d0                	add    %edx,%eax
f010a25f:	05 98 00 00 00       	add    $0x98,%eax
f010a264:	8b 00                	mov    (%eax),%eax
f010a266:	85 c0                	test   %eax,%eax
f010a268:	74 2e                	je     f010a298 <env_create+0xb0a>
f010a26a:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a270:	8b 90 20 da 01 00    	mov    0x1da20(%eax),%edx
f010a276:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a27c:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a282:	89 c8                	mov    %ecx,%eax
f010a284:	01 c0                	add    %eax,%eax
f010a286:	01 c8                	add    %ecx,%eax
f010a288:	c1 e0 03             	shl    $0x3,%eax
f010a28b:	83 e8 80             	sub    $0xffffff80,%eax
f010a28e:	01 d8                	add    %ebx,%eax
f010a290:	83 c0 08             	add    $0x8,%eax
f010a293:	89 42 14             	mov    %eax,0x14(%edx)
f010a296:	eb 29                	jmp    f010a2c1 <env_create+0xb33>
f010a298:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a29e:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a2a4:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a2aa:	89 c8                	mov    %ecx,%eax
f010a2ac:	01 c0                	add    %eax,%eax
f010a2ae:	01 c8                	add    %ecx,%eax
f010a2b0:	c1 e0 03             	shl    $0x3,%eax
f010a2b3:	83 e8 80             	sub    $0xffffff80,%eax
f010a2b6:	01 d8                	add    %ebx,%eax
f010a2b8:	83 c0 08             	add    $0x8,%eax
f010a2bb:	89 82 24 da 01 00    	mov    %eax,0x1da24(%edx)
f010a2c1:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a2c7:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a2cd:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a2d3:	89 c8                	mov    %ecx,%eax
f010a2d5:	01 c0                	add    %eax,%eax
f010a2d7:	01 c8                	add    %ecx,%eax
f010a2d9:	c1 e0 03             	shl    $0x3,%eax
f010a2dc:	83 e8 80             	sub    $0xffffff80,%eax
f010a2df:	01 d8                	add    %ebx,%eax
f010a2e1:	83 c0 08             	add    $0x8,%eax
f010a2e4:	89 82 20 da 01 00    	mov    %eax,0x1da20(%edx)
f010a2ea:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a2f0:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a2f6:	89 d0                	mov    %edx,%eax
f010a2f8:	01 c0                	add    %eax,%eax
f010a2fa:	01 d0                	add    %edx,%eax
f010a2fc:	c1 e0 03             	shl    $0x3,%eax
f010a2ff:	01 c8                	add    %ecx,%eax
f010a301:	05 9c 00 00 00       	add    $0x9c,%eax
f010a306:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010a30c:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a312:	8b 90 2c da 01 00    	mov    0x1da2c(%eax),%edx
f010a318:	42                   	inc    %edx
f010a319:	89 90 2c da 01 00    	mov    %edx,0x1da2c(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010a31f:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a325:	83 ec 04             	sub    $0x4,%esp
f010a328:	6a 01                	push   $0x1
f010a32a:	ff 75 c0             	pushl  -0x40(%ebp)
f010a32d:	50                   	push   %eax
f010a32e:	e8 05 9a ff ff       	call   f0103d38 <pf_add_empty_env_page>
f010a333:	83 c4 10             	add    $0x10,%esp
f010a336:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010a33c:	81 6d c0 00 10 00 00 	subl   $0x1000,-0x40(%ebp)
f010a343:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010a346:	3b 85 50 ff ff ff    	cmp    -0xb0(%ebp),%eax
f010a34c:	0f 83 ca fa ff ff    	jae    f0109e1c <env_create+0x68e>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a352:	83 ec 0c             	sub    $0xc,%esp
f010a355:	6a 02                	push   $0x2
f010a357:	e8 31 40 00 00       	call   f010e38d <isPageReplacmentAlgorithmLRU>
f010a35c:	83 c4 10             	add    $0x10,%esp
f010a35f:	85 c0                	test   %eax,%eax
f010a361:	74 72                	je     f010a3d5 <env_create+0xc47>
		{
			struct WorkingSetElement * elm = NULL;
f010a363:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010a36a:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a370:	8b 80 20 da 01 00    	mov    0x1da20(%eax),%eax
f010a376:	89 45 bc             	mov    %eax,-0x44(%ebp)
f010a379:	eb 2b                	jmp    f010a3a6 <env_create+0xc18>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010a37b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f010a37e:	8b 10                	mov    (%eax),%edx
f010a380:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a386:	8b 40 64             	mov    0x64(%eax),%eax
f010a389:	6a 01                	push   $0x1
f010a38b:	6a 00                	push   $0x0
f010a38d:	52                   	push   %edx
f010a38e:	50                   	push   %eax
f010a38f:	e8 b2 e4 ff ff       	call   f0108846 <pt_set_page_permissions>
f010a394:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010a397:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a39d:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f010a3a3:	89 45 bc             	mov    %eax,-0x44(%ebp)
f010a3a6:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a3ac:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f010a3b0:	74 08                	je     f010a3ba <env_create+0xc2c>
f010a3b2:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010a3b5:	8b 52 10             	mov    0x10(%edx),%edx
f010a3b8:	eb 05                	jmp    f010a3bf <env_create+0xc31>
f010a3ba:	ba 00 00 00 00       	mov    $0x0,%edx
f010a3bf:	89 90 28 da 01 00    	mov    %edx,0x1da28(%eax)
f010a3c5:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f010a3cb:	85 c0                	test   %eax,%eax
f010a3cd:	75 ac                	jne    f010a37b <env_create+0xbed>
f010a3cf:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f010a3d3:	75 a6                	jne    f010a37b <env_create+0xbed>
f010a3d5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010a3d8:	89 45 a0             	mov    %eax,-0x60(%ebp)
f010a3db:	8b 45 a0             	mov    -0x60(%ebp),%eax
f010a3de:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010a3e1:	e8 4a cb ff ff       	call   f0106f30 <popcli>
//		env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010a3e6:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
}
f010a3ec:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010a3ef:	5b                   	pop    %ebx
f010a3f0:	5e                   	pop    %esi
f010a3f1:	5f                   	pop    %edi
f010a3f2:	5d                   	pop    %ebp
f010a3f3:	c3                   	ret    

f010a3f4 <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010a3f4:	55                   	push   %ebp
f010a3f5:	89 e5                	mov    %esp,%ebp
f010a3f7:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_spinlock(&ProcessQueues.qlock);
f010a3fa:	83 ec 0c             	sub    $0xc,%esp
f010a3fd:	68 60 24 55 f0       	push   $0xf0552460
f010a402:	e8 1e 44 00 00       	call   f010e825 <release_spinlock>
f010a407:	83 c4 10             	add    $0x10,%esp

	if (first)
f010a40a:	a1 78 99 17 f0       	mov    0xf0179978,%eax
f010a40f:	85 c0                	test   %eax,%eax
f010a411:	74 30                	je     f010a443 <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010a413:	e8 76 00 00 00       	call   f010a48e <get_cpu_proc>
f010a418:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010a41b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a41e:	8b 40 10             	mov    0x10(%eax),%eax
f010a421:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a424:	83 c2 20             	add    $0x20,%edx
f010a427:	83 ec 04             	sub    $0x4,%esp
f010a42a:	50                   	push   %eax
f010a42b:	52                   	push   %edx
f010a42c:	68 df 54 12 f0       	push   $0xf01254df
f010a431:	e8 36 6b ff ff       	call   f0100f6c <cprintf>
f010a436:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010a439:	c7 05 78 99 17 f0 00 	movl   $0x0,0xf0179978
f010a440:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010a443:	90                   	nop
f010a444:	c9                   	leave  
f010a445:	c3                   	ret    

f010a446 <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010a446:	55                   	push   %ebp
f010a447:	89 e5                	mov    %esp,%ebp
	/*REMOVE THIS LINE BEFORE START CODING*/
	return;
f010a449:	90                   	nop

	// [10] free the environment (return it back to the free environment list)
	/*(ALREADY DONE for you)*/
	free_environment(e); /*(ALREADY DONE for you)*/ // (frees the environment (returns it back to the free environment list))
	/*========================*/
}
f010a44a:	5d                   	pop    %ebp
f010a44b:	c3                   	ret    

f010a44c <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010a44c:	55                   	push   %ebp
f010a44d:	89 e5                	mov    %esp,%ebp
f010a44f:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010a452:	e8 37 00 00 00       	call   f010a48e <get_cpu_proc>
f010a457:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010a45a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a45e:	75 19                	jne    f010a479 <env_exit+0x2d>
f010a460:	68 f5 54 12 f0       	push   $0xf01254f5
f010a465:	68 05 55 12 f0       	push   $0xf0125505
f010a46a:	68 ea 01 00 00       	push   $0x1ea
f010a46f:	68 2f 54 12 f0       	push   $0xf012542f
f010a474:	e8 a1 5e ff ff       	call   f010031a <_panic>
	sched_exit_env(cur_env->env_id);
f010a479:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a47c:	8b 40 10             	mov    0x10(%eax),%eax
f010a47f:	83 ec 0c             	sub    $0xc,%esp
f010a482:	50                   	push   %eax
f010a483:	e8 48 b0 ff ff       	call   f01054d0 <sched_exit_env>
f010a488:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch
	//fos_scheduler();
	//context_switch(&(curenv->context), mycpu()->scheduler);
}
f010a48b:	90                   	nop
f010a48c:	c9                   	leave  
f010a48d:	c3                   	ret    

f010a48e <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010a48e:	55                   	push   %ebp
f010a48f:	89 e5                	mov    %esp,%ebp
f010a491:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010a494:	e8 45 ca ff ff       	call   f0106ede <pushcli>
	c = mycpu();
f010a499:	e8 7d c9 ff ff       	call   f0106e1b <mycpu>
f010a49e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010a4a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a4a4:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010a4aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010a4ad:	e8 7e ca ff ff       	call   f0106f30 <popcli>
	return p;
f010a4b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010a4b5:	c9                   	leave  
f010a4b6:	c3                   	ret    

f010a4b7 <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010a4b7:	55                   	push   %ebp
f010a4b8:	89 e5                	mov    %esp,%ebp
f010a4ba:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010a4bd:	e8 1c ca ff ff       	call   f0106ede <pushcli>
	c = mycpu();
f010a4c2:	e8 54 c9 ff ff       	call   f0106e1b <mycpu>
f010a4c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010a4ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a4cd:	8b 55 08             	mov    0x8(%ebp),%edx
f010a4d0:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010a4d6:	e8 55 ca ff ff       	call   f0106f30 <popcli>
}
f010a4db:	90                   	nop
f010a4dc:	c9                   	leave  
f010a4dd:	c3                   	ret    

f010a4de <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010a4de:	55                   	push   %ebp
f010a4df:	89 e5                	mov    %esp,%ebp
f010a4e1:	53                   	push   %ebx
f010a4e2:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010a4e5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010a4e9:	75 16                	jne    f010a501 <envid2env+0x23>
		*env_store = get_cpu_proc();
f010a4eb:	e8 9e ff ff ff       	call   f010a48e <get_cpu_proc>
f010a4f0:	89 c2                	mov    %eax,%edx
f010a4f2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a4f5:	89 10                	mov    %edx,(%eax)
		return 0;
f010a4f7:	b8 00 00 00 00       	mov    $0x0,%eax
f010a4fc:	e9 b6 00 00 00       	jmp    f010a5b7 <envid2env+0xd9>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010a501:	8b 1d 10 1a 55 f0    	mov    0xf0551a10,%ebx
f010a507:	83 ec 0c             	sub    $0xc,%esp
f010a50a:	6a 08                	push   $0x8
f010a50c:	e8 d7 47 01 00       	call   f011ece8 <nearest_pow2_ceil>
f010a511:	83 c4 10             	add    $0x10,%esp
f010a514:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a517:	8b 45 08             	mov    0x8(%ebp),%eax
f010a51a:	21 c2                	and    %eax,%edx
f010a51c:	89 d0                	mov    %edx,%eax
f010a51e:	c1 e0 06             	shl    $0x6,%eax
f010a521:	29 d0                	sub    %edx,%eax
f010a523:	c1 e0 02             	shl    $0x2,%eax
f010a526:	01 d0                	add    %edx,%eax
f010a528:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010a52f:	01 c8                	add    %ecx,%eax
f010a531:	c1 e0 03             	shl    $0x3,%eax
f010a534:	01 d0                	add    %edx,%eax
f010a536:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a53d:	29 c2                	sub    %eax,%edx
f010a53f:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f010a546:	89 c2                	mov    %eax,%edx
f010a548:	89 d0                	mov    %edx,%eax
f010a54a:	01 d8                	add    %ebx,%eax
f010a54c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010a54f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a552:	8b 40 18             	mov    0x18(%eax),%eax
f010a555:	85 c0                	test   %eax,%eax
f010a557:	74 0b                	je     f010a564 <envid2env+0x86>
f010a559:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a55c:	8b 40 10             	mov    0x10(%eax),%eax
f010a55f:	3b 45 08             	cmp    0x8(%ebp),%eax
f010a562:	74 10                	je     f010a574 <envid2env+0x96>
		*env_store = 0;
f010a564:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a567:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010a56d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010a572:	eb 43                	jmp    f010a5b7 <envid2env+0xd9>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010a574:	e8 15 ff ff ff       	call   f010a48e <get_cpu_proc>
f010a579:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010a57c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010a580:	74 28                	je     f010a5aa <envid2env+0xcc>
f010a582:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a585:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010a588:	74 20                	je     f010a5aa <envid2env+0xcc>
f010a58a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a58d:	8b 50 14             	mov    0x14(%eax),%edx
f010a590:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a593:	8b 40 10             	mov    0x10(%eax),%eax
f010a596:	39 c2                	cmp    %eax,%edx
f010a598:	74 10                	je     f010a5aa <envid2env+0xcc>
		*env_store = 0;
f010a59a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a59d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010a5a3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010a5a8:	eb 0d                	jmp    f010a5b7 <envid2env+0xd9>
	}

	*env_store = e;
f010a5aa:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a5ad:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a5b0:	89 10                	mov    %edx,(%eax)
	return 0;
f010a5b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010a5b7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a5ba:	c9                   	leave  
f010a5bb:	c3                   	ret    

f010a5bc <yield>:
// 8) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010a5bc:	55                   	push   %ebp
f010a5bd:	89 e5                	mov    %esp,%ebp
f010a5bf:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010a5c2:	83 ec 0c             	sub    $0xc,%esp
f010a5c5:	68 60 24 55 f0       	push   $0xf0552460
f010a5ca:	e8 cf 41 00 00       	call   f010e79e <acquire_spinlock>
f010a5cf:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010a5d2:	e8 b7 fe ff ff       	call   f010a48e <get_cpu_proc>
f010a5d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010a5da:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a5de:	75 19                	jne    f010a5f9 <yield+0x3d>
f010a5e0:	68 1a 55 12 f0       	push   $0xf012551a
f010a5e5:	68 05 55 12 f0       	push   $0xf0125505
f010a5ea:	68 49 02 00 00       	push   $0x249
f010a5ef:	68 2f 54 12 f0       	push   $0xf012542f
f010a5f4:	e8 21 5d ff ff       	call   f010031a <_panic>
		p->env_status = ENV_READY;
f010a5f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a5fc:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010a603:	e8 13 00 00 00       	call   f010a61b <sched>
	}
	release_spinlock(&ProcessQueues.qlock); ////release lock
f010a608:	83 ec 0c             	sub    $0xc,%esp
f010a60b:	68 60 24 55 f0       	push   $0xf0552460
f010a610:	e8 10 42 00 00       	call   f010e825 <release_spinlock>
f010a615:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010a618:	90                   	nop
f010a619:	c9                   	leave  
f010a61a:	c3                   	ret    

f010a61b <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010a61b:	55                   	push   %ebp
f010a61c:	89 e5                	mov    %esp,%ebp
f010a61e:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010a621:	e8 68 fe ff ff       	call   f010a48e <get_cpu_proc>
f010a626:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010a629:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a62d:	75 19                	jne    f010a648 <sched+0x2d>
f010a62f:	68 1a 55 12 f0       	push   $0xf012551a
f010a634:	68 05 55 12 f0       	push   $0xf0125505
f010a639:	68 5d 02 00 00       	push   $0x25d
f010a63e:	68 2f 54 12 f0       	push   $0xf012542f
f010a643:	e8 d2 5c ff ff       	call   f010031a <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010a648:	83 ec 0c             	sub    $0xc,%esp
f010a64b:	68 60 24 55 f0       	push   $0xf0552460
f010a650:	e8 62 43 00 00       	call   f010e9b7 <holding_spinlock>
f010a655:	83 c4 10             	add    $0x10,%esp
f010a658:	85 c0                	test   %eax,%eax
f010a65a:	75 17                	jne    f010a673 <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010a65c:	83 ec 04             	sub    $0x4,%esp
f010a65f:	68 24 55 12 f0       	push   $0xf0125524
f010a664:	68 61 02 00 00       	push   $0x261
f010a669:	68 2f 54 12 f0       	push   $0xf012542f
f010a66e:	e8 a7 5c ff ff       	call   f010031a <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010a673:	e8 a3 c7 ff ff       	call   f0106e1b <mycpu>
f010a678:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010a67e:	83 f8 01             	cmp    $0x1,%eax
f010a681:	74 20                	je     f010a6a3 <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010a683:	e8 93 c7 ff ff       	call   f0106e1b <mycpu>
f010a688:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010a68e:	50                   	push   %eax
f010a68f:	68 66 55 12 f0       	push   $0xf0125566
f010a694:	68 64 02 00 00       	push   $0x264
f010a699:	68 2f 54 12 f0       	push   $0xf012542f
f010a69e:	e8 77 5c ff ff       	call   f010031a <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010a6a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a6a6:	8b 40 18             	mov    0x18(%eax),%eax
f010a6a9:	83 f8 02             	cmp    $0x2,%eax
f010a6ac:	75 17                	jne    f010a6c5 <sched+0xaa>
		panic("sched a running process");
f010a6ae:	83 ec 04             	sub    $0x4,%esp
f010a6b1:	68 7d 55 12 f0       	push   $0xf012557d
f010a6b6:	68 67 02 00 00       	push   $0x267
f010a6bb:	68 2f 54 12 f0       	push   $0xf012542f
f010a6c0:	e8 55 5c ff ff       	call   f010031a <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010a6c5:	9c                   	pushf  
f010a6c6:	58                   	pop    %eax
f010a6c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010a6ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010a6cd:	25 00 02 00 00       	and    $0x200,%eax
f010a6d2:	85 c0                	test   %eax,%eax
f010a6d4:	74 17                	je     f010a6ed <sched+0xd2>
		panic("sched is interruptible!");
f010a6d6:	83 ec 04             	sub    $0x4,%esp
f010a6d9:	68 95 55 12 f0       	push   $0xf0125595
f010a6de:	68 69 02 00 00       	push   $0x269
f010a6e3:	68 2f 54 12 f0       	push   $0xf012542f
f010a6e8:	e8 2d 5c ff ff       	call   f010031a <_panic>
	intena = mycpu()->intena;
f010a6ed:	e8 29 c7 ff ff       	call   f0106e1b <mycpu>
f010a6f2:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010a6f8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010a6fb:	e8 1b c7 ff ff       	call   f0106e1b <mycpu>
f010a700:	8b 40 04             	mov    0x4(%eax),%eax
f010a703:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a706:	83 c2 04             	add    $0x4,%edx
f010a709:	83 ec 08             	sub    $0x8,%esp
f010a70c:	50                   	push   %eax
f010a70d:	52                   	push   %edx
f010a70e:	e8 4a a1 ff ff       	call   f010485d <context_switch>
f010a713:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010a716:	e8 00 c7 ff ff       	call   f0106e1b <mycpu>
f010a71b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a71e:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010a724:	90                   	nop
f010a725:	c9                   	leave  
f010a726:	c3                   	ret    

f010a727 <switchkvm>:
// 10) SWITCH VIRTUAL MEMORYs:
//===============================
// [10.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010a727:	55                   	push   %ebp
f010a728:	89 e5                	mov    %esp,%ebp
f010a72a:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010a72d:	a1 e4 51 55 f0       	mov    0xf05551e4,%eax
f010a732:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010a735:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010a738:	0f 22 d8             	mov    %eax,%cr3
}
f010a73b:	90                   	nop
f010a73c:	c9                   	leave  
f010a73d:	c3                   	ret    

f010a73e <switchuvm>:

// [10.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010a73e:	55                   	push   %ebp
f010a73f:	89 e5                	mov    %esp,%ebp
f010a741:	53                   	push   %ebx
f010a742:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010a745:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010a749:	75 17                	jne    f010a762 <switchuvm+0x24>
		panic("switchuvm: no process");
f010a74b:	83 ec 04             	sub    $0x4,%esp
f010a74e:	68 ad 55 12 f0       	push   $0xf01255ad
f010a753:	68 7e 02 00 00       	push   $0x27e
f010a758:	68 2f 54 12 f0       	push   $0xf012542f
f010a75d:	e8 b8 5b ff ff       	call   f010031a <_panic>
	if(proc->kstack == 0)
f010a762:	8b 45 08             	mov    0x8(%ebp),%eax
f010a765:	8b 40 70             	mov    0x70(%eax),%eax
f010a768:	85 c0                	test   %eax,%eax
f010a76a:	75 17                	jne    f010a783 <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010a76c:	83 ec 04             	sub    $0x4,%esp
f010a76f:	68 c3 55 12 f0       	push   $0xf01255c3
f010a774:	68 80 02 00 00       	push   $0x280
f010a779:	68 2f 54 12 f0       	push   $0xf012542f
f010a77e:	e8 97 5b ff ff       	call   f010031a <_panic>
	if(proc->env_page_directory == 0)
f010a783:	8b 45 08             	mov    0x8(%ebp),%eax
f010a786:	8b 40 64             	mov    0x64(%eax),%eax
f010a789:	85 c0                	test   %eax,%eax
f010a78b:	75 17                	jne    f010a7a4 <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010a78d:	83 ec 04             	sub    $0x4,%esp
f010a790:	68 d8 55 12 f0       	push   $0xf01255d8
f010a795:	68 82 02 00 00       	push   $0x282
f010a79a:	68 2f 54 12 f0       	push   $0xf012542f
f010a79f:	e8 76 5b ff ff       	call   f010031a <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010a7a4:	e8 35 c7 ff ff       	call   f0106ede <pushcli>
	struct cpu* c = mycpu();
f010a7a9:	e8 6d c6 ff ff       	call   f0106e1b <mycpu>
f010a7ae:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010a7b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a7b4:	8b 55 08             	mov    0x8(%ebp),%edx
f010a7b7:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010a7bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a7c0:	83 c0 0c             	add    $0xc,%eax
f010a7c3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a7c6:	83 c2 0c             	add    $0xc,%edx
f010a7c9:	c1 ea 10             	shr    $0x10,%edx
f010a7cc:	88 d3                	mov    %dl,%bl
f010a7ce:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a7d1:	83 c2 0c             	add    $0xc,%edx
f010a7d4:	c1 ea 18             	shr    $0x18,%edx
f010a7d7:	88 d1                	mov    %dl,%cl
f010a7d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a7dc:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010a7e3:	68 00 
f010a7e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a7e8:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010a7ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a7f2:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010a7f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a7fb:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010a801:	83 e2 f0             	and    $0xfffffff0,%edx
f010a804:	83 ca 09             	or     $0x9,%edx
f010a807:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010a80d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a810:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010a816:	83 ca 10             	or     $0x10,%edx
f010a819:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010a81f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a822:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010a828:	83 e2 9f             	and    $0xffffff9f,%edx
f010a82b:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010a831:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a834:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010a83a:	83 ca 80             	or     $0xffffff80,%edx
f010a83d:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010a843:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a846:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010a84c:	83 e2 f0             	and    $0xfffffff0,%edx
f010a84f:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010a855:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a858:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010a85e:	83 e2 ef             	and    $0xffffffef,%edx
f010a861:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010a867:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a86a:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010a870:	83 e2 df             	and    $0xffffffdf,%edx
f010a873:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010a879:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a87c:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010a882:	83 ca 40             	or     $0x40,%edx
f010a885:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010a88b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a88e:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010a894:	83 e2 7f             	and    $0x7f,%edx
f010a897:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010a89d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a8a0:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010a8a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a8a9:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010a8af:	83 e2 ef             	and    $0xffffffef,%edx
f010a8b2:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010a8b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a8bb:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010a8c1:	8b 40 70             	mov    0x70(%eax),%eax
f010a8c4:	05 00 80 00 00       	add    $0x8000,%eax
f010a8c9:	89 c2                	mov    %eax,%edx
f010a8cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a8ce:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010a8d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a8d4:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010a8da:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010a8e0:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010a8e4:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010a8e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a8ea:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010a8f0:	8b 40 68             	mov    0x68(%eax),%eax
f010a8f3:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010a8f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a8f9:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010a8fc:	e8 2f c6 ff ff       	call   f0106f30 <popcli>
}
f010a901:	90                   	nop
f010a902:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a905:	c9                   	leave  
f010a906:	c3                   	ret    

f010a907 <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010a907:	55                   	push   %ebp
f010a908:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010a90a:	8b 15 14 1a 55 f0    	mov    0xf0551a14,%edx
f010a910:	8b 45 08             	mov    0x8(%ebp),%eax
f010a913:	89 10                	mov    %edx,(%eax)
f010a915:	8b 45 08             	mov    0x8(%ebp),%eax
f010a918:	8b 00                	mov    (%eax),%eax
f010a91a:	85 c0                	test   %eax,%eax
f010a91c:	75 07                	jne    f010a925 <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010a91e:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010a923:	eb 11                	jmp    f010a936 <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010a925:	8b 45 08             	mov    0x8(%ebp),%eax
f010a928:	8b 00                	mov    (%eax),%eax
f010a92a:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	return 0;
f010a931:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010a936:	5d                   	pop    %ebp
f010a937:	c3                   	ret    

f010a938 <free_environment>:
//===============================
// 2) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010a938:	55                   	push   %ebp
f010a939:	89 e5                	mov    %esp,%ebp
f010a93b:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010a93e:	83 ec 04             	sub    $0x4,%esp
f010a941:	68 6c da 01 00       	push   $0x1da6c
f010a946:	6a 00                	push   $0x0
f010a948:	ff 75 08             	pushl  0x8(%ebp)
f010a94b:	e8 ef 5d 01 00       	call   f012073f <memset>
f010a950:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010a953:	8b 45 08             	mov    0x8(%ebp),%eax
f010a956:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010a95d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010a961:	75 17                	jne    f010a97a <free_environment+0x42>
f010a963:	83 ec 04             	sub    $0x4,%esp
f010a966:	68 0c 54 12 f0       	push   $0xf012540c
f010a96b:	68 bd 02 00 00       	push   $0x2bd
f010a970:	68 2f 54 12 f0       	push   $0xf012542f
f010a975:	e8 a0 59 ff ff       	call   f010031a <_panic>
f010a97a:	8b 15 14 1a 55 f0    	mov    0xf0551a14,%edx
f010a980:	8b 45 08             	mov    0x8(%ebp),%eax
f010a983:	89 50 08             	mov    %edx,0x8(%eax)
f010a986:	8b 45 08             	mov    0x8(%ebp),%eax
f010a989:	8b 40 08             	mov    0x8(%eax),%eax
f010a98c:	85 c0                	test   %eax,%eax
f010a98e:	74 0d                	je     f010a99d <free_environment+0x65>
f010a990:	a1 14 1a 55 f0       	mov    0xf0551a14,%eax
f010a995:	8b 55 08             	mov    0x8(%ebp),%edx
f010a998:	89 50 0c             	mov    %edx,0xc(%eax)
f010a99b:	eb 08                	jmp    f010a9a5 <free_environment+0x6d>
f010a99d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a9a0:	a3 18 1a 55 f0       	mov    %eax,0xf0551a18
f010a9a5:	8b 45 08             	mov    0x8(%ebp),%eax
f010a9a8:	a3 14 1a 55 f0       	mov    %eax,0xf0551a14
f010a9ad:	8b 45 08             	mov    0x8(%ebp),%eax
f010a9b0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010a9b7:	a1 20 1a 55 f0       	mov    0xf0551a20,%eax
f010a9bc:	40                   	inc    %eax
f010a9bd:	a3 20 1a 55 f0       	mov    %eax,0xf0551a20
}
f010a9c2:	90                   	nop
f010a9c3:	c9                   	leave  
f010a9c4:	c3                   	ret    

f010a9c5 <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010a9c5:	55                   	push   %ebp
f010a9c6:	89 e5                	mov    %esp,%ebp
f010a9c8:	53                   	push   %ebx
f010a9c9:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010a9cc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a9cf:	8b 40 0c             	mov    0xc(%eax),%eax
f010a9d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010a9d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a9d8:	8b 40 08             	mov    0x8(%eax),%eax
f010a9db:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010a9de:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010a9e5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010a9e8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a9eb:	01 c2                	add    %eax,%edx
f010a9ed:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a9f0:	01 d0                	add    %edx,%eax
f010a9f2:	48                   	dec    %eax
f010a9f3:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010a9f6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010a9f9:	ba 00 00 00 00       	mov    $0x0,%edx
f010a9fe:	f7 75 dc             	divl   -0x24(%ebp)
f010aa01:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010aa04:	29 d0                	sub    %edx,%eax
f010aa06:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010aa09:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010aa0c:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010aa0f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010aa12:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010aa17:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010aa1a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010aa21:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)

	*allocated_pages = 0;
f010aa28:	8b 45 10             	mov    0x10(%ebp),%eax
f010aa2b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010aa31:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010aa38:	0f 85 35 06 00 00    	jne    f010b073 <program_segment_alloc_map_copy_workingset+0x6ae>
f010aa3e:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa41:	83 c0 20             	add    $0x20,%eax
f010aa44:	83 ec 08             	sub    $0x8,%esp
f010aa47:	68 ec 55 12 f0       	push   $0xf01255ec
f010aa4c:	50                   	push   %eax
f010aa4d:	e8 0b 5c 01 00       	call   f012065d <strcmp>
f010aa52:	83 c4 10             	add    $0x10,%esp
f010aa55:	85 c0                	test   %eax,%eax
f010aa57:	0f 84 16 06 00 00    	je     f010b073 <program_segment_alloc_map_copy_workingset+0x6ae>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010aa5d:	8b 45 14             	mov    0x14(%ebp),%eax
f010aa60:	83 f8 06             	cmp    $0x6,%eax
f010aa63:	76 05                	jbe    f010aa6a <program_segment_alloc_map_copy_workingset+0xa5>
f010aa65:	b8 06 00 00 00       	mov    $0x6,%eax
f010aa6a:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010aa6d:	e9 01 06 00 00       	jmp    f010b073 <program_segment_alloc_map_copy_workingset+0x6ae>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010aa72:	83 ec 0c             	sub    $0xc,%esp
f010aa75:	8d 45 c0             	lea    -0x40(%ebp),%eax
f010aa78:	50                   	push   %eax
f010aa79:	e8 70 d4 ff ff       	call   f0107eee <allocate_frame>
f010aa7e:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010aa81:	8b 55 c0             	mov    -0x40(%ebp),%edx
f010aa84:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa87:	8b 40 64             	mov    0x64(%eax),%eax
f010aa8a:	6a 06                	push   $0x6
f010aa8c:	ff 75 f4             	pushl  -0xc(%ebp)
f010aa8f:	52                   	push   %edx
f010aa90:	50                   	push   %eax
f010aa91:	e8 6c da ff ff       	call   f0108502 <loadtime_map_frame>
f010aa96:	83 c4 10             	add    $0x10,%esp
		wse->time_stamp = 0;
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);

#else
		LOG_STATMENT(cprintf("Updating working set entry # %d",e->page_last_WS_index));
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
f010aa99:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa9c:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010aaa2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aaa5:	89 d0                	mov    %edx,%eax
f010aaa7:	01 c0                	add    %eax,%eax
f010aaa9:	01 d0                	add    %edx,%eax
f010aaab:	c1 e0 03             	shl    $0x3,%eax
f010aaae:	01 c8                	add    %ecx,%eax
f010aab0:	8d 90 88 00 00 00    	lea    0x88(%eax),%edx
f010aab6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aab9:	89 02                	mov    %eax,(%edx)
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
f010aabb:	8b 45 08             	mov    0x8(%ebp),%eax
f010aabe:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010aac4:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aac7:	89 d0                	mov    %edx,%eax
f010aac9:	01 c0                	add    %eax,%eax
f010aacb:	01 d0                	add    %edx,%eax
f010aacd:	c1 e0 03             	shl    $0x3,%eax
f010aad0:	01 c8                	add    %ecx,%eax
f010aad2:	05 8c 00 00 00       	add    $0x8c,%eax
f010aad7:	c6 00 00             	movb   $0x0,(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
f010aada:	8b 45 08             	mov    0x8(%ebp),%eax
f010aadd:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010aae3:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aae6:	89 d0                	mov    %edx,%eax
f010aae8:	01 c0                	add    %eax,%eax
f010aaea:	01 d0                	add    %edx,%eax
f010aaec:	c1 e0 03             	shl    $0x3,%eax
f010aaef:	01 c8                	add    %ecx,%eax
f010aaf1:	05 90 00 00 00       	add    $0x90,%eax
f010aaf6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010aafc:	83 ec 0c             	sub    $0xc,%esp
f010aaff:	6a 02                	push   $0x2
f010ab01:	e8 87 38 00 00       	call   f010e38d <isPageReplacmentAlgorithmLRU>
f010ab06:	83 c4 10             	add    $0x10,%esp
f010ab09:	85 c0                	test   %eax,%eax
f010ab0b:	0f 84 2c 04 00 00    	je     f010af3d <program_segment_alloc_map_copy_workingset+0x578>
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
			}
#else

			LIST_REMOVE(&(e->PageWorkingSetList), &(e->ptr_pageWorkingSet[e->page_last_WS_index]));
f010ab11:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab14:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ab1a:	89 d0                	mov    %edx,%eax
f010ab1c:	01 c0                	add    %eax,%eax
f010ab1e:	01 d0                	add    %edx,%eax
f010ab20:	c1 e0 03             	shl    $0x3,%eax
f010ab23:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010ab29:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab2c:	01 d0                	add    %edx,%eax
f010ab2e:	83 c0 08             	add    $0x8,%eax
f010ab31:	85 c0                	test   %eax,%eax
f010ab33:	75 17                	jne    f010ab4c <program_segment_alloc_map_copy_workingset+0x187>
f010ab35:	83 ec 04             	sub    $0x4,%esp
f010ab38:	68 c1 54 12 f0       	push   $0xf01254c1
f010ab3d:	68 00 03 00 00       	push   $0x300
f010ab42:	68 2f 54 12 f0       	push   $0xf012542f
f010ab47:	e8 ce 57 ff ff       	call   f010031a <_panic>
f010ab4c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab4f:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ab55:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ab58:	89 d0                	mov    %edx,%eax
f010ab5a:	01 c0                	add    %eax,%eax
f010ab5c:	01 d0                	add    %edx,%eax
f010ab5e:	c1 e0 03             	shl    $0x3,%eax
f010ab61:	01 c8                	add    %ecx,%eax
f010ab63:	05 98 00 00 00       	add    $0x98,%eax
f010ab68:	8b 00                	mov    (%eax),%eax
f010ab6a:	85 c0                	test   %eax,%eax
f010ab6c:	74 41                	je     f010abaf <program_segment_alloc_map_copy_workingset+0x1ea>
f010ab6e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab71:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ab77:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ab7a:	89 d0                	mov    %edx,%eax
f010ab7c:	01 c0                	add    %eax,%eax
f010ab7e:	01 d0                	add    %edx,%eax
f010ab80:	c1 e0 03             	shl    $0x3,%eax
f010ab83:	01 c8                	add    %ecx,%eax
f010ab85:	05 98 00 00 00       	add    $0x98,%eax
f010ab8a:	8b 10                	mov    (%eax),%edx
f010ab8c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab8f:	8b 88 58 d5 01 00    	mov    0x1d558(%eax),%ecx
f010ab95:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010ab98:	89 c8                	mov    %ecx,%eax
f010ab9a:	01 c0                	add    %eax,%eax
f010ab9c:	01 c8                	add    %ecx,%eax
f010ab9e:	c1 e0 03             	shl    $0x3,%eax
f010aba1:	01 d8                	add    %ebx,%eax
f010aba3:	05 9c 00 00 00       	add    $0x9c,%eax
f010aba8:	8b 00                	mov    (%eax),%eax
f010abaa:	89 42 14             	mov    %eax,0x14(%edx)
f010abad:	eb 27                	jmp    f010abd6 <program_segment_alloc_map_copy_workingset+0x211>
f010abaf:	8b 45 08             	mov    0x8(%ebp),%eax
f010abb2:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010abb8:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010abbb:	89 d0                	mov    %edx,%eax
f010abbd:	01 c0                	add    %eax,%eax
f010abbf:	01 d0                	add    %edx,%eax
f010abc1:	c1 e0 03             	shl    $0x3,%eax
f010abc4:	01 c8                	add    %ecx,%eax
f010abc6:	05 9c 00 00 00       	add    $0x9c,%eax
f010abcb:	8b 10                	mov    (%eax),%edx
f010abcd:	8b 45 08             	mov    0x8(%ebp),%eax
f010abd0:	89 90 4c d5 01 00    	mov    %edx,0x1d54c(%eax)
f010abd6:	8b 45 08             	mov    0x8(%ebp),%eax
f010abd9:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010abdf:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010abe2:	89 d0                	mov    %edx,%eax
f010abe4:	01 c0                	add    %eax,%eax
f010abe6:	01 d0                	add    %edx,%eax
f010abe8:	c1 e0 03             	shl    $0x3,%eax
f010abeb:	01 c8                	add    %ecx,%eax
f010abed:	05 9c 00 00 00       	add    $0x9c,%eax
f010abf2:	8b 00                	mov    (%eax),%eax
f010abf4:	85 c0                	test   %eax,%eax
f010abf6:	74 41                	je     f010ac39 <program_segment_alloc_map_copy_workingset+0x274>
f010abf8:	8b 45 08             	mov    0x8(%ebp),%eax
f010abfb:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ac01:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ac04:	89 d0                	mov    %edx,%eax
f010ac06:	01 c0                	add    %eax,%eax
f010ac08:	01 d0                	add    %edx,%eax
f010ac0a:	c1 e0 03             	shl    $0x3,%eax
f010ac0d:	01 c8                	add    %ecx,%eax
f010ac0f:	05 9c 00 00 00       	add    $0x9c,%eax
f010ac14:	8b 10                	mov    (%eax),%edx
f010ac16:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac19:	8b 88 58 d5 01 00    	mov    0x1d558(%eax),%ecx
f010ac1f:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010ac22:	89 c8                	mov    %ecx,%eax
f010ac24:	01 c0                	add    %eax,%eax
f010ac26:	01 c8                	add    %ecx,%eax
f010ac28:	c1 e0 03             	shl    $0x3,%eax
f010ac2b:	01 d8                	add    %ebx,%eax
f010ac2d:	05 98 00 00 00       	add    $0x98,%eax
f010ac32:	8b 00                	mov    (%eax),%eax
f010ac34:	89 42 10             	mov    %eax,0x10(%edx)
f010ac37:	eb 27                	jmp    f010ac60 <program_segment_alloc_map_copy_workingset+0x29b>
f010ac39:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac3c:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ac42:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ac45:	89 d0                	mov    %edx,%eax
f010ac47:	01 c0                	add    %eax,%eax
f010ac49:	01 d0                	add    %edx,%eax
f010ac4b:	c1 e0 03             	shl    $0x3,%eax
f010ac4e:	01 c8                	add    %ecx,%eax
f010ac50:	05 98 00 00 00       	add    $0x98,%eax
f010ac55:	8b 10                	mov    (%eax),%edx
f010ac57:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac5a:	89 90 48 d5 01 00    	mov    %edx,0x1d548(%eax)
f010ac60:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac63:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ac69:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ac6c:	89 d0                	mov    %edx,%eax
f010ac6e:	01 c0                	add    %eax,%eax
f010ac70:	01 d0                	add    %edx,%eax
f010ac72:	c1 e0 03             	shl    $0x3,%eax
f010ac75:	01 c8                	add    %ecx,%eax
f010ac77:	05 98 00 00 00       	add    $0x98,%eax
f010ac7c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010ac82:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac85:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ac8b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ac8e:	89 d0                	mov    %edx,%eax
f010ac90:	01 c0                	add    %eax,%eax
f010ac92:	01 d0                	add    %edx,%eax
f010ac94:	c1 e0 03             	shl    $0x3,%eax
f010ac97:	01 c8                	add    %ecx,%eax
f010ac99:	05 9c 00 00 00       	add    $0x9c,%eax
f010ac9e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010aca4:	8b 45 08             	mov    0x8(%ebp),%eax
f010aca7:	8b 80 54 d5 01 00    	mov    0x1d554(%eax),%eax
f010acad:	8d 50 ff             	lea    -0x1(%eax),%edx
f010acb0:	8b 45 08             	mov    0x8(%ebp),%eax
f010acb3:	89 90 54 d5 01 00    	mov    %edx,0x1d554(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010acb9:	8b 45 08             	mov    0x8(%ebp),%eax
f010acbc:	8b 90 1c da 01 00    	mov    0x1da1c(%eax),%edx
f010acc2:	8b 45 08             	mov    0x8(%ebp),%eax
f010acc5:	8b 80 30 da 01 00    	mov    0x1da30(%eax),%eax
f010accb:	48                   	dec    %eax
f010accc:	39 c2                	cmp    %eax,%edx
f010acce:	0f 83 37 01 00 00    	jae    f010ae0b <program_segment_alloc_map_copy_workingset+0x446>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), &(e->ptr_pageWorkingSet[e->page_last_WS_index]));
f010acd4:	8b 45 08             	mov    0x8(%ebp),%eax
f010acd7:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010acdd:	89 d0                	mov    %edx,%eax
f010acdf:	01 c0                	add    %eax,%eax
f010ace1:	01 d0                	add    %edx,%eax
f010ace3:	c1 e0 03             	shl    $0x3,%eax
f010ace6:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010acec:	8b 45 08             	mov    0x8(%ebp),%eax
f010acef:	01 d0                	add    %edx,%eax
f010acf1:	83 c0 08             	add    $0x8,%eax
f010acf4:	85 c0                	test   %eax,%eax
f010acf6:	75 17                	jne    f010ad0f <program_segment_alloc_map_copy_workingset+0x34a>
f010acf8:	83 ec 04             	sub    $0x4,%esp
f010acfb:	68 0c 54 12 f0       	push   $0xf012540c
f010ad00:	68 04 03 00 00       	push   $0x304
f010ad05:	68 2f 54 12 f0       	push   $0xf012542f
f010ad0a:	e8 0b 56 ff ff       	call   f010031a <_panic>
f010ad0f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad12:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ad18:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad1b:	8b 88 10 da 01 00    	mov    0x1da10(%eax),%ecx
f010ad21:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010ad24:	89 d0                	mov    %edx,%eax
f010ad26:	01 c0                	add    %eax,%eax
f010ad28:	01 d0                	add    %edx,%eax
f010ad2a:	c1 e0 03             	shl    $0x3,%eax
f010ad2d:	01 d8                	add    %ebx,%eax
f010ad2f:	05 98 00 00 00       	add    $0x98,%eax
f010ad34:	89 08                	mov    %ecx,(%eax)
f010ad36:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ad39:	89 d0                	mov    %edx,%eax
f010ad3b:	01 c0                	add    %eax,%eax
f010ad3d:	01 d0                	add    %edx,%eax
f010ad3f:	c1 e0 03             	shl    $0x3,%eax
f010ad42:	01 c8                	add    %ecx,%eax
f010ad44:	05 98 00 00 00       	add    $0x98,%eax
f010ad49:	8b 00                	mov    (%eax),%eax
f010ad4b:	85 c0                	test   %eax,%eax
f010ad4d:	74 2e                	je     f010ad7d <program_segment_alloc_map_copy_workingset+0x3b8>
f010ad4f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad52:	8b 90 10 da 01 00    	mov    0x1da10(%eax),%edx
f010ad58:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad5b:	8b 88 58 d5 01 00    	mov    0x1d558(%eax),%ecx
f010ad61:	89 c8                	mov    %ecx,%eax
f010ad63:	01 c0                	add    %eax,%eax
f010ad65:	01 c8                	add    %ecx,%eax
f010ad67:	c1 e0 03             	shl    $0x3,%eax
f010ad6a:	8d 88 80 00 00 00    	lea    0x80(%eax),%ecx
f010ad70:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad73:	01 c8                	add    %ecx,%eax
f010ad75:	83 c0 08             	add    $0x8,%eax
f010ad78:	89 42 14             	mov    %eax,0x14(%edx)
f010ad7b:	eb 29                	jmp    f010ada6 <program_segment_alloc_map_copy_workingset+0x3e1>
f010ad7d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad80:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ad86:	89 d0                	mov    %edx,%eax
f010ad88:	01 c0                	add    %eax,%eax
f010ad8a:	01 d0                	add    %edx,%eax
f010ad8c:	c1 e0 03             	shl    $0x3,%eax
f010ad8f:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010ad95:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad98:	01 d0                	add    %edx,%eax
f010ad9a:	8d 50 08             	lea    0x8(%eax),%edx
f010ad9d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ada0:	89 90 14 da 01 00    	mov    %edx,0x1da14(%eax)
f010ada6:	8b 45 08             	mov    0x8(%ebp),%eax
f010ada9:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010adaf:	89 d0                	mov    %edx,%eax
f010adb1:	01 c0                	add    %eax,%eax
f010adb3:	01 d0                	add    %edx,%eax
f010adb5:	c1 e0 03             	shl    $0x3,%eax
f010adb8:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010adbe:	8b 45 08             	mov    0x8(%ebp),%eax
f010adc1:	01 d0                	add    %edx,%eax
f010adc3:	8d 50 08             	lea    0x8(%eax),%edx
f010adc6:	8b 45 08             	mov    0x8(%ebp),%eax
f010adc9:	89 90 10 da 01 00    	mov    %edx,0x1da10(%eax)
f010adcf:	8b 45 08             	mov    0x8(%ebp),%eax
f010add2:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010add8:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010addb:	89 d0                	mov    %edx,%eax
f010addd:	01 c0                	add    %eax,%eax
f010addf:	01 d0                	add    %edx,%eax
f010ade1:	c1 e0 03             	shl    $0x3,%eax
f010ade4:	01 c8                	add    %ecx,%eax
f010ade6:	05 9c 00 00 00       	add    $0x9c,%eax
f010adeb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010adf1:	8b 45 08             	mov    0x8(%ebp),%eax
f010adf4:	8b 80 1c da 01 00    	mov    0x1da1c(%eax),%eax
f010adfa:	8d 50 01             	lea    0x1(%eax),%edx
f010adfd:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae00:	89 90 1c da 01 00    	mov    %edx,0x1da1c(%eax)
f010ae06:	e9 32 01 00 00       	jmp    f010af3d <program_segment_alloc_map_copy_workingset+0x578>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), &(e->ptr_pageWorkingSet[e->page_last_WS_index]));
f010ae0b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae0e:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ae14:	89 d0                	mov    %edx,%eax
f010ae16:	01 c0                	add    %eax,%eax
f010ae18:	01 d0                	add    %edx,%eax
f010ae1a:	c1 e0 03             	shl    $0x3,%eax
f010ae1d:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010ae23:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae26:	01 d0                	add    %edx,%eax
f010ae28:	83 c0 08             	add    $0x8,%eax
f010ae2b:	85 c0                	test   %eax,%eax
f010ae2d:	75 17                	jne    f010ae46 <program_segment_alloc_map_copy_workingset+0x481>
f010ae2f:	83 ec 04             	sub    $0x4,%esp
f010ae32:	68 0c 54 12 f0       	push   $0xf012540c
f010ae37:	68 09 03 00 00       	push   $0x309
f010ae3c:	68 2f 54 12 f0       	push   $0xf012542f
f010ae41:	e8 d4 54 ff ff       	call   f010031a <_panic>
f010ae46:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae49:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ae4f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae52:	8b 88 20 da 01 00    	mov    0x1da20(%eax),%ecx
f010ae58:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010ae5b:	89 d0                	mov    %edx,%eax
f010ae5d:	01 c0                	add    %eax,%eax
f010ae5f:	01 d0                	add    %edx,%eax
f010ae61:	c1 e0 03             	shl    $0x3,%eax
f010ae64:	01 d8                	add    %ebx,%eax
f010ae66:	05 98 00 00 00       	add    $0x98,%eax
f010ae6b:	89 08                	mov    %ecx,(%eax)
f010ae6d:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ae70:	89 d0                	mov    %edx,%eax
f010ae72:	01 c0                	add    %eax,%eax
f010ae74:	01 d0                	add    %edx,%eax
f010ae76:	c1 e0 03             	shl    $0x3,%eax
f010ae79:	01 c8                	add    %ecx,%eax
f010ae7b:	05 98 00 00 00       	add    $0x98,%eax
f010ae80:	8b 00                	mov    (%eax),%eax
f010ae82:	85 c0                	test   %eax,%eax
f010ae84:	74 2e                	je     f010aeb4 <program_segment_alloc_map_copy_workingset+0x4ef>
f010ae86:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae89:	8b 90 20 da 01 00    	mov    0x1da20(%eax),%edx
f010ae8f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae92:	8b 88 58 d5 01 00    	mov    0x1d558(%eax),%ecx
f010ae98:	89 c8                	mov    %ecx,%eax
f010ae9a:	01 c0                	add    %eax,%eax
f010ae9c:	01 c8                	add    %ecx,%eax
f010ae9e:	c1 e0 03             	shl    $0x3,%eax
f010aea1:	8d 88 80 00 00 00    	lea    0x80(%eax),%ecx
f010aea7:	8b 45 08             	mov    0x8(%ebp),%eax
f010aeaa:	01 c8                	add    %ecx,%eax
f010aeac:	83 c0 08             	add    $0x8,%eax
f010aeaf:	89 42 14             	mov    %eax,0x14(%edx)
f010aeb2:	eb 29                	jmp    f010aedd <program_segment_alloc_map_copy_workingset+0x518>
f010aeb4:	8b 45 08             	mov    0x8(%ebp),%eax
f010aeb7:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010aebd:	89 d0                	mov    %edx,%eax
f010aebf:	01 c0                	add    %eax,%eax
f010aec1:	01 d0                	add    %edx,%eax
f010aec3:	c1 e0 03             	shl    $0x3,%eax
f010aec6:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010aecc:	8b 45 08             	mov    0x8(%ebp),%eax
f010aecf:	01 d0                	add    %edx,%eax
f010aed1:	8d 50 08             	lea    0x8(%eax),%edx
f010aed4:	8b 45 08             	mov    0x8(%ebp),%eax
f010aed7:	89 90 24 da 01 00    	mov    %edx,0x1da24(%eax)
f010aedd:	8b 45 08             	mov    0x8(%ebp),%eax
f010aee0:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010aee6:	89 d0                	mov    %edx,%eax
f010aee8:	01 c0                	add    %eax,%eax
f010aeea:	01 d0                	add    %edx,%eax
f010aeec:	c1 e0 03             	shl    $0x3,%eax
f010aeef:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010aef5:	8b 45 08             	mov    0x8(%ebp),%eax
f010aef8:	01 d0                	add    %edx,%eax
f010aefa:	8d 50 08             	lea    0x8(%eax),%edx
f010aefd:	8b 45 08             	mov    0x8(%ebp),%eax
f010af00:	89 90 20 da 01 00    	mov    %edx,0x1da20(%eax)
f010af06:	8b 45 08             	mov    0x8(%ebp),%eax
f010af09:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010af0f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010af12:	89 d0                	mov    %edx,%eax
f010af14:	01 c0                	add    %eax,%eax
f010af16:	01 d0                	add    %edx,%eax
f010af18:	c1 e0 03             	shl    $0x3,%eax
f010af1b:	01 c8                	add    %ecx,%eax
f010af1d:	05 9c 00 00 00       	add    $0x9c,%eax
f010af22:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010af28:	8b 45 08             	mov    0x8(%ebp),%eax
f010af2b:	8b 80 2c da 01 00    	mov    0x1da2c(%eax),%eax
f010af31:	8d 50 01             	lea    0x1(%eax),%edx
f010af34:	8b 45 08             	mov    0x8(%ebp),%eax
f010af37:	89 90 2c da 01 00    	mov    %edx,0x1da2c(%eax)
		else
		{
			e->page_last_WS_element = NULL;
		}
#else
		e->page_last_WS_index ++;
f010af3d:	8b 45 08             	mov    0x8(%ebp),%eax
f010af40:	8b 80 58 d5 01 00    	mov    0x1d558(%eax),%eax
f010af46:	8d 50 01             	lea    0x1(%eax),%edx
f010af49:	8b 45 08             	mov    0x8(%ebp),%eax
f010af4c:	89 90 58 d5 01 00    	mov    %edx,0x1d558(%eax)
		e->page_last_WS_index %= (e->page_WS_max_size);
f010af52:	8b 45 08             	mov    0x8(%ebp),%eax
f010af55:	8b 80 58 d5 01 00    	mov    0x1d558(%eax),%eax
f010af5b:	8b 55 08             	mov    0x8(%ebp),%edx
f010af5e:	8b 8a 84 00 00 00    	mov    0x84(%edx),%ecx
f010af64:	ba 00 00 00 00       	mov    $0x0,%edx
f010af69:	f7 f1                	div    %ecx
f010af6b:	8b 45 08             	mov    0x8(%ebp),%eax
f010af6e:	89 90 58 d5 01 00    	mov    %edx,0x1d558(%eax)
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010af74:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af77:	c1 e8 16             	shr    $0x16,%eax
f010af7a:	89 c2                	mov    %eax,%edx
f010af7c:	8b 45 18             	mov    0x18(%ebp),%eax
f010af7f:	8b 00                	mov    (%eax),%eax
f010af81:	39 c2                	cmp    %eax,%edx
f010af83:	0f 84 d3 00 00 00    	je     f010b05c <program_segment_alloc_map_copy_workingset+0x697>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010af89:	8b 45 08             	mov    0x8(%ebp),%eax
f010af8c:	8b 90 0c da 01 00    	mov    0x1da0c(%eax),%edx
f010af92:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af95:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010af98:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010af9b:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010afa0:	89 c1                	mov    %eax,%ecx
f010afa2:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010afa5:	89 d0                	mov    %edx,%eax
f010afa7:	01 c0                	add    %eax,%eax
f010afa9:	01 d0                	add    %edx,%eax
f010afab:	c1 e0 03             	shl    $0x3,%eax
f010afae:	01 d8                	add    %ebx,%eax
f010afb0:	05 5c d5 01 00       	add    $0x1d55c,%eax
f010afb5:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010afb7:	8b 45 08             	mov    0x8(%ebp),%eax
f010afba:	8b 90 0c da 01 00    	mov    0x1da0c(%eax),%edx
f010afc0:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010afc3:	89 d0                	mov    %edx,%eax
f010afc5:	01 c0                	add    %eax,%eax
f010afc7:	01 d0                	add    %edx,%eax
f010afc9:	c1 e0 03             	shl    $0x3,%eax
f010afcc:	01 c8                	add    %ecx,%eax
f010afce:	05 60 d5 01 00       	add    $0x1d560,%eax
f010afd3:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010afd6:	8b 45 08             	mov    0x8(%ebp),%eax
f010afd9:	8b 90 0c da 01 00    	mov    0x1da0c(%eax),%edx
f010afdf:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010afe2:	89 d0                	mov    %edx,%eax
f010afe4:	01 c0                	add    %eax,%eax
f010afe6:	01 d0                	add    %edx,%eax
f010afe8:	c1 e0 03             	shl    $0x3,%eax
f010afeb:	01 c8                	add    %ecx,%eax
f010afed:	05 64 d5 01 00       	add    $0x1d564,%eax
f010aff2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010aff8:	8b 45 08             	mov    0x8(%ebp),%eax
f010affb:	8b 80 0c da 01 00    	mov    0x1da0c(%eax),%eax
f010b001:	8d 50 01             	lea    0x1(%eax),%edx
f010b004:	8b 45 08             	mov    0x8(%ebp),%eax
f010b007:	89 90 0c da 01 00    	mov    %edx,0x1da0c(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010b00d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b010:	8b 80 0c da 01 00    	mov    0x1da0c(%eax),%eax
f010b016:	b9 32 00 00 00       	mov    $0x32,%ecx
f010b01b:	ba 00 00 00 00       	mov    $0x0,%edx
f010b020:	f7 f1                	div    %ecx
f010b022:	8b 45 08             	mov    0x8(%ebp),%eax
f010b025:	89 90 0c da 01 00    	mov    %edx,0x1da0c(%eax)
			if (e->table_last_WS_index == 0)
f010b02b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b02e:	8b 80 0c da 01 00    	mov    0x1da0c(%eax),%eax
f010b034:	85 c0                	test   %eax,%eax
f010b036:	75 17                	jne    f010b04f <program_segment_alloc_map_copy_workingset+0x68a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010b038:	83 ec 04             	sub    $0x4,%esp
f010b03b:	68 f0 55 12 f0       	push   $0xf01255f0
f010b040:	68 24 03 00 00       	push   $0x324
f010b045:	68 2f 54 12 f0       	push   $0xf012542f
f010b04a:	e8 cb 52 ff ff       	call   f010031a <_panic>
			(*lastTableNumber) = PDX(iVA);
f010b04f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b052:	c1 e8 16             	shr    $0x16,%eax
f010b055:	89 c2                	mov    %eax,%edx
f010b057:	8b 45 18             	mov    0x18(%ebp),%eax
f010b05a:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010b05c:	8b 45 10             	mov    0x10(%ebp),%eax
f010b05f:	8b 00                	mov    (%eax),%eax
f010b061:	8d 50 01             	lea    0x1(%eax),%edx
f010b064:	8b 45 10             	mov    0x10(%ebp),%eax
f010b067:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010b069:	ff 45 f0             	incl   -0x10(%ebp)
f010b06c:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010b073:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b076:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010b079:	73 0c                	jae    f010b087 <program_segment_alloc_map_copy_workingset+0x6c2>
f010b07b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b07e:	3b 45 14             	cmp    0x14(%ebp),%eax
f010b081:	0f 82 eb f9 ff ff    	jb     f010aa72 <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010b087:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b08a:	8b 00                	mov    (%eax),%eax
f010b08c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010b08f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b092:	8b 40 0c             	mov    0xc(%eax),%eax
f010b095:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b098:	eb 10                	jmp    f010b0aa <program_segment_alloc_map_copy_workingset+0x6e5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010b09a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b09d:	8a 10                	mov    (%eax),%dl
f010b09f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b0a2:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010b0a4:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010b0a7:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b0aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b0ad:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010b0b0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010b0b3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b0b8:	89 c2                	mov    %eax,%edx
f010b0ba:	8b 45 10             	mov    0x10(%ebp),%eax
f010b0bd:	8b 00                	mov    (%eax),%eax
f010b0bf:	c1 e0 0c             	shl    $0xc,%eax
f010b0c2:	01 c2                	add    %eax,%edx
f010b0c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b0c7:	39 c2                	cmp    %eax,%edx
f010b0c9:	76 1d                	jbe    f010b0e8 <program_segment_alloc_map_copy_workingset+0x723>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010b0cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b0ce:	8b 50 04             	mov    0x4(%eax),%edx
f010b0d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b0d4:	01 c2                	add    %eax,%edx
f010b0d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b0d9:	39 c2                	cmp    %eax,%edx
f010b0db:	77 bd                	ja     f010b09a <program_segment_alloc_map_copy_workingset+0x6d5>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010b0dd:	eb 09                	jmp    f010b0e8 <program_segment_alloc_map_copy_workingset+0x723>
	{
		*dst_ptr = 0;
f010b0df:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b0e2:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010b0e5:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010b0e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b0eb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010b0ee:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b0f1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b0f6:	89 c2                	mov    %eax,%edx
f010b0f8:	8b 45 10             	mov    0x10(%ebp),%eax
f010b0fb:	8b 00                	mov    (%eax),%eax
f010b0fd:	c1 e0 0c             	shl    $0xc,%eax
f010b100:	01 c2                	add    %eax,%edx
f010b102:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b105:	39 c2                	cmp    %eax,%edx
f010b107:	77 d6                	ja     f010b0df <program_segment_alloc_map_copy_workingset+0x71a>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010b109:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010b10e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b111:	c9                   	leave  
f010b112:	c3                   	ret    

f010b113 <create_user_directory>:

//==================================================
// 4) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010b113:	55                   	push   %ebp
f010b114:	89 e5                	mov    %esp,%ebp
f010b116:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010b119:	83 ec 0c             	sub    $0xc,%esp
f010b11c:	68 00 10 00 00       	push   $0x1000
f010b121:	e8 ae d6 ff ff       	call   f01087d4 <kmalloc>
f010b126:	83 c4 10             	add    $0x10,%esp
f010b129:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010b12c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b130:	75 17                	jne    f010b149 <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010b132:	83 ec 04             	sub    $0x4,%esp
f010b135:	68 93 56 12 f0       	push   $0xf0125693
f010b13a:	68 54 03 00 00       	push   $0x354
f010b13f:	68 2f 54 12 f0       	push   $0xf012542f
f010b144:	e8 d1 51 ff ff       	call   f010031a <_panic>
	}
	return ptr_user_page_directory;
f010b149:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010b14c:	c9                   	leave  
f010b14d:	c3                   	ret    

f010b14e <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 5) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010b14e:	55                   	push   %ebp
f010b14f:	89 e5                	mov    %esp,%ebp
f010b151:	83 ec 18             	sub    $0x18,%esp
	//remember to leave its bottom page as a GUARD PAGE (i.e. not mapped)
	//return a pointer to the start of the allocated space (including the GUARD PAGE)


#else
	if (KERNEL_HEAP_MAX - __cur_k_stk < KERNEL_STACK_SIZE)
f010b154:	a1 74 99 17 f0       	mov    0xf0179974,%eax
f010b159:	ba 00 f0 ff ff       	mov    $0xfffff000,%edx
f010b15e:	29 c2                	sub    %eax,%edx
f010b160:	89 d0                	mov    %edx,%eax
f010b162:	3d ff 7f 00 00       	cmp    $0x7fff,%eax
f010b167:	77 17                	ja     f010b180 <create_user_kern_stack+0x32>
		panic("Run out of kernel heap!! Unable to create a kernel stack for the process. Can't create more processes!");
f010b169:	83 ec 04             	sub    $0x4,%esp
f010b16c:	68 b0 56 12 f0       	push   $0xf01256b0
f010b171:	68 6d 03 00 00       	push   $0x36d
f010b176:	68 2f 54 12 f0       	push   $0xf012542f
f010b17b:	e8 9a 51 ff ff       	call   f010031a <_panic>
	void* kstack = (void*) __cur_k_stk;
f010b180:	a1 74 99 17 f0       	mov    0xf0179974,%eax
f010b185:	89 45 f4             	mov    %eax,-0xc(%ebp)
	__cur_k_stk += KERNEL_STACK_SIZE;
f010b188:	a1 74 99 17 f0       	mov    0xf0179974,%eax
f010b18d:	05 00 80 00 00       	add    $0x8000,%eax
f010b192:	a3 74 99 17 f0       	mov    %eax,0xf0179974
	return kstack ;
f010b197:	8b 45 f4             	mov    -0xc(%ebp),%eax
//	panic("KERNEL HEAP is OFF! user kernel stack is not supported");
#endif
}
f010b19a:	c9                   	leave  
f010b19b:	c3                   	ret    

f010b19c <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010b19c:	55                   	push   %ebp
f010b19d:	89 e5                	mov    %esp,%ebp
f010b19f:	83 ec 08             	sub    $0x8,%esp
	panic("delete_user_kern_stack() is not implemented yet...!!");

	//Delete the allocated space for the user kernel stack of this process "e"
	//remember to delete the bottom GUARD PAGE (i.e. not mapped)
#else
	panic("KERNEL HEAP is OFF! user kernel stack can't be deleted");
f010b1a2:	83 ec 04             	sub    $0x4,%esp
f010b1a5:	68 18 57 12 f0       	push   $0xf0125718
f010b1aa:	68 83 03 00 00       	push   $0x383
f010b1af:	68 2f 54 12 f0       	push   $0xf012542f
f010b1b4:	e8 61 51 ff ff       	call   f010031a <_panic>

f010b1b9 <initialize_uheap_dynamic_allocator>:
}
//===============================================
// 7) INITIALIZE DYNAMIC ALLOCATOR OF UHEAP:
//===============================================
void initialize_uheap_dynamic_allocator(struct Env* e, uint32 daStart, uint32 daLimit)
{
f010b1b9:	55                   	push   %ebp
f010b1ba:	89 e5                	mov    %esp,%ebp
	//[PROJECT'24.MS2] Initialize the dynamic allocator of the user heap
	//Remember:
	//	1) there's no initial allocations for the dynamic allocator of the user heap (=0)
	//	2) call the initialize_dynamic_allocator(..) to complete the initialization
	//panic("initialize_uheap_dynamic_allocator() is not implemented yet...!!");
}
f010b1bc:	90                   	nop
f010b1bd:	5d                   	pop    %ebp
f010b1be:	c3                   	ret    

f010b1bf <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010b1bf:	55                   	push   %ebp
f010b1c0:	89 e5                	mov    %esp,%ebp
f010b1c2:	53                   	push   %ebx
f010b1c3:	83 ec 14             	sub    $0x14,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010b1c6:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1c9:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b1cc:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010b1cf:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1d2:	8b 55 10             	mov    0x10(%ebp),%edx
f010b1d5:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010b1d8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010b1df:	eb 17                	jmp    f010b1f8 <initialize_environment+0x39>
	{
		e->env_page_directory[i] = 0 ;
f010b1e1:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1e4:	8b 40 64             	mov    0x64(%eax),%eax
f010b1e7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b1ea:	c1 e2 02             	shl    $0x2,%edx
f010b1ed:	01 d0                	add    %edx,%eax
f010b1ef:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010b1f5:	ff 45 f4             	incl   -0xc(%ebp)
f010b1f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b1fb:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010b200:	76 df                	jbe    f010b1e1 <initialize_environment+0x22>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010b202:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010b209:	eb 22                	jmp    f010b22d <initialize_environment+0x6e>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010b20b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b20e:	8b 40 64             	mov    0x64(%eax),%eax
f010b211:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b214:	c1 e2 02             	shl    $0x2,%edx
f010b217:	01 c2                	add    %eax,%edx
f010b219:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f010b21e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010b221:	c1 e1 02             	shl    $0x2,%ecx
f010b224:	01 c8                	add    %ecx,%eax
f010b226:	8b 00                	mov    (%eax),%eax
f010b228:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010b22a:	ff 45 f4             	incl   -0xc(%ebp)
f010b22d:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010b234:	7e d5                	jle    f010b20b <initialize_environment+0x4c>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010b236:	8b 45 08             	mov    0x8(%ebp),%eax
f010b239:	8b 40 64             	mov    0x64(%eax),%eax
f010b23c:	83 ec 0c             	sub    $0xc,%esp
f010b23f:	50                   	push   %eax
f010b240:	e8 09 ff ff ff       	call   f010b14e <create_user_kern_stack>
f010b245:	83 c4 10             	add    $0x10,%esp
f010b248:	89 c2                	mov    %eax,%edx
f010b24a:	8b 45 08             	mov    0x8(%ebp),%eax
f010b24d:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010b250:	8b 45 08             	mov    0x8(%ebp),%eax
f010b253:	8b 40 70             	mov    0x70(%eax),%eax
f010b256:	05 00 80 00 00       	add    $0x8000,%eax
f010b25b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		sp -= sizeof(struct Trapframe);
f010b25e:	83 6d ec 44          	subl   $0x44,-0x14(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010b262:	8b 45 08             	mov    0x8(%ebp),%eax
f010b265:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010b268:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010b26a:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010b26e:	ba a2 d4 10 f0       	mov    $0xf010d4a2,%edx
f010b273:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b276:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010b278:	83 6d ec 20          	subl   $0x20,-0x14(%ebp)
		e->context = (struct Context *) sp;
f010b27c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b27f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010b282:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010b285:	8b 45 08             	mov    0x8(%ebp),%eax
f010b288:	8b 40 04             	mov    0x4(%eax),%eax
f010b28b:	83 ec 04             	sub    $0x4,%esp
f010b28e:	6a 20                	push   $0x20
f010b290:	6a 00                	push   $0x0
f010b292:	50                   	push   %eax
f010b293:	e8 a7 54 01 00       	call   f012073f <memset>
f010b298:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010b29b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b29e:	8b 40 04             	mov    0x4(%eax),%eax
f010b2a1:	ba f4 a3 10 f0       	mov    $0xf010a3f4,%edx
f010b2a6:	89 50 1c             	mov    %edx,0x1c(%eax)
	{
		LIST_INIT(&(e->page_WS_list));
	}
#else
	{
		uint32 env_index = (uint32)(e-envs);
f010b2a9:	8b 45 08             	mov    0x8(%ebp),%eax
f010b2ac:	8b 15 10 1a 55 f0    	mov    0xf0551a10,%edx
f010b2b2:	29 d0                	sub    %edx,%eax
f010b2b4:	c1 f8 02             	sar    $0x2,%eax
f010b2b7:	89 c2                	mov    %eax,%edx
f010b2b9:	89 d0                	mov    %edx,%eax
f010b2bb:	c1 e0 02             	shl    $0x2,%eax
f010b2be:	01 d0                	add    %edx,%eax
f010b2c0:	c1 e0 02             	shl    $0x2,%eax
f010b2c3:	01 d0                	add    %edx,%eax
f010b2c5:	c1 e0 02             	shl    $0x2,%eax
f010b2c8:	01 d0                	add    %edx,%eax
f010b2ca:	c1 e0 02             	shl    $0x2,%eax
f010b2cd:	01 d0                	add    %edx,%eax
f010b2cf:	c1 e0 08             	shl    $0x8,%eax
f010b2d2:	29 d0                	sub    %edx,%eax
f010b2d4:	c1 e0 08             	shl    $0x8,%eax
f010b2d7:	29 d0                	sub    %edx,%eax
f010b2d9:	c1 e0 03             	shl    $0x3,%eax
f010b2dc:	01 d0                	add    %edx,%eax
f010b2de:	c1 e0 03             	shl    $0x3,%eax
f010b2e1:	01 d0                	add    %edx,%eax
f010b2e3:	01 c0                	add    %eax,%eax
f010b2e5:	01 d0                	add    %edx,%eax
f010b2e7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		e->__uptr_pws = (struct WorkingSetElement*) ( ((struct Env*)(UENVS+sizeof(struct Env)*env_index))->ptr_pageWorkingSet );
f010b2ea:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010b2ed:	89 d0                	mov    %edx,%eax
f010b2ef:	c1 e0 06             	shl    $0x6,%eax
f010b2f2:	29 d0                	sub    %edx,%eax
f010b2f4:	c1 e0 02             	shl    $0x2,%eax
f010b2f7:	01 d0                	add    %edx,%eax
f010b2f9:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010b300:	01 c8                	add    %ecx,%eax
f010b302:	c1 e0 03             	shl    $0x3,%eax
f010b305:	01 d0                	add    %edx,%eax
f010b307:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010b30e:	29 c2                	sub    %eax,%edx
f010b310:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f010b317:	89 c2                	mov    %eax,%edx
f010b319:	89 d0                	mov    %edx,%eax
f010b31b:	2d 00 00 40 11       	sub    $0x11400000,%eax
f010b320:	8d 90 88 00 00 00    	lea    0x88(%eax),%edx
f010b326:	8b 45 08             	mov    0x8(%ebp),%eax
f010b329:	89 90 38 da 01 00    	mov    %edx,0x1da38(%eax)
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b32f:	83 ec 0c             	sub    $0xc,%esp
f010b332:	6a 02                	push   $0x2
f010b334:	e8 54 30 00 00       	call   f010e38d <isPageReplacmentAlgorithmLRU>
f010b339:	83 c4 10             	add    $0x10,%esp
f010b33c:	85 c0                	test   %eax,%eax
f010b33e:	0f 84 34 01 00 00    	je     f010b478 <initialize_environment+0x2b9>
	{
#if USE_KHEAP == 1
		//panic("not handled yet");
#else
		for (int i = 0; i < e->page_WS_max_size; ++i)
f010b344:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010b34b:	e9 14 01 00 00       	jmp    f010b464 <initialize_environment+0x2a5>
		{
			LIST_INSERT_HEAD(&(e->PageWorkingSetList), &(e->ptr_pageWorkingSet[i]));
f010b350:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b353:	89 d0                	mov    %edx,%eax
f010b355:	01 c0                	add    %eax,%eax
f010b357:	01 d0                	add    %edx,%eax
f010b359:	c1 e0 03             	shl    $0x3,%eax
f010b35c:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b362:	8b 45 08             	mov    0x8(%ebp),%eax
f010b365:	01 d0                	add    %edx,%eax
f010b367:	83 c0 08             	add    $0x8,%eax
f010b36a:	85 c0                	test   %eax,%eax
f010b36c:	75 17                	jne    f010b385 <initialize_environment+0x1c6>
f010b36e:	83 ec 04             	sub    $0x4,%esp
f010b371:	68 0c 54 12 f0       	push   $0xf012540c
f010b376:	68 e6 03 00 00       	push   $0x3e6
f010b37b:	68 2f 54 12 f0       	push   $0xf012542f
f010b380:	e8 95 4f ff ff       	call   f010031a <_panic>
f010b385:	8b 45 08             	mov    0x8(%ebp),%eax
f010b388:	8b 90 48 d5 01 00    	mov    0x1d548(%eax),%edx
f010b38e:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010b391:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f010b394:	89 c8                	mov    %ecx,%eax
f010b396:	01 c0                	add    %eax,%eax
f010b398:	01 c8                	add    %ecx,%eax
f010b39a:	c1 e0 03             	shl    $0x3,%eax
f010b39d:	01 d8                	add    %ebx,%eax
f010b39f:	05 98 00 00 00       	add    $0x98,%eax
f010b3a4:	89 10                	mov    %edx,(%eax)
f010b3a6:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b3a9:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b3ac:	89 d0                	mov    %edx,%eax
f010b3ae:	01 c0                	add    %eax,%eax
f010b3b0:	01 d0                	add    %edx,%eax
f010b3b2:	c1 e0 03             	shl    $0x3,%eax
f010b3b5:	01 c8                	add    %ecx,%eax
f010b3b7:	05 98 00 00 00       	add    $0x98,%eax
f010b3bc:	8b 00                	mov    (%eax),%eax
f010b3be:	85 c0                	test   %eax,%eax
f010b3c0:	74 28                	je     f010b3ea <initialize_environment+0x22b>
f010b3c2:	8b 45 08             	mov    0x8(%ebp),%eax
f010b3c5:	8b 90 48 d5 01 00    	mov    0x1d548(%eax),%edx
f010b3cb:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f010b3ce:	89 c8                	mov    %ecx,%eax
f010b3d0:	01 c0                	add    %eax,%eax
f010b3d2:	01 c8                	add    %ecx,%eax
f010b3d4:	c1 e0 03             	shl    $0x3,%eax
f010b3d7:	8d 88 80 00 00 00    	lea    0x80(%eax),%ecx
f010b3dd:	8b 45 08             	mov    0x8(%ebp),%eax
f010b3e0:	01 c8                	add    %ecx,%eax
f010b3e2:	83 c0 08             	add    $0x8,%eax
f010b3e5:	89 42 14             	mov    %eax,0x14(%edx)
f010b3e8:	eb 23                	jmp    f010b40d <initialize_environment+0x24e>
f010b3ea:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b3ed:	89 d0                	mov    %edx,%eax
f010b3ef:	01 c0                	add    %eax,%eax
f010b3f1:	01 d0                	add    %edx,%eax
f010b3f3:	c1 e0 03             	shl    $0x3,%eax
f010b3f6:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b3fc:	8b 45 08             	mov    0x8(%ebp),%eax
f010b3ff:	01 d0                	add    %edx,%eax
f010b401:	8d 50 08             	lea    0x8(%eax),%edx
f010b404:	8b 45 08             	mov    0x8(%ebp),%eax
f010b407:	89 90 4c d5 01 00    	mov    %edx,0x1d54c(%eax)
f010b40d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b410:	89 d0                	mov    %edx,%eax
f010b412:	01 c0                	add    %eax,%eax
f010b414:	01 d0                	add    %edx,%eax
f010b416:	c1 e0 03             	shl    $0x3,%eax
f010b419:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b41f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b422:	01 d0                	add    %edx,%eax
f010b424:	8d 50 08             	lea    0x8(%eax),%edx
f010b427:	8b 45 08             	mov    0x8(%ebp),%eax
f010b42a:	89 90 48 d5 01 00    	mov    %edx,0x1d548(%eax)
f010b430:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b433:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b436:	89 d0                	mov    %edx,%eax
f010b438:	01 c0                	add    %eax,%eax
f010b43a:	01 d0                	add    %edx,%eax
f010b43c:	c1 e0 03             	shl    $0x3,%eax
f010b43f:	01 c8                	add    %ecx,%eax
f010b441:	05 9c 00 00 00       	add    $0x9c,%eax
f010b446:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010b44c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b44f:	8b 80 54 d5 01 00    	mov    0x1d554(%eax),%eax
f010b455:	8d 50 01             	lea    0x1(%eax),%edx
f010b458:	8b 45 08             	mov    0x8(%ebp),%eax
f010b45b:	89 90 54 d5 01 00    	mov    %edx,0x1d554(%eax)
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
#if USE_KHEAP == 1
		//panic("not handled yet");
#else
		for (int i = 0; i < e->page_WS_max_size; ++i)
f010b461:	ff 45 f0             	incl   -0x10(%ebp)
f010b464:	8b 45 08             	mov    0x8(%ebp),%eax
f010b467:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f010b46d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b470:	39 c2                	cmp    %eax,%edx
f010b472:	0f 87 d8 fe ff ff    	ja     f010b350 <initialize_environment+0x191>
	}

	//initialize environment working set
#if USE_KHEAP
#else
	for(i=0; i< (e->page_WS_max_size); i++)
f010b478:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010b47f:	eb 54                	jmp    f010b4d5 <initialize_environment+0x316>
	{
		e->ptr_pageWorkingSet[i].virtual_address = 0;
f010b481:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b484:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b487:	89 d0                	mov    %edx,%eax
f010b489:	01 c0                	add    %eax,%eax
f010b48b:	01 d0                	add    %edx,%eax
f010b48d:	c1 e0 03             	shl    $0x3,%eax
f010b490:	01 c8                	add    %ecx,%eax
f010b492:	05 88 00 00 00       	add    $0x88,%eax
f010b497:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].empty = 1;
f010b49d:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b4a0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b4a3:	89 d0                	mov    %edx,%eax
f010b4a5:	01 c0                	add    %eax,%eax
f010b4a7:	01 d0                	add    %edx,%eax
f010b4a9:	c1 e0 03             	shl    $0x3,%eax
f010b4ac:	01 c8                	add    %ecx,%eax
f010b4ae:	05 8c 00 00 00       	add    $0x8c,%eax
f010b4b3:	c6 00 01             	movb   $0x1,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
f010b4b6:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b4b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b4bc:	89 d0                	mov    %edx,%eax
f010b4be:	01 c0                	add    %eax,%eax
f010b4c0:	01 d0                	add    %edx,%eax
f010b4c2:	c1 e0 03             	shl    $0x3,%eax
f010b4c5:	01 c8                	add    %ecx,%eax
f010b4c7:	05 90 00 00 00       	add    $0x90,%eax
f010b4cc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	}

	//initialize environment working set
#if USE_KHEAP
#else
	for(i=0; i< (e->page_WS_max_size); i++)
f010b4d2:	ff 45 f4             	incl   -0xc(%ebp)
f010b4d5:	8b 45 08             	mov    0x8(%ebp),%eax
f010b4d8:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f010b4de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b4e1:	39 c2                	cmp    %eax,%edx
f010b4e3:	77 9c                	ja     f010b481 <initialize_environment+0x2c2>
	{
		e->ptr_pageWorkingSet[i].virtual_address = 0;
		e->ptr_pageWorkingSet[i].empty = 1;
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
f010b4e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010b4e8:	c7 80 58 d5 01 00 00 	movl   $0x0,0x1d558(%eax)
f010b4ef:	00 00 00 
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010b4f2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010b4f9:	eb 54                	jmp    f010b54f <initialize_environment+0x390>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010b4fb:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b4fe:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b501:	89 d0                	mov    %edx,%eax
f010b503:	01 c0                	add    %eax,%eax
f010b505:	01 d0                	add    %edx,%eax
f010b507:	c1 e0 03             	shl    $0x3,%eax
f010b50a:	01 c8                	add    %ecx,%eax
f010b50c:	05 5c d5 01 00       	add    $0x1d55c,%eax
f010b511:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010b517:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b51a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b51d:	89 d0                	mov    %edx,%eax
f010b51f:	01 c0                	add    %eax,%eax
f010b521:	01 d0                	add    %edx,%eax
f010b523:	c1 e0 03             	shl    $0x3,%eax
f010b526:	01 c8                	add    %ecx,%eax
f010b528:	05 60 d5 01 00       	add    $0x1d560,%eax
f010b52d:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010b530:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b533:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b536:	89 d0                	mov    %edx,%eax
f010b538:	01 c0                	add    %eax,%eax
f010b53a:	01 d0                	add    %edx,%eax
f010b53c:	c1 e0 03             	shl    $0x3,%eax
f010b53f:	01 c8                	add    %ecx,%eax
f010b541:	05 64 d5 01 00       	add    $0x1d564,%eax
f010b546:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010b54c:	ff 45 f4             	incl   -0xc(%ebp)
f010b54f:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010b553:	7e a6                	jle    f010b4fb <initialize_environment+0x33c>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010b555:	8b 45 08             	mov    0x8(%ebp),%eax
f010b558:	c7 80 0c da 01 00 00 	movl   $0x0,0x1da0c(%eax)
f010b55f:	00 00 00 

	e->pageFaultsCounter=0;
f010b562:	8b 45 08             	mov    0x8(%ebp),%eax
f010b565:	c7 80 40 da 01 00 00 	movl   $0x0,0x1da40(%eax)
f010b56c:	00 00 00 
	e->tableFaultsCounter=0;
f010b56f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b572:	c7 80 44 da 01 00 00 	movl   $0x0,0x1da44(%eax)
f010b579:	00 00 00 

	e->freeingFullWSCounter = 0;
f010b57c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b57f:	c7 80 48 da 01 00 00 	movl   $0x0,0x1da48(%eax)
f010b586:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010b589:	8b 45 08             	mov    0x8(%ebp),%eax
f010b58c:	c7 80 4c da 01 00 00 	movl   $0x0,0x1da4c(%eax)
f010b593:	00 00 00 

	e->nModifiedPages=0;
f010b596:	8b 45 08             	mov    0x8(%ebp),%eax
f010b599:	c7 80 50 da 01 00 00 	movl   $0x0,0x1da50(%eax)
f010b5a0:	00 00 00 
	e->nNotModifiedPages=0;
f010b5a3:	8b 45 08             	mov    0x8(%ebp),%eax
f010b5a6:	c7 80 54 da 01 00 00 	movl   $0x0,0x1da54(%eax)
f010b5ad:	00 00 00 
	e->nClocks = 0;
f010b5b0:	8b 45 08             	mov    0x8(%ebp),%eax
f010b5b3:	c7 80 68 da 01 00 00 	movl   $0x0,0x1da68(%eax)
f010b5ba:	00 00 00 

	//2020
	e->nPageIn = 0;
f010b5bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010b5c0:	c7 80 5c da 01 00 00 	movl   $0x0,0x1da5c(%eax)
f010b5c7:	00 00 00 
	e->nPageOut = 0;
f010b5ca:	8b 45 08             	mov    0x8(%ebp),%eax
f010b5cd:	c7 80 60 da 01 00 00 	movl   $0x0,0x1da60(%eax)
f010b5d4:	00 00 00 
	e->nNewPageAdded = 0;
f010b5d7:	8b 45 08             	mov    0x8(%ebp),%eax
f010b5da:	c7 80 64 da 01 00 00 	movl   $0x0,0x1da64(%eax)
f010b5e1:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//[PROJECT'24.DONE] call initialize_uheap_dynamic_allocator(...)
	initialize_uheap_dynamic_allocator(e, USER_HEAP_START, USER_HEAP_START + DYN_ALLOC_MAX_SIZE);
f010b5e4:	83 ec 04             	sub    $0x4,%esp
f010b5e7:	68 00 00 00 82       	push   $0x82000000
f010b5ec:	68 00 00 00 80       	push   $0x80000000
f010b5f1:	ff 75 08             	pushl  0x8(%ebp)
f010b5f4:	e8 c0 fb ff ff       	call   f010b1b9 <initialize_uheap_dynamic_allocator>
f010b5f9:	83 c4 10             	add    $0x10,%esp

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010b5fc:	83 ec 0c             	sub    $0xc,%esp
f010b5ff:	ff 75 08             	pushl  0x8(%ebp)
f010b602:	e8 09 00 00 00       	call   f010b610 <complete_environment_initialization>
f010b607:	83 c4 10             	add    $0x10,%esp
}
f010b60a:	90                   	nop
f010b60b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b60e:	c9                   	leave  
f010b60f:	c3                   	ret    

f010b610 <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010b610:	55                   	push   %ebp
f010b611:	89 e5                	mov    %esp,%ebp
f010b613:	53                   	push   %ebx
f010b614:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010b617:	8b 45 08             	mov    0x8(%ebp),%eax
f010b61a:	8b 40 64             	mov    0x64(%eax),%eax
f010b61d:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010b623:	8b 45 08             	mov    0x8(%ebp),%eax
f010b626:	8b 40 68             	mov    0x68(%eax),%eax
f010b629:	83 c8 03             	or     $0x3,%eax
f010b62c:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010b62e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b631:	8b 40 64             	mov    0x64(%eax),%eax
f010b634:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010b63a:	8b 45 08             	mov    0x8(%ebp),%eax
f010b63d:	8b 40 68             	mov    0x68(%eax),%eax
f010b640:	83 c8 05             	or     $0x5,%eax
f010b643:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010b645:	8b 45 08             	mov    0x8(%ebp),%eax
f010b648:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	e->disk_env_pgdir_PA= 0;
f010b64f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b652:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
	e->disk_env_tabledir = 0;
f010b659:	8b 45 08             	mov    0x8(%ebp),%eax
f010b65c:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	e->disk_env_tabledir_PA = 0;
f010b663:	8b 45 08             	mov    0x8(%ebp),%eax
f010b666:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010b66d:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010b670:	8b 45 08             	mov    0x8(%ebp),%eax
f010b673:	8b 58 10             	mov    0x10(%eax),%ebx
f010b676:	83 ec 0c             	sub    $0xc,%esp
f010b679:	6a 08                	push   $0x8
f010b67b:	e8 9d 36 01 00       	call   f011ed1d <log2_ceil>
f010b680:	83 c4 10             	add    $0x10,%esp
f010b683:	ba 01 00 00 00       	mov    $0x1,%edx
f010b688:	88 c1                	mov    %al,%cl
f010b68a:	d3 e2                	shl    %cl,%edx
f010b68c:	89 d0                	mov    %edx,%eax
f010b68e:	01 d8                	add    %ebx,%eax
f010b690:	89 c3                	mov    %eax,%ebx
f010b692:	83 ec 0c             	sub    $0xc,%esp
f010b695:	6a 08                	push   $0x8
f010b697:	e8 4c 36 01 00       	call   f011ece8 <nearest_pow2_ceil>
f010b69c:	83 c4 10             	add    $0x10,%esp
f010b69f:	f7 d8                	neg    %eax
f010b6a1:	21 d8                	and    %ebx,%eax
f010b6a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010b6a6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b6aa:	7f 1b                	jg     f010b6c7 <complete_environment_initialization+0xb7>
		generation = 1 << ENVGENSHIFT;
f010b6ac:	83 ec 0c             	sub    $0xc,%esp
f010b6af:	6a 08                	push   $0x8
f010b6b1:	e8 67 36 01 00       	call   f011ed1d <log2_ceil>
f010b6b6:	83 c4 10             	add    $0x10,%esp
f010b6b9:	ba 01 00 00 00       	mov    $0x1,%edx
f010b6be:	88 c1                	mov    %al,%cl
f010b6c0:	d3 e2                	shl    %cl,%edx
f010b6c2:	89 d0                	mov    %edx,%eax
f010b6c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010b6c7:	8b 45 08             	mov    0x8(%ebp),%eax
f010b6ca:	8b 15 10 1a 55 f0    	mov    0xf0551a10,%edx
f010b6d0:	29 d0                	sub    %edx,%eax
f010b6d2:	c1 f8 02             	sar    $0x2,%eax
f010b6d5:	89 c2                	mov    %eax,%edx
f010b6d7:	89 d0                	mov    %edx,%eax
f010b6d9:	c1 e0 02             	shl    $0x2,%eax
f010b6dc:	01 d0                	add    %edx,%eax
f010b6de:	c1 e0 02             	shl    $0x2,%eax
f010b6e1:	01 d0                	add    %edx,%eax
f010b6e3:	c1 e0 02             	shl    $0x2,%eax
f010b6e6:	01 d0                	add    %edx,%eax
f010b6e8:	c1 e0 02             	shl    $0x2,%eax
f010b6eb:	01 d0                	add    %edx,%eax
f010b6ed:	c1 e0 08             	shl    $0x8,%eax
f010b6f0:	29 d0                	sub    %edx,%eax
f010b6f2:	c1 e0 08             	shl    $0x8,%eax
f010b6f5:	29 d0                	sub    %edx,%eax
f010b6f7:	c1 e0 03             	shl    $0x3,%eax
f010b6fa:	01 d0                	add    %edx,%eax
f010b6fc:	c1 e0 03             	shl    $0x3,%eax
f010b6ff:	01 d0                	add    %edx,%eax
f010b701:	01 c0                	add    %eax,%eax
f010b703:	01 d0                	add    %edx,%eax
f010b705:	0b 45 f4             	or     -0xc(%ebp),%eax
f010b708:	89 c2                	mov    %eax,%edx
f010b70a:	8b 45 08             	mov    0x8(%ebp),%eax
f010b70d:	89 50 10             	mov    %edx,0x10(%eax)

	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010b710:	e8 79 ed ff ff       	call   f010a48e <get_cpu_proc>
f010b715:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010b718:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010b71c:	75 0c                	jne    f010b72a <complete_environment_initialization+0x11a>
		e->env_parent_id = 0;//no parent;
f010b71e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b721:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b728:	eb 0c                	jmp    f010b736 <complete_environment_initialization+0x126>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010b72a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b72d:	8b 50 10             	mov    0x10(%eax),%edx
f010b730:	8b 45 08             	mov    0x8(%ebp),%eax
f010b733:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010b736:	8b 45 08             	mov    0x8(%ebp),%eax
f010b739:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010b740:	8b 45 08             	mov    0x8(%ebp),%eax
f010b743:	c7 80 58 da 01 00 00 	movl   $0x0,0x1da58(%eax)
f010b74a:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010b74d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b750:	8b 00                	mov    (%eax),%eax
f010b752:	83 ec 04             	sub    $0x4,%esp
f010b755:	6a 44                	push   $0x44
f010b757:	6a 00                	push   $0x0
f010b759:	50                   	push   %eax
f010b75a:	e8 e0 4f 01 00       	call   f012073f <memset>
f010b75f:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010b762:	8b 45 08             	mov    0x8(%ebp),%eax
f010b765:	8b 00                	mov    (%eax),%eax
f010b767:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010b76d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b770:	8b 00                	mov    (%eax),%eax
f010b772:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010b778:	8b 45 08             	mov    0x8(%ebp),%eax
f010b77b:	8b 00                	mov    (%eax),%eax
f010b77d:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010b783:	8b 45 08             	mov    0x8(%ebp),%eax
f010b786:	8b 00                	mov    (%eax),%eax
f010b788:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010b78f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b792:	8b 00                	mov    (%eax),%eax
f010b794:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010b79a:	8b 45 08             	mov    0x8(%ebp),%eax
f010b79d:	8b 00                	mov    (%eax),%eax
f010b79f:	8b 55 08             	mov    0x8(%ebp),%edx
f010b7a2:	8b 12                	mov    (%edx),%edx
f010b7a4:	8b 52 38             	mov    0x38(%edx),%edx
f010b7a7:	80 ce 02             	or     $0x2,%dh
f010b7aa:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010b7ad:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010b7b1:	75 17                	jne    f010b7ca <complete_environment_initialization+0x1ba>
f010b7b3:	83 ec 04             	sub    $0x4,%esp
f010b7b6:	68 c1 54 12 f0       	push   $0xf01254c1
f010b7bb:	68 52 04 00 00       	push   $0x452
f010b7c0:	68 2f 54 12 f0       	push   $0xf012542f
f010b7c5:	e8 50 4b ff ff       	call   f010031a <_panic>
f010b7ca:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7cd:	8b 40 08             	mov    0x8(%eax),%eax
f010b7d0:	85 c0                	test   %eax,%eax
f010b7d2:	74 11                	je     f010b7e5 <complete_environment_initialization+0x1d5>
f010b7d4:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7d7:	8b 40 08             	mov    0x8(%eax),%eax
f010b7da:	8b 55 08             	mov    0x8(%ebp),%edx
f010b7dd:	8b 52 0c             	mov    0xc(%edx),%edx
f010b7e0:	89 50 0c             	mov    %edx,0xc(%eax)
f010b7e3:	eb 0b                	jmp    f010b7f0 <complete_environment_initialization+0x1e0>
f010b7e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7e8:	8b 40 0c             	mov    0xc(%eax),%eax
f010b7eb:	a3 18 1a 55 f0       	mov    %eax,0xf0551a18
f010b7f0:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7f3:	8b 40 0c             	mov    0xc(%eax),%eax
f010b7f6:	85 c0                	test   %eax,%eax
f010b7f8:	74 11                	je     f010b80b <complete_environment_initialization+0x1fb>
f010b7fa:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7fd:	8b 40 0c             	mov    0xc(%eax),%eax
f010b800:	8b 55 08             	mov    0x8(%ebp),%edx
f010b803:	8b 52 08             	mov    0x8(%edx),%edx
f010b806:	89 50 08             	mov    %edx,0x8(%eax)
f010b809:	eb 0b                	jmp    f010b816 <complete_environment_initialization+0x206>
f010b80b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b80e:	8b 40 08             	mov    0x8(%eax),%eax
f010b811:	a3 14 1a 55 f0       	mov    %eax,0xf0551a14
f010b816:	8b 45 08             	mov    0x8(%ebp),%eax
f010b819:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010b820:	8b 45 08             	mov    0x8(%ebp),%eax
f010b823:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010b82a:	a1 20 1a 55 f0       	mov    0xf0551a20,%eax
f010b82f:	48                   	dec    %eax
f010b830:	a3 20 1a 55 f0       	mov    %eax,0xf0551a20
	return ;
f010b835:	90                   	nop
}
f010b836:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b839:	c9                   	leave  
f010b83a:	c3                   	ret    

f010b83b <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010b83b:	55                   	push   %ebp
f010b83c:	89 e5                	mov    %esp,%ebp
f010b83e:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010b841:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b844:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010b847:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b84a:	8b 00                	mov    (%eax),%eax
f010b84c:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010b851:	74 17                	je     f010b86a <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010b853:	83 ec 04             	sub    $0x4,%esp
f010b856:	68 4f 57 12 f0       	push   $0xf012574f
f010b85b:	68 5e 04 00 00       	push   $0x45e
f010b860:	68 2f 54 12 f0       	push   $0xf012542f
f010b865:	e8 b0 4a ff ff       	call   f010031a <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010b86a:	8b 45 08             	mov    0x8(%ebp),%eax
f010b86d:	8b 00                	mov    (%eax),%eax
f010b86f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b872:	8b 52 18             	mov    0x18(%edx),%edx
f010b875:	89 50 30             	mov    %edx,0x30(%eax)
}
f010b878:	90                   	nop
f010b879:	c9                   	leave  
f010b87a:	c3                   	ret    

f010b87b <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 11) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010b87b:	55                   	push   %ebp
f010b87c:	89 e5                	mov    %esp,%ebp
f010b87e:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010b881:	8b 45 08             	mov    0x8(%ebp),%eax
f010b884:	8b 40 10             	mov    0x10(%eax),%eax
f010b887:	8d 48 01             	lea    0x1(%eax),%ecx
f010b88a:	8b 55 08             	mov    0x8(%ebp),%edx
f010b88d:	89 4a 10             	mov    %ecx,0x10(%edx)
f010b890:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010b893:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b896:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010b899:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b89c:	8b 00                	mov    (%eax),%eax
f010b89e:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010b8a3:	74 17                	je     f010b8bc <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010b8a5:	83 ec 04             	sub    $0x4,%esp
f010b8a8:	68 4f 57 12 f0       	push   $0xf012574f
f010b8ad:	68 6c 04 00 00       	push   $0x46c
f010b8b2:	68 2f 54 12 f0       	push   $0xf012542f
f010b8b7:	e8 5e 4a ff ff       	call   f010031a <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010b8bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b8bf:	8b 50 1c             	mov    0x1c(%eax),%edx
f010b8c2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b8c5:	01 d0                	add    %edx,%eax
f010b8c7:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010b8ca:	eb 0f                	jmp    f010b8db <PROGRAM_SEGMENT_NEXT+0x60>
f010b8cc:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8cf:	8b 40 10             	mov    0x10(%eax),%eax
f010b8d2:	8d 50 01             	lea    0x1(%eax),%edx
f010b8d5:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8d8:	89 50 10             	mov    %edx,0x10(%eax)
f010b8db:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8de:	8b 40 10             	mov    0x10(%eax),%eax
f010b8e1:	c1 e0 05             	shl    $0x5,%eax
f010b8e4:	89 c2                	mov    %eax,%edx
f010b8e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b8e9:	01 d0                	add    %edx,%eax
f010b8eb:	8b 00                	mov    (%eax),%eax
f010b8ed:	83 f8 01             	cmp    $0x1,%eax
f010b8f0:	74 13                	je     f010b905 <PROGRAM_SEGMENT_NEXT+0x8a>
f010b8f2:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8f5:	8b 50 10             	mov    0x10(%eax),%edx
f010b8f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b8fb:	8b 40 2c             	mov    0x2c(%eax),%eax
f010b8fe:	0f b7 c0             	movzwl %ax,%eax
f010b901:	39 c2                	cmp    %eax,%edx
f010b903:	72 c7                	jb     f010b8cc <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010b905:	8b 45 08             	mov    0x8(%ebp),%eax
f010b908:	8b 40 10             	mov    0x10(%eax),%eax
f010b90b:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010b90e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b911:	8b 40 2c             	mov    0x2c(%eax),%eax
f010b914:	0f b7 c0             	movzwl %ax,%eax
f010b917:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010b91a:	7e 63                	jle    f010b97f <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010b91c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b91f:	c1 e0 05             	shl    $0x5,%eax
f010b922:	89 c2                	mov    %eax,%edx
f010b924:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b927:	01 d0                	add    %edx,%eax
f010b929:	8b 50 04             	mov    0x4(%eax),%edx
f010b92c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b92f:	01 c2                	add    %eax,%edx
f010b931:	8b 45 08             	mov    0x8(%ebp),%eax
f010b934:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010b936:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b939:	c1 e0 05             	shl    $0x5,%eax
f010b93c:	89 c2                	mov    %eax,%edx
f010b93e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b941:	01 d0                	add    %edx,%eax
f010b943:	8b 50 14             	mov    0x14(%eax),%edx
f010b946:	8b 45 08             	mov    0x8(%ebp),%eax
f010b949:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010b94c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b94f:	c1 e0 05             	shl    $0x5,%eax
f010b952:	89 c2                	mov    %eax,%edx
f010b954:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b957:	01 d0                	add    %edx,%eax
f010b959:	8b 50 10             	mov    0x10(%eax),%edx
f010b95c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b95f:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010b962:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b965:	c1 e0 05             	shl    $0x5,%eax
f010b968:	89 c2                	mov    %eax,%edx
f010b96a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b96d:	01 d0                	add    %edx,%eax
f010b96f:	8b 40 08             	mov    0x8(%eax),%eax
f010b972:	89 c2                	mov    %eax,%edx
f010b974:	8b 45 08             	mov    0x8(%ebp),%eax
f010b977:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010b97a:	8b 45 08             	mov    0x8(%ebp),%eax
f010b97d:	eb 05                	jmp    f010b984 <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010b97f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010b984:	c9                   	leave  
f010b985:	c3                   	ret    

f010b986 <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 12) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010b986:	55                   	push   %ebp
f010b987:	89 e5                	mov    %esp,%ebp
f010b989:	57                   	push   %edi
f010b98a:	56                   	push   %esi
f010b98b:	53                   	push   %ebx
f010b98c:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010b98f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010b996:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b999:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010b99c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b99f:	8b 00                	mov    (%eax),%eax
f010b9a1:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010b9a6:	74 17                	je     f010b9bf <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010b9a8:	83 ec 04             	sub    $0x4,%esp
f010b9ab:	68 4f 57 12 f0       	push   $0xf012574f
f010b9b0:	68 88 04 00 00       	push   $0x488
f010b9b5:	68 2f 54 12 f0       	push   $0xf012542f
f010b9ba:	e8 5b 49 ff ff       	call   f010031a <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010b9bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b9c2:	8b 50 1c             	mov    0x1c(%eax),%edx
f010b9c5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b9c8:	01 d0                	add    %edx,%eax
f010b9ca:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010b9cd:	eb 07                	jmp    f010b9d6 <PROGRAM_SEGMENT_FIRST+0x50>
f010b9cf:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b9d2:	40                   	inc    %eax
f010b9d3:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010b9d6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b9d9:	c1 e0 05             	shl    $0x5,%eax
f010b9dc:	89 c2                	mov    %eax,%edx
f010b9de:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b9e1:	01 d0                	add    %edx,%eax
f010b9e3:	8b 00                	mov    (%eax),%eax
f010b9e5:	83 f8 01             	cmp    $0x1,%eax
f010b9e8:	74 10                	je     f010b9fa <PROGRAM_SEGMENT_FIRST+0x74>
f010b9ea:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010b9ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b9f0:	8b 40 2c             	mov    0x2c(%eax),%eax
f010b9f3:	0f b7 c0             	movzwl %ax,%eax
f010b9f6:	39 c2                	cmp    %eax,%edx
f010b9f8:	72 d5                	jb     f010b9cf <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010b9fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b9fd:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010ba00:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ba03:	8b 40 2c             	mov    0x2c(%eax),%eax
f010ba06:	0f b7 c0             	movzwl %ax,%eax
f010ba09:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010ba0c:	7e 68                	jle    f010ba76 <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010ba0e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ba11:	c1 e0 05             	shl    $0x5,%eax
f010ba14:	89 c2                	mov    %eax,%edx
f010ba16:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ba19:	01 d0                	add    %edx,%eax
f010ba1b:	8b 50 04             	mov    0x4(%eax),%edx
f010ba1e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ba21:	01 d0                	add    %edx,%eax
f010ba23:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010ba26:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ba29:	c1 e0 05             	shl    $0x5,%eax
f010ba2c:	89 c2                	mov    %eax,%edx
f010ba2e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ba31:	01 d0                	add    %edx,%eax
f010ba33:	8b 40 14             	mov    0x14(%eax),%eax
f010ba36:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010ba39:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ba3c:	c1 e0 05             	shl    $0x5,%eax
f010ba3f:	89 c2                	mov    %eax,%edx
f010ba41:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ba44:	01 d0                	add    %edx,%eax
f010ba46:	8b 40 10             	mov    0x10(%eax),%eax
f010ba49:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010ba4c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ba4f:	c1 e0 05             	shl    $0x5,%eax
f010ba52:	89 c2                	mov    %eax,%edx
f010ba54:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ba57:	01 d0                	add    %edx,%eax
f010ba59:	8b 40 08             	mov    0x8(%eax),%eax
f010ba5c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010ba5f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba62:	89 c3                	mov    %eax,%ebx
f010ba64:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010ba67:	ba 05 00 00 00       	mov    $0x5,%edx
f010ba6c:	89 df                	mov    %ebx,%edi
f010ba6e:	89 c6                	mov    %eax,%esi
f010ba70:	89 d1                	mov    %edx,%ecx
f010ba72:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010ba74:	eb 1c                	jmp    f010ba92 <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010ba76:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010ba7d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba80:	89 c3                	mov    %eax,%ebx
f010ba82:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010ba85:	ba 05 00 00 00       	mov    $0x5,%edx
f010ba8a:	89 df                	mov    %ebx,%edi
f010ba8c:	89 c6                	mov    %eax,%esi
f010ba8e:	89 d1                	mov    %edx,%ecx
f010ba90:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010ba92:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba95:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010ba98:	5b                   	pop    %ebx
f010ba99:	5e                   	pop    %esi
f010ba9a:	5f                   	pop    %edi
f010ba9b:	5d                   	pop    %ebp
f010ba9c:	c2 04 00             	ret    $0x4

f010ba9f <cleanup_buffers>:

//===============================================================================
// 13) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010ba9f:	55                   	push   %ebp
f010baa0:	89 e5                	mov    %esp,%ebp
f010baa2:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010baa5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
f010baac:	83 ec 0c             	sub    $0xc,%esp
f010baaf:	68 40 25 55 f0       	push   $0xf0552540
f010bab4:	e8 e5 2c 00 00       	call   f010e79e <acquire_spinlock>
f010bab9:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010babc:	a1 30 25 55 f0       	mov    0xf0552530,%eax
f010bac1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010bac4:	e9 c3 00 00 00       	jmp    f010bb8c <cleanup_buffers+0xed>
		{
			if(ptr_fi->proc == e)
f010bac9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bacc:	8b 40 0c             	mov    0xc(%eax),%eax
f010bacf:	3b 45 08             	cmp    0x8(%ebp),%eax
f010bad2:	0f 85 ac 00 00 00    	jne    f010bb84 <cleanup_buffers+0xe5>
			{
				pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->bufferedVA);
f010bad8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010badb:	8b 50 10             	mov    0x10(%eax),%edx
f010bade:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bae1:	8b 40 0c             	mov    0xc(%eax),%eax
f010bae4:	8b 40 64             	mov    0x64(%eax),%eax
f010bae7:	83 ec 08             	sub    $0x8,%esp
f010baea:	52                   	push   %edx
f010baeb:	50                   	push   %eax
f010baec:	e8 62 ce ff ff       	call   f0108953 <pt_clear_page_table_entry>
f010baf1:	83 c4 10             	add    $0x10,%esp

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010baf4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010baf8:	75 17                	jne    f010bb11 <cleanup_buffers+0x72>
f010bafa:	83 ec 04             	sub    $0x4,%esp
f010bafd:	68 c1 54 12 f0       	push   $0xf01254c1
f010bb02:	68 b1 04 00 00       	push   $0x4b1
f010bb07:	68 2f 54 12 f0       	push   $0xf012542f
f010bb0c:	e8 09 48 ff ff       	call   f010031a <_panic>
f010bb11:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb14:	8b 00                	mov    (%eax),%eax
f010bb16:	85 c0                	test   %eax,%eax
f010bb18:	74 10                	je     f010bb2a <cleanup_buffers+0x8b>
f010bb1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb1d:	8b 00                	mov    (%eax),%eax
f010bb1f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bb22:	8b 52 04             	mov    0x4(%edx),%edx
f010bb25:	89 50 04             	mov    %edx,0x4(%eax)
f010bb28:	eb 0b                	jmp    f010bb35 <cleanup_buffers+0x96>
f010bb2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb2d:	8b 40 04             	mov    0x4(%eax),%eax
f010bb30:	a3 34 25 55 f0       	mov    %eax,0xf0552534
f010bb35:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb38:	8b 40 04             	mov    0x4(%eax),%eax
f010bb3b:	85 c0                	test   %eax,%eax
f010bb3d:	74 0f                	je     f010bb4e <cleanup_buffers+0xaf>
f010bb3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb42:	8b 40 04             	mov    0x4(%eax),%eax
f010bb45:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bb48:	8b 12                	mov    (%edx),%edx
f010bb4a:	89 10                	mov    %edx,(%eax)
f010bb4c:	eb 0a                	jmp    f010bb58 <cleanup_buffers+0xb9>
f010bb4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb51:	8b 00                	mov    (%eax),%eax
f010bb53:	a3 30 25 55 f0       	mov    %eax,0xf0552530
f010bb58:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb5b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010bb61:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb64:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010bb6b:	a1 3c 25 55 f0       	mov    0xf055253c,%eax
f010bb70:	48                   	dec    %eax
f010bb71:	a3 3c 25 55 f0       	mov    %eax,0xf055253c

				free_frame(ptr_fi);
f010bb76:	83 ec 0c             	sub    $0xc,%esp
f010bb79:	ff 75 f4             	pushl  -0xc(%ebp)
f010bb7c:	e8 c1 c4 ff ff       	call   f0108042 <free_frame>
f010bb81:	83 c4 10             	add    $0x10,%esp
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010bb84:	a1 38 25 55 f0       	mov    0xf0552538,%eax
f010bb89:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010bb8c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bb90:	74 07                	je     f010bb99 <cleanup_buffers+0xfa>
f010bb92:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb95:	8b 00                	mov    (%eax),%eax
f010bb97:	eb 05                	jmp    f010bb9e <cleanup_buffers+0xff>
f010bb99:	b8 00 00 00 00       	mov    $0x0,%eax
f010bb9e:	a3 38 25 55 f0       	mov    %eax,0xf0552538
f010bba3:	a1 38 25 55 f0       	mov    0xf0552538,%eax
f010bba8:	85 c0                	test   %eax,%eax
f010bbaa:	0f 85 19 ff ff ff    	jne    f010bac9 <cleanup_buffers+0x2a>
f010bbb0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bbb4:	0f 85 0f ff ff ff    	jne    f010bac9 <cleanup_buffers+0x2a>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010bbba:	83 ec 0c             	sub    $0xc,%esp
f010bbbd:	68 40 25 55 f0       	push   $0xf0552540
f010bbc2:	e8 5e 2c 00 00       	call   f010e825 <release_spinlock>
f010bbc7:	83 c4 10             	add    $0x10,%esp

	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010bbca:	90                   	nop
f010bbcb:	c9                   	leave  
f010bbcc:	c3                   	ret    

f010bbcd <set_program_priority>:
#include "../disk/pagefile_manager.h"
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"

void set_program_priority(struct Env* env, int priority)
{
f010bbcd:	55                   	push   %ebp
f010bbce:	89 e5                	mov    %esp,%ebp
f010bbd0:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010bbd3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010bbd7:	7e 06                	jle    f010bbdf <set_program_priority+0x12>
f010bbd9:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010bbdd:	7e 14                	jle    f010bbf3 <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010bbdf:	83 ec 04             	sub    $0x4,%esp
f010bbe2:	68 68 57 12 f0       	push   $0xf0125768
f010bbe7:	6a 10                	push   $0x10
f010bbe9:	68 8c 57 12 f0       	push   $0xf012578c
f010bbee:	e8 27 47 ff ff       	call   f010031a <_panic>
		return;
	}
	if(env == NULL)
f010bbf3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bbf7:	74 78                	je     f010bc71 <set_program_priority+0xa4>
		return;
	switch(priority)
f010bbf9:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010bbfd:	77 56                	ja     f010bc55 <set_program_priority+0x88>
f010bbff:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bc02:	c1 e0 02             	shl    $0x2,%eax
f010bc05:	05 c8 57 12 f0       	add    $0xf01257c8,%eax
f010bc0a:	8b 00                	mov    (%eax),%eax
f010bc0c:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010bc0e:	83 ec 08             	sub    $0x8,%esp
f010bc11:	6a 01                	push   $0x1
f010bc13:	ff 75 08             	pushl  0x8(%ebp)
f010bc16:	e8 b6 d7 ff ff       	call   f01093d1 <half_WS_Size>
f010bc1b:	83 c4 10             	add    $0x10,%esp
			break;
f010bc1e:	eb 35                	jmp    f010bc55 <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010bc20:	83 ec 08             	sub    $0x8,%esp
f010bc23:	6a 00                	push   $0x0
f010bc25:	ff 75 08             	pushl  0x8(%ebp)
f010bc28:	e8 a4 d7 ff ff       	call   f01093d1 <half_WS_Size>
f010bc2d:	83 c4 10             	add    $0x10,%esp
			break;
f010bc30:	eb 23                	jmp    f010bc55 <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010bc32:	83 ec 08             	sub    $0x8,%esp
f010bc35:	6a 01                	push   $0x1
f010bc37:	ff 75 08             	pushl  0x8(%ebp)
f010bc3a:	e8 75 d7 ff ff       	call   f01093b4 <double_WS_Size>
f010bc3f:	83 c4 10             	add    $0x10,%esp
			break;
f010bc42:	eb 11                	jmp    f010bc55 <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010bc44:	83 ec 08             	sub    $0x8,%esp
f010bc47:	6a 00                	push   $0x0
f010bc49:	ff 75 08             	pushl  0x8(%ebp)
f010bc4c:	e8 63 d7 ff ff       	call   f01093b4 <double_WS_Size>
f010bc51:	83 c4 10             	add    $0x10,%esp
			break;
f010bc54:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010bc55:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc58:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010bc5e:	83 ec 08             	sub    $0x8,%esp
f010bc61:	50                   	push   %eax
f010bc62:	68 a9 57 12 f0       	push   $0xf01257a9
f010bc67:	e8 00 53 ff ff       	call   f0100f6c <cprintf>
f010bc6c:	83 c4 10             	add    $0x10,%esp
f010bc6f:	eb 01                	jmp    f010bc72 <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010bc71:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010bc72:	c9                   	leave  
f010bc73:	c3                   	ret    

f010bc74 <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010bc74:	55                   	push   %ebp
f010bc75:	89 e5                	mov    %esp,%ebp
f010bc77:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bc7a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010bc81:	eb 29                	jmp    f010bcac <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010bc83:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bc86:	89 d0                	mov    %edx,%eax
f010bc88:	01 c0                	add    %eax,%eax
f010bc8a:	01 d0                	add    %edx,%eax
f010bc8c:	c1 e0 02             	shl    $0x2,%eax
f010bc8f:	05 80 99 17 f0       	add    $0xf0179980,%eax
f010bc94:	8b 00                	mov    (%eax),%eax
f010bc96:	83 ec 08             	sub    $0x8,%esp
f010bc99:	50                   	push   %eax
f010bc9a:	ff 75 08             	pushl  0x8(%ebp)
f010bc9d:	e8 bb 49 01 00       	call   f012065d <strcmp>
f010bca2:	83 c4 10             	add    $0x10,%esp
f010bca5:	85 c0                	test   %eax,%eax
f010bca7:	74 0f                	je     f010bcb8 <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bca9:	ff 45 f4             	incl   -0xc(%ebp)
f010bcac:	a1 a8 9c 17 f0       	mov    0xf0179ca8,%eax
f010bcb1:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bcb4:	7c cd                	jl     f010bc83 <get_user_program_info+0xf>
f010bcb6:	eb 01                	jmp    f010bcb9 <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010bcb8:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010bcb9:	a1 a8 9c 17 f0       	mov    0xf0179ca8,%eax
f010bcbe:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bcc1:	75 1a                	jne    f010bcdd <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010bcc3:	83 ec 08             	sub    $0x8,%esp
f010bcc6:	ff 75 08             	pushl  0x8(%ebp)
f010bcc9:	68 31 64 12 f0       	push   $0xf0126431
f010bcce:	e8 99 52 ff ff       	call   f0100f6c <cprintf>
f010bcd3:	83 c4 10             	add    $0x10,%esp
		return 0;
f010bcd6:	b8 00 00 00 00       	mov    $0x0,%eax
f010bcdb:	eb 11                	jmp    f010bcee <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010bcdd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bce0:	89 d0                	mov    %edx,%eax
f010bce2:	01 c0                	add    %eax,%eax
f010bce4:	01 d0                	add    %edx,%eax
f010bce6:	c1 e0 02             	shl    $0x2,%eax
f010bce9:	05 80 99 17 f0       	add    $0xf0179980,%eax
}
f010bcee:	c9                   	leave  
f010bcef:	c3                   	ret    

f010bcf0 <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010bcf0:	55                   	push   %ebp
f010bcf1:	89 e5                	mov    %esp,%ebp
f010bcf3:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bcf6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010bcfd:	eb 2d                	jmp    f010bd2c <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010bcff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd02:	89 d0                	mov    %edx,%eax
f010bd04:	01 c0                	add    %eax,%eax
f010bd06:	01 d0                	add    %edx,%eax
f010bd08:	c1 e0 02             	shl    $0x2,%eax
f010bd0b:	05 80 99 17 f0       	add    $0xf0179980,%eax
f010bd10:	8b 00                	mov    (%eax),%eax
f010bd12:	8b 55 08             	mov    0x8(%ebp),%edx
f010bd15:	83 c2 20             	add    $0x20,%edx
f010bd18:	83 ec 08             	sub    $0x8,%esp
f010bd1b:	50                   	push   %eax
f010bd1c:	52                   	push   %edx
f010bd1d:	e8 3b 49 01 00       	call   f012065d <strcmp>
f010bd22:	83 c4 10             	add    $0x10,%esp
f010bd25:	85 c0                	test   %eax,%eax
f010bd27:	74 0f                	je     f010bd38 <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bd29:	ff 45 f4             	incl   -0xc(%ebp)
f010bd2c:	a1 a8 9c 17 f0       	mov    0xf0179ca8,%eax
f010bd31:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bd34:	7c c9                	jl     f010bcff <get_user_program_info_by_env+0xf>
f010bd36:	eb 01                	jmp    f010bd39 <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010bd38:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010bd39:	a1 a8 9c 17 f0       	mov    0xf0179ca8,%eax
f010bd3e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bd41:	75 17                	jne    f010bd5a <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010bd43:	83 ec 0c             	sub    $0xc,%esp
f010bd46:	68 4c 64 12 f0       	push   $0xf012644c
f010bd4b:	e8 1c 52 ff ff       	call   f0100f6c <cprintf>
f010bd50:	83 c4 10             	add    $0x10,%esp
		return 0;
f010bd53:	b8 00 00 00 00       	mov    $0x0,%eax
f010bd58:	eb 11                	jmp    f010bd6b <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010bd5a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd5d:	89 d0                	mov    %edx,%eax
f010bd5f:	01 c0                	add    %eax,%eax
f010bd61:	01 d0                	add    %edx,%eax
f010bd63:	c1 e0 02             	shl    $0x2,%eax
f010bd66:	05 80 99 17 f0       	add    $0xf0179980,%eax
}
f010bd6b:	c9                   	leave  
f010bd6c:	c3                   	ret    

f010bd6d <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010bd6d:	55                   	push   %ebp
f010bd6e:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010bd70:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd73:	83 f8 13             	cmp    $0x13,%eax
f010bd76:	77 0c                	ja     f010bd84 <trapname+0x17>
		return excnames[trapno];
f010bd78:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd7b:	8b 04 85 40 68 12 f0 	mov    -0xfed97c0(,%eax,4),%eax
f010bd82:	eb 2c                	jmp    f010bdb0 <trapname+0x43>
	if (trapno == T_SYSCALL)
f010bd84:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010bd88:	75 07                	jne    f010bd91 <trapname+0x24>
		return "System call";
f010bd8a:	b8 80 64 12 f0       	mov    $0xf0126480,%eax
f010bd8f:	eb 1f                	jmp    f010bdb0 <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010bd91:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010bd95:	75 07                	jne    f010bd9e <trapname+0x31>
		return "Clock Interrupt";
f010bd97:	b8 8c 64 12 f0       	mov    $0xf012648c,%eax
f010bd9c:	eb 12                	jmp    f010bdb0 <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010bd9e:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010bda2:	75 07                	jne    f010bdab <trapname+0x3e>
		return "Keyboard Interrupt";
f010bda4:	b8 9c 64 12 f0       	mov    $0xf012649c,%eax
f010bda9:	eb 05                	jmp    f010bdb0 <trapname+0x43>
	return "(unknown trap)";
f010bdab:	b8 af 64 12 f0       	mov    $0xf01264af,%eax
}
f010bdb0:	5d                   	pop    %ebp
f010bdb1:	c3                   	ret    

f010bdb2 <ts_init>:


void ts_init(void)
{
f010bdb2:	55                   	push   %ebp
f010bdb3:	89 e5                	mov    %esp,%ebp
f010bdb5:	53                   	push   %ebx
f010bdb6:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010bdb9:	e8 20 b1 ff ff       	call   f0106ede <pushcli>

	struct cpu* c = mycpu();
f010bdbe:	e8 58 b0 ff ff       	call   f0106e1b <mycpu>
f010bdc3:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010bdc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdc9:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010bdd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdd3:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010bdd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bddc:	83 c0 0c             	add    $0xc,%eax
f010bddf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bde2:	83 c2 0c             	add    $0xc,%edx
f010bde5:	c1 ea 10             	shr    $0x10,%edx
f010bde8:	88 d3                	mov    %dl,%bl
f010bdea:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bded:	83 c2 0c             	add    $0xc,%edx
f010bdf0:	c1 ea 18             	shr    $0x18,%edx
f010bdf3:	88 d1                	mov    %dl,%cl
f010bdf5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bdf8:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010bdff:	68 00 
f010be01:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010be04:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010be0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be0e:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010be14:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be17:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be1d:	83 e2 f0             	and    $0xfffffff0,%edx
f010be20:	83 ca 09             	or     $0x9,%edx
f010be23:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010be29:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be2c:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be32:	83 ca 10             	or     $0x10,%edx
f010be35:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010be3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be3e:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be44:	83 e2 9f             	and    $0xffffff9f,%edx
f010be47:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010be4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be50:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be56:	83 ca 80             	or     $0xffffff80,%edx
f010be59:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010be5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be62:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be68:	83 e2 f0             	and    $0xfffffff0,%edx
f010be6b:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be71:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be74:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be7a:	83 e2 ef             	and    $0xffffffef,%edx
f010be7d:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be83:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be86:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be8c:	83 e2 df             	and    $0xffffffdf,%edx
f010be8f:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be95:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be98:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be9e:	83 ca 40             	or     $0x40,%edx
f010bea1:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bea7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010beaa:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010beb0:	83 e2 7f             	and    $0x7f,%edx
f010beb3:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010beb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bebc:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010bec2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bec5:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010becb:	83 e2 ef             	and    $0xffffffef,%edx
f010bece:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010bed4:	e8 57 b0 ff ff       	call   f0106f30 <popcli>
f010bed9:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010bedf:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010bee3:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010bee6:	90                   	nop
f010bee7:	83 c4 14             	add    $0x14,%esp
f010beea:	5b                   	pop    %ebx
f010beeb:	5d                   	pop    %ebp
f010beec:	c3                   	ret    

f010beed <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010beed:	55                   	push   %ebp
f010beee:	89 e5                	mov    %esp,%ebp
f010bef0:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010bef3:	b8 9c d3 10 f0       	mov    $0xf010d39c,%eax
f010bef8:	66 a3 80 1a 55 f0    	mov    %ax,0xf0551a80
f010befe:	66 c7 05 82 1a 55 f0 	movw   $0x8,0xf0551a82
f010bf05:	08 00 
f010bf07:	a0 84 1a 55 f0       	mov    0xf0551a84,%al
f010bf0c:	83 e0 e0             	and    $0xffffffe0,%eax
f010bf0f:	a2 84 1a 55 f0       	mov    %al,0xf0551a84
f010bf14:	a0 84 1a 55 f0       	mov    0xf0551a84,%al
f010bf19:	83 e0 1f             	and    $0x1f,%eax
f010bf1c:	a2 84 1a 55 f0       	mov    %al,0xf0551a84
f010bf21:	a0 85 1a 55 f0       	mov    0xf0551a85,%al
f010bf26:	83 e0 f0             	and    $0xfffffff0,%eax
f010bf29:	83 c8 0e             	or     $0xe,%eax
f010bf2c:	a2 85 1a 55 f0       	mov    %al,0xf0551a85
f010bf31:	a0 85 1a 55 f0       	mov    0xf0551a85,%al
f010bf36:	83 e0 ef             	and    $0xffffffef,%eax
f010bf39:	a2 85 1a 55 f0       	mov    %al,0xf0551a85
f010bf3e:	a0 85 1a 55 f0       	mov    0xf0551a85,%al
f010bf43:	83 e0 9f             	and    $0xffffff9f,%eax
f010bf46:	a2 85 1a 55 f0       	mov    %al,0xf0551a85
f010bf4b:	a0 85 1a 55 f0       	mov    0xf0551a85,%al
f010bf50:	83 c8 80             	or     $0xffffff80,%eax
f010bf53:	a2 85 1a 55 f0       	mov    %al,0xf0551a85
f010bf58:	b8 9c d3 10 f0       	mov    $0xf010d39c,%eax
f010bf5d:	c1 e8 10             	shr    $0x10,%eax
f010bf60:	66 a3 86 1a 55 f0    	mov    %ax,0xf0551a86
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010bf66:	b8 a4 d3 10 f0       	mov    $0xf010d3a4,%eax
f010bf6b:	66 a3 b0 1a 55 f0    	mov    %ax,0xf0551ab0
f010bf71:	66 c7 05 b2 1a 55 f0 	movw   $0x8,0xf0551ab2
f010bf78:	08 00 
f010bf7a:	a0 b4 1a 55 f0       	mov    0xf0551ab4,%al
f010bf7f:	83 e0 e0             	and    $0xffffffe0,%eax
f010bf82:	a2 b4 1a 55 f0       	mov    %al,0xf0551ab4
f010bf87:	a0 b4 1a 55 f0       	mov    0xf0551ab4,%al
f010bf8c:	83 e0 1f             	and    $0x1f,%eax
f010bf8f:	a2 b4 1a 55 f0       	mov    %al,0xf0551ab4
f010bf94:	a0 b5 1a 55 f0       	mov    0xf0551ab5,%al
f010bf99:	83 e0 f0             	and    $0xfffffff0,%eax
f010bf9c:	83 c8 0e             	or     $0xe,%eax
f010bf9f:	a2 b5 1a 55 f0       	mov    %al,0xf0551ab5
f010bfa4:	a0 b5 1a 55 f0       	mov    0xf0551ab5,%al
f010bfa9:	83 e0 ef             	and    $0xffffffef,%eax
f010bfac:	a2 b5 1a 55 f0       	mov    %al,0xf0551ab5
f010bfb1:	a0 b5 1a 55 f0       	mov    0xf0551ab5,%al
f010bfb6:	83 e0 9f             	and    $0xffffff9f,%eax
f010bfb9:	a2 b5 1a 55 f0       	mov    %al,0xf0551ab5
f010bfbe:	a0 b5 1a 55 f0       	mov    0xf0551ab5,%al
f010bfc3:	83 c8 80             	or     $0xffffff80,%eax
f010bfc6:	a2 b5 1a 55 f0       	mov    %al,0xf0551ab5
f010bfcb:	b8 a4 d3 10 f0       	mov    $0xf010d3a4,%eax
f010bfd0:	c1 e8 10             	shr    $0x10,%eax
f010bfd3:	66 a3 b6 1a 55 f0    	mov    %ax,0xf0551ab6
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010bfd9:	b8 ac d3 10 f0       	mov    $0xf010d3ac,%eax
f010bfde:	66 a3 40 1b 55 f0    	mov    %ax,0xf0551b40
f010bfe4:	66 c7 05 42 1b 55 f0 	movw   $0x8,0xf0551b42
f010bfeb:	08 00 
f010bfed:	a0 44 1b 55 f0       	mov    0xf0551b44,%al
f010bff2:	83 e0 e0             	and    $0xffffffe0,%eax
f010bff5:	a2 44 1b 55 f0       	mov    %al,0xf0551b44
f010bffa:	a0 44 1b 55 f0       	mov    0xf0551b44,%al
f010bfff:	83 e0 1f             	and    $0x1f,%eax
f010c002:	a2 44 1b 55 f0       	mov    %al,0xf0551b44
f010c007:	a0 45 1b 55 f0       	mov    0xf0551b45,%al
f010c00c:	83 e0 f0             	and    $0xfffffff0,%eax
f010c00f:	83 c8 0e             	or     $0xe,%eax
f010c012:	a2 45 1b 55 f0       	mov    %al,0xf0551b45
f010c017:	a0 45 1b 55 f0       	mov    0xf0551b45,%al
f010c01c:	83 e0 ef             	and    $0xffffffef,%eax
f010c01f:	a2 45 1b 55 f0       	mov    %al,0xf0551b45
f010c024:	a0 45 1b 55 f0       	mov    0xf0551b45,%al
f010c029:	83 c8 60             	or     $0x60,%eax
f010c02c:	a2 45 1b 55 f0       	mov    %al,0xf0551b45
f010c031:	a0 45 1b 55 f0       	mov    0xf0551b45,%al
f010c036:	83 c8 80             	or     $0xffffff80,%eax
f010c039:	a2 45 1b 55 f0       	mov    %al,0xf0551b45
f010c03e:	b8 ac d3 10 f0       	mov    $0xf010d3ac,%eax
f010c043:	c1 e8 10             	shr    $0x10,%eax
f010c046:	66 a3 46 1b 55 f0    	mov    %ax,0xf0551b46
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010c04c:	b8 b6 d3 10 f0       	mov    $0xf010d3b6,%eax
f010c051:	66 a3 48 1b 55 f0    	mov    %ax,0xf0551b48
f010c057:	66 c7 05 4a 1b 55 f0 	movw   $0x8,0xf0551b4a
f010c05e:	08 00 
f010c060:	a0 4c 1b 55 f0       	mov    0xf0551b4c,%al
f010c065:	83 e0 e0             	and    $0xffffffe0,%eax
f010c068:	a2 4c 1b 55 f0       	mov    %al,0xf0551b4c
f010c06d:	a0 4c 1b 55 f0       	mov    0xf0551b4c,%al
f010c072:	83 e0 1f             	and    $0x1f,%eax
f010c075:	a2 4c 1b 55 f0       	mov    %al,0xf0551b4c
f010c07a:	a0 4d 1b 55 f0       	mov    0xf0551b4d,%al
f010c07f:	83 e0 f0             	and    $0xfffffff0,%eax
f010c082:	83 c8 0e             	or     $0xe,%eax
f010c085:	a2 4d 1b 55 f0       	mov    %al,0xf0551b4d
f010c08a:	a0 4d 1b 55 f0       	mov    0xf0551b4d,%al
f010c08f:	83 e0 ef             	and    $0xffffffef,%eax
f010c092:	a2 4d 1b 55 f0       	mov    %al,0xf0551b4d
f010c097:	a0 4d 1b 55 f0       	mov    0xf0551b4d,%al
f010c09c:	83 c8 60             	or     $0x60,%eax
f010c09f:	a2 4d 1b 55 f0       	mov    %al,0xf0551b4d
f010c0a4:	a0 4d 1b 55 f0       	mov    0xf0551b4d,%al
f010c0a9:	83 c8 80             	or     $0xffffff80,%eax
f010c0ac:	a2 4d 1b 55 f0       	mov    %al,0xf0551b4d
f010c0b1:	b8 b6 d3 10 f0       	mov    $0xf010d3b6,%eax
f010c0b6:	c1 e8 10             	shr    $0x10,%eax
f010c0b9:	66 a3 4e 1b 55 f0    	mov    %ax,0xf0551b4e
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010c0bf:	b8 c0 d3 10 f0       	mov    $0xf010d3c0,%eax
f010c0c4:	66 a3 c0 1b 55 f0    	mov    %ax,0xf0551bc0
f010c0ca:	66 c7 05 c2 1b 55 f0 	movw   $0x8,0xf0551bc2
f010c0d1:	08 00 
f010c0d3:	a0 c4 1b 55 f0       	mov    0xf0551bc4,%al
f010c0d8:	83 e0 e0             	and    $0xffffffe0,%eax
f010c0db:	a2 c4 1b 55 f0       	mov    %al,0xf0551bc4
f010c0e0:	a0 c4 1b 55 f0       	mov    0xf0551bc4,%al
f010c0e5:	83 e0 1f             	and    $0x1f,%eax
f010c0e8:	a2 c4 1b 55 f0       	mov    %al,0xf0551bc4
f010c0ed:	a0 c5 1b 55 f0       	mov    0xf0551bc5,%al
f010c0f2:	83 e0 f0             	and    $0xfffffff0,%eax
f010c0f5:	83 c8 0e             	or     $0xe,%eax
f010c0f8:	a2 c5 1b 55 f0       	mov    %al,0xf0551bc5
f010c0fd:	a0 c5 1b 55 f0       	mov    0xf0551bc5,%al
f010c102:	83 e0 ef             	and    $0xffffffef,%eax
f010c105:	a2 c5 1b 55 f0       	mov    %al,0xf0551bc5
f010c10a:	a0 c5 1b 55 f0       	mov    0xf0551bc5,%al
f010c10f:	83 c8 60             	or     $0x60,%eax
f010c112:	a2 c5 1b 55 f0       	mov    %al,0xf0551bc5
f010c117:	a0 c5 1b 55 f0       	mov    0xf0551bc5,%al
f010c11c:	83 c8 80             	or     $0xffffff80,%eax
f010c11f:	a2 c5 1b 55 f0       	mov    %al,0xf0551bc5
f010c124:	b8 c0 d3 10 f0       	mov    $0xf010d3c0,%eax
f010c129:	c1 e8 10             	shr    $0x10,%eax
f010c12c:	66 a3 c6 1b 55 f0    	mov    %ax,0xf0551bc6

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010c132:	b8 ca d3 10 f0       	mov    $0xf010d3ca,%eax
f010c137:	66 a3 40 1a 55 f0    	mov    %ax,0xf0551a40
f010c13d:	66 c7 05 42 1a 55 f0 	movw   $0x8,0xf0551a42
f010c144:	08 00 
f010c146:	a0 44 1a 55 f0       	mov    0xf0551a44,%al
f010c14b:	83 e0 e0             	and    $0xffffffe0,%eax
f010c14e:	a2 44 1a 55 f0       	mov    %al,0xf0551a44
f010c153:	a0 44 1a 55 f0       	mov    0xf0551a44,%al
f010c158:	83 e0 1f             	and    $0x1f,%eax
f010c15b:	a2 44 1a 55 f0       	mov    %al,0xf0551a44
f010c160:	a0 45 1a 55 f0       	mov    0xf0551a45,%al
f010c165:	83 e0 f0             	and    $0xfffffff0,%eax
f010c168:	83 c8 0e             	or     $0xe,%eax
f010c16b:	a2 45 1a 55 f0       	mov    %al,0xf0551a45
f010c170:	a0 45 1a 55 f0       	mov    0xf0551a45,%al
f010c175:	83 e0 ef             	and    $0xffffffef,%eax
f010c178:	a2 45 1a 55 f0       	mov    %al,0xf0551a45
f010c17d:	a0 45 1a 55 f0       	mov    0xf0551a45,%al
f010c182:	83 c8 60             	or     $0x60,%eax
f010c185:	a2 45 1a 55 f0       	mov    %al,0xf0551a45
f010c18a:	a0 45 1a 55 f0       	mov    0xf0551a45,%al
f010c18f:	83 c8 80             	or     $0xffffff80,%eax
f010c192:	a2 45 1a 55 f0       	mov    %al,0xf0551a45
f010c197:	b8 ca d3 10 f0       	mov    $0xf010d3ca,%eax
f010c19c:	c1 e8 10             	shr    $0x10,%eax
f010c19f:	66 a3 46 1a 55 f0    	mov    %ax,0xf0551a46
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010c1a5:	b8 d4 d3 10 f0       	mov    $0xf010d3d4,%eax
f010c1aa:	66 a3 48 1a 55 f0    	mov    %ax,0xf0551a48
f010c1b0:	66 c7 05 4a 1a 55 f0 	movw   $0x8,0xf0551a4a
f010c1b7:	08 00 
f010c1b9:	a0 4c 1a 55 f0       	mov    0xf0551a4c,%al
f010c1be:	83 e0 e0             	and    $0xffffffe0,%eax
f010c1c1:	a2 4c 1a 55 f0       	mov    %al,0xf0551a4c
f010c1c6:	a0 4c 1a 55 f0       	mov    0xf0551a4c,%al
f010c1cb:	83 e0 1f             	and    $0x1f,%eax
f010c1ce:	a2 4c 1a 55 f0       	mov    %al,0xf0551a4c
f010c1d3:	a0 4d 1a 55 f0       	mov    0xf0551a4d,%al
f010c1d8:	83 c8 0f             	or     $0xf,%eax
f010c1db:	a2 4d 1a 55 f0       	mov    %al,0xf0551a4d
f010c1e0:	a0 4d 1a 55 f0       	mov    0xf0551a4d,%al
f010c1e5:	83 e0 ef             	and    $0xffffffef,%eax
f010c1e8:	a2 4d 1a 55 f0       	mov    %al,0xf0551a4d
f010c1ed:	a0 4d 1a 55 f0       	mov    0xf0551a4d,%al
f010c1f2:	83 c8 60             	or     $0x60,%eax
f010c1f5:	a2 4d 1a 55 f0       	mov    %al,0xf0551a4d
f010c1fa:	a0 4d 1a 55 f0       	mov    0xf0551a4d,%al
f010c1ff:	83 c8 80             	or     $0xffffff80,%eax
f010c202:	a2 4d 1a 55 f0       	mov    %al,0xf0551a4d
f010c207:	b8 d4 d3 10 f0       	mov    $0xf010d3d4,%eax
f010c20c:	c1 e8 10             	shr    $0x10,%eax
f010c20f:	66 a3 4e 1a 55 f0    	mov    %ax,0xf0551a4e
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010c215:	b8 de d3 10 f0       	mov    $0xf010d3de,%eax
f010c21a:	66 a3 50 1a 55 f0    	mov    %ax,0xf0551a50
f010c220:	66 c7 05 52 1a 55 f0 	movw   $0x8,0xf0551a52
f010c227:	08 00 
f010c229:	a0 54 1a 55 f0       	mov    0xf0551a54,%al
f010c22e:	83 e0 e0             	and    $0xffffffe0,%eax
f010c231:	a2 54 1a 55 f0       	mov    %al,0xf0551a54
f010c236:	a0 54 1a 55 f0       	mov    0xf0551a54,%al
f010c23b:	83 e0 1f             	and    $0x1f,%eax
f010c23e:	a2 54 1a 55 f0       	mov    %al,0xf0551a54
f010c243:	a0 55 1a 55 f0       	mov    0xf0551a55,%al
f010c248:	83 e0 f0             	and    $0xfffffff0,%eax
f010c24b:	83 c8 0e             	or     $0xe,%eax
f010c24e:	a2 55 1a 55 f0       	mov    %al,0xf0551a55
f010c253:	a0 55 1a 55 f0       	mov    0xf0551a55,%al
f010c258:	83 e0 ef             	and    $0xffffffef,%eax
f010c25b:	a2 55 1a 55 f0       	mov    %al,0xf0551a55
f010c260:	a0 55 1a 55 f0       	mov    0xf0551a55,%al
f010c265:	83 c8 60             	or     $0x60,%eax
f010c268:	a2 55 1a 55 f0       	mov    %al,0xf0551a55
f010c26d:	a0 55 1a 55 f0       	mov    0xf0551a55,%al
f010c272:	83 c8 80             	or     $0xffffff80,%eax
f010c275:	a2 55 1a 55 f0       	mov    %al,0xf0551a55
f010c27a:	b8 de d3 10 f0       	mov    $0xf010d3de,%eax
f010c27f:	c1 e8 10             	shr    $0x10,%eax
f010c282:	66 a3 56 1a 55 f0    	mov    %ax,0xf0551a56
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010c288:	b8 e8 d3 10 f0       	mov    $0xf010d3e8,%eax
f010c28d:	66 a3 58 1a 55 f0    	mov    %ax,0xf0551a58
f010c293:	66 c7 05 5a 1a 55 f0 	movw   $0x8,0xf0551a5a
f010c29a:	08 00 
f010c29c:	a0 5c 1a 55 f0       	mov    0xf0551a5c,%al
f010c2a1:	83 e0 e0             	and    $0xffffffe0,%eax
f010c2a4:	a2 5c 1a 55 f0       	mov    %al,0xf0551a5c
f010c2a9:	a0 5c 1a 55 f0       	mov    0xf0551a5c,%al
f010c2ae:	83 e0 1f             	and    $0x1f,%eax
f010c2b1:	a2 5c 1a 55 f0       	mov    %al,0xf0551a5c
f010c2b6:	a0 5d 1a 55 f0       	mov    0xf0551a5d,%al
f010c2bb:	83 c8 0f             	or     $0xf,%eax
f010c2be:	a2 5d 1a 55 f0       	mov    %al,0xf0551a5d
f010c2c3:	a0 5d 1a 55 f0       	mov    0xf0551a5d,%al
f010c2c8:	83 e0 ef             	and    $0xffffffef,%eax
f010c2cb:	a2 5d 1a 55 f0       	mov    %al,0xf0551a5d
f010c2d0:	a0 5d 1a 55 f0       	mov    0xf0551a5d,%al
f010c2d5:	83 c8 60             	or     $0x60,%eax
f010c2d8:	a2 5d 1a 55 f0       	mov    %al,0xf0551a5d
f010c2dd:	a0 5d 1a 55 f0       	mov    0xf0551a5d,%al
f010c2e2:	83 c8 80             	or     $0xffffff80,%eax
f010c2e5:	a2 5d 1a 55 f0       	mov    %al,0xf0551a5d
f010c2ea:	b8 e8 d3 10 f0       	mov    $0xf010d3e8,%eax
f010c2ef:	c1 e8 10             	shr    $0x10,%eax
f010c2f2:	66 a3 5e 1a 55 f0    	mov    %ax,0xf0551a5e
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010c2f8:	b8 f2 d3 10 f0       	mov    $0xf010d3f2,%eax
f010c2fd:	66 a3 60 1a 55 f0    	mov    %ax,0xf0551a60
f010c303:	66 c7 05 62 1a 55 f0 	movw   $0x8,0xf0551a62
f010c30a:	08 00 
f010c30c:	a0 64 1a 55 f0       	mov    0xf0551a64,%al
f010c311:	83 e0 e0             	and    $0xffffffe0,%eax
f010c314:	a2 64 1a 55 f0       	mov    %al,0xf0551a64
f010c319:	a0 64 1a 55 f0       	mov    0xf0551a64,%al
f010c31e:	83 e0 1f             	and    $0x1f,%eax
f010c321:	a2 64 1a 55 f0       	mov    %al,0xf0551a64
f010c326:	a0 65 1a 55 f0       	mov    0xf0551a65,%al
f010c32b:	83 c8 0f             	or     $0xf,%eax
f010c32e:	a2 65 1a 55 f0       	mov    %al,0xf0551a65
f010c333:	a0 65 1a 55 f0       	mov    0xf0551a65,%al
f010c338:	83 e0 ef             	and    $0xffffffef,%eax
f010c33b:	a2 65 1a 55 f0       	mov    %al,0xf0551a65
f010c340:	a0 65 1a 55 f0       	mov    0xf0551a65,%al
f010c345:	83 c8 60             	or     $0x60,%eax
f010c348:	a2 65 1a 55 f0       	mov    %al,0xf0551a65
f010c34d:	a0 65 1a 55 f0       	mov    0xf0551a65,%al
f010c352:	83 c8 80             	or     $0xffffff80,%eax
f010c355:	a2 65 1a 55 f0       	mov    %al,0xf0551a65
f010c35a:	b8 f2 d3 10 f0       	mov    $0xf010d3f2,%eax
f010c35f:	c1 e8 10             	shr    $0x10,%eax
f010c362:	66 a3 66 1a 55 f0    	mov    %ax,0xf0551a66
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010c368:	b8 fc d3 10 f0       	mov    $0xf010d3fc,%eax
f010c36d:	66 a3 68 1a 55 f0    	mov    %ax,0xf0551a68
f010c373:	66 c7 05 6a 1a 55 f0 	movw   $0x8,0xf0551a6a
f010c37a:	08 00 
f010c37c:	a0 6c 1a 55 f0       	mov    0xf0551a6c,%al
f010c381:	83 e0 e0             	and    $0xffffffe0,%eax
f010c384:	a2 6c 1a 55 f0       	mov    %al,0xf0551a6c
f010c389:	a0 6c 1a 55 f0       	mov    0xf0551a6c,%al
f010c38e:	83 e0 1f             	and    $0x1f,%eax
f010c391:	a2 6c 1a 55 f0       	mov    %al,0xf0551a6c
f010c396:	a0 6d 1a 55 f0       	mov    0xf0551a6d,%al
f010c39b:	83 e0 f0             	and    $0xfffffff0,%eax
f010c39e:	83 c8 0e             	or     $0xe,%eax
f010c3a1:	a2 6d 1a 55 f0       	mov    %al,0xf0551a6d
f010c3a6:	a0 6d 1a 55 f0       	mov    0xf0551a6d,%al
f010c3ab:	83 e0 ef             	and    $0xffffffef,%eax
f010c3ae:	a2 6d 1a 55 f0       	mov    %al,0xf0551a6d
f010c3b3:	a0 6d 1a 55 f0       	mov    0xf0551a6d,%al
f010c3b8:	83 c8 60             	or     $0x60,%eax
f010c3bb:	a2 6d 1a 55 f0       	mov    %al,0xf0551a6d
f010c3c0:	a0 6d 1a 55 f0       	mov    0xf0551a6d,%al
f010c3c5:	83 c8 80             	or     $0xffffff80,%eax
f010c3c8:	a2 6d 1a 55 f0       	mov    %al,0xf0551a6d
f010c3cd:	b8 fc d3 10 f0       	mov    $0xf010d3fc,%eax
f010c3d2:	c1 e8 10             	shr    $0x10,%eax
f010c3d5:	66 a3 6e 1a 55 f0    	mov    %ax,0xf0551a6e
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010c3db:	b8 06 d4 10 f0       	mov    $0xf010d406,%eax
f010c3e0:	66 a3 70 1a 55 f0    	mov    %ax,0xf0551a70
f010c3e6:	66 c7 05 72 1a 55 f0 	movw   $0x8,0xf0551a72
f010c3ed:	08 00 
f010c3ef:	a0 74 1a 55 f0       	mov    0xf0551a74,%al
f010c3f4:	83 e0 e0             	and    $0xffffffe0,%eax
f010c3f7:	a2 74 1a 55 f0       	mov    %al,0xf0551a74
f010c3fc:	a0 74 1a 55 f0       	mov    0xf0551a74,%al
f010c401:	83 e0 1f             	and    $0x1f,%eax
f010c404:	a2 74 1a 55 f0       	mov    %al,0xf0551a74
f010c409:	a0 75 1a 55 f0       	mov    0xf0551a75,%al
f010c40e:	83 e0 f0             	and    $0xfffffff0,%eax
f010c411:	83 c8 0e             	or     $0xe,%eax
f010c414:	a2 75 1a 55 f0       	mov    %al,0xf0551a75
f010c419:	a0 75 1a 55 f0       	mov    0xf0551a75,%al
f010c41e:	83 e0 ef             	and    $0xffffffef,%eax
f010c421:	a2 75 1a 55 f0       	mov    %al,0xf0551a75
f010c426:	a0 75 1a 55 f0       	mov    0xf0551a75,%al
f010c42b:	83 c8 60             	or     $0x60,%eax
f010c42e:	a2 75 1a 55 f0       	mov    %al,0xf0551a75
f010c433:	a0 75 1a 55 f0       	mov    0xf0551a75,%al
f010c438:	83 c8 80             	or     $0xffffff80,%eax
f010c43b:	a2 75 1a 55 f0       	mov    %al,0xf0551a75
f010c440:	b8 06 d4 10 f0       	mov    $0xf010d406,%eax
f010c445:	c1 e8 10             	shr    $0x10,%eax
f010c448:	66 a3 76 1a 55 f0    	mov    %ax,0xf0551a76
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010c44e:	b8 10 d4 10 f0       	mov    $0xf010d410,%eax
f010c453:	66 a3 78 1a 55 f0    	mov    %ax,0xf0551a78
f010c459:	66 c7 05 7a 1a 55 f0 	movw   $0x8,0xf0551a7a
f010c460:	08 00 
f010c462:	a0 7c 1a 55 f0       	mov    0xf0551a7c,%al
f010c467:	83 e0 e0             	and    $0xffffffe0,%eax
f010c46a:	a2 7c 1a 55 f0       	mov    %al,0xf0551a7c
f010c46f:	a0 7c 1a 55 f0       	mov    0xf0551a7c,%al
f010c474:	83 e0 1f             	and    $0x1f,%eax
f010c477:	a2 7c 1a 55 f0       	mov    %al,0xf0551a7c
f010c47c:	a0 7d 1a 55 f0       	mov    0xf0551a7d,%al
f010c481:	83 e0 f0             	and    $0xfffffff0,%eax
f010c484:	83 c8 0e             	or     $0xe,%eax
f010c487:	a2 7d 1a 55 f0       	mov    %al,0xf0551a7d
f010c48c:	a0 7d 1a 55 f0       	mov    0xf0551a7d,%al
f010c491:	83 e0 ef             	and    $0xffffffef,%eax
f010c494:	a2 7d 1a 55 f0       	mov    %al,0xf0551a7d
f010c499:	a0 7d 1a 55 f0       	mov    0xf0551a7d,%al
f010c49e:	83 c8 60             	or     $0x60,%eax
f010c4a1:	a2 7d 1a 55 f0       	mov    %al,0xf0551a7d
f010c4a6:	a0 7d 1a 55 f0       	mov    0xf0551a7d,%al
f010c4ab:	83 c8 80             	or     $0xffffff80,%eax
f010c4ae:	a2 7d 1a 55 f0       	mov    %al,0xf0551a7d
f010c4b3:	b8 10 d4 10 f0       	mov    $0xf010d410,%eax
f010c4b8:	c1 e8 10             	shr    $0x10,%eax
f010c4bb:	66 a3 7e 1a 55 f0    	mov    %ax,0xf0551a7e
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010c4c1:	b8 16 d4 10 f0       	mov    $0xf010d416,%eax
f010c4c6:	66 a3 90 1a 55 f0    	mov    %ax,0xf0551a90
f010c4cc:	66 c7 05 92 1a 55 f0 	movw   $0x8,0xf0551a92
f010c4d3:	08 00 
f010c4d5:	a0 94 1a 55 f0       	mov    0xf0551a94,%al
f010c4da:	83 e0 e0             	and    $0xffffffe0,%eax
f010c4dd:	a2 94 1a 55 f0       	mov    %al,0xf0551a94
f010c4e2:	a0 94 1a 55 f0       	mov    0xf0551a94,%al
f010c4e7:	83 e0 1f             	and    $0x1f,%eax
f010c4ea:	a2 94 1a 55 f0       	mov    %al,0xf0551a94
f010c4ef:	a0 95 1a 55 f0       	mov    0xf0551a95,%al
f010c4f4:	83 e0 f0             	and    $0xfffffff0,%eax
f010c4f7:	83 c8 0e             	or     $0xe,%eax
f010c4fa:	a2 95 1a 55 f0       	mov    %al,0xf0551a95
f010c4ff:	a0 95 1a 55 f0       	mov    0xf0551a95,%al
f010c504:	83 e0 ef             	and    $0xffffffef,%eax
f010c507:	a2 95 1a 55 f0       	mov    %al,0xf0551a95
f010c50c:	a0 95 1a 55 f0       	mov    0xf0551a95,%al
f010c511:	83 c8 60             	or     $0x60,%eax
f010c514:	a2 95 1a 55 f0       	mov    %al,0xf0551a95
f010c519:	a0 95 1a 55 f0       	mov    0xf0551a95,%al
f010c51e:	83 c8 80             	or     $0xffffff80,%eax
f010c521:	a2 95 1a 55 f0       	mov    %al,0xf0551a95
f010c526:	b8 16 d4 10 f0       	mov    $0xf010d416,%eax
f010c52b:	c1 e8 10             	shr    $0x10,%eax
f010c52e:	66 a3 96 1a 55 f0    	mov    %ax,0xf0551a96
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010c534:	b8 1a d4 10 f0       	mov    $0xf010d41a,%eax
f010c539:	66 a3 98 1a 55 f0    	mov    %ax,0xf0551a98
f010c53f:	66 c7 05 9a 1a 55 f0 	movw   $0x8,0xf0551a9a
f010c546:	08 00 
f010c548:	a0 9c 1a 55 f0       	mov    0xf0551a9c,%al
f010c54d:	83 e0 e0             	and    $0xffffffe0,%eax
f010c550:	a2 9c 1a 55 f0       	mov    %al,0xf0551a9c
f010c555:	a0 9c 1a 55 f0       	mov    0xf0551a9c,%al
f010c55a:	83 e0 1f             	and    $0x1f,%eax
f010c55d:	a2 9c 1a 55 f0       	mov    %al,0xf0551a9c
f010c562:	a0 9d 1a 55 f0       	mov    0xf0551a9d,%al
f010c567:	83 e0 f0             	and    $0xfffffff0,%eax
f010c56a:	83 c8 0e             	or     $0xe,%eax
f010c56d:	a2 9d 1a 55 f0       	mov    %al,0xf0551a9d
f010c572:	a0 9d 1a 55 f0       	mov    0xf0551a9d,%al
f010c577:	83 e0 ef             	and    $0xffffffef,%eax
f010c57a:	a2 9d 1a 55 f0       	mov    %al,0xf0551a9d
f010c57f:	a0 9d 1a 55 f0       	mov    0xf0551a9d,%al
f010c584:	83 c8 60             	or     $0x60,%eax
f010c587:	a2 9d 1a 55 f0       	mov    %al,0xf0551a9d
f010c58c:	a0 9d 1a 55 f0       	mov    0xf0551a9d,%al
f010c591:	83 c8 80             	or     $0xffffff80,%eax
f010c594:	a2 9d 1a 55 f0       	mov    %al,0xf0551a9d
f010c599:	b8 1a d4 10 f0       	mov    $0xf010d41a,%eax
f010c59e:	c1 e8 10             	shr    $0x10,%eax
f010c5a1:	66 a3 9e 1a 55 f0    	mov    %ax,0xf0551a9e
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010c5a7:	b8 1e d4 10 f0       	mov    $0xf010d41e,%eax
f010c5ac:	66 a3 a0 1a 55 f0    	mov    %ax,0xf0551aa0
f010c5b2:	66 c7 05 a2 1a 55 f0 	movw   $0x8,0xf0551aa2
f010c5b9:	08 00 
f010c5bb:	a0 a4 1a 55 f0       	mov    0xf0551aa4,%al
f010c5c0:	83 e0 e0             	and    $0xffffffe0,%eax
f010c5c3:	a2 a4 1a 55 f0       	mov    %al,0xf0551aa4
f010c5c8:	a0 a4 1a 55 f0       	mov    0xf0551aa4,%al
f010c5cd:	83 e0 1f             	and    $0x1f,%eax
f010c5d0:	a2 a4 1a 55 f0       	mov    %al,0xf0551aa4
f010c5d5:	a0 a5 1a 55 f0       	mov    0xf0551aa5,%al
f010c5da:	83 e0 f0             	and    $0xfffffff0,%eax
f010c5dd:	83 c8 0e             	or     $0xe,%eax
f010c5e0:	a2 a5 1a 55 f0       	mov    %al,0xf0551aa5
f010c5e5:	a0 a5 1a 55 f0       	mov    0xf0551aa5,%al
f010c5ea:	83 e0 ef             	and    $0xffffffef,%eax
f010c5ed:	a2 a5 1a 55 f0       	mov    %al,0xf0551aa5
f010c5f2:	a0 a5 1a 55 f0       	mov    0xf0551aa5,%al
f010c5f7:	83 c8 60             	or     $0x60,%eax
f010c5fa:	a2 a5 1a 55 f0       	mov    %al,0xf0551aa5
f010c5ff:	a0 a5 1a 55 f0       	mov    0xf0551aa5,%al
f010c604:	83 c8 80             	or     $0xffffff80,%eax
f010c607:	a2 a5 1a 55 f0       	mov    %al,0xf0551aa5
f010c60c:	b8 1e d4 10 f0       	mov    $0xf010d41e,%eax
f010c611:	c1 e8 10             	shr    $0x10,%eax
f010c614:	66 a3 a6 1a 55 f0    	mov    %ax,0xf0551aa6
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010c61a:	b8 22 d4 10 f0       	mov    $0xf010d422,%eax
f010c61f:	66 a3 a8 1a 55 f0    	mov    %ax,0xf0551aa8
f010c625:	66 c7 05 aa 1a 55 f0 	movw   $0x8,0xf0551aaa
f010c62c:	08 00 
f010c62e:	a0 ac 1a 55 f0       	mov    0xf0551aac,%al
f010c633:	83 e0 e0             	and    $0xffffffe0,%eax
f010c636:	a2 ac 1a 55 f0       	mov    %al,0xf0551aac
f010c63b:	a0 ac 1a 55 f0       	mov    0xf0551aac,%al
f010c640:	83 e0 1f             	and    $0x1f,%eax
f010c643:	a2 ac 1a 55 f0       	mov    %al,0xf0551aac
f010c648:	a0 ad 1a 55 f0       	mov    0xf0551aad,%al
f010c64d:	83 e0 f0             	and    $0xfffffff0,%eax
f010c650:	83 c8 0e             	or     $0xe,%eax
f010c653:	a2 ad 1a 55 f0       	mov    %al,0xf0551aad
f010c658:	a0 ad 1a 55 f0       	mov    0xf0551aad,%al
f010c65d:	83 e0 ef             	and    $0xffffffef,%eax
f010c660:	a2 ad 1a 55 f0       	mov    %al,0xf0551aad
f010c665:	a0 ad 1a 55 f0       	mov    0xf0551aad,%al
f010c66a:	83 c8 60             	or     $0x60,%eax
f010c66d:	a2 ad 1a 55 f0       	mov    %al,0xf0551aad
f010c672:	a0 ad 1a 55 f0       	mov    0xf0551aad,%al
f010c677:	83 c8 80             	or     $0xffffff80,%eax
f010c67a:	a2 ad 1a 55 f0       	mov    %al,0xf0551aad
f010c67f:	b8 22 d4 10 f0       	mov    $0xf010d422,%eax
f010c684:	c1 e8 10             	shr    $0x10,%eax
f010c687:	66 a3 ae 1a 55 f0    	mov    %ax,0xf0551aae
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010c68d:	b8 26 d4 10 f0       	mov    $0xf010d426,%eax
f010c692:	66 a3 c0 1a 55 f0    	mov    %ax,0xf0551ac0
f010c698:	66 c7 05 c2 1a 55 f0 	movw   $0x8,0xf0551ac2
f010c69f:	08 00 
f010c6a1:	a0 c4 1a 55 f0       	mov    0xf0551ac4,%al
f010c6a6:	83 e0 e0             	and    $0xffffffe0,%eax
f010c6a9:	a2 c4 1a 55 f0       	mov    %al,0xf0551ac4
f010c6ae:	a0 c4 1a 55 f0       	mov    0xf0551ac4,%al
f010c6b3:	83 e0 1f             	and    $0x1f,%eax
f010c6b6:	a2 c4 1a 55 f0       	mov    %al,0xf0551ac4
f010c6bb:	a0 c5 1a 55 f0       	mov    0xf0551ac5,%al
f010c6c0:	83 e0 f0             	and    $0xfffffff0,%eax
f010c6c3:	83 c8 0e             	or     $0xe,%eax
f010c6c6:	a2 c5 1a 55 f0       	mov    %al,0xf0551ac5
f010c6cb:	a0 c5 1a 55 f0       	mov    0xf0551ac5,%al
f010c6d0:	83 e0 ef             	and    $0xffffffef,%eax
f010c6d3:	a2 c5 1a 55 f0       	mov    %al,0xf0551ac5
f010c6d8:	a0 c5 1a 55 f0       	mov    0xf0551ac5,%al
f010c6dd:	83 c8 60             	or     $0x60,%eax
f010c6e0:	a2 c5 1a 55 f0       	mov    %al,0xf0551ac5
f010c6e5:	a0 c5 1a 55 f0       	mov    0xf0551ac5,%al
f010c6ea:	83 c8 80             	or     $0xffffff80,%eax
f010c6ed:	a2 c5 1a 55 f0       	mov    %al,0xf0551ac5
f010c6f2:	b8 26 d4 10 f0       	mov    $0xf010d426,%eax
f010c6f7:	c1 e8 10             	shr    $0x10,%eax
f010c6fa:	66 a3 c6 1a 55 f0    	mov    %ax,0xf0551ac6
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010c700:	b8 2c d4 10 f0       	mov    $0xf010d42c,%eax
f010c705:	66 a3 c8 1a 55 f0    	mov    %ax,0xf0551ac8
f010c70b:	66 c7 05 ca 1a 55 f0 	movw   $0x8,0xf0551aca
f010c712:	08 00 
f010c714:	a0 cc 1a 55 f0       	mov    0xf0551acc,%al
f010c719:	83 e0 e0             	and    $0xffffffe0,%eax
f010c71c:	a2 cc 1a 55 f0       	mov    %al,0xf0551acc
f010c721:	a0 cc 1a 55 f0       	mov    0xf0551acc,%al
f010c726:	83 e0 1f             	and    $0x1f,%eax
f010c729:	a2 cc 1a 55 f0       	mov    %al,0xf0551acc
f010c72e:	a0 cd 1a 55 f0       	mov    0xf0551acd,%al
f010c733:	83 e0 f0             	and    $0xfffffff0,%eax
f010c736:	83 c8 0e             	or     $0xe,%eax
f010c739:	a2 cd 1a 55 f0       	mov    %al,0xf0551acd
f010c73e:	a0 cd 1a 55 f0       	mov    0xf0551acd,%al
f010c743:	83 e0 ef             	and    $0xffffffef,%eax
f010c746:	a2 cd 1a 55 f0       	mov    %al,0xf0551acd
f010c74b:	a0 cd 1a 55 f0       	mov    0xf0551acd,%al
f010c750:	83 c8 60             	or     $0x60,%eax
f010c753:	a2 cd 1a 55 f0       	mov    %al,0xf0551acd
f010c758:	a0 cd 1a 55 f0       	mov    0xf0551acd,%al
f010c75d:	83 c8 80             	or     $0xffffff80,%eax
f010c760:	a2 cd 1a 55 f0       	mov    %al,0xf0551acd
f010c765:	b8 2c d4 10 f0       	mov    $0xf010d42c,%eax
f010c76a:	c1 e8 10             	shr    $0x10,%eax
f010c76d:	66 a3 ce 1a 55 f0    	mov    %ax,0xf0551ace
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010c773:	b8 30 d4 10 f0       	mov    $0xf010d430,%eax
f010c778:	66 a3 d0 1a 55 f0    	mov    %ax,0xf0551ad0
f010c77e:	66 c7 05 d2 1a 55 f0 	movw   $0x8,0xf0551ad2
f010c785:	08 00 
f010c787:	a0 d4 1a 55 f0       	mov    0xf0551ad4,%al
f010c78c:	83 e0 e0             	and    $0xffffffe0,%eax
f010c78f:	a2 d4 1a 55 f0       	mov    %al,0xf0551ad4
f010c794:	a0 d4 1a 55 f0       	mov    0xf0551ad4,%al
f010c799:	83 e0 1f             	and    $0x1f,%eax
f010c79c:	a2 d4 1a 55 f0       	mov    %al,0xf0551ad4
f010c7a1:	a0 d5 1a 55 f0       	mov    0xf0551ad5,%al
f010c7a6:	83 e0 f0             	and    $0xfffffff0,%eax
f010c7a9:	83 c8 0e             	or     $0xe,%eax
f010c7ac:	a2 d5 1a 55 f0       	mov    %al,0xf0551ad5
f010c7b1:	a0 d5 1a 55 f0       	mov    0xf0551ad5,%al
f010c7b6:	83 e0 ef             	and    $0xffffffef,%eax
f010c7b9:	a2 d5 1a 55 f0       	mov    %al,0xf0551ad5
f010c7be:	a0 d5 1a 55 f0       	mov    0xf0551ad5,%al
f010c7c3:	83 c8 60             	or     $0x60,%eax
f010c7c6:	a2 d5 1a 55 f0       	mov    %al,0xf0551ad5
f010c7cb:	a0 d5 1a 55 f0       	mov    0xf0551ad5,%al
f010c7d0:	83 c8 80             	or     $0xffffff80,%eax
f010c7d3:	a2 d5 1a 55 f0       	mov    %al,0xf0551ad5
f010c7d8:	b8 30 d4 10 f0       	mov    $0xf010d430,%eax
f010c7dd:	c1 e8 10             	shr    $0x10,%eax
f010c7e0:	66 a3 d6 1a 55 f0    	mov    %ax,0xf0551ad6
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010c7e6:	b8 36 d4 10 f0       	mov    $0xf010d436,%eax
f010c7eb:	66 a3 d8 1a 55 f0    	mov    %ax,0xf0551ad8
f010c7f1:	66 c7 05 da 1a 55 f0 	movw   $0x8,0xf0551ada
f010c7f8:	08 00 
f010c7fa:	a0 dc 1a 55 f0       	mov    0xf0551adc,%al
f010c7ff:	83 e0 e0             	and    $0xffffffe0,%eax
f010c802:	a2 dc 1a 55 f0       	mov    %al,0xf0551adc
f010c807:	a0 dc 1a 55 f0       	mov    0xf0551adc,%al
f010c80c:	83 e0 1f             	and    $0x1f,%eax
f010c80f:	a2 dc 1a 55 f0       	mov    %al,0xf0551adc
f010c814:	a0 dd 1a 55 f0       	mov    0xf0551add,%al
f010c819:	83 e0 f0             	and    $0xfffffff0,%eax
f010c81c:	83 c8 0e             	or     $0xe,%eax
f010c81f:	a2 dd 1a 55 f0       	mov    %al,0xf0551add
f010c824:	a0 dd 1a 55 f0       	mov    0xf0551add,%al
f010c829:	83 e0 ef             	and    $0xffffffef,%eax
f010c82c:	a2 dd 1a 55 f0       	mov    %al,0xf0551add
f010c831:	a0 dd 1a 55 f0       	mov    0xf0551add,%al
f010c836:	83 c8 60             	or     $0x60,%eax
f010c839:	a2 dd 1a 55 f0       	mov    %al,0xf0551add
f010c83e:	a0 dd 1a 55 f0       	mov    0xf0551add,%al
f010c843:	83 c8 80             	or     $0xffffff80,%eax
f010c846:	a2 dd 1a 55 f0       	mov    %al,0xf0551add
f010c84b:	b8 36 d4 10 f0       	mov    $0xf010d436,%eax
f010c850:	c1 e8 10             	shr    $0x10,%eax
f010c853:	66 a3 de 1a 55 f0    	mov    %ax,0xf0551ade

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010c859:	b8 3c d4 10 f0       	mov    $0xf010d43c,%eax
f010c85e:	66 a3 50 1b 55 f0    	mov    %ax,0xf0551b50
f010c864:	66 c7 05 52 1b 55 f0 	movw   $0x8,0xf0551b52
f010c86b:	08 00 
f010c86d:	a0 54 1b 55 f0       	mov    0xf0551b54,%al
f010c872:	83 e0 e0             	and    $0xffffffe0,%eax
f010c875:	a2 54 1b 55 f0       	mov    %al,0xf0551b54
f010c87a:	a0 54 1b 55 f0       	mov    0xf0551b54,%al
f010c87f:	83 e0 1f             	and    $0x1f,%eax
f010c882:	a2 54 1b 55 f0       	mov    %al,0xf0551b54
f010c887:	a0 55 1b 55 f0       	mov    0xf0551b55,%al
f010c88c:	83 e0 f0             	and    $0xfffffff0,%eax
f010c88f:	83 c8 0e             	or     $0xe,%eax
f010c892:	a2 55 1b 55 f0       	mov    %al,0xf0551b55
f010c897:	a0 55 1b 55 f0       	mov    0xf0551b55,%al
f010c89c:	83 e0 ef             	and    $0xffffffef,%eax
f010c89f:	a2 55 1b 55 f0       	mov    %al,0xf0551b55
f010c8a4:	a0 55 1b 55 f0       	mov    0xf0551b55,%al
f010c8a9:	83 c8 60             	or     $0x60,%eax
f010c8ac:	a2 55 1b 55 f0       	mov    %al,0xf0551b55
f010c8b1:	a0 55 1b 55 f0       	mov    0xf0551b55,%al
f010c8b6:	83 c8 80             	or     $0xffffff80,%eax
f010c8b9:	a2 55 1b 55 f0       	mov    %al,0xf0551b55
f010c8be:	b8 3c d4 10 f0       	mov    $0xf010d43c,%eax
f010c8c3:	c1 e8 10             	shr    $0x10,%eax
f010c8c6:	66 a3 56 1b 55 f0    	mov    %ax,0xf0551b56
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010c8cc:	b8 42 d4 10 f0       	mov    $0xf010d442,%eax
f010c8d1:	66 a3 58 1b 55 f0    	mov    %ax,0xf0551b58
f010c8d7:	66 c7 05 5a 1b 55 f0 	movw   $0x8,0xf0551b5a
f010c8de:	08 00 
f010c8e0:	a0 5c 1b 55 f0       	mov    0xf0551b5c,%al
f010c8e5:	83 e0 e0             	and    $0xffffffe0,%eax
f010c8e8:	a2 5c 1b 55 f0       	mov    %al,0xf0551b5c
f010c8ed:	a0 5c 1b 55 f0       	mov    0xf0551b5c,%al
f010c8f2:	83 e0 1f             	and    $0x1f,%eax
f010c8f5:	a2 5c 1b 55 f0       	mov    %al,0xf0551b5c
f010c8fa:	a0 5d 1b 55 f0       	mov    0xf0551b5d,%al
f010c8ff:	83 e0 f0             	and    $0xfffffff0,%eax
f010c902:	83 c8 0e             	or     $0xe,%eax
f010c905:	a2 5d 1b 55 f0       	mov    %al,0xf0551b5d
f010c90a:	a0 5d 1b 55 f0       	mov    0xf0551b5d,%al
f010c90f:	83 e0 ef             	and    $0xffffffef,%eax
f010c912:	a2 5d 1b 55 f0       	mov    %al,0xf0551b5d
f010c917:	a0 5d 1b 55 f0       	mov    0xf0551b5d,%al
f010c91c:	83 c8 60             	or     $0x60,%eax
f010c91f:	a2 5d 1b 55 f0       	mov    %al,0xf0551b5d
f010c924:	a0 5d 1b 55 f0       	mov    0xf0551b5d,%al
f010c929:	83 c8 80             	or     $0xffffff80,%eax
f010c92c:	a2 5d 1b 55 f0       	mov    %al,0xf0551b5d
f010c931:	b8 42 d4 10 f0       	mov    $0xf010d442,%eax
f010c936:	c1 e8 10             	shr    $0x10,%eax
f010c939:	66 a3 5e 1b 55 f0    	mov    %ax,0xf0551b5e
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010c93f:	b8 48 d4 10 f0       	mov    $0xf010d448,%eax
f010c944:	66 a3 60 1b 55 f0    	mov    %ax,0xf0551b60
f010c94a:	66 c7 05 62 1b 55 f0 	movw   $0x8,0xf0551b62
f010c951:	08 00 
f010c953:	a0 64 1b 55 f0       	mov    0xf0551b64,%al
f010c958:	83 e0 e0             	and    $0xffffffe0,%eax
f010c95b:	a2 64 1b 55 f0       	mov    %al,0xf0551b64
f010c960:	a0 64 1b 55 f0       	mov    0xf0551b64,%al
f010c965:	83 e0 1f             	and    $0x1f,%eax
f010c968:	a2 64 1b 55 f0       	mov    %al,0xf0551b64
f010c96d:	a0 65 1b 55 f0       	mov    0xf0551b65,%al
f010c972:	83 e0 f0             	and    $0xfffffff0,%eax
f010c975:	83 c8 0e             	or     $0xe,%eax
f010c978:	a2 65 1b 55 f0       	mov    %al,0xf0551b65
f010c97d:	a0 65 1b 55 f0       	mov    0xf0551b65,%al
f010c982:	83 e0 ef             	and    $0xffffffef,%eax
f010c985:	a2 65 1b 55 f0       	mov    %al,0xf0551b65
f010c98a:	a0 65 1b 55 f0       	mov    0xf0551b65,%al
f010c98f:	83 c8 60             	or     $0x60,%eax
f010c992:	a2 65 1b 55 f0       	mov    %al,0xf0551b65
f010c997:	a0 65 1b 55 f0       	mov    0xf0551b65,%al
f010c99c:	83 c8 80             	or     $0xffffff80,%eax
f010c99f:	a2 65 1b 55 f0       	mov    %al,0xf0551b65
f010c9a4:	b8 48 d4 10 f0       	mov    $0xf010d448,%eax
f010c9a9:	c1 e8 10             	shr    $0x10,%eax
f010c9ac:	66 a3 66 1b 55 f0    	mov    %ax,0xf0551b66
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010c9b2:	b8 4e d4 10 f0       	mov    $0xf010d44e,%eax
f010c9b7:	66 a3 68 1b 55 f0    	mov    %ax,0xf0551b68
f010c9bd:	66 c7 05 6a 1b 55 f0 	movw   $0x8,0xf0551b6a
f010c9c4:	08 00 
f010c9c6:	a0 6c 1b 55 f0       	mov    0xf0551b6c,%al
f010c9cb:	83 e0 e0             	and    $0xffffffe0,%eax
f010c9ce:	a2 6c 1b 55 f0       	mov    %al,0xf0551b6c
f010c9d3:	a0 6c 1b 55 f0       	mov    0xf0551b6c,%al
f010c9d8:	83 e0 1f             	and    $0x1f,%eax
f010c9db:	a2 6c 1b 55 f0       	mov    %al,0xf0551b6c
f010c9e0:	a0 6d 1b 55 f0       	mov    0xf0551b6d,%al
f010c9e5:	83 e0 f0             	and    $0xfffffff0,%eax
f010c9e8:	83 c8 0e             	or     $0xe,%eax
f010c9eb:	a2 6d 1b 55 f0       	mov    %al,0xf0551b6d
f010c9f0:	a0 6d 1b 55 f0       	mov    0xf0551b6d,%al
f010c9f5:	83 e0 ef             	and    $0xffffffef,%eax
f010c9f8:	a2 6d 1b 55 f0       	mov    %al,0xf0551b6d
f010c9fd:	a0 6d 1b 55 f0       	mov    0xf0551b6d,%al
f010ca02:	83 c8 60             	or     $0x60,%eax
f010ca05:	a2 6d 1b 55 f0       	mov    %al,0xf0551b6d
f010ca0a:	a0 6d 1b 55 f0       	mov    0xf0551b6d,%al
f010ca0f:	83 c8 80             	or     $0xffffff80,%eax
f010ca12:	a2 6d 1b 55 f0       	mov    %al,0xf0551b6d
f010ca17:	b8 4e d4 10 f0       	mov    $0xf010d44e,%eax
f010ca1c:	c1 e8 10             	shr    $0x10,%eax
f010ca1f:	66 a3 6e 1b 55 f0    	mov    %ax,0xf0551b6e
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010ca25:	b8 54 d4 10 f0       	mov    $0xf010d454,%eax
f010ca2a:	66 a3 70 1b 55 f0    	mov    %ax,0xf0551b70
f010ca30:	66 c7 05 72 1b 55 f0 	movw   $0x8,0xf0551b72
f010ca37:	08 00 
f010ca39:	a0 74 1b 55 f0       	mov    0xf0551b74,%al
f010ca3e:	83 e0 e0             	and    $0xffffffe0,%eax
f010ca41:	a2 74 1b 55 f0       	mov    %al,0xf0551b74
f010ca46:	a0 74 1b 55 f0       	mov    0xf0551b74,%al
f010ca4b:	83 e0 1f             	and    $0x1f,%eax
f010ca4e:	a2 74 1b 55 f0       	mov    %al,0xf0551b74
f010ca53:	a0 75 1b 55 f0       	mov    0xf0551b75,%al
f010ca58:	83 e0 f0             	and    $0xfffffff0,%eax
f010ca5b:	83 c8 0e             	or     $0xe,%eax
f010ca5e:	a2 75 1b 55 f0       	mov    %al,0xf0551b75
f010ca63:	a0 75 1b 55 f0       	mov    0xf0551b75,%al
f010ca68:	83 e0 ef             	and    $0xffffffef,%eax
f010ca6b:	a2 75 1b 55 f0       	mov    %al,0xf0551b75
f010ca70:	a0 75 1b 55 f0       	mov    0xf0551b75,%al
f010ca75:	83 c8 60             	or     $0x60,%eax
f010ca78:	a2 75 1b 55 f0       	mov    %al,0xf0551b75
f010ca7d:	a0 75 1b 55 f0       	mov    0xf0551b75,%al
f010ca82:	83 c8 80             	or     $0xffffff80,%eax
f010ca85:	a2 75 1b 55 f0       	mov    %al,0xf0551b75
f010ca8a:	b8 54 d4 10 f0       	mov    $0xf010d454,%eax
f010ca8f:	c1 e8 10             	shr    $0x10,%eax
f010ca92:	66 a3 76 1b 55 f0    	mov    %ax,0xf0551b76
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010ca98:	b8 5a d4 10 f0       	mov    $0xf010d45a,%eax
f010ca9d:	66 a3 78 1b 55 f0    	mov    %ax,0xf0551b78
f010caa3:	66 c7 05 7a 1b 55 f0 	movw   $0x8,0xf0551b7a
f010caaa:	08 00 
f010caac:	a0 7c 1b 55 f0       	mov    0xf0551b7c,%al
f010cab1:	83 e0 e0             	and    $0xffffffe0,%eax
f010cab4:	a2 7c 1b 55 f0       	mov    %al,0xf0551b7c
f010cab9:	a0 7c 1b 55 f0       	mov    0xf0551b7c,%al
f010cabe:	83 e0 1f             	and    $0x1f,%eax
f010cac1:	a2 7c 1b 55 f0       	mov    %al,0xf0551b7c
f010cac6:	a0 7d 1b 55 f0       	mov    0xf0551b7d,%al
f010cacb:	83 e0 f0             	and    $0xfffffff0,%eax
f010cace:	83 c8 0e             	or     $0xe,%eax
f010cad1:	a2 7d 1b 55 f0       	mov    %al,0xf0551b7d
f010cad6:	a0 7d 1b 55 f0       	mov    0xf0551b7d,%al
f010cadb:	83 e0 ef             	and    $0xffffffef,%eax
f010cade:	a2 7d 1b 55 f0       	mov    %al,0xf0551b7d
f010cae3:	a0 7d 1b 55 f0       	mov    0xf0551b7d,%al
f010cae8:	83 c8 60             	or     $0x60,%eax
f010caeb:	a2 7d 1b 55 f0       	mov    %al,0xf0551b7d
f010caf0:	a0 7d 1b 55 f0       	mov    0xf0551b7d,%al
f010caf5:	83 c8 80             	or     $0xffffff80,%eax
f010caf8:	a2 7d 1b 55 f0       	mov    %al,0xf0551b7d
f010cafd:	b8 5a d4 10 f0       	mov    $0xf010d45a,%eax
f010cb02:	c1 e8 10             	shr    $0x10,%eax
f010cb05:	66 a3 7e 1b 55 f0    	mov    %ax,0xf0551b7e
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010cb0b:	b8 60 d4 10 f0       	mov    $0xf010d460,%eax
f010cb10:	66 a3 80 1b 55 f0    	mov    %ax,0xf0551b80
f010cb16:	66 c7 05 82 1b 55 f0 	movw   $0x8,0xf0551b82
f010cb1d:	08 00 
f010cb1f:	a0 84 1b 55 f0       	mov    0xf0551b84,%al
f010cb24:	83 e0 e0             	and    $0xffffffe0,%eax
f010cb27:	a2 84 1b 55 f0       	mov    %al,0xf0551b84
f010cb2c:	a0 84 1b 55 f0       	mov    0xf0551b84,%al
f010cb31:	83 e0 1f             	and    $0x1f,%eax
f010cb34:	a2 84 1b 55 f0       	mov    %al,0xf0551b84
f010cb39:	a0 85 1b 55 f0       	mov    0xf0551b85,%al
f010cb3e:	83 e0 f0             	and    $0xfffffff0,%eax
f010cb41:	83 c8 0e             	or     $0xe,%eax
f010cb44:	a2 85 1b 55 f0       	mov    %al,0xf0551b85
f010cb49:	a0 85 1b 55 f0       	mov    0xf0551b85,%al
f010cb4e:	83 e0 ef             	and    $0xffffffef,%eax
f010cb51:	a2 85 1b 55 f0       	mov    %al,0xf0551b85
f010cb56:	a0 85 1b 55 f0       	mov    0xf0551b85,%al
f010cb5b:	83 c8 60             	or     $0x60,%eax
f010cb5e:	a2 85 1b 55 f0       	mov    %al,0xf0551b85
f010cb63:	a0 85 1b 55 f0       	mov    0xf0551b85,%al
f010cb68:	83 c8 80             	or     $0xffffff80,%eax
f010cb6b:	a2 85 1b 55 f0       	mov    %al,0xf0551b85
f010cb70:	b8 60 d4 10 f0       	mov    $0xf010d460,%eax
f010cb75:	c1 e8 10             	shr    $0x10,%eax
f010cb78:	66 a3 86 1b 55 f0    	mov    %ax,0xf0551b86
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010cb7e:	b8 66 d4 10 f0       	mov    $0xf010d466,%eax
f010cb83:	66 a3 88 1b 55 f0    	mov    %ax,0xf0551b88
f010cb89:	66 c7 05 8a 1b 55 f0 	movw   $0x8,0xf0551b8a
f010cb90:	08 00 
f010cb92:	a0 8c 1b 55 f0       	mov    0xf0551b8c,%al
f010cb97:	83 e0 e0             	and    $0xffffffe0,%eax
f010cb9a:	a2 8c 1b 55 f0       	mov    %al,0xf0551b8c
f010cb9f:	a0 8c 1b 55 f0       	mov    0xf0551b8c,%al
f010cba4:	83 e0 1f             	and    $0x1f,%eax
f010cba7:	a2 8c 1b 55 f0       	mov    %al,0xf0551b8c
f010cbac:	a0 8d 1b 55 f0       	mov    0xf0551b8d,%al
f010cbb1:	83 e0 f0             	and    $0xfffffff0,%eax
f010cbb4:	83 c8 0e             	or     $0xe,%eax
f010cbb7:	a2 8d 1b 55 f0       	mov    %al,0xf0551b8d
f010cbbc:	a0 8d 1b 55 f0       	mov    0xf0551b8d,%al
f010cbc1:	83 e0 ef             	and    $0xffffffef,%eax
f010cbc4:	a2 8d 1b 55 f0       	mov    %al,0xf0551b8d
f010cbc9:	a0 8d 1b 55 f0       	mov    0xf0551b8d,%al
f010cbce:	83 c8 60             	or     $0x60,%eax
f010cbd1:	a2 8d 1b 55 f0       	mov    %al,0xf0551b8d
f010cbd6:	a0 8d 1b 55 f0       	mov    0xf0551b8d,%al
f010cbdb:	83 c8 80             	or     $0xffffff80,%eax
f010cbde:	a2 8d 1b 55 f0       	mov    %al,0xf0551b8d
f010cbe3:	b8 66 d4 10 f0       	mov    $0xf010d466,%eax
f010cbe8:	c1 e8 10             	shr    $0x10,%eax
f010cbeb:	66 a3 8e 1b 55 f0    	mov    %ax,0xf0551b8e
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010cbf1:	b8 6c d4 10 f0       	mov    $0xf010d46c,%eax
f010cbf6:	66 a3 90 1b 55 f0    	mov    %ax,0xf0551b90
f010cbfc:	66 c7 05 92 1b 55 f0 	movw   $0x8,0xf0551b92
f010cc03:	08 00 
f010cc05:	a0 94 1b 55 f0       	mov    0xf0551b94,%al
f010cc0a:	83 e0 e0             	and    $0xffffffe0,%eax
f010cc0d:	a2 94 1b 55 f0       	mov    %al,0xf0551b94
f010cc12:	a0 94 1b 55 f0       	mov    0xf0551b94,%al
f010cc17:	83 e0 1f             	and    $0x1f,%eax
f010cc1a:	a2 94 1b 55 f0       	mov    %al,0xf0551b94
f010cc1f:	a0 95 1b 55 f0       	mov    0xf0551b95,%al
f010cc24:	83 e0 f0             	and    $0xfffffff0,%eax
f010cc27:	83 c8 0e             	or     $0xe,%eax
f010cc2a:	a2 95 1b 55 f0       	mov    %al,0xf0551b95
f010cc2f:	a0 95 1b 55 f0       	mov    0xf0551b95,%al
f010cc34:	83 e0 ef             	and    $0xffffffef,%eax
f010cc37:	a2 95 1b 55 f0       	mov    %al,0xf0551b95
f010cc3c:	a0 95 1b 55 f0       	mov    0xf0551b95,%al
f010cc41:	83 c8 60             	or     $0x60,%eax
f010cc44:	a2 95 1b 55 f0       	mov    %al,0xf0551b95
f010cc49:	a0 95 1b 55 f0       	mov    0xf0551b95,%al
f010cc4e:	83 c8 80             	or     $0xffffff80,%eax
f010cc51:	a2 95 1b 55 f0       	mov    %al,0xf0551b95
f010cc56:	b8 6c d4 10 f0       	mov    $0xf010d46c,%eax
f010cc5b:	c1 e8 10             	shr    $0x10,%eax
f010cc5e:	66 a3 96 1b 55 f0    	mov    %ax,0xf0551b96
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010cc64:	b8 72 d4 10 f0       	mov    $0xf010d472,%eax
f010cc69:	66 a3 98 1b 55 f0    	mov    %ax,0xf0551b98
f010cc6f:	66 c7 05 9a 1b 55 f0 	movw   $0x8,0xf0551b9a
f010cc76:	08 00 
f010cc78:	a0 9c 1b 55 f0       	mov    0xf0551b9c,%al
f010cc7d:	83 e0 e0             	and    $0xffffffe0,%eax
f010cc80:	a2 9c 1b 55 f0       	mov    %al,0xf0551b9c
f010cc85:	a0 9c 1b 55 f0       	mov    0xf0551b9c,%al
f010cc8a:	83 e0 1f             	and    $0x1f,%eax
f010cc8d:	a2 9c 1b 55 f0       	mov    %al,0xf0551b9c
f010cc92:	a0 9d 1b 55 f0       	mov    0xf0551b9d,%al
f010cc97:	83 e0 f0             	and    $0xfffffff0,%eax
f010cc9a:	83 c8 0e             	or     $0xe,%eax
f010cc9d:	a2 9d 1b 55 f0       	mov    %al,0xf0551b9d
f010cca2:	a0 9d 1b 55 f0       	mov    0xf0551b9d,%al
f010cca7:	83 e0 ef             	and    $0xffffffef,%eax
f010ccaa:	a2 9d 1b 55 f0       	mov    %al,0xf0551b9d
f010ccaf:	a0 9d 1b 55 f0       	mov    0xf0551b9d,%al
f010ccb4:	83 c8 60             	or     $0x60,%eax
f010ccb7:	a2 9d 1b 55 f0       	mov    %al,0xf0551b9d
f010ccbc:	a0 9d 1b 55 f0       	mov    0xf0551b9d,%al
f010ccc1:	83 c8 80             	or     $0xffffff80,%eax
f010ccc4:	a2 9d 1b 55 f0       	mov    %al,0xf0551b9d
f010ccc9:	b8 72 d4 10 f0       	mov    $0xf010d472,%eax
f010ccce:	c1 e8 10             	shr    $0x10,%eax
f010ccd1:	66 a3 9e 1b 55 f0    	mov    %ax,0xf0551b9e
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010ccd7:	b8 78 d4 10 f0       	mov    $0xf010d478,%eax
f010ccdc:	66 a3 a0 1b 55 f0    	mov    %ax,0xf0551ba0
f010cce2:	66 c7 05 a2 1b 55 f0 	movw   $0x8,0xf0551ba2
f010cce9:	08 00 
f010cceb:	a0 a4 1b 55 f0       	mov    0xf0551ba4,%al
f010ccf0:	83 e0 e0             	and    $0xffffffe0,%eax
f010ccf3:	a2 a4 1b 55 f0       	mov    %al,0xf0551ba4
f010ccf8:	a0 a4 1b 55 f0       	mov    0xf0551ba4,%al
f010ccfd:	83 e0 1f             	and    $0x1f,%eax
f010cd00:	a2 a4 1b 55 f0       	mov    %al,0xf0551ba4
f010cd05:	a0 a5 1b 55 f0       	mov    0xf0551ba5,%al
f010cd0a:	83 e0 f0             	and    $0xfffffff0,%eax
f010cd0d:	83 c8 0e             	or     $0xe,%eax
f010cd10:	a2 a5 1b 55 f0       	mov    %al,0xf0551ba5
f010cd15:	a0 a5 1b 55 f0       	mov    0xf0551ba5,%al
f010cd1a:	83 e0 ef             	and    $0xffffffef,%eax
f010cd1d:	a2 a5 1b 55 f0       	mov    %al,0xf0551ba5
f010cd22:	a0 a5 1b 55 f0       	mov    0xf0551ba5,%al
f010cd27:	83 c8 60             	or     $0x60,%eax
f010cd2a:	a2 a5 1b 55 f0       	mov    %al,0xf0551ba5
f010cd2f:	a0 a5 1b 55 f0       	mov    0xf0551ba5,%al
f010cd34:	83 c8 80             	or     $0xffffff80,%eax
f010cd37:	a2 a5 1b 55 f0       	mov    %al,0xf0551ba5
f010cd3c:	b8 78 d4 10 f0       	mov    $0xf010d478,%eax
f010cd41:	c1 e8 10             	shr    $0x10,%eax
f010cd44:	66 a3 a6 1b 55 f0    	mov    %ax,0xf0551ba6
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010cd4a:	b8 7e d4 10 f0       	mov    $0xf010d47e,%eax
f010cd4f:	66 a3 a8 1b 55 f0    	mov    %ax,0xf0551ba8
f010cd55:	66 c7 05 aa 1b 55 f0 	movw   $0x8,0xf0551baa
f010cd5c:	08 00 
f010cd5e:	a0 ac 1b 55 f0       	mov    0xf0551bac,%al
f010cd63:	83 e0 e0             	and    $0xffffffe0,%eax
f010cd66:	a2 ac 1b 55 f0       	mov    %al,0xf0551bac
f010cd6b:	a0 ac 1b 55 f0       	mov    0xf0551bac,%al
f010cd70:	83 e0 1f             	and    $0x1f,%eax
f010cd73:	a2 ac 1b 55 f0       	mov    %al,0xf0551bac
f010cd78:	a0 ad 1b 55 f0       	mov    0xf0551bad,%al
f010cd7d:	83 e0 f0             	and    $0xfffffff0,%eax
f010cd80:	83 c8 0e             	or     $0xe,%eax
f010cd83:	a2 ad 1b 55 f0       	mov    %al,0xf0551bad
f010cd88:	a0 ad 1b 55 f0       	mov    0xf0551bad,%al
f010cd8d:	83 e0 ef             	and    $0xffffffef,%eax
f010cd90:	a2 ad 1b 55 f0       	mov    %al,0xf0551bad
f010cd95:	a0 ad 1b 55 f0       	mov    0xf0551bad,%al
f010cd9a:	83 c8 60             	or     $0x60,%eax
f010cd9d:	a2 ad 1b 55 f0       	mov    %al,0xf0551bad
f010cda2:	a0 ad 1b 55 f0       	mov    0xf0551bad,%al
f010cda7:	83 c8 80             	or     $0xffffff80,%eax
f010cdaa:	a2 ad 1b 55 f0       	mov    %al,0xf0551bad
f010cdaf:	b8 7e d4 10 f0       	mov    $0xf010d47e,%eax
f010cdb4:	c1 e8 10             	shr    $0x10,%eax
f010cdb7:	66 a3 ae 1b 55 f0    	mov    %ax,0xf0551bae
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010cdbd:	b8 84 d4 10 f0       	mov    $0xf010d484,%eax
f010cdc2:	66 a3 b0 1b 55 f0    	mov    %ax,0xf0551bb0
f010cdc8:	66 c7 05 b2 1b 55 f0 	movw   $0x8,0xf0551bb2
f010cdcf:	08 00 
f010cdd1:	a0 b4 1b 55 f0       	mov    0xf0551bb4,%al
f010cdd6:	83 e0 e0             	and    $0xffffffe0,%eax
f010cdd9:	a2 b4 1b 55 f0       	mov    %al,0xf0551bb4
f010cdde:	a0 b4 1b 55 f0       	mov    0xf0551bb4,%al
f010cde3:	83 e0 1f             	and    $0x1f,%eax
f010cde6:	a2 b4 1b 55 f0       	mov    %al,0xf0551bb4
f010cdeb:	a0 b5 1b 55 f0       	mov    0xf0551bb5,%al
f010cdf0:	83 e0 f0             	and    $0xfffffff0,%eax
f010cdf3:	83 c8 0e             	or     $0xe,%eax
f010cdf6:	a2 b5 1b 55 f0       	mov    %al,0xf0551bb5
f010cdfb:	a0 b5 1b 55 f0       	mov    0xf0551bb5,%al
f010ce00:	83 e0 ef             	and    $0xffffffef,%eax
f010ce03:	a2 b5 1b 55 f0       	mov    %al,0xf0551bb5
f010ce08:	a0 b5 1b 55 f0       	mov    0xf0551bb5,%al
f010ce0d:	83 c8 60             	or     $0x60,%eax
f010ce10:	a2 b5 1b 55 f0       	mov    %al,0xf0551bb5
f010ce15:	a0 b5 1b 55 f0       	mov    0xf0551bb5,%al
f010ce1a:	83 c8 80             	or     $0xffffff80,%eax
f010ce1d:	a2 b5 1b 55 f0       	mov    %al,0xf0551bb5
f010ce22:	b8 84 d4 10 f0       	mov    $0xf010d484,%eax
f010ce27:	c1 e8 10             	shr    $0x10,%eax
f010ce2a:	66 a3 b6 1b 55 f0    	mov    %ax,0xf0551bb6
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010ce30:	b8 8a d4 10 f0       	mov    $0xf010d48a,%eax
f010ce35:	66 a3 b8 1b 55 f0    	mov    %ax,0xf0551bb8
f010ce3b:	66 c7 05 ba 1b 55 f0 	movw   $0x8,0xf0551bba
f010ce42:	08 00 
f010ce44:	a0 bc 1b 55 f0       	mov    0xf0551bbc,%al
f010ce49:	83 e0 e0             	and    $0xffffffe0,%eax
f010ce4c:	a2 bc 1b 55 f0       	mov    %al,0xf0551bbc
f010ce51:	a0 bc 1b 55 f0       	mov    0xf0551bbc,%al
f010ce56:	83 e0 1f             	and    $0x1f,%eax
f010ce59:	a2 bc 1b 55 f0       	mov    %al,0xf0551bbc
f010ce5e:	a0 bd 1b 55 f0       	mov    0xf0551bbd,%al
f010ce63:	83 e0 f0             	and    $0xfffffff0,%eax
f010ce66:	83 c8 0e             	or     $0xe,%eax
f010ce69:	a2 bd 1b 55 f0       	mov    %al,0xf0551bbd
f010ce6e:	a0 bd 1b 55 f0       	mov    0xf0551bbd,%al
f010ce73:	83 e0 ef             	and    $0xffffffef,%eax
f010ce76:	a2 bd 1b 55 f0       	mov    %al,0xf0551bbd
f010ce7b:	a0 bd 1b 55 f0       	mov    0xf0551bbd,%al
f010ce80:	83 c8 60             	or     $0x60,%eax
f010ce83:	a2 bd 1b 55 f0       	mov    %al,0xf0551bbd
f010ce88:	a0 bd 1b 55 f0       	mov    0xf0551bbd,%al
f010ce8d:	83 c8 80             	or     $0xffffff80,%eax
f010ce90:	a2 bd 1b 55 f0       	mov    %al,0xf0551bbd
f010ce95:	b8 8a d4 10 f0       	mov    $0xf010d48a,%eax
f010ce9a:	c1 e8 10             	shr    $0x10,%eax
f010ce9d:	66 a3 be 1b 55 f0    	mov    %ax,0xf0551bbe
f010cea3:	c7 45 fc 40 1a 55 f0 	movl   $0xf0551a40,-0x4(%ebp)
f010ceaa:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010ceb1:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010ceb4:	48                   	dec    %eax
f010ceb5:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010ceb9:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010cebc:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010cec0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010cec3:	c1 e8 10             	shr    $0x10,%eax
f010cec6:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010ceca:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010cecd:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010ced0:	90                   	nop
f010ced1:	c9                   	leave  
f010ced2:	c3                   	ret    

f010ced3 <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010ced3:	55                   	push   %ebp
f010ced4:	89 e5                	mov    %esp,%ebp
f010ced6:	53                   	push   %ebx
f010ced7:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010ceda:	83 ec 08             	sub    $0x8,%esp
f010cedd:	ff 75 08             	pushl  0x8(%ebp)
f010cee0:	68 be 64 12 f0       	push   $0xf01264be
f010cee5:	e8 82 40 ff ff       	call   f0100f6c <cprintf>
f010ceea:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010ceed:	8b 45 08             	mov    0x8(%ebp),%eax
f010cef0:	83 ec 0c             	sub    $0xc,%esp
f010cef3:	50                   	push   %eax
f010cef4:	e8 fd 00 00 00       	call   f010cff6 <print_regs>
f010cef9:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010cefc:	8b 45 08             	mov    0x8(%ebp),%eax
f010ceff:	8b 40 20             	mov    0x20(%eax),%eax
f010cf02:	0f b7 c0             	movzwl %ax,%eax
f010cf05:	83 ec 08             	sub    $0x8,%esp
f010cf08:	50                   	push   %eax
f010cf09:	68 d0 64 12 f0       	push   $0xf01264d0
f010cf0e:	e8 59 40 ff ff       	call   f0100f6c <cprintf>
f010cf13:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010cf16:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf19:	8b 40 24             	mov    0x24(%eax),%eax
f010cf1c:	0f b7 c0             	movzwl %ax,%eax
f010cf1f:	83 ec 08             	sub    $0x8,%esp
f010cf22:	50                   	push   %eax
f010cf23:	68 e3 64 12 f0       	push   $0xf01264e3
f010cf28:	e8 3f 40 ff ff       	call   f0100f6c <cprintf>
f010cf2d:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010cf30:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf33:	8b 58 28             	mov    0x28(%eax),%ebx
f010cf36:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf39:	8b 40 28             	mov    0x28(%eax),%eax
f010cf3c:	83 ec 0c             	sub    $0xc,%esp
f010cf3f:	50                   	push   %eax
f010cf40:	e8 28 ee ff ff       	call   f010bd6d <trapname>
f010cf45:	83 c4 10             	add    $0x10,%esp
f010cf48:	89 c2                	mov    %eax,%edx
f010cf4a:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf4d:	8b 40 28             	mov    0x28(%eax),%eax
f010cf50:	53                   	push   %ebx
f010cf51:	52                   	push   %edx
f010cf52:	50                   	push   %eax
f010cf53:	68 f6 64 12 f0       	push   $0xf01264f6
f010cf58:	e8 0f 40 ff ff       	call   f0100f6c <cprintf>
f010cf5d:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010cf60:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf63:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cf66:	83 ec 08             	sub    $0x8,%esp
f010cf69:	50                   	push   %eax
f010cf6a:	68 0d 65 12 f0       	push   $0xf012650d
f010cf6f:	e8 f8 3f ff ff       	call   f0100f6c <cprintf>
f010cf74:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010cf77:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf7a:	8b 40 30             	mov    0x30(%eax),%eax
f010cf7d:	83 ec 08             	sub    $0x8,%esp
f010cf80:	50                   	push   %eax
f010cf81:	68 1c 65 12 f0       	push   $0xf012651c
f010cf86:	e8 e1 3f ff ff       	call   f0100f6c <cprintf>
f010cf8b:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010cf8e:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf91:	8b 40 34             	mov    0x34(%eax),%eax
f010cf94:	0f b7 c0             	movzwl %ax,%eax
f010cf97:	83 ec 08             	sub    $0x8,%esp
f010cf9a:	50                   	push   %eax
f010cf9b:	68 2b 65 12 f0       	push   $0xf012652b
f010cfa0:	e8 c7 3f ff ff       	call   f0100f6c <cprintf>
f010cfa5:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010cfa8:	8b 45 08             	mov    0x8(%ebp),%eax
f010cfab:	8b 40 38             	mov    0x38(%eax),%eax
f010cfae:	83 ec 08             	sub    $0x8,%esp
f010cfb1:	50                   	push   %eax
f010cfb2:	68 3e 65 12 f0       	push   $0xf012653e
f010cfb7:	e8 b0 3f ff ff       	call   f0100f6c <cprintf>
f010cfbc:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010cfbf:	8b 45 08             	mov    0x8(%ebp),%eax
f010cfc2:	8b 40 3c             	mov    0x3c(%eax),%eax
f010cfc5:	83 ec 08             	sub    $0x8,%esp
f010cfc8:	50                   	push   %eax
f010cfc9:	68 4d 65 12 f0       	push   $0xf012654d
f010cfce:	e8 99 3f ff ff       	call   f0100f6c <cprintf>
f010cfd3:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010cfd6:	8b 45 08             	mov    0x8(%ebp),%eax
f010cfd9:	8b 40 40             	mov    0x40(%eax),%eax
f010cfdc:	0f b7 c0             	movzwl %ax,%eax
f010cfdf:	83 ec 08             	sub    $0x8,%esp
f010cfe2:	50                   	push   %eax
f010cfe3:	68 5c 65 12 f0       	push   $0xf012655c
f010cfe8:	e8 7f 3f ff ff       	call   f0100f6c <cprintf>
f010cfed:	83 c4 10             	add    $0x10,%esp
}
f010cff0:	90                   	nop
f010cff1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010cff4:	c9                   	leave  
f010cff5:	c3                   	ret    

f010cff6 <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010cff6:	55                   	push   %ebp
f010cff7:	89 e5                	mov    %esp,%ebp
f010cff9:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010cffc:	8b 45 08             	mov    0x8(%ebp),%eax
f010cfff:	8b 00                	mov    (%eax),%eax
f010d001:	83 ec 08             	sub    $0x8,%esp
f010d004:	50                   	push   %eax
f010d005:	68 6f 65 12 f0       	push   $0xf012656f
f010d00a:	e8 5d 3f ff ff       	call   f0100f6c <cprintf>
f010d00f:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010d012:	8b 45 08             	mov    0x8(%ebp),%eax
f010d015:	8b 40 04             	mov    0x4(%eax),%eax
f010d018:	83 ec 08             	sub    $0x8,%esp
f010d01b:	50                   	push   %eax
f010d01c:	68 7e 65 12 f0       	push   $0xf012657e
f010d021:	e8 46 3f ff ff       	call   f0100f6c <cprintf>
f010d026:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010d029:	8b 45 08             	mov    0x8(%ebp),%eax
f010d02c:	8b 40 08             	mov    0x8(%eax),%eax
f010d02f:	83 ec 08             	sub    $0x8,%esp
f010d032:	50                   	push   %eax
f010d033:	68 8d 65 12 f0       	push   $0xf012658d
f010d038:	e8 2f 3f ff ff       	call   f0100f6c <cprintf>
f010d03d:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010d040:	8b 45 08             	mov    0x8(%ebp),%eax
f010d043:	8b 40 0c             	mov    0xc(%eax),%eax
f010d046:	83 ec 08             	sub    $0x8,%esp
f010d049:	50                   	push   %eax
f010d04a:	68 9c 65 12 f0       	push   $0xf012659c
f010d04f:	e8 18 3f ff ff       	call   f0100f6c <cprintf>
f010d054:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010d057:	8b 45 08             	mov    0x8(%ebp),%eax
f010d05a:	8b 40 10             	mov    0x10(%eax),%eax
f010d05d:	83 ec 08             	sub    $0x8,%esp
f010d060:	50                   	push   %eax
f010d061:	68 ab 65 12 f0       	push   $0xf01265ab
f010d066:	e8 01 3f ff ff       	call   f0100f6c <cprintf>
f010d06b:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010d06e:	8b 45 08             	mov    0x8(%ebp),%eax
f010d071:	8b 40 14             	mov    0x14(%eax),%eax
f010d074:	83 ec 08             	sub    $0x8,%esp
f010d077:	50                   	push   %eax
f010d078:	68 ba 65 12 f0       	push   $0xf01265ba
f010d07d:	e8 ea 3e ff ff       	call   f0100f6c <cprintf>
f010d082:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010d085:	8b 45 08             	mov    0x8(%ebp),%eax
f010d088:	8b 40 18             	mov    0x18(%eax),%eax
f010d08b:	83 ec 08             	sub    $0x8,%esp
f010d08e:	50                   	push   %eax
f010d08f:	68 c9 65 12 f0       	push   $0xf01265c9
f010d094:	e8 d3 3e ff ff       	call   f0100f6c <cprintf>
f010d099:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010d09c:	8b 45 08             	mov    0x8(%ebp),%eax
f010d09f:	8b 40 1c             	mov    0x1c(%eax),%eax
f010d0a2:	83 ec 08             	sub    $0x8,%esp
f010d0a5:	50                   	push   %eax
f010d0a6:	68 d8 65 12 f0       	push   $0xf01265d8
f010d0ab:	e8 bc 3e ff ff       	call   f0100f6c <cprintf>
f010d0b0:	83 c4 10             	add    $0x10,%esp
}
f010d0b3:	90                   	nop
f010d0b4:	c9                   	leave  
f010d0b5:	c3                   	ret    

f010d0b6 <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010d0b6:	55                   	push   %ebp
f010d0b7:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010d0b9:	8b 45 08             	mov    0x8(%ebp),%eax
f010d0bc:	8b 55 0c             	mov    0xc(%ebp),%edx
f010d0bf:	89 14 85 40 22 55 f0 	mov    %edx,-0xfaaddc0(,%eax,4)
}
f010d0c6:	90                   	nop
f010d0c7:	5d                   	pop    %ebp
f010d0c8:	c3                   	ret    

f010d0c9 <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010d0c9:	55                   	push   %ebp
f010d0ca:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010d0cc:	8b 45 08             	mov    0x8(%ebp),%eax
f010d0cf:	c7 04 85 40 22 55 f0 	movl   $0x0,-0xfaaddc0(,%eax,4)
f010d0d6:	00 00 00 00 
}
f010d0da:	90                   	nop
f010d0db:	5d                   	pop    %ebp
f010d0dc:	c3                   	ret    

f010d0dd <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010d0dd:	55                   	push   %ebp
f010d0de:	89 e5                	mov    %esp,%ebp
f010d0e0:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010d0e3:	8b 45 08             	mov    0x8(%ebp),%eax
f010d0e6:	8b 40 28             	mov    0x28(%eax),%eax
f010d0e9:	83 e8 20             	sub    $0x20,%eax
f010d0ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010d0ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d0f2:	8b 04 85 40 22 55 f0 	mov    -0xfaaddc0(,%eax,4),%eax
f010d0f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010d0fc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010d100:	74 0e                	je     f010d110 <irq_dispatch+0x33>
	{
		handler(tf);
f010d102:	83 ec 0c             	sub    $0xc,%esp
f010d105:	ff 75 08             	pushl  0x8(%ebp)
f010d108:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d10b:	ff d0                	call   *%eax
f010d10d:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010d110:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d113:	0f b6 c0             	movzbl %al,%eax
f010d116:	83 ec 0c             	sub    $0xc,%esp
f010d119:	50                   	push   %eax
f010d11a:	e8 c3 9c ff ff       	call   f0106de2 <pic_sendEOI>
f010d11f:	83 c4 10             	add    $0x10,%esp
}
f010d122:	90                   	nop
f010d123:	c9                   	leave  
f010d124:	c3                   	ret    

f010d125 <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010d125:	55                   	push   %ebp
f010d126:	89 e5                	mov    %esp,%ebp
f010d128:	57                   	push   %edi
f010d129:	56                   	push   %esi
f010d12a:	53                   	push   %ebx
f010d12b:	83 ec 1c             	sub    $0x1c,%esp
	if(tf->tf_trapno == T_PGFLT)
f010d12e:	8b 45 08             	mov    0x8(%ebp),%eax
f010d131:	8b 40 28             	mov    0x28(%eax),%eax
f010d134:	83 f8 0e             	cmp    $0xe,%eax
f010d137:	75 51                	jne    f010d18a <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010d139:	a0 80 22 55 f0       	mov    0xf0552280,%al
f010d13e:	84 c0                	test   %al,%al
f010d140:	74 1f                	je     f010d161 <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010d142:	8b 45 08             	mov    0x8(%ebp),%eax
f010d145:	8b 40 30             	mov    0x30(%eax),%eax
f010d148:	89 c2                	mov    %eax,%edx
f010d14a:	a0 80 22 55 f0       	mov    0xf0552280,%al
f010d14f:	0f b6 c0             	movzbl %al,%eax
f010d152:	01 d0                	add    %edx,%eax
f010d154:	89 c2                	mov    %eax,%edx
f010d156:	8b 45 08             	mov    0x8(%ebp),%eax
f010d159:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010d15c:	e9 0c 01 00 00       	jmp    f010d26d <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010d161:	83 ec 0c             	sub    $0xc,%esp
f010d164:	6a 01                	push   $0x1
f010d166:	e8 22 12 00 00       	call   f010e38d <isPageReplacmentAlgorithmLRU>
f010d16b:	83 c4 10             	add    $0x10,%esp
f010d16e:	85 c0                	test   %eax,%eax
f010d170:	74 05                	je     f010d177 <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010d172:	e8 de 97 ff ff       	call   f0106955 <update_WS_time_stamps>
		}
		fault_handler(tf);
f010d177:	83 ec 0c             	sub    $0xc,%esp
f010d17a:	ff 75 08             	pushl  0x8(%ebp)
f010d17d:	e8 f0 12 00 00       	call   f010e472 <fault_handler>
f010d182:	83 c4 10             	add    $0x10,%esp
f010d185:	e9 e3 00 00 00       	jmp    f010d26d <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010d18a:	8b 45 08             	mov    0x8(%ebp),%eax
f010d18d:	8b 40 28             	mov    0x28(%eax),%eax
f010d190:	83 f8 30             	cmp    $0x30,%eax
f010d193:	75 6e                	jne    f010d203 <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010d195:	8b 45 08             	mov    0x8(%ebp),%eax
f010d198:	8b 40 38             	mov    0x38(%eax),%eax
f010d19b:	25 00 02 00 00       	and    $0x200,%eax
f010d1a0:	85 c0                	test   %eax,%eax
f010d1a2:	74 06                	je     f010d1aa <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010d1a4:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010d1a5:	e8 24 78 ff ff       	call   f01049ce <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010d1aa:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1ad:	8b 78 04             	mov    0x4(%eax),%edi
f010d1b0:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1b3:	8b 30                	mov    (%eax),%esi
f010d1b5:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1b8:	8b 58 10             	mov    0x10(%eax),%ebx
f010d1bb:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1be:	8b 48 18             	mov    0x18(%eax),%ecx
f010d1c1:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1c4:	8b 50 14             	mov    0x14(%eax),%edx
f010d1c7:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1ca:	8b 40 1c             	mov    0x1c(%eax),%eax
f010d1cd:	83 ec 08             	sub    $0x8,%esp
f010d1d0:	57                   	push   %edi
f010d1d1:	56                   	push   %esi
f010d1d2:	53                   	push   %ebx
f010d1d3:	51                   	push   %ecx
f010d1d4:	52                   	push   %edx
f010d1d5:	50                   	push   %eax
f010d1d6:	e8 23 09 00 00       	call   f010dafe <syscall>
f010d1db:	83 c4 20             	add    $0x20,%esp
f010d1de:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010d1e1:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1e4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010d1e7:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d1ea:	9c                   	pushf  
f010d1eb:	58                   	pop    %eax
f010d1ec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010d1ef:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010d1f2:	25 00 02 00 00       	and    $0x200,%eax
f010d1f7:	85 c0                	test   %eax,%eax
f010d1f9:	74 72                	je     f010d26d <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010d1fb:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010d1fc:	e8 a5 77 ff ff       	call   f01049a6 <kclock_stop>
f010d201:	eb 6a                	jmp    f010d26d <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010d203:	8b 45 08             	mov    0x8(%ebp),%eax
f010d206:	8b 40 28             	mov    0x28(%eax),%eax
f010d209:	83 f8 08             	cmp    $0x8,%eax
f010d20c:	75 17                	jne    f010d225 <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010d20e:	83 ec 04             	sub    $0x4,%esp
f010d211:	68 e7 65 12 f0       	push   $0xf01265e7
f010d216:	68 22 01 00 00       	push   $0x122
f010d21b:	68 f6 65 12 f0       	push   $0xf01265f6
f010d220:	e8 f5 30 ff ff       	call   f010031a <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010d225:	83 ec 0c             	sub    $0xc,%esp
f010d228:	ff 75 08             	pushl  0x8(%ebp)
f010d22b:	e8 a3 fc ff ff       	call   f010ced3 <print_trapframe>
f010d230:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010d233:	8b 45 08             	mov    0x8(%ebp),%eax
f010d236:	8b 40 34             	mov    0x34(%eax),%eax
f010d239:	66 83 f8 08          	cmp    $0x8,%ax
f010d23d:	75 17                	jne    f010d256 <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010d23f:	83 ec 04             	sub    $0x4,%esp
f010d242:	68 07 66 12 f0       	push   $0xf0126607
f010d247:	68 2a 01 00 00       	push   $0x12a
f010d24c:	68 f6 65 12 f0       	push   $0xf01265f6
f010d251:	e8 c4 30 ff ff       	call   f010031a <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010d256:	83 ec 04             	sub    $0x4,%esp
f010d259:	68 20 66 12 f0       	push   $0xf0126620
f010d25e:	68 2f 01 00 00       	push   $0x12f
f010d263:	68 f6 65 12 f0       	push   $0xf01265f6
f010d268:	e8 ad 30 ff ff       	call   f010031a <_panic>
		}
	}
}
f010d26d:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010d270:	5b                   	pop    %ebx
f010d271:	5e                   	pop    %esi
f010d272:	5f                   	pop    %edi
f010d273:	5d                   	pop    %ebp
f010d274:	c3                   	ret    

f010d275 <trap>:

void trap(struct Trapframe *tf)
{
f010d275:	55                   	push   %ebp
f010d276:	89 e5                	mov    %esp,%ebp
f010d278:	83 ec 28             	sub    $0x28,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010d27b:	e8 26 77 ff ff       	call   f01049a6 <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d280:	9c                   	pushf  
f010d281:	58                   	pop    %eax
f010d282:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return eflags;
f010d285:	8b 45 e0             	mov    -0x20(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010d288:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (flags & FL_IF)
f010d28b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d28e:	25 00 02 00 00       	and    $0x200,%eax
f010d293:	85 c0                	test   %eax,%eax
f010d295:	74 25                	je     f010d2bc <trap+0x47>
	{
		print_trapframe(tf);
f010d297:	83 ec 0c             	sub    $0xc,%esp
f010d29a:	ff 75 08             	pushl  0x8(%ebp)
f010d29d:	e8 31 fc ff ff       	call   f010ced3 <print_trapframe>
f010d2a2:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010d2a5:	83 ec 04             	sub    $0x4,%esp
f010d2a8:	68 40 66 12 f0       	push   $0xf0126640
f010d2ad:	68 45 01 00 00       	push   $0x145
f010d2b2:	68 f6 65 12 f0       	push   $0xf01265f6
f010d2b7:	e8 5e 30 ff ff       	call   f010031a <_panic>
	}

	int userTrap = 0;
f010d2bc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010d2c3:	e8 c6 d1 ff ff       	call   f010a48e <get_cpu_proc>
f010d2c8:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010d2cb:	8b 45 08             	mov    0x8(%ebp),%eax
f010d2ce:	8b 40 34             	mov    0x34(%eax),%eax
f010d2d1:	0f b7 c0             	movzwl %ax,%eax
f010d2d4:	83 e0 03             	and    $0x3,%eax
f010d2d7:	83 f8 03             	cmp    $0x3,%eax
f010d2da:	75 54                	jne    f010d330 <trap+0xbb>
	{
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010d2dc:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010d2e0:	74 0b                	je     f010d2ed <trap+0x78>
f010d2e2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d2e5:	8b 40 18             	mov    0x18(%eax),%eax
f010d2e8:	83 f8 02             	cmp    $0x2,%eax
f010d2eb:	74 19                	je     f010d306 <trap+0x91>
f010d2ed:	68 84 66 12 f0       	push   $0xf0126684
f010d2f2:	68 b2 66 12 f0       	push   $0xf01266b2
f010d2f7:	68 4d 01 00 00       	push   $0x14d
f010d2fc:	68 f6 65 12 f0       	push   $0xf01265f6
f010d301:	e8 14 30 ff ff       	call   f010031a <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
f010d306:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d309:	8b 00                	mov    (%eax),%eax
f010d30b:	3b 45 08             	cmp    0x8(%ebp),%eax
f010d30e:	74 19                	je     f010d329 <trap+0xb4>
f010d310:	68 c7 66 12 f0       	push   $0xf01266c7
f010d315:	68 b2 66 12 f0       	push   $0xf01266b2
f010d31a:	68 4f 01 00 00       	push   $0x14f
f010d31f:	68 f6 65 12 f0       	push   $0xf01265f6
f010d324:	e8 f1 2f ff ff       	call   f010031a <_panic>
		userTrap = 1;
f010d329:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010d330:	8b 45 08             	mov    0x8(%ebp),%eax
f010d333:	8b 40 28             	mov    0x28(%eax),%eax
f010d336:	83 f8 1f             	cmp    $0x1f,%eax
f010d339:	76 1b                	jbe    f010d356 <trap+0xe1>
f010d33b:	8b 45 08             	mov    0x8(%ebp),%eax
f010d33e:	8b 40 28             	mov    0x28(%eax),%eax
f010d341:	83 f8 2f             	cmp    $0x2f,%eax
f010d344:	77 10                	ja     f010d356 <trap+0xe1>
	{
		irq_dispatch(tf);
f010d346:	83 ec 0c             	sub    $0xc,%esp
f010d349:	ff 75 08             	pushl  0x8(%ebp)
f010d34c:	e8 8c fd ff ff       	call   f010d0dd <irq_dispatch>
f010d351:	83 c4 10             	add    $0x10,%esp
f010d354:	eb 0e                	jmp    f010d364 <trap+0xef>
	}
	else
	{
		trap_dispatch(tf);
f010d356:	83 ec 0c             	sub    $0xc,%esp
f010d359:	ff 75 08             	pushl  0x8(%ebp)
f010d35c:	e8 c4 fd ff ff       	call   f010d125 <trap_dispatch>
f010d361:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d364:	9c                   	pushf  
f010d365:	58                   	pop    %eax
f010d366:	89 45 f4             	mov    %eax,-0xc(%ebp)
        return eflags;
f010d369:	8b 45 f4             	mov    -0xc(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010d36c:	25 00 02 00 00       	and    $0x200,%eax
f010d371:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(IEN == 0);
f010d374:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010d378:	74 19                	je     f010d393 <trap+0x11e>
f010d37a:	68 dd 66 12 f0       	push   $0xf01266dd
f010d37f:	68 b2 66 12 f0       	push   $0xf01266b2
f010d384:	68 66 01 00 00       	push   $0x166
f010d389:	68 f6 65 12 f0       	push   $0xf01265f6
f010d38e:	e8 87 2f ff ff       	call   f010031a <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010d393:	e8 36 76 ff ff       	call   f01049ce <kclock_resume>
	//	cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010d398:	90                   	nop
f010d399:	c9                   	leave  
f010d39a:	c3                   	ret    
f010d39b:	90                   	nop

f010d39c <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010d39c:	6a 08                	push   $0x8
f010d39e:	e9 ed 00 00 00       	jmp    f010d490 <_alltraps>
f010d3a3:	90                   	nop

f010d3a4 <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010d3a4:	6a 0e                	push   $0xe
f010d3a6:	e9 e5 00 00 00       	jmp    f010d490 <_alltraps>
f010d3ab:	90                   	nop

f010d3ac <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010d3ac:	6a 00                	push   $0x0
f010d3ae:	6a 20                	push   $0x20
f010d3b0:	e9 db 00 00 00       	jmp    f010d490 <_alltraps>
f010d3b5:	90                   	nop

f010d3b6 <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010d3b6:	6a 00                	push   $0x0
f010d3b8:	6a 21                	push   $0x21
f010d3ba:	e9 d1 00 00 00       	jmp    f010d490 <_alltraps>
f010d3bf:	90                   	nop

f010d3c0 <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010d3c0:	6a 00                	push   $0x0
f010d3c2:	6a 30                	push   $0x30
f010d3c4:	e9 c7 00 00 00       	jmp    f010d490 <_alltraps>
f010d3c9:	90                   	nop

f010d3ca <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010d3ca:	6a 00                	push   $0x0
f010d3cc:	6a 00                	push   $0x0
f010d3ce:	e9 bd 00 00 00       	jmp    f010d490 <_alltraps>
f010d3d3:	90                   	nop

f010d3d4 <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010d3d4:	6a 00                	push   $0x0
f010d3d6:	6a 01                	push   $0x1
f010d3d8:	e9 b3 00 00 00       	jmp    f010d490 <_alltraps>
f010d3dd:	90                   	nop

f010d3de <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010d3de:	6a 00                	push   $0x0
f010d3e0:	6a 02                	push   $0x2
f010d3e2:	e9 a9 00 00 00       	jmp    f010d490 <_alltraps>
f010d3e7:	90                   	nop

f010d3e8 <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010d3e8:	6a 00                	push   $0x0
f010d3ea:	6a 03                	push   $0x3
f010d3ec:	e9 9f 00 00 00       	jmp    f010d490 <_alltraps>
f010d3f1:	90                   	nop

f010d3f2 <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010d3f2:	6a 00                	push   $0x0
f010d3f4:	6a 04                	push   $0x4
f010d3f6:	e9 95 00 00 00       	jmp    f010d490 <_alltraps>
f010d3fb:	90                   	nop

f010d3fc <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010d3fc:	6a 00                	push   $0x0
f010d3fe:	6a 05                	push   $0x5
f010d400:	e9 8b 00 00 00       	jmp    f010d490 <_alltraps>
f010d405:	90                   	nop

f010d406 <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010d406:	6a 00                	push   $0x0
f010d408:	6a 06                	push   $0x6
f010d40a:	e9 81 00 00 00       	jmp    f010d490 <_alltraps>
f010d40f:	90                   	nop

f010d410 <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010d410:	6a 00                	push   $0x0
f010d412:	6a 07                	push   $0x7
f010d414:	eb 7a                	jmp    f010d490 <_alltraps>

f010d416 <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010d416:	6a 0a                	push   $0xa
f010d418:	eb 76                	jmp    f010d490 <_alltraps>

f010d41a <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010d41a:	6a 0b                	push   $0xb
f010d41c:	eb 72                	jmp    f010d490 <_alltraps>

f010d41e <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010d41e:	6a 0c                	push   $0xc
f010d420:	eb 6e                	jmp    f010d490 <_alltraps>

f010d422 <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010d422:	6a 0d                	push   $0xd
f010d424:	eb 6a                	jmp    f010d490 <_alltraps>

f010d426 <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010d426:	6a 00                	push   $0x0
f010d428:	6a 10                	push   $0x10
f010d42a:	eb 64                	jmp    f010d490 <_alltraps>

f010d42c <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010d42c:	6a 11                	push   $0x11
f010d42e:	eb 60                	jmp    f010d490 <_alltraps>

f010d430 <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010d430:	6a 00                	push   $0x0
f010d432:	6a 12                	push   $0x12
f010d434:	eb 5a                	jmp    f010d490 <_alltraps>

f010d436 <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010d436:	6a 00                	push   $0x0
f010d438:	6a 13                	push   $0x13
f010d43a:	eb 54                	jmp    f010d490 <_alltraps>

f010d43c <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010d43c:	6a 00                	push   $0x0
f010d43e:	6a 22                	push   $0x22
f010d440:	eb 4e                	jmp    f010d490 <_alltraps>

f010d442 <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010d442:	6a 00                	push   $0x0
f010d444:	6a 23                	push   $0x23
f010d446:	eb 48                	jmp    f010d490 <_alltraps>

f010d448 <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010d448:	6a 00                	push   $0x0
f010d44a:	6a 24                	push   $0x24
f010d44c:	eb 42                	jmp    f010d490 <_alltraps>

f010d44e <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010d44e:	6a 00                	push   $0x0
f010d450:	6a 25                	push   $0x25
f010d452:	eb 3c                	jmp    f010d490 <_alltraps>

f010d454 <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010d454:	6a 00                	push   $0x0
f010d456:	6a 26                	push   $0x26
f010d458:	eb 36                	jmp    f010d490 <_alltraps>

f010d45a <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010d45a:	6a 00                	push   $0x0
f010d45c:	6a 27                	push   $0x27
f010d45e:	eb 30                	jmp    f010d490 <_alltraps>

f010d460 <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010d460:	6a 00                	push   $0x0
f010d462:	6a 28                	push   $0x28
f010d464:	eb 2a                	jmp    f010d490 <_alltraps>

f010d466 <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010d466:	6a 00                	push   $0x0
f010d468:	6a 29                	push   $0x29
f010d46a:	eb 24                	jmp    f010d490 <_alltraps>

f010d46c <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010d46c:	6a 00                	push   $0x0
f010d46e:	6a 2a                	push   $0x2a
f010d470:	eb 1e                	jmp    f010d490 <_alltraps>

f010d472 <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010d472:	6a 00                	push   $0x0
f010d474:	6a 2b                	push   $0x2b
f010d476:	eb 18                	jmp    f010d490 <_alltraps>

f010d478 <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010d478:	6a 00                	push   $0x0
f010d47a:	6a 2c                	push   $0x2c
f010d47c:	eb 12                	jmp    f010d490 <_alltraps>

f010d47e <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010d47e:	6a 00                	push   $0x0
f010d480:	6a 2d                	push   $0x2d
f010d482:	eb 0c                	jmp    f010d490 <_alltraps>

f010d484 <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010d484:	6a 00                	push   $0x0
f010d486:	6a 2e                	push   $0x2e
f010d488:	eb 06                	jmp    f010d490 <_alltraps>

f010d48a <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010d48a:	6a 00                	push   $0x0
f010d48c:	6a 2f                	push   $0x2f
f010d48e:	eb 00                	jmp    f010d490 <_alltraps>

f010d490 <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010d490:	1e                   	push   %ds
push 	%es
f010d491:	06                   	push   %es
pushal
f010d492:	60                   	pusha  

mov 	$(GD_KD), %ax
f010d493:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010d497:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010d499:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010d49b:	54                   	push   %esp
call 	trap
f010d49c:	e8 d4 fd ff ff       	call   f010d275 <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010d4a1:	59                   	pop    %ecx

f010d4a2 <trapret>:
.globl trapret
trapret:
popal
f010d4a2:	61                   	popa   
pop 	%es
f010d4a3:	07                   	pop    %es
pop 	%ds
f010d4a4:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010d4a5:	83 c4 08             	add    $0x8,%esp
iret
f010d4a8:	cf                   	iret   

f010d4a9 <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f010d4a9:	55                   	push   %ebp
f010d4aa:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010d4ac:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4af:	8b 15 20 4f 55 f0    	mov    0xf0554f20,%edx
f010d4b5:	29 d0                	sub    %edx,%eax
f010d4b7:	c1 f8 03             	sar    $0x3,%eax
f010d4ba:	89 c2                	mov    %eax,%edx
f010d4bc:	89 d0                	mov    %edx,%eax
f010d4be:	c1 e0 02             	shl    $0x2,%eax
f010d4c1:	01 d0                	add    %edx,%eax
f010d4c3:	c1 e0 02             	shl    $0x2,%eax
f010d4c6:	01 d0                	add    %edx,%eax
f010d4c8:	c1 e0 02             	shl    $0x2,%eax
f010d4cb:	01 d0                	add    %edx,%eax
f010d4cd:	89 c1                	mov    %eax,%ecx
f010d4cf:	c1 e1 08             	shl    $0x8,%ecx
f010d4d2:	01 c8                	add    %ecx,%eax
f010d4d4:	89 c1                	mov    %eax,%ecx
f010d4d6:	c1 e1 10             	shl    $0x10,%ecx
f010d4d9:	01 c8                	add    %ecx,%eax
f010d4db:	01 c0                	add    %eax,%eax
f010d4dd:	01 d0                	add    %edx,%eax
}
f010d4df:	5d                   	pop    %ebp
f010d4e0:	c3                   	ret    

f010d4e1 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010d4e1:	55                   	push   %ebp
f010d4e2:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010d4e4:	ff 75 08             	pushl  0x8(%ebp)
f010d4e7:	e8 bd ff ff ff       	call   f010d4a9 <to_frame_number>
f010d4ec:	83 c4 04             	add    $0x4,%esp
f010d4ef:	c1 e0 0c             	shl    $0xc,%eax
}
f010d4f2:	c9                   	leave  
f010d4f3:	c3                   	ret    

f010d4f4 <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName)
{
f010d4f4:	55                   	push   %ebp
f010d4f5:	89 e5                	mov    %esp,%ebp
f010d4f7:	83 ec 18             	sub    $0x18,%esp
f010d4fa:	8b 45 10             	mov    0x10(%ebp),%eax
f010d4fd:	88 45 f4             	mov    %al,-0xc(%ebp)
	//2024 - better to use locks instead (to support multiprocessors)
	pushcli();	//disable interrupts
f010d500:	e8 d9 99 ff ff       	call   f0106ede <pushcli>
		// Destroy the environment if not.

		// LAB 3: Your code here.

		// Print the string supplied by the user.
		if (printProgName)
f010d505:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
f010d509:	74 23                	je     f010d52e <sys_cputs+0x3a>
			cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f010d50b:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d510:	8b 40 10             	mov    0x10(%eax),%eax
f010d513:	8b 15 c4 36 57 f0    	mov    0xf05736c4,%edx
f010d519:	83 c2 20             	add    $0x20,%edx
f010d51c:	83 ec 04             	sub    $0x4,%esp
f010d51f:	50                   	push   %eax
f010d520:	52                   	push   %edx
f010d521:	68 90 68 12 f0       	push   $0xf0126890
f010d526:	e8 41 3a ff ff       	call   f0100f6c <cprintf>
f010d52b:	83 c4 10             	add    $0x10,%esp
		cprintf("%.*s",len, s);
f010d52e:	83 ec 04             	sub    $0x4,%esp
f010d531:	ff 75 08             	pushl  0x8(%ebp)
f010d534:	ff 75 0c             	pushl  0xc(%ebp)
f010d537:	68 99 68 12 f0       	push   $0xf0126899
f010d53c:	e8 2b 3a ff ff       	call   f0100f6c <cprintf>
f010d541:	83 c4 10             	add    $0x10,%esp
	}
	popcli();	//enable interrupts
f010d544:	e8 e7 99 ff ff       	call   f0106f30 <popcli>
}
f010d549:	90                   	nop
f010d54a:	c9                   	leave  
f010d54b:	c3                   	ret    

f010d54c <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f010d54c:	55                   	push   %ebp
f010d54d:	89 e5                	mov    %esp,%ebp
f010d54f:	83 ec 18             	sub    $0x18,%esp
f010d552:	8b 45 08             	mov    0x8(%ebp),%eax
f010d555:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f010d558:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010d55c:	83 ec 08             	sub    $0x8,%esp
f010d55f:	50                   	push   %eax
f010d560:	68 9e 68 12 f0       	push   $0xf012689e
f010d565:	e8 02 3a ff ff       	call   f0100f6c <cprintf>
f010d56a:	83 c4 10             	add    $0x10,%esp
}
f010d56d:	90                   	nop
f010d56e:	c9                   	leave  
f010d56f:	c3                   	ret    

f010d570 <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f010d570:	55                   	push   %ebp
f010d571:	89 e5                	mov    %esp,%ebp
f010d573:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d576:	9c                   	pushf  
f010d577:	58                   	pop    %eax
f010d578:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010d57b:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010d57e:	25 00 02 00 00       	and    $0x200,%eax
f010d583:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010d586:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010d58a:	74 10                	je     f010d59c <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f010d58c:	e8 14 38 ff ff       	call   f0100da5 <cons_getc2>
f010d591:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d594:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d598:	74 f2                	je     f010d58c <sys_cgetc+0x1c>
f010d59a:	eb 0e                	jmp    f010d5aa <sys_cgetc+0x3a>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f010d59c:	e8 a9 37 ff ff       	call   f0100d4a <cons_getc>
f010d5a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d5a4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d5a8:	74 f2                	je     f010d59c <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010d5aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010d5ad:	c9                   	leave  
f010d5ae:	c3                   	ret    

f010d5af <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f010d5af:	55                   	push   %ebp
f010d5b0:	89 e5                	mov    %esp,%ebp
f010d5b2:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010d5b5:	e8 d7 38 ff ff       	call   f0100e91 <cons_lock>
}
f010d5ba:	90                   	nop
f010d5bb:	c9                   	leave  
f010d5bc:	c3                   	ret    

f010d5bd <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f010d5bd:	55                   	push   %ebp
f010d5be:	89 e5                	mov    %esp,%ebp
f010d5c0:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010d5c3:	e8 10 39 ff ff       	call   f0100ed8 <cons_unlock>
}
f010d5c8:	90                   	nop
f010d5c9:	c9                   	leave  
f010d5ca:	c3                   	ret    

f010d5cb <__sys_allocate_page>:
//	E_INVAL if va >= UTOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f010d5cb:	55                   	push   %ebp
f010d5cc:	89 e5                	mov    %esp,%ebp
f010d5ce:	83 ec 28             	sub    $0x28,%esp
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	int r;
	struct Env *e = cur_env;
f010d5d1:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d5d6:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//if ((r = envid2env(envid, &e, 1)) < 0)
	//return r;

	struct FrameInfo *ptr_frame_info ;
	r = allocate_frame(&ptr_frame_info) ;
f010d5d9:	83 ec 0c             	sub    $0xc,%esp
f010d5dc:	8d 45 e0             	lea    -0x20(%ebp),%eax
f010d5df:	50                   	push   %eax
f010d5e0:	e8 09 a9 ff ff       	call   f0107eee <allocate_frame>
f010d5e5:	83 c4 10             	add    $0x10,%esp
f010d5e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010d5eb:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010d5ef:	75 08                	jne    f010d5f9 <__sys_allocate_page+0x2e>
		return r ;
f010d5f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d5f4:	e9 d0 00 00 00       	jmp    f010d6c9 <__sys_allocate_page+0xfe>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f010d5f9:	8b 45 08             	mov    0x8(%ebp),%eax
f010d5fc:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010d601:	77 0c                	ja     f010d60f <__sys_allocate_page+0x44>
f010d603:	8b 45 08             	mov    0x8(%ebp),%eax
f010d606:	25 ff 0f 00 00       	and    $0xfff,%eax
f010d60b:	85 c0                	test   %eax,%eax
f010d60d:	74 0a                	je     f010d619 <__sys_allocate_page+0x4e>
		return E_INVAL;
f010d60f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010d614:	e9 b0 00 00 00       	jmp    f010d6c9 <__sys_allocate_page+0xfe>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010d619:	8b 45 0c             	mov    0xc(%ebp),%eax
f010d61c:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010d621:	83 f8 04             	cmp    $0x4,%eax
f010d624:	74 0a                	je     f010d630 <__sys_allocate_page+0x65>
		return E_INVAL;
f010d626:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010d62b:	e9 99 00 00 00       	jmp    f010d6c9 <__sys_allocate_page+0xfe>


	uint32 physical_address = to_physical_address(ptr_frame_info) ;
f010d630:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010d633:	83 ec 0c             	sub    $0xc,%esp
f010d636:	50                   	push   %eax
f010d637:	e8 a5 fe ff ff       	call   f010d4e1 <to_physical_address>
f010d63c:	83 c4 10             	add    $0x10,%esp
f010d63f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//return it to the original status
		ptr_frame_info->references -= 1;
	}
#else
	{
		memset(STATIC_KERNEL_VIRTUAL_ADDRESS(physical_address), 0, PAGE_SIZE);
f010d642:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010d645:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010d648:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d64b:	c1 e8 0c             	shr    $0xc,%eax
f010d64e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010d651:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f010d656:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010d659:	72 17                	jb     f010d672 <__sys_allocate_page+0xa7>
f010d65b:	ff 75 e8             	pushl  -0x18(%ebp)
f010d65e:	68 a4 68 12 f0       	push   $0xf01268a4
f010d663:	68 b5 00 00 00       	push   $0xb5
f010d668:	68 d3 68 12 f0       	push   $0xf01268d3
f010d66d:	e8 a8 2c ff ff       	call   f010031a <_panic>
f010d672:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d675:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010d67a:	83 ec 04             	sub    $0x4,%esp
f010d67d:	68 00 10 00 00       	push   $0x1000
f010d682:	6a 00                	push   $0x0
f010d684:	50                   	push   %eax
f010d685:	e8 b5 30 01 00       	call   f012073f <memset>
f010d68a:	83 c4 10             	add    $0x10,%esp
	}
#endif
	r = map_frame(e->env_page_directory, ptr_frame_info, (uint32)va, perm) ;
f010d68d:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010d690:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010d693:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d696:	8b 40 64             	mov    0x64(%eax),%eax
f010d699:	ff 75 0c             	pushl  0xc(%ebp)
f010d69c:	51                   	push   %ecx
f010d69d:	52                   	push   %edx
f010d69e:	50                   	push   %eax
f010d69f:	e8 60 ac ff ff       	call   f0108304 <map_frame>
f010d6a4:	83 c4 10             	add    $0x10,%esp
f010d6a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010d6aa:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010d6ae:	75 14                	jne    f010d6c4 <__sys_allocate_page+0xf9>
	{
		decrement_references(ptr_frame_info);
f010d6b0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010d6b3:	83 ec 0c             	sub    $0xc,%esp
f010d6b6:	50                   	push   %eax
f010d6b7:	e8 3f aa ff ff       	call   f01080fb <decrement_references>
f010d6bc:	83 c4 10             	add    $0x10,%esp
		return r;
f010d6bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d6c2:	eb 05                	jmp    f010d6c9 <__sys_allocate_page+0xfe>
	}
	return 0 ;
f010d6c4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010d6c9:	c9                   	leave  
f010d6ca:	c3                   	ret    

f010d6cb <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f010d6cb:	55                   	push   %ebp
f010d6cc:	89 e5                	mov    %esp,%ebp
f010d6ce:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010d6d1:	83 ec 04             	sub    $0x4,%esp
f010d6d4:	68 e7 68 12 f0       	push   $0xf01268e7
f010d6d9:	68 dc 00 00 00       	push   $0xdc
f010d6de:	68 d3 68 12 f0       	push   $0xf01268d3
f010d6e3:	e8 32 2c ff ff       	call   f010031a <_panic>

f010d6e8 <__sys_unmap_frame>:
// Return 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int __sys_unmap_frame(int32 envid, void *va)
{
f010d6e8:	55                   	push   %ebp
f010d6e9:	89 e5                	mov    %esp,%ebp
f010d6eb:	83 ec 08             	sub    $0x8,%esp
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	panic("sys_page_unmap not implemented");
f010d6ee:	83 ec 04             	sub    $0x4,%esp
f010d6f1:	68 08 69 12 f0       	push   $0xf0126908
f010d6f6:	68 ed 00 00 00       	push   $0xed
f010d6fb:	68 d3 68 12 f0       	push   $0xf01268d3
f010d700:	e8 15 2c ff ff       	call   f010031a <_panic>

f010d705 <sys_calculate_required_frames>:
	return 0;
}

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f010d705:	55                   	push   %ebp
f010d706:	89 e5                	mov    %esp,%ebp
f010d708:	83 ec 08             	sub    $0x8,%esp
	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f010d70b:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d710:	8b 40 64             	mov    0x64(%eax),%eax
f010d713:	83 ec 04             	sub    $0x4,%esp
f010d716:	ff 75 0c             	pushl  0xc(%ebp)
f010d719:	ff 75 08             	pushl  0x8(%ebp)
f010d71c:	50                   	push   %eax
f010d71d:	e8 4e bd ff ff       	call   f0109470 <calculate_required_frames>
f010d722:	83 c4 10             	add    $0x10,%esp
}
f010d725:	c9                   	leave  
f010d726:	c3                   	ret    

f010d727 <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f010d727:	55                   	push   %ebp
f010d728:	89 e5                	mov    %esp,%ebp
f010d72a:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010d72d:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010d730:	83 ec 0c             	sub    $0xc,%esp
f010d733:	50                   	push   %eax
f010d734:	e8 83 ae ff ff       	call   f01085bc <calculate_available_frames>
f010d739:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010d73c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010d73f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d742:	01 d0                	add    %edx,%eax
}
f010d744:	c9                   	leave  
f010d745:	c3                   	ret    

f010d746 <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f010d746:	55                   	push   %ebp
f010d747:	89 e5                	mov    %esp,%ebp
f010d749:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010d74c:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010d74f:	83 ec 0c             	sub    $0xc,%esp
f010d752:	50                   	push   %eax
f010d753:	e8 64 ae ff ff       	call   f01085bc <calculate_available_frames>
f010d758:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010d75b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010d75e:	c9                   	leave  
f010d75f:	c3                   	ret    

f010d760 <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010d760:	55                   	push   %ebp
f010d761:	89 e5                	mov    %esp,%ebp
f010d763:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010d766:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010d769:	83 ec 0c             	sub    $0xc,%esp
f010d76c:	50                   	push   %eax
f010d76d:	e8 4a ae ff ff       	call   f01085bc <calculate_available_frames>
f010d772:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010d775:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010d778:	c9                   	leave  
f010d779:	c3                   	ret    

f010d77a <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f010d77a:	55                   	push   %ebp
f010d77b:	89 e5                	mov    %esp,%ebp
f010d77d:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010d780:	83 ec 0c             	sub    $0xc,%esp
f010d783:	ff 75 08             	pushl  0x8(%ebp)
f010d786:	e8 3f 1b 01 00       	call   f011f2ca <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010d78b:	83 c4 10             	add    $0x10,%esp
}
f010d78e:	c9                   	leave  
f010d78f:	c3                   	ret    

f010d790 <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f010d790:	55                   	push   %ebp
f010d791:	89 e5                	mov    %esp,%ebp
f010d793:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010d796:	e8 5a 1a 01 00       	call   f011f1f5 <scarce_memory>
}
f010d79b:	90                   	nop
f010d79c:	c9                   	leave  
f010d79d:	c3                   	ret    

f010d79e <sys_clearFFL>:

void sys_clearFFL()
{
f010d79e:	55                   	push   %ebp
f010d79f:	89 e5                	mov    %esp,%ebp
f010d7a1:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
f010d7a4:	83 ec 0c             	sub    $0xc,%esp
f010d7a7:	68 40 25 55 f0       	push   $0xf0552540
f010d7ac:	e8 ed 0f 00 00       	call   f010e79e <acquire_spinlock>
f010d7b1:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f010d7b4:	a1 2c 25 55 f0       	mov    0xf055252c,%eax
f010d7b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010d7bc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010d7c3:	eb 12                	jmp    f010d7d7 <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f010d7c5:	83 ec 0c             	sub    $0xc,%esp
f010d7c8:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010d7cb:	50                   	push   %eax
f010d7cc:	e8 1d a7 ff ff       	call   f0107eee <allocate_frame>
f010d7d1:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010d7d4:	ff 45 f4             	incl   -0xc(%ebp)
f010d7d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d7da:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010d7dd:	7c e6                	jl     f010d7c5 <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010d7df:	83 ec 0c             	sub    $0xc,%esp
f010d7e2:	68 40 25 55 f0       	push   $0xf0552540
f010d7e7:	e8 39 10 00 00       	call   f010e825 <release_spinlock>
f010d7ec:	83 c4 10             	add    $0x10,%esp
}
f010d7ef:	90                   	nop
f010d7f0:	c9                   	leave  
f010d7f1:	c3                   	ret    

f010d7f2 <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f010d7f2:	55                   	push   %ebp
f010d7f3:	89 e5                	mov    %esp,%ebp
f010d7f5:	83 ec 08             	sub    $0x8,%esp
	return pf_calculate_allocated_pages(cur_env);
f010d7f8:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d7fd:	83 ec 0c             	sub    $0xc,%esp
f010d800:	50                   	push   %eax
f010d801:	e8 87 6c ff ff       	call   f010448d <pf_calculate_allocated_pages>
f010d806:	83 c4 10             	add    $0x10,%esp
}
f010d809:	c9                   	leave  
f010d80a:	c3                   	ret    

f010d80b <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f010d80b:	55                   	push   %ebp
f010d80c:	89 e5                	mov    %esp,%ebp
f010d80e:	83 ec 08             	sub    $0x8,%esp
	if(isBufferingEnabled())
f010d811:	e8 3a 0c 00 00       	call   f010e450 <isBufferingEnabled>
f010d816:	84 c0                	test   %al,%al
f010d818:	74 19                	je     f010d833 <sys_free_user_mem+0x28>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010d81a:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d81f:	83 ec 04             	sub    $0x4,%esp
f010d822:	ff 75 0c             	pushl  0xc(%ebp)
f010d825:	ff 75 08             	pushl  0x8(%ebp)
f010d828:	50                   	push   %eax
f010d829:	e8 8d bc ff ff       	call   f01094bb <__free_user_mem_with_buffering>
f010d82e:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010d831:	eb 18                	jmp    f010d84b <sys_free_user_mem+0x40>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f010d833:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d838:	83 ec 04             	sub    $0x4,%esp
f010d83b:	ff 75 0c             	pushl  0xc(%ebp)
f010d83e:	ff 75 08             	pushl  0x8(%ebp)
f010d841:	50                   	push   %eax
f010d842:	e8 66 bc ff ff       	call   f01094ad <free_user_mem>
f010d847:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010d84a:	90                   	nop
}
f010d84b:	c9                   	leave  
f010d84c:	c3                   	ret    

f010d84d <sys_allocate_user_mem>:

void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f010d84d:	55                   	push   %ebp
f010d84e:	89 e5                	mov    %esp,%ebp
f010d850:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation

	allocate_user_mem(cur_env, virtual_address, size);
f010d853:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d858:	83 ec 04             	sub    $0x4,%esp
f010d85b:	ff 75 0c             	pushl  0xc(%ebp)
f010d85e:	ff 75 08             	pushl  0x8(%ebp)
f010d861:	50                   	push   %eax
f010d862:	e8 38 bc ff ff       	call   f010949f <allocate_user_mem>
f010d867:	83 c4 10             	add    $0x10,%esp
	return;
f010d86a:	90                   	nop
}
f010d86b:	c9                   	leave  
f010d86c:	c3                   	ret    

f010d86d <sys_allocate_chunk>:

void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f010d86d:	55                   	push   %ebp
f010d86e:	89 e5                	mov    %esp,%ebp
f010d870:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation

	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010d873:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d878:	8b 40 64             	mov    0x64(%eax),%eax
f010d87b:	ff 75 10             	pushl  0x10(%ebp)
f010d87e:	ff 75 0c             	pushl  0xc(%ebp)
f010d881:	ff 75 08             	pushl  0x8(%ebp)
f010d884:	50                   	push   %eax
f010d885:	e8 b2 bb ff ff       	call   f010943c <allocate_chunk>
f010d88a:	83 c4 10             	add    $0x10,%esp
	return;
f010d88d:	90                   	nop
}
f010d88e:	c9                   	leave  
f010d88f:	c3                   	ret    

f010d890 <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010d890:	55                   	push   %ebp
f010d891:	89 e5                	mov    %esp,%ebp
f010d893:	83 ec 08             	sub    $0x8,%esp
	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010d896:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d89b:	ff 75 10             	pushl  0x10(%ebp)
f010d89e:	ff 75 0c             	pushl  0xc(%ebp)
f010d8a1:	ff 75 08             	pushl  0x8(%ebp)
f010d8a4:	50                   	push   %eax
f010d8a5:	e8 2e bc ff ff       	call   f01094d8 <move_user_mem>
f010d8aa:	83 c4 10             	add    $0x10,%esp
	return;
f010d8ad:	90                   	nop
}
f010d8ae:	c9                   	leave  
f010d8af:	c3                   	ret    

f010d8b0 <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010d8b0:	55                   	push   %ebp
f010d8b1:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f010d8b3:	a1 04 4f 55 f0       	mov    0xf0554f04,%eax
}
f010d8b8:	5d                   	pop    %ebp
f010d8b9:	c3                   	ret    

f010d8ba <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f010d8ba:	55                   	push   %ebp
f010d8bb:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010d8bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010d8c0:	a3 04 4f 55 f0       	mov    %eax,0xf0554f04
}
f010d8c5:	90                   	nop
f010d8c6:	5d                   	pop    %ebp
f010d8c7:	c3                   	ret    

f010d8c8 <sys_createSharedObject>:

/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_createSharedObject(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010d8c8:	55                   	push   %ebp
f010d8c9:	89 e5                	mov    %esp,%ebp
f010d8cb:	83 ec 18             	sub    $0x18,%esp
f010d8ce:	8b 45 10             	mov    0x10(%ebp),%eax
f010d8d1:	88 45 f4             	mov    %al,-0xc(%ebp)
	return createSharedObject(cur_env->env_id, shareName, size, isWritable, virtual_address);
f010d8d4:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
f010d8d8:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d8dd:	8b 40 10             	mov    0x10(%eax),%eax
f010d8e0:	83 ec 0c             	sub    $0xc,%esp
f010d8e3:	ff 75 14             	pushl  0x14(%ebp)
f010d8e6:	52                   	push   %edx
f010d8e7:	ff 75 0c             	pushl  0xc(%ebp)
f010d8ea:	ff 75 08             	pushl  0x8(%ebp)
f010d8ed:	50                   	push   %eax
f010d8ee:	e8 34 ae ff ff       	call   f0108727 <createSharedObject>
f010d8f3:	83 c4 20             	add    $0x20,%esp
}
f010d8f6:	c9                   	leave  
f010d8f7:	c3                   	ret    

f010d8f8 <sys_getSizeOfSharedObject>:

int sys_getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f010d8f8:	55                   	push   %ebp
f010d8f9:	89 e5                	mov    %esp,%ebp
f010d8fb:	83 ec 08             	sub    $0x8,%esp
	return getSizeOfSharedObject(ownerID, shareName);
f010d8fe:	83 ec 08             	sub    $0x8,%esp
f010d901:	ff 75 0c             	pushl  0xc(%ebp)
f010d904:	ff 75 08             	pushl  0x8(%ebp)
f010d907:	e8 3b ae ff ff       	call   f0108747 <getSizeOfSharedObject>
f010d90c:	83 c4 10             	add    $0x10,%esp
}
f010d90f:	c9                   	leave  
f010d910:	c3                   	ret    

f010d911 <sys_getSharedObject>:

int sys_getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f010d911:	55                   	push   %ebp
f010d912:	89 e5                	mov    %esp,%ebp
f010d914:	83 ec 08             	sub    $0x8,%esp
	return getSharedObject(ownerID, shareName, virtual_address);
f010d917:	83 ec 04             	sub    $0x4,%esp
f010d91a:	ff 75 10             	pushl  0x10(%ebp)
f010d91d:	ff 75 0c             	pushl  0xc(%ebp)
f010d920:	ff 75 08             	pushl  0x8(%ebp)
f010d923:	e8 4e ae ff ff       	call   f0108776 <getSharedObject>
f010d928:	83 c4 10             	add    $0x10,%esp
}
f010d92b:	c9                   	leave  
f010d92c:	c3                   	ret    

f010d92d <sys_freeSharedObject>:

int sys_freeSharedObject(int32 sharedObjectID, void *startVA)
{
f010d92d:	55                   	push   %ebp
f010d92e:	89 e5                	mov    %esp,%ebp
f010d930:	83 ec 08             	sub    $0x8,%esp
	return freeSharedObject(sharedObjectID, startVA);
f010d933:	83 ec 08             	sub    $0x8,%esp
f010d936:	ff 75 0c             	pushl  0xc(%ebp)
f010d939:	ff 75 08             	pushl  0x8(%ebp)
f010d93c:	e8 52 ae ff ff       	call   f0108793 <freeSharedObject>
f010d941:	83 c4 10             	add    $0x10,%esp
}
f010d944:	c9                   	leave  
f010d945:	c3                   	ret    

f010d946 <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f010d946:	55                   	push   %ebp
f010d947:	89 e5                	mov    %esp,%ebp
	return cur_env->env_id;
f010d949:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d94e:	8b 40 10             	mov    0x10(%eax),%eax
}
f010d951:	5d                   	pop    %ebp
f010d952:	c3                   	ret    

f010d953 <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f010d953:	55                   	push   %ebp
f010d954:	89 e5                	mov    %esp,%ebp
	//return cur_env->env_id;
	return (cur_env - envs) ;
f010d956:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d95b:	89 c2                	mov    %eax,%edx
f010d95d:	a1 10 1a 55 f0       	mov    0xf0551a10,%eax
f010d962:	29 c2                	sub    %eax,%edx
f010d964:	89 d0                	mov    %edx,%eax
f010d966:	c1 f8 02             	sar    $0x2,%eax
f010d969:	89 c2                	mov    %eax,%edx
f010d96b:	89 d0                	mov    %edx,%eax
f010d96d:	c1 e0 02             	shl    $0x2,%eax
f010d970:	01 d0                	add    %edx,%eax
f010d972:	c1 e0 02             	shl    $0x2,%eax
f010d975:	01 d0                	add    %edx,%eax
f010d977:	c1 e0 02             	shl    $0x2,%eax
f010d97a:	01 d0                	add    %edx,%eax
f010d97c:	c1 e0 02             	shl    $0x2,%eax
f010d97f:	01 d0                	add    %edx,%eax
f010d981:	c1 e0 08             	shl    $0x8,%eax
f010d984:	29 d0                	sub    %edx,%eax
f010d986:	c1 e0 08             	shl    $0x8,%eax
f010d989:	29 d0                	sub    %edx,%eax
f010d98b:	c1 e0 03             	shl    $0x3,%eax
f010d98e:	01 d0                	add    %edx,%eax
f010d990:	c1 e0 03             	shl    $0x3,%eax
f010d993:	01 d0                	add    %edx,%eax
f010d995:	01 c0                	add    %eax,%eax
f010d997:	01 d0                	add    %edx,%eax
}
f010d999:	5d                   	pop    %ebp
f010d99a:	c3                   	ret    

f010d99b <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f010d99b:	55                   	push   %ebp
f010d99c:	89 e5                	mov    %esp,%ebp
	return cur_env->env_parent_id;
f010d99e:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d9a3:	8b 40 14             	mov    0x14(%eax),%eax
}
f010d9a6:	5d                   	pop    %ebp
f010d9a7:	c3                   	ret    

f010d9a8 <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f010d9a8:	55                   	push   %ebp
f010d9a9:	89 e5                	mov    %esp,%ebp
f010d9ab:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Env *e;
	if (envid == 0)
f010d9ae:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010d9b2:	75 0a                	jne    f010d9be <sys_destroy_env+0x16>
	{
		e = cur_env ;
f010d9b4:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d9b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010d9bc:	eb 22                	jmp    f010d9e0 <sys_destroy_env+0x38>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f010d9be:	83 ec 04             	sub    $0x4,%esp
f010d9c1:	6a 00                	push   $0x0
f010d9c3:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010d9c6:	50                   	push   %eax
f010d9c7:	ff 75 08             	pushl  0x8(%ebp)
f010d9ca:	e8 0f cb ff ff       	call   f010a4de <envid2env>
f010d9cf:	83 c4 10             	add    $0x10,%esp
f010d9d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d9d5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d9d9:	79 05                	jns    f010d9e0 <sys_destroy_env+0x38>
	{
		return r;
f010d9db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d9de:	eb 5e                	jmp    f010da3e <sys_destroy_env+0x96>
	}

	if (e == cur_env)
f010d9e0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010d9e3:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d9e8:	39 c2                	cmp    %eax,%edx
f010d9ea:	75 1b                	jne    f010da07 <sys_destroy_env+0x5f>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010d9ec:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d9f1:	8b 40 10             	mov    0x10(%eax),%eax
f010d9f4:	83 ec 08             	sub    $0x8,%esp
f010d9f7:	50                   	push   %eax
f010d9f8:	68 27 69 12 f0       	push   $0xf0126927
f010d9fd:	e8 6a 35 ff ff       	call   f0100f6c <cprintf>
f010da02:	83 c4 10             	add    $0x10,%esp
f010da05:	eb 20                	jmp    f010da27 <sys_destroy_env+0x7f>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010da07:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010da0a:	8b 50 10             	mov    0x10(%eax),%edx
f010da0d:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010da12:	8b 40 10             	mov    0x10(%eax),%eax
f010da15:	83 ec 04             	sub    $0x4,%esp
f010da18:	52                   	push   %edx
f010da19:	50                   	push   %eax
f010da1a:	68 42 69 12 f0       	push   $0xf0126942
f010da1f:	e8 48 35 ff ff       	call   f0100f6c <cprintf>
f010da24:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010da27:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010da2a:	8b 40 10             	mov    0x10(%eax),%eax
f010da2d:	83 ec 0c             	sub    $0xc,%esp
f010da30:	50                   	push   %eax
f010da31:	e8 4b 7d ff ff       	call   f0105781 <sched_kill_env>
f010da36:	83 c4 10             	add    $0x10,%esp

	return 0;
f010da39:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010da3e:	c9                   	leave  
f010da3f:	c3                   	ret    

f010da40 <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f010da40:	55                   	push   %ebp
f010da41:	89 e5                	mov    %esp,%ebp
f010da43:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010da46:	e8 01 ca ff ff       	call   f010a44c <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010da4b:	90                   	nop
f010da4c:	c9                   	leave  
f010da4d:	c3                   	ret    

f010da4e <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010da4e:	55                   	push   %ebp
f010da4f:	89 e5                	mov    %esp,%ebp
f010da51:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f010da54:	ff 75 14             	pushl  0x14(%ebp)
f010da57:	ff 75 10             	pushl  0x10(%ebp)
f010da5a:	ff 75 0c             	pushl  0xc(%ebp)
f010da5d:	ff 75 08             	pushl  0x8(%ebp)
f010da60:	e8 29 bd ff ff       	call   f010978e <env_create>
f010da65:	83 c4 10             	add    $0x10,%esp
f010da68:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f010da6b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010da6f:	75 07                	jne    f010da78 <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f010da71:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010da76:	eb 14                	jmp    f010da8c <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010da78:	83 ec 0c             	sub    $0xc,%esp
f010da7b:	ff 75 f4             	pushl  -0xc(%ebp)
f010da7e:	e8 40 79 ff ff       	call   f01053c3 <sched_new_env>
f010da83:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010da86:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010da89:	8b 40 10             	mov    0x10(%eax),%eax
}
f010da8c:	c9                   	leave  
f010da8d:	c3                   	ret    

f010da8e <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f010da8e:	55                   	push   %ebp
f010da8f:	89 e5                	mov    %esp,%ebp
f010da91:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010da94:	8b 45 08             	mov    0x8(%ebp),%eax
f010da97:	83 ec 0c             	sub    $0xc,%esp
f010da9a:	50                   	push   %eax
f010da9b:	e8 79 79 ff ff       	call   f0105419 <sched_run_env>
f010daa0:	83 c4 10             	add    $0x10,%esp
}
f010daa3:	90                   	nop
f010daa4:	c9                   	leave  
f010daa5:	c3                   	ret    

f010daa6 <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f010daa6:	55                   	push   %ebp
f010daa7:	89 e5                	mov    %esp,%ebp
f010daa9:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010daac:	0f 31                	rdtsc  
f010daae:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010dab1:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010dab4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dab7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010daba:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010dabd:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010dac0:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010dac3:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010dac6:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010dac9:	89 01                	mov    %eax,(%ecx)
f010dacb:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010dace:	8b 45 08             	mov    0x8(%ebp),%eax
f010dad1:	c9                   	leave  
f010dad2:	c2 04 00             	ret    $0x4

f010dad5 <sys_rcr2>:

uint32 sys_rcr2()
{
f010dad5:	55                   	push   %ebp
f010dad6:	89 e5                	mov    %esp,%ebp
f010dad8:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010dadb:	0f 20 d0             	mov    %cr2,%eax
f010dade:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010dae1:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010dae4:	90                   	nop
}
f010dae5:	c9                   	leave  
f010dae6:	c3                   	ret    

f010dae7 <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f010dae7:	55                   	push   %ebp
f010dae8:	89 e5                	mov    %esp,%ebp
f010daea:	83 ec 04             	sub    $0x4,%esp
f010daed:	8b 45 08             	mov    0x8(%ebp),%eax
f010daf0:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010daf3:	8a 45 fc             	mov    -0x4(%ebp),%al
f010daf6:	a2 80 22 55 f0       	mov    %al,0xf0552280
}
f010dafb:	90                   	nop
f010dafc:	c9                   	leave  
f010dafd:	c3                   	ret    

f010dafe <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f010dafe:	55                   	push   %ebp
f010daff:	89 e5                	mov    %esp,%ebp
f010db01:	56                   	push   %esi
f010db02:	53                   	push   %ebx
f010db03:	83 ec 10             	sub    $0x10,%esp
	cur_env = get_cpu_proc();
f010db06:	e8 83 c9 ff ff       	call   f010a48e <get_cpu_proc>
f010db0b:	a3 c4 36 57 f0       	mov    %eax,0xf05736c4
	assert(cur_env != NULL);
f010db10:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010db15:	85 c0                	test   %eax,%eax
f010db17:	75 19                	jne    f010db32 <syscall+0x34>
f010db19:	68 5a 69 12 f0       	push   $0xf012695a
f010db1e:	68 6a 69 12 f0       	push   $0xf012696a
f010db23:	68 f5 01 00 00       	push   $0x1f5
f010db28:	68 d3 68 12 f0       	push   $0xf01268d3
f010db2d:	e8 e8 27 ff ff       	call   f010031a <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f010db32:	83 7d 08 2b          	cmpl   $0x2b,0x8(%ebp)
f010db36:	0f 87 bc 03 00 00    	ja     f010def8 <syscall+0x3fa>
f010db3c:	8b 45 08             	mov    0x8(%ebp),%eax
f010db3f:	c1 e0 02             	shl    $0x2,%eax
f010db42:	05 80 69 12 f0       	add    $0xf0126980,%eax
f010db47:	8b 00                	mov    (%eax),%eax
f010db49:	ff e0                	jmp    *%eax
	{
	//TODO: [PROJECT'24.MS1 - #02] [2] SYSTEM CALLS - Add suitable code here

	//======================================================================
	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3);
f010db4b:	8b 45 14             	mov    0x14(%ebp),%eax
f010db4e:	0f b6 d0             	movzbl %al,%edx
f010db51:	8b 45 0c             	mov    0xc(%ebp),%eax
f010db54:	83 ec 04             	sub    $0x4,%esp
f010db57:	52                   	push   %edx
f010db58:	ff 75 10             	pushl  0x10(%ebp)
f010db5b:	50                   	push   %eax
f010db5c:	e8 93 f9 ff ff       	call   f010d4f4 <sys_cputs>
f010db61:	83 c4 10             	add    $0x10,%esp
		return 0;
f010db64:	b8 00 00 00 00       	mov    $0x0,%eax
f010db69:	e9 8f 03 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010db6e:	e8 fd f9 ff ff       	call   f010d570 <sys_cgetc>
f010db73:	e9 85 03 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010db78:	e8 32 fa ff ff       	call   f010d5af <sys_lock_cons>
		return 0;
f010db7d:	b8 00 00 00 00       	mov    $0x0,%eax
f010db82:	e9 76 03 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010db87:	e8 31 fa ff ff       	call   f010d5bd <sys_unlock_cons>
		return 0;
f010db8c:	b8 00 00 00 00       	mov    $0x0,%eax
f010db91:	e9 67 03 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010db96:	83 ec 08             	sub    $0x8,%esp
f010db99:	ff 75 10             	pushl  0x10(%ebp)
f010db9c:	ff 75 0c             	pushl  0xc(%ebp)
f010db9f:	e8 61 fb ff ff       	call   f010d705 <sys_calculate_required_frames>
f010dba4:	83 c4 10             	add    $0x10,%esp
f010dba7:	e9 51 03 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010dbac:	e8 76 fb ff ff       	call   f010d727 <sys_calculate_free_frames>
f010dbb1:	e9 47 03 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010dbb6:	e8 8b fb ff ff       	call   f010d746 <sys_calculate_modified_frames>
f010dbbb:	e9 3d 03 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010dbc0:	e8 9b fb ff ff       	call   f010d760 <sys_calculate_notmod_frames>
f010dbc5:	e9 33 03 00 00       	jmp    f010defd <syscall+0x3ff>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010dbca:	e8 23 fc ff ff       	call   f010d7f2 <sys_pf_calculate_allocated_pages>
f010dbcf:	e9 29 03 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010dbd4:	83 ec 0c             	sub    $0xc,%esp
f010dbd7:	ff 75 0c             	pushl  0xc(%ebp)
f010dbda:	e8 9b fb ff ff       	call   f010d77a <sys_calculate_pages_tobe_removed_ready_exit>
f010dbdf:	83 c4 10             	add    $0x10,%esp
f010dbe2:	e9 16 03 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010dbe7:	e8 a4 fb ff ff       	call   f010d790 <sys_scarce_memory>
		return 0;
f010dbec:	b8 00 00 00 00       	mov    $0x0,%eax
f010dbf1:	e9 07 03 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f010dbf6:	83 ec 04             	sub    $0x4,%esp
f010dbf9:	ff 75 14             	pushl  0x14(%ebp)
f010dbfc:	ff 75 10             	pushl  0x10(%ebp)
f010dbff:	ff 75 0c             	pushl  0xc(%ebp)
f010dc02:	e8 66 fc ff ff       	call   f010d86d <sys_allocate_chunk>
f010dc07:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dc0a:	b8 00 00 00 00       	mov    $0x0,%eax
f010dc0f:	e9 e9 02 00 00       	jmp    f010defd <syscall+0x3ff>
		break;

		//======================
	case SYS_allocate_page:
		__sys_allocate_page((void*)a1, a2);
f010dc14:	8b 55 10             	mov    0x10(%ebp),%edx
f010dc17:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dc1a:	83 ec 08             	sub    $0x8,%esp
f010dc1d:	52                   	push   %edx
f010dc1e:	50                   	push   %eax
f010dc1f:	e8 a7 f9 ff ff       	call   f010d5cb <__sys_allocate_page>
f010dc24:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dc27:	b8 00 00 00 00       	mov    $0x0,%eax
f010dc2c:	e9 cc 02 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010dc31:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010dc34:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010dc37:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010dc3a:	8b 55 10             	mov    0x10(%ebp),%edx
f010dc3d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dc40:	83 ec 0c             	sub    $0xc,%esp
f010dc43:	56                   	push   %esi
f010dc44:	53                   	push   %ebx
f010dc45:	51                   	push   %ecx
f010dc46:	52                   	push   %edx
f010dc47:	50                   	push   %eax
f010dc48:	e8 7e fa ff ff       	call   f010d6cb <__sys_map_frame>
f010dc4d:	83 c4 20             	add    $0x20,%esp
		return 0;
f010dc50:	b8 00 00 00 00       	mov    $0x0,%eax
f010dc55:	e9 a3 02 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	case SYS_unmap_frame:
		__sys_unmap_frame(a1, (void*)a2);
f010dc5a:	8b 55 10             	mov    0x10(%ebp),%edx
f010dc5d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dc60:	83 ec 08             	sub    $0x8,%esp
f010dc63:	52                   	push   %edx
f010dc64:	50                   	push   %eax
f010dc65:	e8 7e fa ff ff       	call   f010d6e8 <__sys_unmap_frame>
f010dc6a:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dc6d:	b8 00 00 00 00       	mov    $0x0,%eax
f010dc72:	e9 86 02 00 00       	jmp    f010defd <syscall+0x3ff>
		break;

	case SYS_cputc:
		sys_cputc((const char)a1);
f010dc77:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dc7a:	0f be c0             	movsbl %al,%eax
f010dc7d:	83 ec 0c             	sub    $0xc,%esp
f010dc80:	50                   	push   %eax
f010dc81:	e8 c6 f8 ff ff       	call   f010d54c <sys_cputc>
f010dc86:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dc89:	b8 00 00 00 00       	mov    $0x0,%eax
f010dc8e:	e9 6a 02 00 00       	jmp    f010defd <syscall+0x3ff>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f010dc93:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dc96:	0f be c0             	movsbl %al,%eax
f010dc99:	83 ec 0c             	sub    $0xc,%esp
f010dc9c:	50                   	push   %eax
f010dc9d:	e8 fc fa ff ff       	call   f010d79e <sys_clearFFL>
f010dca2:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dca5:	b8 00 00 00 00       	mov    $0x0,%eax
f010dcaa:	e9 4e 02 00 00       	jmp    f010defd <syscall+0x3ff>
		break;

	case SYS_create_shared_object:
		return sys_createSharedObject((char*)a1, a2, a3, (void*)a4);
f010dcaf:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010dcb2:	8b 45 14             	mov    0x14(%ebp),%eax
f010dcb5:	0f b6 d0             	movzbl %al,%edx
f010dcb8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dcbb:	51                   	push   %ecx
f010dcbc:	52                   	push   %edx
f010dcbd:	ff 75 10             	pushl  0x10(%ebp)
f010dcc0:	50                   	push   %eax
f010dcc1:	e8 02 fc ff ff       	call   f010d8c8 <sys_createSharedObject>
f010dcc6:	83 c4 10             	add    $0x10,%esp
f010dcc9:	e9 2f 02 00 00       	jmp    f010defd <syscall+0x3ff>
		break;

	case SYS_get_shared_object:
		return sys_getSharedObject((int32)a1, (char*)a2, (void*)a3);
f010dcce:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010dcd1:	8b 55 10             	mov    0x10(%ebp),%edx
f010dcd4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dcd7:	83 ec 04             	sub    $0x4,%esp
f010dcda:	51                   	push   %ecx
f010dcdb:	52                   	push   %edx
f010dcdc:	50                   	push   %eax
f010dcdd:	e8 2f fc ff ff       	call   f010d911 <sys_getSharedObject>
f010dce2:	83 c4 10             	add    $0x10,%esp
f010dce5:	e9 13 02 00 00       	jmp    f010defd <syscall+0x3ff>
		break;

	case SYS_free_shared_object:
		return sys_freeSharedObject((int32)a1, (void *)a2);
f010dcea:	8b 55 10             	mov    0x10(%ebp),%edx
f010dced:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dcf0:	83 ec 08             	sub    $0x8,%esp
f010dcf3:	52                   	push   %edx
f010dcf4:	50                   	push   %eax
f010dcf5:	e8 33 fc ff ff       	call   f010d92d <sys_freeSharedObject>
f010dcfa:	83 c4 10             	add    $0x10,%esp
f010dcfd:	e9 fb 01 00 00       	jmp    f010defd <syscall+0x3ff>
		break;

	case SYS_get_size_of_shared_object:
		return sys_getSizeOfSharedObject((int32)a1, (char*)a2);
f010dd02:	8b 55 10             	mov    0x10(%ebp),%edx
f010dd05:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dd08:	83 ec 08             	sub    $0x8,%esp
f010dd0b:	52                   	push   %edx
f010dd0c:	50                   	push   %eax
f010dd0d:	e8 e6 fb ff ff       	call   f010d8f8 <sys_getSizeOfSharedObject>
f010dd12:	83 c4 10             	add    $0x10,%esp
f010dd15:	e9 e3 01 00 00       	jmp    f010defd <syscall+0x3ff>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f010dd1a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dd1d:	ff 75 18             	pushl  0x18(%ebp)
f010dd20:	ff 75 14             	pushl  0x14(%ebp)
f010dd23:	ff 75 10             	pushl  0x10(%ebp)
f010dd26:	50                   	push   %eax
f010dd27:	e8 22 fd ff ff       	call   f010da4e <sys_create_env>
f010dd2c:	83 c4 10             	add    $0x10,%esp
f010dd2f:	e9 c9 01 00 00       	jmp    f010defd <syscall+0x3ff>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f010dd34:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dd37:	83 ec 0c             	sub    $0xc,%esp
f010dd3a:	50                   	push   %eax
f010dd3b:	e8 4e fd ff ff       	call   f010da8e <sys_run_env>
f010dd40:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dd43:	b8 00 00 00 00       	mov    $0x0,%eax
f010dd48:	e9 b0 01 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010dd4d:	e8 01 fc ff ff       	call   f010d953 <sys_getenvindex>
f010dd52:	e9 a6 01 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010dd57:	e8 ea fb ff ff       	call   f010d946 <sys_getenvid>
f010dd5c:	e9 9c 01 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010dd61:	e8 35 fc ff ff       	call   f010d99b <sys_getparentenvid>
f010dd66:	e9 92 01 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010dd6b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dd6e:	83 ec 0c             	sub    $0xc,%esp
f010dd71:	50                   	push   %eax
f010dd72:	e8 31 fc ff ff       	call   f010d9a8 <sys_destroy_env>
f010dd77:	83 c4 10             	add    $0x10,%esp
f010dd7a:	e9 7e 01 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010dd7f:	e8 bc fc ff ff       	call   f010da40 <sys_exit_env>
		return 0;
f010dd84:	b8 00 00 00 00       	mov    $0x0,%eax
f010dd89:	e9 6f 01 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f010dd8e:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010dd91:	83 ec 0c             	sub    $0xc,%esp
f010dd94:	50                   	push   %eax
f010dd95:	e8 0c fd ff ff       	call   f010daa6 <sys_get_virtual_time>
f010dd9a:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010dd9d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dda0:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f010dda3:	8b 45 10             	mov    0x10(%ebp),%eax
f010dda6:	89 45 f0             	mov    %eax,-0x10(%ebp)
		*ptrlow = res.low;
f010dda9:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010ddac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ddaf:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010ddb1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ddb4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ddb7:	89 10                	mov    %edx,(%eax)
		return 0;
f010ddb9:	b8 00 00 00 00       	mov    $0x0,%eax
f010ddbe:	e9 3a 01 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010ddc3:	83 ec 04             	sub    $0x4,%esp
f010ddc6:	ff 75 14             	pushl  0x14(%ebp)
f010ddc9:	ff 75 10             	pushl  0x10(%ebp)
f010ddcc:	ff 75 0c             	pushl  0xc(%ebp)
f010ddcf:	e8 bc fa ff ff       	call   f010d890 <sys_move_user_mem>
f010ddd4:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ddd7:	b8 00 00 00 00       	mov    $0x0,%eax
f010dddc:	e9 1c 01 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010dde1:	e8 ef fc ff ff       	call   f010dad5 <sys_rcr2>
f010dde6:	e9 12 01 00 00       	jmp    f010defd <syscall+0x3ff>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010ddeb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ddee:	0f b6 c0             	movzbl %al,%eax
f010ddf1:	83 ec 0c             	sub    $0xc,%esp
f010ddf4:	50                   	push   %eax
f010ddf5:	e8 ed fc ff ff       	call   f010dae7 <sys_bypassPageFault>
f010ddfa:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ddfd:	b8 00 00 00 00       	mov    $0x0,%eax
f010de02:	e9 f6 00 00 00       	jmp    f010defd <syscall+0x3ff>

	case SYS_rsttst:
		rsttst();
f010de07:	e8 f4 0c 01 00       	call   f011eb00 <rsttst>
		return 0;
f010de0c:	b8 00 00 00 00       	mov    $0x0,%eax
f010de11:	e9 e7 00 00 00       	jmp    f010defd <syscall+0x3ff>
	case SYS_inctst:
		inctst();
f010de16:	e8 2d 0d 01 00       	call   f011eb48 <inctst>
		return 0;
f010de1b:	b8 00 00 00 00       	mov    $0x0,%eax
f010de20:	e9 d8 00 00 00       	jmp    f010defd <syscall+0x3ff>
	case SYS_chktst:
		chktst(a1);
f010de25:	83 ec 0c             	sub    $0xc,%esp
f010de28:	ff 75 0c             	pushl  0xc(%ebp)
f010de2b:	e8 5a 0e 01 00       	call   f011ec8a <chktst>
f010de30:	83 c4 10             	add    $0x10,%esp
		return 0;
f010de33:	b8 00 00 00 00       	mov    $0x0,%eax
f010de38:	e9 c0 00 00 00       	jmp    f010defd <syscall+0x3ff>
	case SYS_gettst:
		return gettst();
f010de3d:	e8 3a 0d 01 00       	call   f011eb7c <gettst>
f010de42:	e9 b6 00 00 00       	jmp    f010defd <syscall+0x3ff>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f010de47:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010de4a:	8b 45 18             	mov    0x18(%ebp),%eax
f010de4d:	0f be c0             	movsbl %al,%eax
f010de50:	83 ec 0c             	sub    $0xc,%esp
f010de53:	52                   	push   %edx
f010de54:	50                   	push   %eax
f010de55:	ff 75 14             	pushl  0x14(%ebp)
f010de58:	ff 75 10             	pushl  0x10(%ebp)
f010de5b:	ff 75 0c             	pushl  0xc(%ebp)
f010de5e:	e8 23 0d 01 00       	call   f011eb86 <tst>
f010de63:	83 c4 20             	add    $0x20,%esp
		return 0;
f010de66:	b8 00 00 00 00       	mov    $0x0,%eax
f010de6b:	e9 8d 00 00 00       	jmp    f010defd <syscall+0x3ff>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010de70:	e8 3b fa ff ff       	call   f010d8b0 <sys_get_heap_strategy>
f010de75:	e9 83 00 00 00       	jmp    f010defd <syscall+0x3ff>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010de7a:	83 ec 0c             	sub    $0xc,%esp
f010de7d:	ff 75 0c             	pushl  0xc(%ebp)
f010de80:	e8 35 fa ff ff       	call   f010d8ba <sys_set_uheap_strategy>
f010de85:	83 c4 10             	add    $0x10,%esp
		return 0;
f010de88:	b8 00 00 00 00       	mov    $0x0,%eax
f010de8d:	eb 6e                	jmp    f010defd <syscall+0x3ff>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f010de8f:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010de92:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010de95:	8b 55 10             	mov    0x10(%ebp),%edx
f010de98:	8b 45 0c             	mov    0xc(%ebp),%eax
f010de9b:	53                   	push   %ebx
f010de9c:	51                   	push   %ecx
f010de9d:	52                   	push   %edx
f010de9e:	50                   	push   %eax
f010de9f:	e8 73 31 00 00       	call   f0111017 <sys_check_LRU_lists>
f010dea4:	83 c4 10             	add    $0x10,%esp
f010dea7:	eb 54                	jmp    f010defd <syscall+0x3ff>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f010dea9:	8b 55 10             	mov    0x10(%ebp),%edx
f010deac:	8b 45 0c             	mov    0xc(%ebp),%eax
f010deaf:	83 ec 08             	sub    $0x8,%esp
f010deb2:	52                   	push   %edx
f010deb3:	50                   	push   %eax
f010deb4:	e8 20 33 00 00       	call   f01111d9 <sys_check_LRU_lists_free>
f010deb9:	83 c4 10             	add    $0x10,%esp
f010debc:	eb 3f                	jmp    f010defd <syscall+0x3ff>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f010debe:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010dec1:	8b 55 10             	mov    0x10(%ebp),%edx
f010dec4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dec7:	51                   	push   %ecx
f010dec8:	ff 75 14             	pushl  0x14(%ebp)
f010decb:	52                   	push   %edx
f010decc:	50                   	push   %eax
f010decd:	e8 94 34 00 00       	call   f0111366 <sys_check_WS_list>
f010ded2:	83 c4 10             	add    $0x10,%esp
f010ded5:	eb 26                	jmp    f010defd <syscall+0x3ff>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f010ded7:	8b 55 10             	mov    0x10(%ebp),%edx
f010deda:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dedd:	83 ec 08             	sub    $0x8,%esp
f010dee0:	52                   	push   %edx
f010dee1:	50                   	push   %eax
f010dee2:	e8 a4 0f 01 00       	call   f011ee8b <sys_utilities>
f010dee7:	83 c4 10             	add    $0x10,%esp
		return 0;
f010deea:	b8 00 00 00 00       	mov    $0x0,%eax
f010deef:	eb 0c                	jmp    f010defd <syscall+0x3ff>

	case NSYSCALLS:
		return 	-E_INVAL;
f010def1:	b8 03 00 00 00       	mov    $0x3,%eax
f010def6:	eb 05                	jmp    f010defd <syscall+0x3ff>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f010def8:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010defd:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010df00:	5b                   	pop    %ebx
f010df01:	5e                   	pop    %esi
f010df02:	5d                   	pop    %ebp
f010df03:	c3                   	ret    

f010df04 <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010df04:	55                   	push   %ebp
f010df05:	89 e5                	mov    %esp,%ebp
f010df07:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010df0a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010df0d:	8b 00                	mov    (%eax),%eax
f010df0f:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010df12:	8b 45 10             	mov    0x10(%ebp),%eax
f010df15:	8b 00                	mov    (%eax),%eax
f010df17:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010df1a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010df21:	e9 ca 00 00 00       	jmp    f010dff0 <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010df26:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010df29:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010df2c:	01 d0                	add    %edx,%eax
f010df2e:	89 c2                	mov    %eax,%edx
f010df30:	c1 ea 1f             	shr    $0x1f,%edx
f010df33:	01 d0                	add    %edx,%eax
f010df35:	d1 f8                	sar    %eax
f010df37:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010df3a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010df3d:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010df40:	eb 03                	jmp    f010df45 <stab_binsearch+0x41>
			m--;
f010df42:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010df45:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010df48:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010df4b:	7c 1e                	jl     f010df6b <stab_binsearch+0x67>
f010df4d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010df50:	89 d0                	mov    %edx,%eax
f010df52:	01 c0                	add    %eax,%eax
f010df54:	01 d0                	add    %edx,%eax
f010df56:	c1 e0 02             	shl    $0x2,%eax
f010df59:	89 c2                	mov    %eax,%edx
f010df5b:	8b 45 08             	mov    0x8(%ebp),%eax
f010df5e:	01 d0                	add    %edx,%eax
f010df60:	8a 40 04             	mov    0x4(%eax),%al
f010df63:	0f b6 c0             	movzbl %al,%eax
f010df66:	3b 45 14             	cmp    0x14(%ebp),%eax
f010df69:	75 d7                	jne    f010df42 <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010df6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010df6e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010df71:	7d 09                	jge    f010df7c <stab_binsearch+0x78>
			l = true_m + 1;
f010df73:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010df76:	40                   	inc    %eax
f010df77:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010df7a:	eb 74                	jmp    f010dff0 <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010df7c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010df83:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010df86:	89 d0                	mov    %edx,%eax
f010df88:	01 c0                	add    %eax,%eax
f010df8a:	01 d0                	add    %edx,%eax
f010df8c:	c1 e0 02             	shl    $0x2,%eax
f010df8f:	89 c2                	mov    %eax,%edx
f010df91:	8b 45 08             	mov    0x8(%ebp),%eax
f010df94:	01 d0                	add    %edx,%eax
f010df96:	8b 40 08             	mov    0x8(%eax),%eax
f010df99:	3b 45 18             	cmp    0x18(%ebp),%eax
f010df9c:	73 11                	jae    f010dfaf <stab_binsearch+0xab>
			*region_left = m;
f010df9e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dfa1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010dfa4:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010dfa6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010dfa9:	40                   	inc    %eax
f010dfaa:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010dfad:	eb 41                	jmp    f010dff0 <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010dfaf:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010dfb2:	89 d0                	mov    %edx,%eax
f010dfb4:	01 c0                	add    %eax,%eax
f010dfb6:	01 d0                	add    %edx,%eax
f010dfb8:	c1 e0 02             	shl    $0x2,%eax
f010dfbb:	89 c2                	mov    %eax,%edx
f010dfbd:	8b 45 08             	mov    0x8(%ebp),%eax
f010dfc0:	01 d0                	add    %edx,%eax
f010dfc2:	8b 40 08             	mov    0x8(%eax),%eax
f010dfc5:	3b 45 18             	cmp    0x18(%ebp),%eax
f010dfc8:	76 14                	jbe    f010dfde <stab_binsearch+0xda>
			*region_right = m - 1;
f010dfca:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dfcd:	8d 50 ff             	lea    -0x1(%eax),%edx
f010dfd0:	8b 45 10             	mov    0x10(%ebp),%eax
f010dfd3:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010dfd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dfd8:	48                   	dec    %eax
f010dfd9:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010dfdc:	eb 12                	jmp    f010dff0 <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010dfde:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dfe1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010dfe4:	89 10                	mov    %edx,(%eax)
			l = m;
f010dfe6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dfe9:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010dfec:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010dff0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010dff3:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010dff6:	0f 8e 2a ff ff ff    	jle    f010df26 <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010dffc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e000:	75 0f                	jne    f010e011 <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010e002:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e005:	8b 00                	mov    (%eax),%eax
f010e007:	8d 50 ff             	lea    -0x1(%eax),%edx
f010e00a:	8b 45 10             	mov    0x10(%ebp),%eax
f010e00d:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010e00f:	eb 3d                	jmp    f010e04e <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010e011:	8b 45 10             	mov    0x10(%ebp),%eax
f010e014:	8b 00                	mov    (%eax),%eax
f010e016:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010e019:	eb 03                	jmp    f010e01e <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010e01b:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010e01e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e021:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010e023:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010e026:	7d 1e                	jge    f010e046 <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010e028:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e02b:	89 d0                	mov    %edx,%eax
f010e02d:	01 c0                	add    %eax,%eax
f010e02f:	01 d0                	add    %edx,%eax
f010e031:	c1 e0 02             	shl    $0x2,%eax
f010e034:	89 c2                	mov    %eax,%edx
f010e036:	8b 45 08             	mov    0x8(%ebp),%eax
f010e039:	01 d0                	add    %edx,%eax
f010e03b:	8a 40 04             	mov    0x4(%eax),%al
f010e03e:	0f b6 c0             	movzbl %al,%eax
f010e041:	3b 45 14             	cmp    0x14(%ebp),%eax
f010e044:	75 d5                	jne    f010e01b <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010e046:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e049:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e04c:	89 10                	mov    %edx,(%eax)
	}
}
f010e04e:	90                   	nop
f010e04f:	c9                   	leave  
f010e050:	c3                   	ret    

f010e051 <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010e051:	55                   	push   %ebp
f010e052:	89 e5                	mov    %esp,%ebp
f010e054:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010e057:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e05a:	c7 00 30 6a 12 f0    	movl   $0xf0126a30,(%eax)
	info->eip_line = 0;
f010e060:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e063:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010e06a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e06d:	c7 40 08 30 6a 12 f0 	movl   $0xf0126a30,0x8(%eax)
	info->eip_fn_namelen = 9;
f010e074:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e077:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010e07e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e081:	8b 55 08             	mov    0x8(%ebp),%edx
f010e084:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010e087:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e08a:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010e091:	8b 45 08             	mov    0x8(%ebp),%eax
f010e094:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010e099:	76 1e                	jbe    f010e0b9 <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010e09b:	c7 45 f4 98 df 12 f0 	movl   $0xf012df98,-0xc(%ebp)
		stab_end = __STAB_END__;
f010e0a2:	c7 45 f0 e0 f1 15 f0 	movl   $0xf015f1e0,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010e0a9:	c7 45 ec e1 f1 15 f0 	movl   $0xf015f1e1,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010e0b0:	c7 45 e8 32 06 17 f0 	movl   $0xf0170632,-0x18(%ebp)
f010e0b7:	eb 2a                	jmp    f010e0e3 <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010e0b9:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010e0c0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e0c3:	8b 00                	mov    (%eax),%eax
f010e0c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010e0c8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e0cb:	8b 40 04             	mov    0x4(%eax),%eax
f010e0ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010e0d1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e0d4:	8b 40 08             	mov    0x8(%eax),%eax
f010e0d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010e0da:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e0dd:	8b 40 0c             	mov    0xc(%eax),%eax
f010e0e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010e0e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e0e6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e0e9:	76 0a                	jbe    f010e0f5 <debuginfo_eip+0xa4>
f010e0eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e0ee:	48                   	dec    %eax
f010e0ef:	8a 00                	mov    (%eax),%al
f010e0f1:	84 c0                	test   %al,%al
f010e0f3:	74 0a                	je     f010e0ff <debuginfo_eip+0xae>
		return -1;
f010e0f5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010e0fa:	e9 01 02 00 00       	jmp    f010e300 <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010e0ff:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010e106:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e109:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e10c:	29 c2                	sub    %eax,%edx
f010e10e:	89 d0                	mov    %edx,%eax
f010e110:	c1 f8 02             	sar    $0x2,%eax
f010e113:	89 c2                	mov    %eax,%edx
f010e115:	89 d0                	mov    %edx,%eax
f010e117:	c1 e0 02             	shl    $0x2,%eax
f010e11a:	01 d0                	add    %edx,%eax
f010e11c:	c1 e0 02             	shl    $0x2,%eax
f010e11f:	01 d0                	add    %edx,%eax
f010e121:	c1 e0 02             	shl    $0x2,%eax
f010e124:	01 d0                	add    %edx,%eax
f010e126:	89 c1                	mov    %eax,%ecx
f010e128:	c1 e1 08             	shl    $0x8,%ecx
f010e12b:	01 c8                	add    %ecx,%eax
f010e12d:	89 c1                	mov    %eax,%ecx
f010e12f:	c1 e1 10             	shl    $0x10,%ecx
f010e132:	01 c8                	add    %ecx,%eax
f010e134:	01 c0                	add    %eax,%eax
f010e136:	01 d0                	add    %edx,%eax
f010e138:	48                   	dec    %eax
f010e139:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010e13c:	ff 75 08             	pushl  0x8(%ebp)
f010e13f:	6a 64                	push   $0x64
f010e141:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010e144:	50                   	push   %eax
f010e145:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010e148:	50                   	push   %eax
f010e149:	ff 75 f4             	pushl  -0xc(%ebp)
f010e14c:	e8 b3 fd ff ff       	call   f010df04 <stab_binsearch>
f010e151:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010e154:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e157:	85 c0                	test   %eax,%eax
f010e159:	75 0a                	jne    f010e165 <debuginfo_eip+0x114>
		return -1;
f010e15b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010e160:	e9 9b 01 00 00       	jmp    f010e300 <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010e165:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e168:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010e16b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010e16e:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010e171:	ff 75 08             	pushl  0x8(%ebp)
f010e174:	6a 24                	push   $0x24
f010e176:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010e179:	50                   	push   %eax
f010e17a:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010e17d:	50                   	push   %eax
f010e17e:	ff 75 f4             	pushl  -0xc(%ebp)
f010e181:	e8 7e fd ff ff       	call   f010df04 <stab_binsearch>
f010e186:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010e189:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010e18c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010e18f:	39 c2                	cmp    %eax,%edx
f010e191:	0f 8f 86 00 00 00    	jg     f010e21d <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010e197:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e19a:	89 c2                	mov    %eax,%edx
f010e19c:	89 d0                	mov    %edx,%eax
f010e19e:	01 c0                	add    %eax,%eax
f010e1a0:	01 d0                	add    %edx,%eax
f010e1a2:	c1 e0 02             	shl    $0x2,%eax
f010e1a5:	89 c2                	mov    %eax,%edx
f010e1a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e1aa:	01 d0                	add    %edx,%eax
f010e1ac:	8b 00                	mov    (%eax),%eax
f010e1ae:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010e1b1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e1b4:	29 d1                	sub    %edx,%ecx
f010e1b6:	89 ca                	mov    %ecx,%edx
f010e1b8:	39 d0                	cmp    %edx,%eax
f010e1ba:	73 22                	jae    f010e1de <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010e1bc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e1bf:	89 c2                	mov    %eax,%edx
f010e1c1:	89 d0                	mov    %edx,%eax
f010e1c3:	01 c0                	add    %eax,%eax
f010e1c5:	01 d0                	add    %edx,%eax
f010e1c7:	c1 e0 02             	shl    $0x2,%eax
f010e1ca:	89 c2                	mov    %eax,%edx
f010e1cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e1cf:	01 d0                	add    %edx,%eax
f010e1d1:	8b 10                	mov    (%eax),%edx
f010e1d3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e1d6:	01 c2                	add    %eax,%edx
f010e1d8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e1db:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010e1de:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e1e1:	89 c2                	mov    %eax,%edx
f010e1e3:	89 d0                	mov    %edx,%eax
f010e1e5:	01 c0                	add    %eax,%eax
f010e1e7:	01 d0                	add    %edx,%eax
f010e1e9:	c1 e0 02             	shl    $0x2,%eax
f010e1ec:	89 c2                	mov    %eax,%edx
f010e1ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e1f1:	01 d0                	add    %edx,%eax
f010e1f3:	8b 50 08             	mov    0x8(%eax),%edx
f010e1f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e1f9:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010e1fc:	8b 55 08             	mov    0x8(%ebp),%edx
f010e1ff:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e202:	8b 40 10             	mov    0x10(%eax),%eax
f010e205:	29 c2                	sub    %eax,%edx
f010e207:	89 d0                	mov    %edx,%eax
f010e209:	c1 f8 02             	sar    $0x2,%eax
f010e20c:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010e20f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e212:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010e215:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010e218:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010e21b:	eb 15                	jmp    f010e232 <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010e21d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e220:	8b 55 08             	mov    0x8(%ebp),%edx
f010e223:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010e226:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e229:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010e22c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010e22f:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010e232:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e235:	8b 40 08             	mov    0x8(%eax),%eax
f010e238:	83 ec 08             	sub    $0x8,%esp
f010e23b:	6a 3a                	push   $0x3a
f010e23d:	50                   	push   %eax
f010e23e:	e8 d0 24 01 00       	call   f0120713 <strfind>
f010e243:	83 c4 10             	add    $0x10,%esp
f010e246:	89 c2                	mov    %eax,%edx
f010e248:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e24b:	8b 40 08             	mov    0x8(%eax),%eax
f010e24e:	29 c2                	sub    %eax,%edx
f010e250:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e253:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010e256:	eb 03                	jmp    f010e25b <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010e258:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010e25b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e25e:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010e261:	7c 4e                	jl     f010e2b1 <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010e263:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e266:	89 d0                	mov    %edx,%eax
f010e268:	01 c0                	add    %eax,%eax
f010e26a:	01 d0                	add    %edx,%eax
f010e26c:	c1 e0 02             	shl    $0x2,%eax
f010e26f:	89 c2                	mov    %eax,%edx
f010e271:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e274:	01 d0                	add    %edx,%eax
f010e276:	8a 40 04             	mov    0x4(%eax),%al
f010e279:	3c 84                	cmp    $0x84,%al
f010e27b:	74 34                	je     f010e2b1 <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010e27d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e280:	89 d0                	mov    %edx,%eax
f010e282:	01 c0                	add    %eax,%eax
f010e284:	01 d0                	add    %edx,%eax
f010e286:	c1 e0 02             	shl    $0x2,%eax
f010e289:	89 c2                	mov    %eax,%edx
f010e28b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e28e:	01 d0                	add    %edx,%eax
f010e290:	8a 40 04             	mov    0x4(%eax),%al
f010e293:	3c 64                	cmp    $0x64,%al
f010e295:	75 c1                	jne    f010e258 <debuginfo_eip+0x207>
f010e297:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e29a:	89 d0                	mov    %edx,%eax
f010e29c:	01 c0                	add    %eax,%eax
f010e29e:	01 d0                	add    %edx,%eax
f010e2a0:	c1 e0 02             	shl    $0x2,%eax
f010e2a3:	89 c2                	mov    %eax,%edx
f010e2a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e2a8:	01 d0                	add    %edx,%eax
f010e2aa:	8b 40 08             	mov    0x8(%eax),%eax
f010e2ad:	85 c0                	test   %eax,%eax
f010e2af:	74 a7                	je     f010e258 <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010e2b1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e2b4:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010e2b7:	7c 42                	jl     f010e2fb <debuginfo_eip+0x2aa>
f010e2b9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e2bc:	89 d0                	mov    %edx,%eax
f010e2be:	01 c0                	add    %eax,%eax
f010e2c0:	01 d0                	add    %edx,%eax
f010e2c2:	c1 e0 02             	shl    $0x2,%eax
f010e2c5:	89 c2                	mov    %eax,%edx
f010e2c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e2ca:	01 d0                	add    %edx,%eax
f010e2cc:	8b 00                	mov    (%eax),%eax
f010e2ce:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010e2d1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e2d4:	29 d1                	sub    %edx,%ecx
f010e2d6:	89 ca                	mov    %ecx,%edx
f010e2d8:	39 d0                	cmp    %edx,%eax
f010e2da:	73 1f                	jae    f010e2fb <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010e2dc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e2df:	89 d0                	mov    %edx,%eax
f010e2e1:	01 c0                	add    %eax,%eax
f010e2e3:	01 d0                	add    %edx,%eax
f010e2e5:	c1 e0 02             	shl    $0x2,%eax
f010e2e8:	89 c2                	mov    %eax,%edx
f010e2ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e2ed:	01 d0                	add    %edx,%eax
f010e2ef:	8b 10                	mov    (%eax),%edx
f010e2f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e2f4:	01 c2                	add    %eax,%edx
f010e2f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e2f9:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010e2fb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e300:	c9                   	leave  
f010e301:	c3                   	ret    

f010e302 <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f010e302:	55                   	push   %ebp
f010e303:	89 e5                	mov    %esp,%ebp
f010e305:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f010e308:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010e30c:	74 1c                	je     f010e32a <setPageReplacmentAlgorithmLRU+0x28>
f010e30e:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010e312:	74 16                	je     f010e32a <setPageReplacmentAlgorithmLRU+0x28>
f010e314:	68 3c 6a 12 f0       	push   $0xf0126a3c
f010e319:	68 86 6a 12 f0       	push   $0xf0126a86
f010e31e:	6a 19                	push   $0x19
f010e320:	68 9b 6a 12 f0       	push   $0xf0126a9b
f010e325:	e8 f0 1f ff ff       	call   f010031a <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f010e32a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e32d:	a3 68 51 55 f0       	mov    %eax,0xf0555168
}
f010e332:	90                   	nop
f010e333:	c9                   	leave  
f010e334:	c3                   	ret    

f010e335 <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f010e335:	55                   	push   %ebp
f010e336:	89 e5                	mov    %esp,%ebp
f010e338:	c7 05 68 51 55 f0 03 	movl   $0x3,0xf0555168
f010e33f:	00 00 00 
f010e342:	90                   	nop
f010e343:	5d                   	pop    %ebp
f010e344:	c3                   	ret    

f010e345 <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f010e345:	55                   	push   %ebp
f010e346:	89 e5                	mov    %esp,%ebp
f010e348:	c7 05 68 51 55 f0 04 	movl   $0x4,0xf0555168
f010e34f:	00 00 00 
f010e352:	90                   	nop
f010e353:	5d                   	pop    %ebp
f010e354:	c3                   	ret    

f010e355 <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f010e355:	55                   	push   %ebp
f010e356:	89 e5                	mov    %esp,%ebp
f010e358:	c7 05 68 51 55 f0 05 	movl   $0x5,0xf0555168
f010e35f:	00 00 00 
f010e362:	90                   	nop
f010e363:	5d                   	pop    %ebp
f010e364:	c3                   	ret    

f010e365 <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f010e365:	55                   	push   %ebp
f010e366:	89 e5                	mov    %esp,%ebp
f010e368:	c7 05 68 51 55 f0 07 	movl   $0x7,0xf0555168
f010e36f:	00 00 00 
f010e372:	90                   	nop
f010e373:	5d                   	pop    %ebp
f010e374:	c3                   	ret    

f010e375 <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f010e375:	55                   	push   %ebp
f010e376:	89 e5                	mov    %esp,%ebp
f010e378:	c7 05 68 51 55 f0 06 	movl   $0x6,0xf0555168
f010e37f:	00 00 00 
f010e382:	8b 45 08             	mov    0x8(%ebp),%eax
f010e385:	a3 00 25 55 f0       	mov    %eax,0xf0552500
f010e38a:	90                   	nop
f010e38b:	5d                   	pop    %ebp
f010e38c:	c3                   	ret    

f010e38d <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f010e38d:	55                   	push   %ebp
f010e38e:	89 e5                	mov    %esp,%ebp
f010e390:	8b 15 68 51 55 f0    	mov    0xf0555168,%edx
f010e396:	8b 45 08             	mov    0x8(%ebp),%eax
f010e399:	39 c2                	cmp    %eax,%edx
f010e39b:	0f 94 c0             	sete   %al
f010e39e:	0f b6 c0             	movzbl %al,%eax
f010e3a1:	5d                   	pop    %ebp
f010e3a2:	c3                   	ret    

f010e3a3 <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f010e3a3:	55                   	push   %ebp
f010e3a4:	89 e5                	mov    %esp,%ebp
f010e3a6:	a1 68 51 55 f0       	mov    0xf0555168,%eax
f010e3ab:	83 f8 03             	cmp    $0x3,%eax
f010e3ae:	75 07                	jne    f010e3b7 <isPageReplacmentAlgorithmCLOCK+0x14>
f010e3b0:	b8 01 00 00 00       	mov    $0x1,%eax
f010e3b5:	eb 05                	jmp    f010e3bc <isPageReplacmentAlgorithmCLOCK+0x19>
f010e3b7:	b8 00 00 00 00       	mov    $0x0,%eax
f010e3bc:	5d                   	pop    %ebp
f010e3bd:	c3                   	ret    

f010e3be <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f010e3be:	55                   	push   %ebp
f010e3bf:	89 e5                	mov    %esp,%ebp
f010e3c1:	a1 68 51 55 f0       	mov    0xf0555168,%eax
f010e3c6:	83 f8 04             	cmp    $0x4,%eax
f010e3c9:	75 07                	jne    f010e3d2 <isPageReplacmentAlgorithmFIFO+0x14>
f010e3cb:	b8 01 00 00 00       	mov    $0x1,%eax
f010e3d0:	eb 05                	jmp    f010e3d7 <isPageReplacmentAlgorithmFIFO+0x19>
f010e3d2:	b8 00 00 00 00       	mov    $0x0,%eax
f010e3d7:	5d                   	pop    %ebp
f010e3d8:	c3                   	ret    

f010e3d9 <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f010e3d9:	55                   	push   %ebp
f010e3da:	89 e5                	mov    %esp,%ebp
f010e3dc:	a1 68 51 55 f0       	mov    0xf0555168,%eax
f010e3e1:	83 f8 05             	cmp    $0x5,%eax
f010e3e4:	75 07                	jne    f010e3ed <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f010e3e6:	b8 01 00 00 00       	mov    $0x1,%eax
f010e3eb:	eb 05                	jmp    f010e3f2 <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f010e3ed:	b8 00 00 00 00       	mov    $0x0,%eax
f010e3f2:	5d                   	pop    %ebp
f010e3f3:	c3                   	ret    

f010e3f4 <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f010e3f4:	55                   	push   %ebp
f010e3f5:	89 e5                	mov    %esp,%ebp
f010e3f7:	a1 68 51 55 f0       	mov    0xf0555168,%eax
f010e3fc:	83 f8 07             	cmp    $0x7,%eax
f010e3ff:	75 07                	jne    f010e408 <isPageReplacmentAlgorithmDynamicLocal+0x14>
f010e401:	b8 01 00 00 00       	mov    $0x1,%eax
f010e406:	eb 05                	jmp    f010e40d <isPageReplacmentAlgorithmDynamicLocal+0x19>
f010e408:	b8 00 00 00 00       	mov    $0x0,%eax
f010e40d:	5d                   	pop    %ebp
f010e40e:	c3                   	ret    

f010e40f <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f010e40f:	55                   	push   %ebp
f010e410:	89 e5                	mov    %esp,%ebp
f010e412:	a1 68 51 55 f0       	mov    0xf0555168,%eax
f010e417:	83 f8 06             	cmp    $0x6,%eax
f010e41a:	75 07                	jne    f010e423 <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f010e41c:	b8 01 00 00 00       	mov    $0x1,%eax
f010e421:	eb 05                	jmp    f010e428 <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f010e423:	b8 00 00 00 00       	mov    $0x0,%eax
f010e428:	5d                   	pop    %ebp
f010e429:	c3                   	ret    

f010e42a <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f010e42a:	55                   	push   %ebp
f010e42b:	89 e5                	mov    %esp,%ebp
f010e42d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e430:	a3 18 4f 55 f0       	mov    %eax,0xf0554f18
f010e435:	90                   	nop
f010e436:	5d                   	pop    %ebp
f010e437:	c3                   	ret    

f010e438 <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f010e438:	55                   	push   %ebp
f010e439:	89 e5                	mov    %esp,%ebp
f010e43b:	a1 18 4f 55 f0       	mov    0xf0554f18,%eax
f010e440:	5d                   	pop    %ebp
f010e441:	c3                   	ret    

f010e442 <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f010e442:	55                   	push   %ebp
f010e443:	89 e5                	mov    %esp,%ebp
f010e445:	8b 45 08             	mov    0x8(%ebp),%eax
f010e448:	a3 d4 51 55 f0       	mov    %eax,0xf05551d4
f010e44d:	90                   	nop
f010e44e:	5d                   	pop    %ebp
f010e44f:	c3                   	ret    

f010e450 <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f010e450:	55                   	push   %ebp
f010e451:	89 e5                	mov    %esp,%ebp
f010e453:	a1 d4 51 55 f0       	mov    0xf05551d4,%eax
f010e458:	5d                   	pop    %ebp
f010e459:	c3                   	ret    

f010e45a <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f010e45a:	55                   	push   %ebp
f010e45b:	89 e5                	mov    %esp,%ebp
f010e45d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e460:	a3 70 52 55 f0       	mov    %eax,0xf0555270
f010e465:	90                   	nop
f010e466:	5d                   	pop    %ebp
f010e467:	c3                   	ret    

f010e468 <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f010e468:	55                   	push   %ebp
f010e469:	89 e5                	mov    %esp,%ebp
f010e46b:	a1 70 52 55 f0       	mov    0xf0555270,%eax
f010e470:	5d                   	pop    %ebp
f010e471:	c3                   	ret    

f010e472 <fault_handler>:
uint32 before_last_fault_va = 0;
int8 num_repeated_fault  = 0;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f010e472:	55                   	push   %ebp
f010e473:	89 e5                	mov    %esp,%ebp
f010e475:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010e478:	0f 20 d0             	mov    %cr2,%eax
f010e47b:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f010e47e:	8b 45 d8             	mov    -0x28(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010e481:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010e484:	e8 05 c0 ff ff       	call   f010a48e <get_cpu_proc>
f010e489:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f010e48c:	a1 8c 22 55 f0       	mov    0xf055228c,%eax
f010e491:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e494:	75 50                	jne    f010e4e6 <fault_handler+0x74>
f010e496:	a1 98 22 55 f0       	mov    0xf0552298,%eax
f010e49b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010e49e:	75 46                	jne    f010e4e6 <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f010e4a0:	a0 94 22 55 f0       	mov    0xf0552294,%al
f010e4a5:	40                   	inc    %eax
f010e4a6:	a2 94 22 55 f0       	mov    %al,0xf0552294
		if (num_repeated_fault == 3)
f010e4ab:	a0 94 22 55 f0       	mov    0xf0552294,%al
f010e4b0:	3c 03                	cmp    $0x3,%al
f010e4b2:	75 4d                	jne    f010e501 <fault_handler+0x8f>
		{
			print_trapframe(tf);
f010e4b4:	83 ec 0c             	sub    $0xc,%esp
f010e4b7:	ff 75 08             	pushl  0x8(%ebp)
f010e4ba:	e8 14 ea ff ff       	call   f010ced3 <print_trapframe>
f010e4bf:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f010e4c2:	8b 15 88 22 55 f0    	mov    0xf0552288,%edx
f010e4c8:	a1 90 22 55 f0       	mov    0xf0552290,%eax
f010e4cd:	83 ec 08             	sub    $0x8,%esp
f010e4d0:	ff 75 ec             	pushl  -0x14(%ebp)
f010e4d3:	52                   	push   %edx
f010e4d4:	50                   	push   %eax
f010e4d5:	68 b8 6a 12 f0       	push   $0xf0126ab8
f010e4da:	6a 57                	push   $0x57
f010e4dc:	68 9b 6a 12 f0       	push   $0xf0126a9b
f010e4e1:	e8 34 1e ff ff       	call   f010031a <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f010e4e6:	a1 8c 22 55 f0       	mov    0xf055228c,%eax
f010e4eb:	a3 90 22 55 f0       	mov    %eax,0xf0552290
		before_last_eip = last_eip;
f010e4f0:	a1 84 22 55 f0       	mov    0xf0552284,%eax
f010e4f5:	a3 88 22 55 f0       	mov    %eax,0xf0552288
		num_repeated_fault = 0;
f010e4fa:	c6 05 94 22 55 f0 00 	movb   $0x0,0xf0552294
	}
	last_eip = (uint32)tf->tf_eip;
f010e501:	8b 45 08             	mov    0x8(%ebp),%eax
f010e504:	8b 40 30             	mov    0x30(%eax),%eax
f010e507:	a3 84 22 55 f0       	mov    %eax,0xf0552284
	last_fault_va = fault_va ;
f010e50c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e50f:	a3 8c 22 55 f0       	mov    %eax,0xf055228c
	last_faulted_env = cur_env;
f010e514:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e517:	a3 98 22 55 f0       	mov    %eax,0xf0552298
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010e51c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010e523:	8b 45 08             	mov    0x8(%ebp),%eax
f010e526:	8b 40 34             	mov    0x34(%eax),%eax
f010e529:	0f b7 c0             	movzwl %ax,%eax
f010e52c:	83 e0 03             	and    $0x3,%eax
f010e52f:	83 f8 03             	cmp    $0x3,%eax
f010e532:	75 07                	jne    f010e53b <fault_handler+0xc9>
		userTrap = 1;
f010e534:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f010e53b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e53f:	0f 85 a9 00 00 00    	jne    f010e5ee <fault_handler+0x17c>
	{
		struct cpu* c = mycpu();
f010e545:	e8 d1 88 ff ff       	call   f0106e1b <mycpu>
f010e54a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010e54d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010e551:	74 2f                	je     f010e582 <fault_handler+0x110>
f010e553:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e556:	8b 40 70             	mov    0x70(%eax),%eax
f010e559:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e55c:	77 24                	ja     f010e582 <fault_handler+0x110>
f010e55e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e561:	8b 40 70             	mov    0x70(%eax),%eax
f010e564:	05 00 10 00 00       	add    $0x1000,%eax
f010e569:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e56c:	76 14                	jbe    f010e582 <fault_handler+0x110>
			panic("User Kernel Stack: overflow exception!");
f010e56e:	83 ec 04             	sub    $0x4,%esp
f010e571:	68 28 6b 12 f0       	push   $0xf0126b28
f010e576:	6a 6e                	push   $0x6e
f010e578:	68 9b 6a 12 f0       	push   $0xf0126a9b
f010e57d:	e8 98 1d ff ff       	call   f010031a <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f010e582:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e585:	8b 40 08             	mov    0x8(%eax),%eax
f010e588:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e58b:	0f 87 83 00 00 00    	ja     f010e614 <fault_handler+0x1a2>
f010e591:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e594:	8b 40 08             	mov    0x8(%eax),%eax
f010e597:	05 00 10 00 00       	add    $0x1000,%eax
f010e59c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e59f:	76 73                	jbe    f010e614 <fault_handler+0x1a2>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f010e5a1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e5a4:	ba 00 4c 55 f0       	mov    $0xf0554c00,%edx
f010e5a9:	29 d0                	sub    %edx,%eax
f010e5ab:	c1 f8 03             	sar    $0x3,%eax
f010e5ae:	89 c2                	mov    %eax,%edx
f010e5b0:	89 d0                	mov    %edx,%eax
f010e5b2:	c1 e0 02             	shl    $0x2,%eax
f010e5b5:	01 d0                	add    %edx,%eax
f010e5b7:	01 c0                	add    %eax,%eax
f010e5b9:	01 d0                	add    %edx,%eax
f010e5bb:	c1 e0 03             	shl    $0x3,%eax
f010e5be:	01 d0                	add    %edx,%eax
f010e5c0:	89 c1                	mov    %eax,%ecx
f010e5c2:	c1 e1 0b             	shl    $0xb,%ecx
f010e5c5:	01 c8                	add    %ecx,%eax
f010e5c7:	c1 e0 05             	shl    $0x5,%eax
f010e5ca:	01 d0                	add    %edx,%eax
f010e5cc:	c1 e0 02             	shl    $0x2,%eax
f010e5cf:	01 d0                	add    %edx,%eax
f010e5d1:	01 c0                	add    %eax,%eax
f010e5d3:	01 d0                	add    %edx,%eax
f010e5d5:	c1 e0 03             	shl    $0x3,%eax
f010e5d8:	01 d0                	add    %edx,%eax
f010e5da:	f7 d8                	neg    %eax
f010e5dc:	50                   	push   %eax
f010e5dd:	68 50 6b 12 f0       	push   $0xf0126b50
f010e5e2:	6a 70                	push   $0x70
f010e5e4:	68 9b 6a 12 f0       	push   $0xf0126a9b
f010e5e9:	e8 2c 1d ff ff       	call   f010031a <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010e5ee:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010e5f5:	76 1d                	jbe    f010e614 <fault_handler+0x1a2>
f010e5f7:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010e5fe:	77 14                	ja     f010e614 <fault_handler+0x1a2>
			panic("User: stack underflow exception!");
f010e600:	83 ec 04             	sub    $0x4,%esp
f010e603:	68 84 6b 12 f0       	push   $0xf0126b84
f010e608:	6a 7b                	push   $0x7b
f010e60a:	68 9b 6a 12 f0       	push   $0xf0126a9b
f010e60f:	e8 06 1d ff ff       	call   f010031a <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010e614:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e617:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f010e61a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010e61e:	75 25                	jne    f010e645 <fault_handler+0x1d3>
	{
		print_trapframe(tf);
f010e620:	83 ec 0c             	sub    $0xc,%esp
f010e623:	ff 75 08             	pushl  0x8(%ebp)
f010e626:	e8 a8 e8 ff ff       	call   f010ced3 <print_trapframe>
f010e62b:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010e62e:	83 ec 04             	sub    $0x4,%esp
f010e631:	68 a5 6b 12 f0       	push   $0xf0126ba5
f010e636:	68 84 00 00 00       	push   $0x84
f010e63b:	68 9b 6a 12 f0       	push   $0xf0126a9b
f010e640:	e8 d5 1c ff ff       	call   f010031a <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f010e645:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e648:	8b 40 64             	mov    0x64(%eax),%eax
f010e64b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e64e:	c1 ea 16             	shr    $0x16,%edx
f010e651:	c1 e2 02             	shl    $0x2,%edx
f010e654:	01 d0                	add    %edx,%eax
f010e656:	8b 00                	mov    (%eax),%eax
f010e658:	83 e0 01             	and    $0x1,%eax
f010e65b:	85 c0                	test   %eax,%eax
f010e65d:	75 28                	jne    f010e687 <fault_handler+0x215>
	{
		// we have a table fault =============================================================
		//		cprintf("[%s] user TABLE fault va %08x\n", curenv->prog_name, fault_va);
		//		print_trapframe(tf);

		faulted_env->tableFaultsCounter ++ ;
f010e65f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e662:	8b 80 44 da 01 00    	mov    0x1da44(%eax),%eax
f010e668:	8d 50 01             	lea    0x1(%eax),%edx
f010e66b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e66e:	89 90 44 da 01 00    	mov    %edx,0x1da44(%eax)

		table_fault_handler(faulted_env, fault_va);
f010e674:	83 ec 08             	sub    $0x8,%esp
f010e677:	ff 75 ec             	pushl  -0x14(%ebp)
f010e67a:	ff 75 e0             	pushl  -0x20(%ebp)
f010e67d:	e8 8f 00 00 00       	call   f010e711 <table_fault_handler>
f010e682:	83 c4 10             	add    $0x10,%esp
f010e685:	eb 7b                	jmp    f010e702 <fault_handler+0x290>

			/*============================================================================================*/
		}

		/*2022: Check if fault due to Access Rights */
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f010e687:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e68a:	8b 40 64             	mov    0x64(%eax),%eax
f010e68d:	83 ec 08             	sub    $0x8,%esp
f010e690:	ff 75 ec             	pushl  -0x14(%ebp)
f010e693:	50                   	push   %eax
f010e694:	e8 71 a2 ff ff       	call   f010890a <pt_get_page_permissions>
f010e699:	83 c4 10             	add    $0x10,%esp
f010e69c:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (perms & PERM_PRESENT)
f010e69f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010e6a2:	83 e0 01             	and    $0x1,%eax
f010e6a5:	85 c0                	test   %eax,%eax
f010e6a7:	74 17                	je     f010e6c0 <fault_handler+0x24e>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f010e6a9:	ff 75 ec             	pushl  -0x14(%ebp)
f010e6ac:	68 bc 6b 12 f0       	push   $0xf0126bbc
f010e6b1:	68 a1 00 00 00       	push   $0xa1
f010e6b6:	68 9b 6a 12 f0       	push   $0xf0126a9b
f010e6bb:	e8 5a 1c ff ff       	call   f010031a <_panic>
		/*============================================================================================*/


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f010e6c0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e6c3:	8b 80 40 da 01 00    	mov    0x1da40(%eax),%eax
f010e6c9:	8d 50 01             	lea    0x1(%eax),%edx
f010e6cc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e6cf:	89 90 40 da 01 00    	mov    %edx,0x1da40(%eax)

		//		cprintf("[%08s] user PAGE fault va %08x\n", curenv->prog_name, fault_va);
		//		cprintf("\nPage working set BEFORE fault handler...\n");
		//		env_page_ws_print(curenv);

		if(isBufferingEnabled())
f010e6d5:	e8 76 fd ff ff       	call   f010e450 <isBufferingEnabled>
f010e6da:	84 c0                	test   %al,%al
f010e6dc:	74 13                	je     f010e6f1 <fault_handler+0x27f>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f010e6de:	83 ec 08             	sub    $0x8,%esp
f010e6e1:	ff 75 ec             	pushl  -0x14(%ebp)
f010e6e4:	ff 75 e0             	pushl  -0x20(%ebp)
f010e6e7:	e8 64 00 00 00       	call   f010e750 <__page_fault_handler_with_buffering>
f010e6ec:	83 c4 10             	add    $0x10,%esp
f010e6ef:	eb 11                	jmp    f010e702 <fault_handler+0x290>
		}
		else
		{
			//page_fault_handler(faulted_env, fault_va);
			page_fault_handler(faulted_env, fault_va);
f010e6f1:	83 ec 08             	sub    $0x8,%esp
f010e6f4:	ff 75 ec             	pushl  -0x14(%ebp)
f010e6f7:	ff 75 e0             	pushl  -0x20(%ebp)
f010e6fa:	e8 34 00 00 00       	call   f010e733 <page_fault_handler>
f010e6ff:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010e702:	0f 20 d8             	mov    %cr3,%eax
f010e705:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010e708:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e70b:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f010e70e:	90                   	nop
f010e70f:	c9                   	leave  
f010e710:	c3                   	ret    

f010e711 <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f010e711:	55                   	push   %ebp
f010e712:	89 e5                	mov    %esp,%ebp
f010e714:	83 ec 18             	sub    $0x18,%esp
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
	}
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
f010e717:	8b 45 08             	mov    0x8(%ebp),%eax
f010e71a:	8b 40 64             	mov    0x64(%eax),%eax
f010e71d:	83 ec 04             	sub    $0x4,%esp
f010e720:	8d 55 f4             	lea    -0xc(%ebp),%edx
f010e723:	52                   	push   %edx
f010e724:	ff 75 0c             	pushl  0xc(%ebp)
f010e727:	50                   	push   %eax
f010e728:	e8 24 9b ff ff       	call   f0108251 <__static_cpt>
f010e72d:	83 c4 10             	add    $0x10,%esp
	}
#endif
}
f010e730:	90                   	nop
f010e731:	c9                   	leave  
f010e732:	c3                   	ret    

f010e733 <page_fault_handler>:

//=========================
// [3] PAGE FAULT HANDLER:
//=========================
void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f010e733:	55                   	push   %ebp
f010e734:	89 e5                	mov    %esp,%ebp
f010e736:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24] [3] PAGE FAULT HANDLER
	// Write your code here, remove the panic and write your code
	panic("page_fault_handler() is not implemented yet...!!");
f010e739:	83 ec 04             	sub    $0x4,%esp
f010e73c:	68 00 6c 12 f0       	push   $0xf0126c00
f010e741:	68 db 00 00 00       	push   $0xdb
f010e746:	68 9b 6a 12 f0       	push   $0xf0126a9b
f010e74b:	e8 ca 1b ff ff       	call   f010031a <_panic>

f010e750 <__page_fault_handler_with_buffering>:
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f010e750:	55                   	push   %ebp
f010e751:	89 e5                	mov    %esp,%ebp
f010e753:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] PAGE FAULT HANDLER WITH BUFFERING
	// your code is here, remove the panic and write your code
	panic("__page_fault_handler_with_buffering() is not implemented yet...!!");
f010e756:	83 ec 04             	sub    $0x4,%esp
f010e759:	68 34 6c 12 f0       	push   $0xf0126c34
f010e75e:	68 fc 00 00 00       	push   $0xfc
f010e763:	68 9b 6a 12 f0       	push   $0xf0126a9b
f010e768:	e8 ad 1b ff ff       	call   f010031a <_panic>

f010e76d <init_spinlock>:
#include "spinlock.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_spinlock(struct spinlock *lk, char *name)
{
f010e76d:	55                   	push   %ebp
f010e76e:	89 e5                	mov    %esp,%ebp
f010e770:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f010e773:	8b 45 08             	mov    0x8(%ebp),%eax
f010e776:	83 c0 04             	add    $0x4,%eax
f010e779:	83 ec 08             	sub    $0x8,%esp
f010e77c:	ff 75 0c             	pushl  0xc(%ebp)
f010e77f:	50                   	push   %eax
f010e780:	e8 1b 1e 01 00       	call   f01205a0 <strcpy>
f010e785:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010e788:	8b 45 08             	mov    0x8(%ebp),%eax
f010e78b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f010e791:	8b 45 08             	mov    0x8(%ebp),%eax
f010e794:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f010e79b:	90                   	nop
f010e79c:	c9                   	leave  
f010e79d:	c3                   	ret    

f010e79e <acquire_spinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_spinlock(struct spinlock *lk)
{
f010e79e:	55                   	push   %ebp
f010e79f:	89 e5                	mov    %esp,%ebp
f010e7a1:	53                   	push   %ebx
f010e7a2:	83 ec 14             	sub    $0x14,%esp
	if(holding_spinlock(lk))
f010e7a5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7a8:	83 ec 0c             	sub    $0xc,%esp
f010e7ab:	50                   	push   %eax
f010e7ac:	e8 06 02 00 00       	call   f010e9b7 <holding_spinlock>
f010e7b1:	83 c4 10             	add    $0x10,%esp
f010e7b4:	85 c0                	test   %eax,%eax
f010e7b6:	74 18                	je     f010e7d0 <acquire_spinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f010e7b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7bb:	83 c0 04             	add    $0x4,%eax
f010e7be:	50                   	push   %eax
f010e7bf:	68 78 6c 12 f0       	push   $0xf0126c78
f010e7c4:	6a 1f                	push   $0x1f
f010e7c6:	68 b5 6c 12 f0       	push   $0xf0126cb5
f010e7cb:	e8 4a 1b ff ff       	call   f010031a <_panic>

	pushcli(); // disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler) just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
f010e7d0:	e8 09 87 ff ff       	call   f0106ede <pushcli>

	//cprintf("\nAttempt to acquire SPIN lock [%s] by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f010e7d5:	90                   	nop
f010e7d6:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e7dc:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010e7e3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e7e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e7e9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010e7ec:	f0 87 02             	lock xchg %eax,(%edx)
f010e7ef:	89 45 ec             	mov    %eax,-0x14(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f010e7f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e7f5:	85 c0                	test   %eax,%eax
f010e7f7:	75 dd                	jne    f010e7d6 <acquire_spinlock+0x38>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f010e7f9:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f010e7fe:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010e801:	e8 15 86 ff ff       	call   f0106e1b <mycpu>
f010e806:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f010e809:	8b 45 08             	mov    0x8(%ebp),%eax
f010e80c:	83 c0 48             	add    $0x48,%eax
f010e80f:	83 ec 08             	sub    $0x8,%esp
f010e812:	50                   	push   %eax
f010e813:	8d 45 08             	lea    0x8(%ebp),%eax
f010e816:	50                   	push   %eax
f010e817:	e8 74 00 00 00       	call   f010e890 <getcallerpcs>
f010e81c:	83 c4 10             	add    $0x10,%esp

}
f010e81f:	90                   	nop
f010e820:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010e823:	c9                   	leave  
f010e824:	c3                   	ret    

f010e825 <release_spinlock>:

// Release the lock.
void release_spinlock(struct spinlock *lk)
{
f010e825:	55                   	push   %ebp
f010e826:	89 e5                	mov    %esp,%ebp
f010e828:	83 ec 08             	sub    $0x8,%esp
	if(!holding_spinlock(lk))
f010e82b:	83 ec 0c             	sub    $0xc,%esp
f010e82e:	ff 75 08             	pushl  0x8(%ebp)
f010e831:	e8 81 01 00 00       	call   f010e9b7 <holding_spinlock>
f010e836:	83 c4 10             	add    $0x10,%esp
f010e839:	85 c0                	test   %eax,%eax
f010e83b:	75 26                	jne    f010e863 <release_spinlock+0x3e>
	{
		printcallstack(lk);
f010e83d:	83 ec 0c             	sub    $0xc,%esp
f010e840:	ff 75 08             	pushl  0x8(%ebp)
f010e843:	e8 08 01 00 00       	call   f010e950 <printcallstack>
f010e848:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f010e84b:	8b 45 08             	mov    0x8(%ebp),%eax
f010e84e:	83 c0 04             	add    $0x4,%eax
f010e851:	50                   	push   %eax
f010e852:	68 cc 6c 12 f0       	push   $0xf0126ccc
f010e857:	6a 3b                	push   $0x3b
f010e859:	68 b5 6c 12 f0       	push   $0xf0126cb5
f010e85e:	e8 b7 1a ff ff       	call   f010031a <_panic>
	}
	lk->pcs[0] = 0;
f010e863:	8b 45 08             	mov    0x8(%ebp),%eax
f010e866:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f010e86d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e870:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f010e877:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f010e87c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e87f:	8b 55 08             	mov    0x8(%ebp),%edx
f010e882:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	popcli();
f010e888:	e8 a3 86 ff ff       	call   f0106f30 <popcli>
}
f010e88d:	90                   	nop
f010e88e:	c9                   	leave  
f010e88f:	c3                   	ret    

f010e890 <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f010e890:	55                   	push   %ebp
f010e891:	89 e5                	mov    %esp,%ebp
f010e893:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f010e896:	e8 f3 bb ff ff       	call   f010a48e <get_cpu_proc>
f010e89b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f010e89e:	e8 78 85 ff ff       	call   f0106e1b <mycpu>
f010e8a3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f010e8a6:	8b 45 08             	mov    0x8(%ebp),%eax
f010e8a9:	83 e8 08             	sub    $0x8,%eax
f010e8ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f010e8af:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010e8b6:	eb 67                	jmp    f010e91f <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010e8b8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e8bc:	74 67                	je     f010e925 <getcallerpcs+0x95>
f010e8be:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f010e8c5:	76 5e                	jbe    f010e925 <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010e8c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e8ca:	8b 40 08             	mov    0x8(%eax),%eax
f010e8cd:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010e8d2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010e8d5:	77 10                	ja     f010e8e7 <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010e8d7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e8da:	8b 40 08             	mov    0x8(%eax),%eax
f010e8dd:	05 00 90 00 00       	add    $0x9000,%eax
f010e8e2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010e8e5:	77 3e                	ja     f010e925 <getcallerpcs+0x95>
f010e8e7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010e8eb:	74 10                	je     f010e8fd <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f010e8ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e8f0:	8b 40 70             	mov    0x70(%eax),%eax
f010e8f3:	05 00 80 00 00       	add    $0x8000,%eax
f010e8f8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010e8fb:	76 28                	jbe    f010e925 <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f010e8fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e900:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010e907:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e90a:	01 c2                	add    %eax,%edx
f010e90c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e90f:	8b 40 04             	mov    0x4(%eax),%eax
f010e912:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f010e914:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e917:	8b 00                	mov    (%eax),%eax
f010e919:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f010e91c:	ff 45 f0             	incl   -0x10(%ebp)
f010e91f:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010e923:	7e 93                	jle    f010e8b8 <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f010e925:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e928:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f010e92b:	eb 18                	jmp    f010e945 <getcallerpcs+0xb5>
		pcs[i] = 0;
f010e92d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e930:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010e937:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e93a:	01 d0                	add    %edx,%eax
f010e93c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f010e942:	ff 45 f0             	incl   -0x10(%ebp)
f010e945:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010e949:	7e e2                	jle    f010e92d <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f010e94b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010e94e:	c9                   	leave  
f010e94f:	c3                   	ret    

f010e950 <printcallstack>:

void printcallstack(struct spinlock *lk)
{
f010e950:	55                   	push   %ebp
f010e951:	89 e5                	mov    %esp,%ebp
f010e953:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f010e956:	83 ec 0c             	sub    $0xc,%esp
f010e959:	68 0a 6d 12 f0       	push   $0xf0126d0a
f010e95e:	e8 09 26 ff ff       	call   f0100f6c <cprintf>
f010e963:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f010e966:	8b 45 08             	mov    0x8(%ebp),%eax
f010e969:	83 c0 48             	add    $0x48,%eax
f010e96c:	83 ec 08             	sub    $0x8,%esp
f010e96f:	50                   	push   %eax
f010e970:	8d 45 08             	lea    0x8(%ebp),%eax
f010e973:	50                   	push   %eax
f010e974:	e8 17 ff ff ff       	call   f010e890 <getcallerpcs>
f010e979:	83 c4 10             	add    $0x10,%esp
f010e97c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f010e97f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010e986:	eb 24                	jmp    f010e9ac <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f010e988:	8b 45 08             	mov    0x8(%ebp),%eax
f010e98b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e98e:	83 c2 10             	add    $0x10,%edx
f010e991:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f010e995:	83 ec 04             	sub    $0x4,%esp
f010e998:	50                   	push   %eax
f010e999:	ff 75 f4             	pushl  -0xc(%ebp)
f010e99c:	68 1a 6d 12 f0       	push   $0xf0126d1a
f010e9a1:	e8 c6 25 ff ff       	call   f0100f6c <cprintf>
f010e9a6:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct spinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f010e9a9:	ff 45 f4             	incl   -0xc(%ebp)
f010e9ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e9af:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010e9b2:	7c d4                	jl     f010e988 <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f010e9b4:	90                   	nop
f010e9b5:	c9                   	leave  
f010e9b6:	c3                   	ret    

f010e9b7 <holding_spinlock>:
// Check whether this cpu is holding the lock.
int holding_spinlock(struct spinlock *lock)
{
f010e9b7:	55                   	push   %ebp
f010e9b8:	89 e5                	mov    %esp,%ebp
f010e9ba:	53                   	push   %ebx
f010e9bb:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f010e9be:	e8 1b 85 ff ff       	call   f0106ede <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f010e9c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e9c6:	8b 00                	mov    (%eax),%eax
f010e9c8:	85 c0                	test   %eax,%eax
f010e9ca:	74 16                	je     f010e9e2 <holding_spinlock+0x2b>
f010e9cc:	8b 45 08             	mov    0x8(%ebp),%eax
f010e9cf:	8b 58 44             	mov    0x44(%eax),%ebx
f010e9d2:	e8 44 84 ff ff       	call   f0106e1b <mycpu>
f010e9d7:	39 c3                	cmp    %eax,%ebx
f010e9d9:	75 07                	jne    f010e9e2 <holding_spinlock+0x2b>
f010e9db:	b8 01 00 00 00       	mov    $0x1,%eax
f010e9e0:	eb 05                	jmp    f010e9e7 <holding_spinlock+0x30>
f010e9e2:	b8 00 00 00 00       	mov    $0x0,%eax
f010e9e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f010e9ea:	e8 41 85 ff ff       	call   f0106f30 <popcli>
	return r;
f010e9ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e9f2:	83 c4 14             	add    $0x14,%esp
f010e9f5:	5b                   	pop    %ebx
f010e9f6:	5d                   	pop    %ebp
f010e9f7:	c3                   	ret    

f010e9f8 <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f010e9f8:	55                   	push   %ebp
f010e9f9:	89 e5                	mov    %esp,%ebp
f010e9fb:	83 ec 08             	sub    $0x8,%esp
	init_channel(&(lk->chan), "sleep lock channel");
f010e9fe:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea01:	83 c0 74             	add    $0x74,%eax
f010ea04:	83 ec 08             	sub    $0x8,%esp
f010ea07:	68 2c 6d 12 f0       	push   $0xf0126d2c
f010ea0c:	50                   	push   %eax
f010ea0d:	e8 de 00 00 00       	call   f010eaf0 <init_channel>
f010ea12:	83 c4 10             	add    $0x10,%esp
	init_spinlock(&(lk->lk), "lock of sleep lock");
f010ea15:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea18:	83 c0 04             	add    $0x4,%eax
f010ea1b:	83 ec 08             	sub    $0x8,%esp
f010ea1e:	68 3f 6d 12 f0       	push   $0xf0126d3f
f010ea23:	50                   	push   %eax
f010ea24:	e8 44 fd ff ff       	call   f010e76d <init_spinlock>
f010ea29:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f010ea2c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea2f:	05 c4 00 00 00       	add    $0xc4,%eax
f010ea34:	83 ec 08             	sub    $0x8,%esp
f010ea37:	ff 75 0c             	pushl  0xc(%ebp)
f010ea3a:	50                   	push   %eax
f010ea3b:	e8 60 1b 01 00       	call   f01205a0 <strcpy>
f010ea40:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010ea43:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea46:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f010ea4c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea4f:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f010ea56:	00 00 00 
}
f010ea59:	90                   	nop
f010ea5a:	c9                   	leave  
f010ea5b:	c3                   	ret    

f010ea5c <holding_sleeplock>:
int holding_sleeplock(struct sleeplock *lk)
{
f010ea5c:	55                   	push   %ebp
f010ea5d:	89 e5                	mov    %esp,%ebp
f010ea5f:	53                   	push   %ebx
f010ea60:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_spinlock(&(lk->lk));
f010ea63:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea66:	83 c0 04             	add    $0x4,%eax
f010ea69:	83 ec 0c             	sub    $0xc,%esp
f010ea6c:	50                   	push   %eax
f010ea6d:	e8 2c fd ff ff       	call   f010e79e <acquire_spinlock>
f010ea72:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f010ea75:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea78:	8b 00                	mov    (%eax),%eax
f010ea7a:	85 c0                	test   %eax,%eax
f010ea7c:	74 1c                	je     f010ea9a <holding_sleeplock+0x3e>
f010ea7e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea81:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f010ea87:	e8 02 ba ff ff       	call   f010a48e <get_cpu_proc>
f010ea8c:	8b 40 10             	mov    0x10(%eax),%eax
f010ea8f:	39 c3                	cmp    %eax,%ebx
f010ea91:	75 07                	jne    f010ea9a <holding_sleeplock+0x3e>
f010ea93:	b8 01 00 00 00       	mov    $0x1,%eax
f010ea98:	eb 05                	jmp    f010ea9f <holding_sleeplock+0x43>
f010ea9a:	b8 00 00 00 00       	mov    $0x0,%eax
f010ea9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_spinlock(&(lk->lk));
f010eaa2:	8b 45 08             	mov    0x8(%ebp),%eax
f010eaa5:	83 c0 04             	add    $0x4,%eax
f010eaa8:	83 ec 0c             	sub    $0xc,%esp
f010eaab:	50                   	push   %eax
f010eaac:	e8 74 fd ff ff       	call   f010e825 <release_spinlock>
f010eab1:	83 c4 10             	add    $0x10,%esp
	return r;
f010eab4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010eab7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010eaba:	c9                   	leave  
f010eabb:	c3                   	ret    

f010eabc <acquire_sleeplock>:
//==========================================================================

void acquire_sleeplock(struct sleeplock *lk)
{
f010eabc:	55                   	push   %ebp
f010eabd:	89 e5                	mov    %esp,%ebp
f010eabf:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("acquire_sleeplock is not implemented yet");
f010eac2:	83 ec 04             	sub    $0x4,%esp
f010eac5:	68 54 6d 12 f0       	push   $0xf0126d54
f010eaca:	6a 25                	push   $0x25
f010eacc:	68 7d 6d 12 f0       	push   $0xf0126d7d
f010ead1:	e8 44 18 ff ff       	call   f010031a <_panic>

f010ead6 <release_sleeplock>:
	//Your Code is Here...

}

void release_sleeplock(struct sleeplock *lk)
{
f010ead6:	55                   	push   %ebp
f010ead7:	89 e5                	mov    %esp,%ebp
f010ead9:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #14] [4] LOCKS - release_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("release_sleeplock is not implemented yet");
f010eadc:	83 ec 04             	sub    $0x4,%esp
f010eadf:	68 94 6d 12 f0       	push   $0xf0126d94
f010eae4:	6a 2e                	push   $0x2e
f010eae6:	68 7d 6d 12 f0       	push   $0xf0126d7d
f010eaeb:	e8 2a 18 ff ff       	call   f010031a <_panic>

f010eaf0 <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f010eaf0:	55                   	push   %ebp
f010eaf1:	89 e5                	mov    %esp,%ebp
f010eaf3:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f010eaf6:	8b 45 08             	mov    0x8(%ebp),%eax
f010eaf9:	83 c0 10             	add    $0x10,%eax
f010eafc:	83 ec 08             	sub    $0x8,%esp
f010eaff:	ff 75 0c             	pushl  0xc(%ebp)
f010eb02:	50                   	push   %eax
f010eb03:	e8 98 1a 01 00       	call   f01205a0 <strcpy>
f010eb08:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f010eb0b:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb0e:	83 ec 0c             	sub    $0xc,%esp
f010eb11:	50                   	push   %eax
f010eb12:	e8 3e 61 ff ff       	call   f0104c55 <init_queue>
f010eb17:	83 c4 10             	add    $0x10,%esp
}
f010eb1a:	90                   	nop
f010eb1b:	c9                   	leave  
f010eb1c:	c3                   	ret    

f010eb1d <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct spinlock* lk)
{
f010eb1d:	55                   	push   %ebp
f010eb1e:	89 e5                	mov    %esp,%ebp
f010eb20:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #10] [4] LOCKS - sleep
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("sleep is not implemented yet");
f010eb23:	83 ec 04             	sub    $0x4,%esp
f010eb26:	68 c0 6d 12 f0       	push   $0xf0126dc0
f010eb2b:	6a 21                	push   $0x21
f010eb2d:	68 dd 6d 12 f0       	push   $0xf0126ddd
f010eb32:	e8 e3 17 ff ff       	call   f010031a <_panic>

f010eb37 <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f010eb37:	55                   	push   %ebp
f010eb38:	89 e5                	mov    %esp,%ebp
f010eb3a:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #11] [4] LOCKS - wakeup_one
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wakeup_one is not implemented yet");
f010eb3d:	83 ec 04             	sub    $0x4,%esp
f010eb40:	68 f4 6d 12 f0       	push   $0xf0126df4
f010eb45:	6a 31                	push   $0x31
f010eb47:	68 dd 6d 12 f0       	push   $0xf0126ddd
f010eb4c:	e8 c9 17 ff ff       	call   f010031a <_panic>

f010eb51 <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f010eb51:	55                   	push   %ebp
f010eb52:	89 e5                	mov    %esp,%ebp
f010eb54:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #12] [4] LOCKS - wakeup_all
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wakeup_all is not implemented yet");
f010eb57:	83 ec 04             	sub    $0x4,%esp
f010eb5a:	68 18 6e 12 f0       	push   $0xf0126e18
f010eb5f:	6a 41                	push   $0x41
f010eb61:	68 dd 6d 12 f0       	push   $0xf0126ddd
f010eb66:	e8 af 17 ff ff       	call   f010031a <_panic>

f010eb6b <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f010eb6b:	55                   	push   %ebp
f010eb6c:	89 e5                	mov    %esp,%ebp
f010eb6e:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("init_ksemaphore is not implemented yet");
f010eb71:	83 ec 04             	sub    $0x4,%esp
f010eb74:	68 3c 6e 12 f0       	push   $0xf0126e3c
f010eb79:	6a 13                	push   $0x13
f010eb7b:	68 63 6e 12 f0       	push   $0xf0126e63
f010eb80:	e8 95 17 ff ff       	call   f010031a <_panic>

f010eb85 <wait_ksemaphore>:
	//Your Code is Here...
}

void wait_ksemaphore(struct ksemaphore *ksem)
{
f010eb85:	55                   	push   %ebp
f010eb86:	89 e5                	mov    %esp,%ebp
f010eb88:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wait_ksemaphore is not implemented yet");
f010eb8b:	83 ec 04             	sub    $0x4,%esp
f010eb8e:	68 7c 6e 12 f0       	push   $0xf0126e7c
f010eb93:	6a 1b                	push   $0x1b
f010eb95:	68 63 6e 12 f0       	push   $0xf0126e63
f010eb9a:	e8 7b 17 ff ff       	call   f010031a <_panic>

f010eb9f <signal_ksemaphore>:
	//Your Code is Here...

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f010eb9f:	55                   	push   %ebp
f010eba0:	89 e5                	mov    %esp,%ebp
f010eba2:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("signal_ksemaphore is not implemented yet");
f010eba5:	83 ec 04             	sub    $0x4,%esp
f010eba8:	68 a4 6e 12 f0       	push   $0xf0126ea4
f010ebad:	6a 24                	push   $0x24
f010ebaf:	68 63 6e 12 f0       	push   $0xf0126e63
f010ebb4:	e8 61 17 ff ff       	call   f010031a <_panic>

f010ebb9 <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010ebb9:	55                   	push   %ebp
f010ebba:	89 e5                	mov    %esp,%ebp
f010ebbc:	c7 05 b0 4f 55 f0 01 	movl   $0x1,0xf0554fb0
f010ebc3:	00 00 00 
f010ebc6:	90                   	nop
f010ebc7:	5d                   	pop    %ebp
f010ebc8:	c3                   	ret    

f010ebc9 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f010ebc9:	55                   	push   %ebp
f010ebca:	89 e5                	mov    %esp,%ebp
f010ebcc:	c7 05 b0 4f 55 f0 02 	movl   $0x2,0xf0554fb0
f010ebd3:	00 00 00 
f010ebd6:	90                   	nop
f010ebd7:	5d                   	pop    %ebp
f010ebd8:	c3                   	ret    

f010ebd9 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f010ebd9:	55                   	push   %ebp
f010ebda:	89 e5                	mov    %esp,%ebp
f010ebdc:	c7 05 b0 4f 55 f0 03 	movl   $0x3,0xf0554fb0
f010ebe3:	00 00 00 
f010ebe6:	90                   	nop
f010ebe7:	5d                   	pop    %ebp
f010ebe8:	c3                   	ret    

f010ebe9 <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010ebe9:	55                   	push   %ebp
f010ebea:	89 e5                	mov    %esp,%ebp
f010ebec:	a1 b0 4f 55 f0       	mov    0xf0554fb0,%eax
f010ebf1:	83 f8 01             	cmp    $0x1,%eax
f010ebf4:	75 04                	jne    f010ebfa <isKHeapPlacementStrategyFIRSTFIT+0x11>
f010ebf6:	b0 01                	mov    $0x1,%al
f010ebf8:	eb 02                	jmp    f010ebfc <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010ebfa:	b0 00                	mov    $0x0,%al
f010ebfc:	5d                   	pop    %ebp
f010ebfd:	c3                   	ret    

f010ebfe <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f010ebfe:	55                   	push   %ebp
f010ebff:	89 e5                	mov    %esp,%ebp
f010ec01:	a1 b0 4f 55 f0       	mov    0xf0554fb0,%eax
f010ec06:	83 f8 02             	cmp    $0x2,%eax
f010ec09:	75 04                	jne    f010ec0f <isKHeapPlacementStrategyBESTFIT+0x11>
f010ec0b:	b0 01                	mov    $0x1,%al
f010ec0d:	eb 02                	jmp    f010ec11 <isKHeapPlacementStrategyBESTFIT+0x13>
f010ec0f:	b0 00                	mov    $0x0,%al
f010ec11:	5d                   	pop    %ebp
f010ec12:	c3                   	ret    

f010ec13 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f010ec13:	55                   	push   %ebp
f010ec14:	89 e5                	mov    %esp,%ebp
f010ec16:	a1 b0 4f 55 f0       	mov    0xf0554fb0,%eax
f010ec1b:	83 f8 03             	cmp    $0x3,%eax
f010ec1e:	75 04                	jne    f010ec24 <isKHeapPlacementStrategyNEXTFIT+0x11>
f010ec20:	b0 01                	mov    $0x1,%al
f010ec22:	eb 02                	jmp    f010ec26 <isKHeapPlacementStrategyNEXTFIT+0x13>
f010ec24:	b0 00                	mov    $0x0,%al
f010ec26:	5d                   	pop    %ebp
f010ec27:	c3                   	ret    

f010ec28 <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f010ec28:	55                   	push   %ebp
f010ec29:	89 e5                	mov    %esp,%ebp
f010ec2b:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f010ec2e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ec35:	eb 26                	jmp    f010ec5d <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f010ec37:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ec3a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010ec41:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec44:	01 c2                	add    %eax,%edx
f010ec46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ec49:	40                   	inc    %eax
f010ec4a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010ec51:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec54:	01 c8                	add    %ecx,%eax
f010ec56:	8b 00                	mov    (%eax),%eax
f010ec58:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f010ec5a:	ff 45 f4             	incl   -0xc(%ebp)
f010ec5d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec60:	48                   	dec    %eax
f010ec61:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ec64:	7f d1                	jg     f010ec37 <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f010ec66:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f010ec69:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f010ec70:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010ec77:	eb 35                	jmp    f010ecae <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f010ec79:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ec7c:	89 d0                	mov    %edx,%eax
f010ec7e:	01 c0                	add    %eax,%eax
f010ec80:	01 d0                	add    %edx,%eax
f010ec82:	c1 e0 02             	shl    $0x2,%eax
f010ec85:	05 c0 9c 17 f0       	add    $0xf0179cc0,%eax
f010ec8a:	8b 10                	mov    (%eax),%edx
f010ec8c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec8f:	8b 00                	mov    (%eax),%eax
f010ec91:	83 ec 08             	sub    $0x8,%esp
f010ec94:	52                   	push   %edx
f010ec95:	50                   	push   %eax
f010ec96:	e8 c2 19 01 00       	call   f012065d <strcmp>
f010ec9b:	83 c4 10             	add    $0x10,%esp
f010ec9e:	85 c0                	test   %eax,%eax
f010eca0:	75 09                	jne    f010ecab <tst_handler+0x83>
		{
			test_found = 1;
f010eca2:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f010eca9:	eb 0f                	jmp    f010ecba <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f010ecab:	ff 45 ec             	incl   -0x14(%ebp)
f010ecae:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ecb1:	a1 74 9d 17 f0       	mov    0xf0179d74,%eax
f010ecb6:	39 c2                	cmp    %eax,%edx
f010ecb8:	72 bf                	jb     f010ec79 <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f010ecba:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ecbe:	74 29                	je     f010ece9 <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f010ecc0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ecc3:	89 d0                	mov    %edx,%eax
f010ecc5:	01 c0                	add    %eax,%eax
f010ecc7:	01 d0                	add    %edx,%eax
f010ecc9:	c1 e0 02             	shl    $0x2,%eax
f010eccc:	05 c8 9c 17 f0       	add    $0xf0179cc8,%eax
f010ecd1:	8b 00                	mov    (%eax),%eax
f010ecd3:	83 ec 08             	sub    $0x8,%esp
f010ecd6:	ff 75 0c             	pushl  0xc(%ebp)
f010ecd9:	ff 75 08             	pushl  0x8(%ebp)
f010ecdc:	ff d0                	call   *%eax
f010ecde:	83 c4 10             	add    $0x10,%esp
f010ece1:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f010ece4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ece7:	eb 1b                	jmp    f010ed04 <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f010ece9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ecec:	8b 00                	mov    (%eax),%eax
f010ecee:	83 ec 08             	sub    $0x8,%esp
f010ecf1:	50                   	push   %eax
f010ecf2:	68 e4 71 12 f0       	push   $0xf01271e4
f010ecf7:	e8 70 22 ff ff       	call   f0100f6c <cprintf>
f010ecfc:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ecff:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f010ed04:	c9                   	leave  
f010ed05:	c3                   	ret    

f010ed06 <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f010ed06:	55                   	push   %ebp
f010ed07:	89 e5                	mov    %esp,%ebp
f010ed09:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f010ed0c:	e8 0f f1 00 00       	call   f011de20 <test_three_creation_functions>
	return 0;
f010ed11:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ed16:	c9                   	leave  
f010ed17:	c3                   	ret    

f010ed18 <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f010ed18:	55                   	push   %ebp
f010ed19:	89 e5                	mov    %esp,%ebp
f010ed1b:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f010ed1e:	e8 51 80 00 00       	call   f0116d74 <test_priority_normal_and_higher>
	return 0;
f010ed23:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ed28:	c9                   	leave  
f010ed29:	c3                   	ret    

f010ed2a <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f010ed2a:	55                   	push   %ebp
f010ed2b:	89 e5                	mov    %esp,%ebp
f010ed2d:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f010ed30:	e8 a9 8a 00 00       	call   f01177de <test_priority_normal_and_lower>
	return 0;
f010ed35:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ed3a:	c9                   	leave  
f010ed3b:	c3                   	ret    

f010ed3c <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f010ed3c:	55                   	push   %ebp
f010ed3d:	89 e5                	mov    %esp,%ebp
f010ed3f:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f010ed42:	e8 91 f2 00 00       	call   f011dfd8 <test_kfreeall>
	return 0;
f010ed47:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ed4c:	c9                   	leave  
f010ed4d:	c3                   	ret    

f010ed4e <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f010ed4e:	55                   	push   %ebp
f010ed4f:	89 e5                	mov    %esp,%ebp
f010ed51:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f010ed54:	e8 9c f2 00 00       	call   f011dff5 <test_kexpand>
	return 0;
f010ed59:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ed5e:	c9                   	leave  
f010ed5f:	c3                   	ret    

f010ed60 <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f010ed60:	55                   	push   %ebp
f010ed61:	89 e5                	mov    %esp,%ebp
f010ed63:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f010ed66:	e8 a7 f2 00 00       	call   f011e012 <test_kshrink>
	return 0;
f010ed6b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ed70:	c9                   	leave  
f010ed71:	c3                   	ret    

f010ed72 <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f010ed72:	55                   	push   %ebp
f010ed73:	89 e5                	mov    %esp,%ebp
f010ed75:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f010ed78:	e8 b2 f2 00 00       	call   f011e02f <test_kfreelast>
	return 0;
f010ed7d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ed82:	c9                   	leave  
f010ed83:	c3                   	ret    

f010ed84 <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f010ed84:	55                   	push   %ebp
f010ed85:	89 e5                	mov    %esp,%ebp
f010ed87:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f010ed8a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ed8d:	83 c0 04             	add    $0x4,%eax
f010ed90:	8b 00                	mov    (%eax),%eax
f010ed92:	83 ec 04             	sub    $0x4,%esp
f010ed95:	6a 0a                	push   $0xa
f010ed97:	6a 00                	push   $0x0
f010ed99:	50                   	push   %eax
f010ed9a:	e8 12 1b 01 00       	call   f01208b1 <strtol>
f010ed9f:	83 c4 10             	add    $0x10,%esp
f010eda2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f010eda5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f010edac:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
f010edb3:	83 ec 0c             	sub    $0xc,%esp
f010edb6:	68 60 24 55 f0       	push   $0xf0552460
f010edbb:	e8 de f9 ff ff       	call   f010e79e <acquire_spinlock>
f010edc0:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f010edc3:	a1 e0 24 55 f0       	mov    0xf05524e0,%eax
f010edc8:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010edcb:	eb 3b                	jmp    f010ee08 <tst_sc_MLFQ+0x84>
			{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f010edcd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010edd0:	83 c0 20             	add    $0x20,%eax
f010edd3:	83 ec 08             	sub    $0x8,%esp
f010edd6:	68 f7 71 12 f0       	push   $0xf01271f7
f010eddb:	50                   	push   %eax
f010eddc:	e8 7c 18 01 00       	call   f012065d <strcmp>
f010ede1:	83 c4 10             	add    $0x10,%esp
f010ede4:	85 c0                	test   %eax,%eax
f010ede6:	75 12                	jne    f010edfa <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f010ede8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010edec:	74 07                	je     f010edf5 <tst_sc_MLFQ+0x71>
					firstTime = 0;
f010edee:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f010edf5:	ff 45 f4             	incl   -0xc(%ebp)
f010edf8:	eb 06                	jmp    f010ee00 <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f010edfa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010edfe:	74 31                	je     f010ee31 <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f010ee00:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f010ee05:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010ee08:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010ee0c:	74 08                	je     f010ee16 <tst_sc_MLFQ+0x92>
f010ee0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ee11:	8b 40 08             	mov    0x8(%eax),%eax
f010ee14:	eb 05                	jmp    f010ee1b <tst_sc_MLFQ+0x97>
f010ee16:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee1b:	a3 e8 24 55 f0       	mov    %eax,0xf05524e8
f010ee20:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f010ee25:	85 c0                	test   %eax,%eax
f010ee27:	75 a4                	jne    f010edcd <tst_sc_MLFQ+0x49>
f010ee29:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010ee2d:	75 9e                	jne    f010edcd <tst_sc_MLFQ+0x49>
f010ee2f:	eb 01                	jmp    f010ee32 <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f010ee31:	90                   	nop
			}
		if(cnt == numOfSlave2)
f010ee32:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ee35:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010ee38:	75 12                	jne    f010ee4c <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f010ee3a:	83 ec 0c             	sub    $0xc,%esp
f010ee3d:	68 00 72 12 f0       	push   $0xf0127200
f010ee42:	e8 25 21 ff ff       	call   f0100f6c <cprintf>
f010ee47:	83 c4 10             	add    $0x10,%esp
f010ee4a:	eb 17                	jmp    f010ee63 <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f010ee4c:	83 ec 04             	sub    $0x4,%esp
f010ee4f:	68 39 72 12 f0       	push   $0xf0127239
f010ee54:	68 9b 00 00 00       	push   $0x9b
f010ee59:	68 4f 72 12 f0       	push   $0xf012724f
f010ee5e:	e8 b7 14 ff ff       	call   f010031a <_panic>
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f010ee63:	83 ec 0c             	sub    $0xc,%esp
f010ee66:	68 60 24 55 f0       	push   $0xf0552460
f010ee6b:	e8 b5 f9 ff ff       	call   f010e825 <release_spinlock>
f010ee70:	83 c4 10             	add    $0x10,%esp
	return 0;
f010ee73:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ee78:	c9                   	leave  
f010ee79:	c3                   	ret    

f010ee7a <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f010ee7a:	55                   	push   %ebp
f010ee7b:	89 e5                	mov    %esp,%ebp
f010ee7d:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f010ee80:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010ee84:	74 17                	je     f010ee9d <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f010ee86:	83 ec 0c             	sub    $0xc,%esp
f010ee89:	68 68 72 12 f0       	push   $0xf0127268
f010ee8e:	e8 d9 20 ff ff       	call   f0100f6c <cprintf>
f010ee93:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ee96:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee9b:	eb 45                	jmp    f010eee2 <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f010ee9d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eea0:	83 c0 04             	add    $0x4,%eax
f010eea3:	8b 00                	mov    (%eax),%eax
f010eea5:	83 ec 04             	sub    $0x4,%esp
f010eea8:	6a 0a                	push   $0xa
f010eeaa:	6a 00                	push   $0x0
f010eeac:	50                   	push   %eax
f010eead:	e8 ff 19 01 00       	call   f01208b1 <strtol>
f010eeb2:	83 c4 10             	add    $0x10,%esp
f010eeb5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f010eeb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eebb:	83 f8 01             	cmp    $0x1,%eax
f010eebe:	74 10                	je     f010eed0 <tst_bsd_nice+0x56>
f010eec0:	83 f8 02             	cmp    $0x2,%eax
f010eec3:	74 12                	je     f010eed7 <tst_bsd_nice+0x5d>
f010eec5:	85 c0                	test   %eax,%eax
f010eec7:	75 14                	jne    f010eedd <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f010eec9:	e8 54 f4 00 00       	call   f011e322 <test_bsd_nice_0>
		break;
f010eece:	eb 0d                	jmp    f010eedd <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f010eed0:	e8 d7 f6 00 00       	call   f011e5ac <test_bsd_nice_1>
		break;
f010eed5:	eb 06                	jmp    f010eedd <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f010eed7:	e8 e4 f8 00 00       	call   f011e7c0 <test_bsd_nice_2>
		break;
f010eedc:	90                   	nop
	}
	return 0;
f010eedd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010eee2:	c9                   	leave  
f010eee3:	c3                   	ret    

f010eee4 <tst_str2lower>:

int tst_str2lower(int number_of_arguments, char **arguments)
{
f010eee4:	55                   	push   %ebp
f010eee5:	89 e5                	mov    %esp,%ebp
f010eee7:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f010eeea:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010eeee:	74 17                	je     f010ef07 <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f010eef0:	83 ec 0c             	sub    $0xc,%esp
f010eef3:	68 a8 72 12 f0       	push   $0xf01272a8
f010eef8:	e8 6f 20 ff ff       	call   f0100f6c <cprintf>
f010eefd:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ef00:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef05:	eb 0a                	jmp    f010ef11 <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f010ef07:	e8 42 29 00 00       	call   f011184e <test_str2lower_function>
	return 0;
f010ef0c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ef11:	c9                   	leave  
f010ef12:	c3                   	ret    

f010ef13 <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f010ef13:	55                   	push   %ebp
f010ef14:	89 e5                	mov    %esp,%ebp
f010ef16:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f010ef19:	e8 66 25 00 00       	call   f0111484 <TestAutoCompleteCommand>
f010ef1e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f010ef21:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ef26:	c9                   	leave  
f010ef27:	c3                   	ret    

f010ef28 <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f010ef28:	55                   	push   %ebp
f010ef29:	89 e5                	mov    %esp,%ebp
f010ef2b:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010ef2e:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010ef32:	74 1a                	je     f010ef4e <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f010ef34:	83 ec 0c             	sub    $0xc,%esp
f010ef37:	68 dc 72 12 f0       	push   $0xf01272dc
f010ef3c:	e8 2b 20 ff ff       	call   f0100f6c <cprintf>
f010ef41:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ef44:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef49:	e9 2f 01 00 00       	jmp    f010f07d <tst_dyn_alloc+0x155>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f010ef4e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef51:	83 c0 04             	add    $0x4,%eax
f010ef54:	8b 00                	mov    (%eax),%eax
f010ef56:	83 ec 08             	sub    $0x8,%esp
f010ef59:	68 19 73 12 f0       	push   $0xf0127319
f010ef5e:	50                   	push   %eax
f010ef5f:	e8 f9 16 01 00       	call   f012065d <strcmp>
f010ef64:	83 c4 10             	add    $0x10,%esp
f010ef67:	85 c0                	test   %eax,%eax
f010ef69:	75 0a                	jne    f010ef75 <tst_dyn_alloc+0x4d>
	{
		test_initialize_dynamic_allocator();
f010ef6b:	e8 35 07 00 00       	call   f010f6a5 <test_initialize_dynamic_allocator>
f010ef70:	e9 03 01 00 00       	jmp    f010f078 <tst_dyn_alloc+0x150>
	}
	// Test 2 Example for alloc_block_FF: tstdynalloc allocFF
	else if(strcmp(arguments[1], "allocff") == 0)
f010ef75:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef78:	83 c0 04             	add    $0x4,%eax
f010ef7b:	8b 00                	mov    (%eax),%eax
f010ef7d:	83 ec 08             	sub    $0x8,%esp
f010ef80:	68 1e 73 12 f0       	push   $0xf012731e
f010ef85:	50                   	push   %eax
f010ef86:	e8 d2 16 01 00       	call   f012065d <strcmp>
f010ef8b:	83 c4 10             	add    $0x10,%esp
f010ef8e:	85 c0                	test   %eax,%eax
f010ef90:	75 0a                	jne    f010ef9c <tst_dyn_alloc+0x74>
	{
		test_alloc_block_FF();
f010ef92:	e8 c7 0b 00 00       	call   f010fb5e <test_alloc_block_FF>
f010ef97:	e9 dc 00 00 00       	jmp    f010f078 <tst_dyn_alloc+0x150>
	}
	// Test 3 Example for alloc_block_BF: tstdynalloc allocBF
	else if(strcmp(arguments[1], "allocbf") == 0)
f010ef9c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef9f:	83 c0 04             	add    $0x4,%eax
f010efa2:	8b 00                	mov    (%eax),%eax
f010efa4:	83 ec 08             	sub    $0x8,%esp
f010efa7:	68 26 73 12 f0       	push   $0xf0127326
f010efac:	50                   	push   %eax
f010efad:	e8 ab 16 01 00       	call   f012065d <strcmp>
f010efb2:	83 c4 10             	add    $0x10,%esp
f010efb5:	85 c0                	test   %eax,%eax
f010efb7:	75 0a                	jne    f010efc3 <tst_dyn_alloc+0x9b>
	{
		test_alloc_block_BF();
f010efb9:	e8 1a 10 00 00       	call   f010ffd8 <test_alloc_block_BF>
f010efbe:	e9 b5 00 00 00       	jmp    f010f078 <tst_dyn_alloc+0x150>
	}
	// Test 4 Example for alloc_block_NF: tstdynalloc allocNF
	else if(strcmp(arguments[1], "allocnf") == 0)
f010efc3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010efc6:	83 c0 04             	add    $0x4,%eax
f010efc9:	8b 00                	mov    (%eax),%eax
f010efcb:	83 ec 08             	sub    $0x8,%esp
f010efce:	68 2e 73 12 f0       	push   $0xf012732e
f010efd3:	50                   	push   %eax
f010efd4:	e8 84 16 01 00       	call   f012065d <strcmp>
f010efd9:	83 c4 10             	add    $0x10,%esp
f010efdc:	85 c0                	test   %eax,%eax
f010efde:	75 0a                	jne    f010efea <tst_dyn_alloc+0xc2>
	{
		test_alloc_block_NF();
f010efe0:	e8 10 10 00 00       	call   f010fff5 <test_alloc_block_NF>
f010efe5:	e9 8e 00 00 00       	jmp    f010f078 <tst_dyn_alloc+0x150>
	}
	// Test 5 Example for free_block: tstdynalloc freeFF
	else if(strcmp(arguments[1], "freeff") == 0)
f010efea:	8b 45 0c             	mov    0xc(%ebp),%eax
f010efed:	83 c0 04             	add    $0x4,%eax
f010eff0:	8b 00                	mov    (%eax),%eax
f010eff2:	83 ec 08             	sub    $0x8,%esp
f010eff5:	68 36 73 12 f0       	push   $0xf0127336
f010effa:	50                   	push   %eax
f010effb:	e8 5d 16 01 00       	call   f012065d <strcmp>
f010f000:	83 c4 10             	add    $0x10,%esp
f010f003:	85 c0                	test   %eax,%eax
f010f005:	75 07                	jne    f010f00e <tst_dyn_alloc+0xe6>
	{
		test_free_block_FF();
f010f007:	e8 ef 0f 00 00       	call   f010fffb <test_free_block_FF>
f010f00c:	eb 6a                	jmp    f010f078 <tst_dyn_alloc+0x150>
	}
	// Test 6 Example for free_block: tstdynalloc freeBF
	else if(strcmp(arguments[1], "freebf") == 0)
f010f00e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f011:	83 c0 04             	add    $0x4,%eax
f010f014:	8b 00                	mov    (%eax),%eax
f010f016:	83 ec 08             	sub    $0x8,%esp
f010f019:	68 3d 73 12 f0       	push   $0xf012733d
f010f01e:	50                   	push   %eax
f010f01f:	e8 39 16 01 00       	call   f012065d <strcmp>
f010f024:	83 c4 10             	add    $0x10,%esp
f010f027:	85 c0                	test   %eax,%eax
f010f029:	75 07                	jne    f010f032 <tst_dyn_alloc+0x10a>
	{
		test_free_block_BF();
f010f02b:	e8 03 1f 00 00       	call   f0110f33 <test_free_block_BF>
f010f030:	eb 46                	jmp    f010f078 <tst_dyn_alloc+0x150>
	}
	// Test 7 Example for free_block: tstdynalloc freeNF
	else if(strcmp(arguments[1], "freenf") == 0)
f010f032:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f035:	83 c0 04             	add    $0x4,%eax
f010f038:	8b 00                	mov    (%eax),%eax
f010f03a:	83 ec 08             	sub    $0x8,%esp
f010f03d:	68 44 73 12 f0       	push   $0xf0127344
f010f042:	50                   	push   %eax
f010f043:	e8 15 16 01 00       	call   f012065d <strcmp>
f010f048:	83 c4 10             	add    $0x10,%esp
f010f04b:	85 c0                	test   %eax,%eax
f010f04d:	75 07                	jne    f010f056 <tst_dyn_alloc+0x12e>
	{
		test_free_block_NF();
f010f04f:	e8 2c 1f 00 00       	call   f0110f80 <test_free_block_NF>
f010f054:	eb 22                	jmp    f010f078 <tst_dyn_alloc+0x150>
	}
	// Test 8 Example for realloc_block_ff: tstdynalloc reallocFF
	else if(strcmp(arguments[1], "reallocff") == 0)
f010f056:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f059:	83 c0 04             	add    $0x4,%eax
f010f05c:	8b 00                	mov    (%eax),%eax
f010f05e:	83 ec 08             	sub    $0x8,%esp
f010f061:	68 4b 73 12 f0       	push   $0xf012734b
f010f066:	50                   	push   %eax
f010f067:	e8 f1 15 01 00       	call   f012065d <strcmp>
f010f06c:	83 c4 10             	add    $0x10,%esp
f010f06f:	85 c0                	test   %eax,%eax
f010f071:	75 05                	jne    f010f078 <tst_dyn_alloc+0x150>
	{
		test_realloc_block_FF();
f010f073:	e8 25 1f 00 00       	call   f0110f9d <test_realloc_block_FF>
		//test_realloc_block_FF_COMPLETE();
	}
	return 0;
f010f078:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f07d:	c9                   	leave  
f010f07e:	c3                   	ret    

f010f07f <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f010f07f:	55                   	push   %ebp
f010f080:	89 e5                	mov    %esp,%ebp
f010f082:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010f085:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f089:	74 1a                	je     f010f0a5 <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstchunk <testname>\n") ;
f010f08b:	83 ec 0c             	sub    $0xc,%esp
f010f08e:	68 58 73 12 f0       	push   $0xf0127358
f010f093:	e8 d4 1e ff ff       	call   f0100f6c <cprintf>
f010f098:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f09b:	b8 00 00 00 00       	mov    $0x0,%eax
f010f0a0:	e9 e1 00 00 00       	jmp    f010f186 <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f010f0a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0a8:	83 c0 04             	add    $0x4,%eax
f010f0ab:	8b 00                	mov    (%eax),%eax
f010f0ad:	83 ec 08             	sub    $0x8,%esp
f010f0b0:	68 91 73 12 f0       	push   $0xf0127391
f010f0b5:	50                   	push   %eax
f010f0b6:	e8 a2 15 01 00       	call   f012065d <strcmp>
f010f0bb:	83 c4 10             	add    $0x10,%esp
f010f0be:	85 c0                	test   %eax,%eax
f010f0c0:	75 0a                	jne    f010f0cc <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f010f0c2:	e8 9a 30 00 00       	call   f0112161 <test_cut_paste_pages>
f010f0c7:	e9 b5 00 00 00       	jmp    f010f181 <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f010f0cc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0cf:	83 c0 04             	add    $0x4,%eax
f010f0d2:	8b 00                	mov    (%eax),%eax
f010f0d4:	83 ec 08             	sub    $0x8,%esp
f010f0d7:	68 9a 73 12 f0       	push   $0xf012739a
f010f0dc:	50                   	push   %eax
f010f0dd:	e8 7b 15 01 00       	call   f012065d <strcmp>
f010f0e2:	83 c4 10             	add    $0x10,%esp
f010f0e5:	85 c0                	test   %eax,%eax
f010f0e7:	75 0a                	jne    f010f0f3 <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f010f0e9:	e8 be 3a 00 00       	call   f0112bac <test_copy_paste_chunk>
f010f0ee:	e9 8e 00 00 00       	jmp    f010f181 <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f010f0f3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0f6:	83 c0 04             	add    $0x4,%eax
f010f0f9:	8b 00                	mov    (%eax),%eax
f010f0fb:	83 ec 08             	sub    $0x8,%esp
f010f0fe:	68 a4 73 12 f0       	push   $0xf01273a4
f010f103:	50                   	push   %eax
f010f104:	e8 54 15 01 00       	call   f012065d <strcmp>
f010f109:	83 c4 10             	add    $0x10,%esp
f010f10c:	85 c0                	test   %eax,%eax
f010f10e:	75 07                	jne    f010f117 <tst_chunks+0x98>
	{
		test_share_chunk();
f010f110:	e8 95 4b 00 00       	call   f0113caa <test_share_chunk>
f010f115:	eb 6a                	jmp    f010f181 <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f010f117:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f11a:	83 c0 04             	add    $0x4,%eax
f010f11d:	8b 00                	mov    (%eax),%eax
f010f11f:	83 ec 08             	sub    $0x8,%esp
f010f122:	68 aa 73 12 f0       	push   $0xf01273aa
f010f127:	50                   	push   %eax
f010f128:	e8 30 15 01 00       	call   f012065d <strcmp>
f010f12d:	83 c4 10             	add    $0x10,%esp
f010f130:	85 c0                	test   %eax,%eax
f010f132:	75 07                	jne    f010f13b <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f010f134:	e8 99 55 00 00       	call   f01146d2 <test_allocate_chunk>
f010f139:	eb 46                	jmp    f010f181 <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f010f13b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f13e:	83 c0 04             	add    $0x4,%eax
f010f141:	8b 00                	mov    (%eax),%eax
f010f143:	83 ec 08             	sub    $0x8,%esp
f010f146:	68 b3 73 12 f0       	push   $0xf01273b3
f010f14b:	50                   	push   %eax
f010f14c:	e8 0c 15 01 00       	call   f012065d <strcmp>
f010f151:	83 c4 10             	add    $0x10,%esp
f010f154:	85 c0                	test   %eax,%eax
f010f156:	75 07                	jne    f010f15f <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f010f158:	e8 7c 5e 00 00       	call   f0114fd9 <test_calculate_required_frames>
f010f15d:	eb 22                	jmp    f010f181 <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f010f15f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f162:	83 c0 04             	add    $0x4,%eax
f010f165:	8b 00                	mov    (%eax),%eax
f010f167:	83 ec 08             	sub    $0x8,%esp
f010f16a:	68 c2 73 12 f0       	push   $0xf01273c2
f010f16f:	50                   	push   %eax
f010f170:	e8 e8 14 01 00       	call   f012065d <strcmp>
f010f175:	83 c4 10             	add    $0x10,%esp
f010f178:	85 c0                	test   %eax,%eax
f010f17a:	75 05                	jne    f010f181 <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f010f17c:	e8 cc 66 00 00       	call   f011584d <test_calculate_allocated_space>
	}
	return 0;
f010f181:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f186:	c9                   	leave  
f010f187:	c3                   	ret    

f010f188 <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f010f188:	55                   	push   %ebp
f010f189:	89 e5                	mov    %esp,%ebp
f010f18b:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010f18e:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f192:	74 1a                	je     f010f1ae <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstpg <testname>\n") ;
f010f194:	83 ec 0c             	sub    $0xc,%esp
f010f197:	68 d4 73 12 f0       	push   $0xf01273d4
f010f19c:	e8 cb 1d ff ff       	call   f0100f6c <cprintf>
f010f1a1:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f1a4:	b8 00 00 00 00       	mov    $0x0,%eax
f010f1a9:	e9 ba 00 00 00       	jmp    f010f268 <tst_paging_manipulation+0xe0>
	}
	// Test 1.1-Set/Clear permissions: tstpg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f010f1ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1b1:	83 c0 04             	add    $0x4,%eax
f010f1b4:	8b 00                	mov    (%eax),%eax
f010f1b6:	83 ec 08             	sub    $0x8,%esp
f010f1b9:	68 0a 74 12 f0       	push   $0xf012740a
f010f1be:	50                   	push   %eax
f010f1bf:	e8 99 14 01 00       	call   f012065d <strcmp>
f010f1c4:	83 c4 10             	add    $0x10,%esp
f010f1c7:	85 c0                	test   %eax,%eax
f010f1c9:	75 0a                	jne    f010f1d5 <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f010f1cb:	e8 04 2a 00 00       	call   f0111bd4 <test_pt_set_page_permissions>
f010f1d0:	e9 8e 00 00 00       	jmp    f010f263 <tst_paging_manipulation+0xdb>
	}
	// Test 1.2-Set/Clear permissions: tstpg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f010f1d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1d8:	83 c0 04             	add    $0x4,%eax
f010f1db:	8b 00                	mov    (%eax),%eax
f010f1dd:	83 ec 08             	sub    $0x8,%esp
f010f1e0:	68 12 74 12 f0       	push   $0xf0127412
f010f1e5:	50                   	push   %eax
f010f1e6:	e8 72 14 01 00       	call   f012065d <strcmp>
f010f1eb:	83 c4 10             	add    $0x10,%esp
f010f1ee:	85 c0                	test   %eax,%eax
f010f1f0:	75 07                	jne    f010f1f9 <tst_paging_manipulation+0x71>
	{
		test_pt_set_page_permissions_invalid_va();
f010f1f2:	e8 4c 2c 00 00       	call   f0111e43 <test_pt_set_page_permissions_invalid_va>
f010f1f7:	eb 6a                	jmp    f010f263 <tst_paging_manipulation+0xdb>
	}
	// Test 2-Get permissions: tstpg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f010f1f9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1fc:	83 c0 04             	add    $0x4,%eax
f010f1ff:	8b 00                	mov    (%eax),%eax
f010f201:	83 ec 08             	sub    $0x8,%esp
f010f204:	68 1a 74 12 f0       	push   $0xf012741a
f010f209:	50                   	push   %eax
f010f20a:	e8 4e 14 01 00       	call   f012065d <strcmp>
f010f20f:	83 c4 10             	add    $0x10,%esp
f010f212:	85 c0                	test   %eax,%eax
f010f214:	75 07                	jne    f010f21d <tst_paging_manipulation+0x95>
	{
		test_pt_get_page_permissions();
f010f216:	e8 71 2c 00 00       	call   f0111e8c <test_pt_get_page_permissions>
f010f21b:	eb 46                	jmp    f010f263 <tst_paging_manipulation+0xdb>
	}
	// Test 3.1-Clear entry: tstpg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f010f21d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f220:	83 c0 04             	add    $0x4,%eax
f010f223:	8b 00                	mov    (%eax),%eax
f010f225:	83 ec 08             	sub    $0x8,%esp
f010f228:	68 22 74 12 f0       	push   $0xf0127422
f010f22d:	50                   	push   %eax
f010f22e:	e8 2a 14 01 00       	call   f012065d <strcmp>
f010f233:	83 c4 10             	add    $0x10,%esp
f010f236:	85 c0                	test   %eax,%eax
f010f238:	75 07                	jne    f010f241 <tst_paging_manipulation+0xb9>
	{
		test_pt_clear_page_table_entry();
f010f23a:	e8 91 2d 00 00       	call   f0111fd0 <test_pt_clear_page_table_entry>
f010f23f:	eb 22                	jmp    f010f263 <tst_paging_manipulation+0xdb>
	}
	// Test 3.2-Clear entry: tstpg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f010f241:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f244:	83 c0 04             	add    $0x4,%eax
f010f247:	8b 00                	mov    (%eax),%eax
f010f249:	83 ec 08             	sub    $0x8,%esp
f010f24c:	68 29 74 12 f0       	push   $0xf0127429
f010f251:	50                   	push   %eax
f010f252:	e8 06 14 01 00       	call   f012065d <strcmp>
f010f257:	83 c4 10             	add    $0x10,%esp
f010f25a:	85 c0                	test   %eax,%eax
f010f25c:	75 05                	jne    f010f263 <tst_paging_manipulation+0xdb>
	{
		test_pt_clear_page_table_entry_invalid_va();
f010f25e:	e8 c6 2e 00 00       	call   f0112129 <test_pt_clear_page_table_entry_invalid_va>
	// Test 4-Convert virtual to physical: tstpg v2p
//	else if(strcmp(arguments[1], "v2p") == 0)
//	{
//		test_virtual_to_physical();
//	}
	return 0;
f010f263:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f268:	c9                   	leave  
f010f269:	c3                   	ret    

f010f26a <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f010f26a:	55                   	push   %ebp
f010f26b:	89 e5                	mov    %esp,%ebp
f010f26d:	83 ec 18             	sub    $0x18,%esp
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f010f270:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f273:	83 c0 08             	add    $0x8,%eax
f010f276:	8b 00                	mov    (%eax),%eax
f010f278:	83 ec 08             	sub    $0x8,%esp
f010f27b:	68 30 74 12 f0       	push   $0xf0127430
f010f280:	50                   	push   %eax
f010f281:	e8 d7 13 01 00       	call   f012065d <strcmp>
f010f286:	83 c4 10             	add    $0x10,%esp
f010f289:	85 c0                	test   %eax,%eax
f010f28b:	75 20                	jne    f010f2ad <tst_kheap+0x43>
f010f28d:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f010f291:	74 1a                	je     f010f2ad <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <1 or 2 or 3>\n") ;
f010f293:	83 ec 0c             	sub    $0xc,%esp
f010f296:	68 38 74 12 f0       	push   $0xf0127438
f010f29b:	e8 cc 1c ff ff       	call   f0100f6c <cprintf>
f010f2a0:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f2a3:	b8 00 00 00 00       	mov    $0x0,%eax
f010f2a8:	e9 f6 03 00 00       	jmp    f010f6a3 <tst_kheap+0x439>
	}
	if (strcmp(arguments[2], "kmalloc") != 0 && number_of_arguments != 3)
f010f2ad:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2b0:	83 c0 08             	add    $0x8,%eax
f010f2b3:	8b 00                	mov    (%eax),%eax
f010f2b5:	83 ec 08             	sub    $0x8,%esp
f010f2b8:	68 30 74 12 f0       	push   $0xf0127430
f010f2bd:	50                   	push   %eax
f010f2be:	e8 9a 13 01 00       	call   f012065d <strcmp>
f010f2c3:	83 c4 10             	add    $0x10,%esp
f010f2c6:	85 c0                	test   %eax,%eax
f010f2c8:	74 43                	je     f010f30d <tst_kheap+0xa3>
f010f2ca:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f010f2ce:	74 3d                	je     f010f30d <tst_kheap+0xa3>
	{
		if (strcmp(arguments[2], "krealloc") != 0 && number_of_arguments != 5)
f010f2d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2d3:	83 c0 08             	add    $0x8,%eax
f010f2d6:	8b 00                	mov    (%eax),%eax
f010f2d8:	83 ec 08             	sub    $0x8,%esp
f010f2db:	68 88 74 12 f0       	push   $0xf0127488
f010f2e0:	50                   	push   %eax
f010f2e1:	e8 77 13 01 00       	call   f012065d <strcmp>
f010f2e6:	83 c4 10             	add    $0x10,%esp
f010f2e9:	85 c0                	test   %eax,%eax
f010f2eb:	74 20                	je     f010f30d <tst_kheap+0xa3>
f010f2ed:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
f010f2f1:	74 1a                	je     f010f30d <tst_kheap+0xa3>
		{
			cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> <testname>\n") ;
f010f2f3:	83 ec 0c             	sub    $0xc,%esp
f010f2f6:	68 94 74 12 f0       	push   $0xf0127494
f010f2fb:	e8 6c 1c ff ff       	call   f0100f6c <cprintf>
f010f300:	83 c4 10             	add    $0x10,%esp
			return 0;
f010f303:	b8 00 00 00 00       	mov    $0x0,%eax
f010f308:	e9 96 03 00 00       	jmp    f010f6a3 <tst_kheap+0x439>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f010f30d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f310:	83 c0 04             	add    $0x4,%eax
f010f313:	8b 00                	mov    (%eax),%eax
f010f315:	83 ec 08             	sub    $0x8,%esp
f010f318:	68 d9 74 12 f0       	push   $0xf01274d9
f010f31d:	50                   	push   %eax
f010f31e:	e8 3a 13 01 00       	call   f012065d <strcmp>
f010f323:	83 c4 10             	add    $0x10,%esp
f010f326:	85 c0                	test   %eax,%eax
f010f328:	74 1d                	je     f010f347 <tst_kheap+0xdd>
f010f32a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f32d:	83 c0 04             	add    $0x4,%eax
f010f330:	8b 00                	mov    (%eax),%eax
f010f332:	83 ec 08             	sub    $0x8,%esp
f010f335:	68 dc 74 12 f0       	push   $0xf01274dc
f010f33a:	50                   	push   %eax
f010f33b:	e8 1d 13 01 00       	call   f012065d <strcmp>
f010f340:	83 c4 10             	add    $0x10,%esp
f010f343:	85 c0                	test   %eax,%eax
f010f345:	75 1a                	jne    f010f361 <tst_kheap+0xf7>
	{
		setKHeapPlacementStrategyFIRSTFIT();
f010f347:	e8 6d f8 ff ff       	call   f010ebb9 <setKHeapPlacementStrategyFIRSTFIT>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f010f34c:	83 ec 0c             	sub    $0xc,%esp
f010f34f:	68 e0 74 12 f0       	push   $0xf01274e0
f010f354:	e8 13 1c ff ff       	call   f0100f6c <cprintf>
f010f359:	83 c4 10             	add    $0x10,%esp
f010f35c:	e9 a0 00 00 00       	jmp    f010f401 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f010f361:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f364:	83 c0 04             	add    $0x4,%eax
f010f367:	8b 00                	mov    (%eax),%eax
f010f369:	83 ec 08             	sub    $0x8,%esp
f010f36c:	68 0d 75 12 f0       	push   $0xf012750d
f010f371:	50                   	push   %eax
f010f372:	e8 e6 12 01 00       	call   f012065d <strcmp>
f010f377:	83 c4 10             	add    $0x10,%esp
f010f37a:	85 c0                	test   %eax,%eax
f010f37c:	74 1d                	je     f010f39b <tst_kheap+0x131>
f010f37e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f381:	83 c0 04             	add    $0x4,%eax
f010f384:	8b 00                	mov    (%eax),%eax
f010f386:	83 ec 08             	sub    $0x8,%esp
f010f389:	68 10 75 12 f0       	push   $0xf0127510
f010f38e:	50                   	push   %eax
f010f38f:	e8 c9 12 01 00       	call   f012065d <strcmp>
f010f394:	83 c4 10             	add    $0x10,%esp
f010f397:	85 c0                	test   %eax,%eax
f010f399:	75 17                	jne    f010f3b2 <tst_kheap+0x148>
	{
		setKHeapPlacementStrategyBESTFIT();
f010f39b:	e8 29 f8 ff ff       	call   f010ebc9 <setKHeapPlacementStrategyBESTFIT>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f010f3a0:	83 ec 0c             	sub    $0xc,%esp
f010f3a3:	68 14 75 12 f0       	push   $0xf0127514
f010f3a8:	e8 bf 1b ff ff       	call   f0100f6c <cprintf>
f010f3ad:	83 c4 10             	add    $0x10,%esp
f010f3b0:	eb 4f                	jmp    f010f401 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f010f3b2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3b5:	83 c0 04             	add    $0x4,%eax
f010f3b8:	8b 00                	mov    (%eax),%eax
f010f3ba:	83 ec 08             	sub    $0x8,%esp
f010f3bd:	68 40 75 12 f0       	push   $0xf0127540
f010f3c2:	50                   	push   %eax
f010f3c3:	e8 95 12 01 00       	call   f012065d <strcmp>
f010f3c8:	83 c4 10             	add    $0x10,%esp
f010f3cb:	85 c0                	test   %eax,%eax
f010f3cd:	74 1d                	je     f010f3ec <tst_kheap+0x182>
f010f3cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3d2:	83 c0 04             	add    $0x4,%eax
f010f3d5:	8b 00                	mov    (%eax),%eax
f010f3d7:	83 ec 08             	sub    $0x8,%esp
f010f3da:	68 43 75 12 f0       	push   $0xf0127543
f010f3df:	50                   	push   %eax
f010f3e0:	e8 78 12 01 00       	call   f012065d <strcmp>
f010f3e5:	83 c4 10             	add    $0x10,%esp
f010f3e8:	85 c0                	test   %eax,%eax
f010f3ea:	75 15                	jne    f010f401 <tst_kheap+0x197>
	{
		setKHeapPlacementStrategyNEXTFIT();
f010f3ec:	e8 e8 f7 ff ff       	call   f010ebd9 <setKHeapPlacementStrategyNEXTFIT>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f010f3f1:	83 ec 0c             	sub    $0xc,%esp
f010f3f4:	68 48 75 12 f0       	push   $0xf0127548
f010f3f9:	e8 6e 1b ff ff       	call   f0100f6c <cprintf>
f010f3fe:	83 c4 10             	add    $0x10,%esp
	}

	// Test 1-kmalloc: tst kheap FF kmalloc 1
	if(strcmp(arguments[2], "kmalloc") == 0)
f010f401:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f404:	83 c0 08             	add    $0x8,%eax
f010f407:	8b 00                	mov    (%eax),%eax
f010f409:	83 ec 08             	sub    $0x8,%esp
f010f40c:	68 30 74 12 f0       	push   $0xf0127430
f010f411:	50                   	push   %eax
f010f412:	e8 46 12 01 00       	call   f012065d <strcmp>
f010f417:	83 c4 10             	add    $0x10,%esp
f010f41a:	85 c0                	test   %eax,%eax
f010f41c:	0f 85 13 01 00 00    	jne    f010f535 <tst_kheap+0x2cb>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f010f422:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f425:	83 c0 0c             	add    $0xc,%eax
f010f428:	8b 00                	mov    (%eax),%eax
f010f42a:	83 ec 04             	sub    $0x4,%esp
f010f42d:	6a 0a                	push   $0xa
f010f42f:	6a 00                	push   $0x0
f010f431:	50                   	push   %eax
f010f432:	e8 7a 14 01 00       	call   f01208b1 <strtol>
f010f437:	83 c4 10             	add    $0x10,%esp
f010f43a:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f010f43d:	e8 a7 f7 ff ff       	call   f010ebe9 <isKHeapPlacementStrategyFIRSTFIT>
f010f442:	84 c0                	test   %al,%al
f010f444:	74 54                	je     f010f49a <tst_kheap+0x230>
		{
			if (testNum == 0)
f010f446:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f44a:	75 1a                	jne    f010f466 <tst_kheap+0x1fc>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f010f44c:	83 ec 0c             	sub    $0xc,%esp
f010f44f:	68 74 75 12 f0       	push   $0xf0127574
f010f454:	e8 13 1b ff ff       	call   f0100f6c <cprintf>
f010f459:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f45c:	b8 00 00 00 00       	mov    $0x0,%eax
f010f461:	e9 3d 02 00 00       	jmp    f010f6a3 <tst_kheap+0x439>
			}
			//Test FIRST FIT allocation
			if (testNum == 1)
f010f466:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010f46a:	75 0a                	jne    f010f476 <tst_kheap+0x20c>
				test_kmalloc();
f010f46c:	e8 ba 8d 00 00       	call   f011822b <test_kmalloc>
f010f471:	e9 b5 00 00 00       	jmp    f010f52b <tst_kheap+0x2c1>
			else if (testNum == 2)
f010f476:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010f47a:	75 0a                	jne    f010f486 <tst_kheap+0x21c>
				test_kmalloc_firstfit1();
f010f47c:	e8 c4 98 00 00       	call   f0118d45 <test_kmalloc_firstfit1>
f010f481:	e9 a5 00 00 00       	jmp    f010f52b <tst_kheap+0x2c1>
			else if (testNum == 3)
f010f486:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f010f48a:	0f 85 9b 00 00 00    	jne    f010f52b <tst_kheap+0x2c1>
				test_kmalloc_firstfit2();
f010f490:	e8 44 a3 00 00       	call   f01197d9 <test_kmalloc_firstfit2>
f010f495:	e9 91 00 00 00       	jmp    f010f52b <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyBESTFIT())
f010f49a:	e8 5f f7 ff ff       	call   f010ebfe <isKHeapPlacementStrategyBESTFIT>
f010f49f:	84 c0                	test   %al,%al
f010f4a1:	74 47                	je     f010f4ea <tst_kheap+0x280>
		{
			if (testNum == 0)
f010f4a3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f4a7:	75 1a                	jne    f010f4c3 <tst_kheap+0x259>
			{
				cprintf("Error: [Kernel.BestFit] must specify the test number (1, 2, 3) as an argument\n");
f010f4a9:	83 ec 0c             	sub    $0xc,%esp
f010f4ac:	68 c4 75 12 f0       	push   $0xf01275c4
f010f4b1:	e8 b6 1a ff ff       	call   f0100f6c <cprintf>
f010f4b6:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f4b9:	b8 00 00 00 00       	mov    $0x0,%eax
f010f4be:	e9 e0 01 00 00       	jmp    f010f6a3 <tst_kheap+0x439>
			}
			if (testNum == 1)
f010f4c3:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010f4c7:	75 07                	jne    f010f4d0 <tst_kheap+0x266>
				test_kmalloc();
f010f4c9:	e8 5d 8d 00 00       	call   f011822b <test_kmalloc>
f010f4ce:	eb 5b                	jmp    f010f52b <tst_kheap+0x2c1>
			else if (testNum == 2)
f010f4d0:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010f4d4:	75 07                	jne    f010f4dd <tst_kheap+0x273>
				test_kmalloc_bestfit1();
f010f4d6:	e8 cb e8 00 00       	call   f011dda6 <test_kmalloc_bestfit1>
f010f4db:	eb 4e                	jmp    f010f52b <tst_kheap+0x2c1>
			else if (testNum == 3)
f010f4dd:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f010f4e1:	75 48                	jne    f010f52b <tst_kheap+0x2c1>
				test_kmalloc_bestfit2();
f010f4e3:	e8 db e8 00 00       	call   f011ddc3 <test_kmalloc_bestfit2>
f010f4e8:	eb 41                	jmp    f010f52b <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyNEXTFIT())
f010f4ea:	e8 24 f7 ff ff       	call   f010ec13 <isKHeapPlacementStrategyNEXTFIT>
f010f4ef:	84 c0                	test   %al,%al
f010f4f1:	74 38                	je     f010f52b <tst_kheap+0x2c1>
		{
			if (testNum == 0)
f010f4f3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f4f7:	75 1a                	jne    f010f513 <tst_kheap+0x2a9>
			{
				cprintf("Error: [Kernel.NextFit] must specify the test number (1 or 2) as an argument\n");
f010f4f9:	83 ec 0c             	sub    $0xc,%esp
f010f4fc:	68 14 76 12 f0       	push   $0xf0127614
f010f501:	e8 66 1a ff ff       	call   f0100f6c <cprintf>
f010f506:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f509:	b8 00 00 00 00       	mov    $0x0,%eax
f010f50e:	e9 90 01 00 00       	jmp    f010f6a3 <tst_kheap+0x439>
			}
			//Test cont. allocation
			if (testNum == 1)
f010f513:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010f517:	75 07                	jne    f010f520 <tst_kheap+0x2b6>
				test_kmalloc();
f010f519:	e8 0d 8d 00 00       	call   f011822b <test_kmalloc>
f010f51e:	eb 0b                	jmp    f010f52b <tst_kheap+0x2c1>
			//Test nextfit strategy
			else if (testNum == 2)
f010f520:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010f524:	75 05                	jne    f010f52b <tst_kheap+0x2c1>
				test_kmalloc_nextfit();
f010f526:	e8 5b e8 00 00       	call   f011dd86 <test_kmalloc_nextfit>
		}
		return 0;
f010f52b:	b8 00 00 00 00       	mov    $0x0,%eax
f010f530:	e9 6e 01 00 00       	jmp    f010f6a3 <tst_kheap+0x439>
	}
	// Test 2-kfree: tst kheap FF kfree
	else if(strcmp(arguments[2], "kfree") == 0)
f010f535:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f538:	83 c0 08             	add    $0x8,%eax
f010f53b:	8b 00                	mov    (%eax),%eax
f010f53d:	83 ec 08             	sub    $0x8,%esp
f010f540:	68 62 76 12 f0       	push   $0xf0127662
f010f545:	50                   	push   %eax
f010f546:	e8 12 11 01 00       	call   f012065d <strcmp>
f010f54b:	83 c4 10             	add    $0x10,%esp
f010f54e:	85 c0                	test   %eax,%eax
f010f550:	75 28                	jne    f010f57a <tst_kheap+0x310>
	{
		if (isKHeapPlacementStrategyBESTFIT() || isKHeapPlacementStrategyFIRSTFIT())
f010f552:	e8 a7 f6 ff ff       	call   f010ebfe <isKHeapPlacementStrategyBESTFIT>
f010f557:	84 c0                	test   %al,%al
f010f559:	75 09                	jne    f010f564 <tst_kheap+0x2fa>
f010f55b:	e8 89 f6 ff ff       	call   f010ebe9 <isKHeapPlacementStrategyFIRSTFIT>
f010f560:	84 c0                	test   %al,%al
f010f562:	74 07                	je     f010f56b <tst_kheap+0x301>
		{
			test_kfree_bestfirstfit();
f010f564:	e8 29 ad 00 00       	call   f011a292 <test_kfree_bestfirstfit>
f010f569:	eb 05                	jmp    f010f570 <tst_kheap+0x306>
		}
		else //NEXT & CONT
		{
			test_kfree();
f010f56b:	e8 90 e8 00 00       	call   f011de00 <test_kfree>
		}
		return 0;
f010f570:	b8 00 00 00 00       	mov    $0x0,%eax
f010f575:	e9 29 01 00 00       	jmp    f010f6a3 <tst_kheap+0x439>
	}
	// Test 3-kphysaddr: tst kheap FF kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f010f57a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f57d:	83 c0 08             	add    $0x8,%eax
f010f580:	8b 00                	mov    (%eax),%eax
f010f582:	83 ec 08             	sub    $0x8,%esp
f010f585:	68 68 76 12 f0       	push   $0xf0127668
f010f58a:	50                   	push   %eax
f010f58b:	e8 cd 10 01 00       	call   f012065d <strcmp>
f010f590:	83 c4 10             	add    $0x10,%esp
f010f593:	85 c0                	test   %eax,%eax
f010f595:	75 0f                	jne    f010f5a6 <tst_kheap+0x33c>
	{
		test_kheap_phys_addr();
f010f597:	e8 01 c3 00 00       	call   f011b89d <test_kheap_phys_addr>
		return 0;
f010f59c:	b8 00 00 00 00       	mov    $0x0,%eax
f010f5a1:	e9 fd 00 00 00       	jmp    f010f6a3 <tst_kheap+0x439>
	}
	// Test 4-kvirtaddr: tst kheap FF kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f010f5a6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5a9:	83 c0 08             	add    $0x8,%eax
f010f5ac:	8b 00                	mov    (%eax),%eax
f010f5ae:	83 ec 08             	sub    $0x8,%esp
f010f5b1:	68 72 76 12 f0       	push   $0xf0127672
f010f5b6:	50                   	push   %eax
f010f5b7:	e8 a1 10 01 00       	call   f012065d <strcmp>
f010f5bc:	83 c4 10             	add    $0x10,%esp
f010f5bf:	85 c0                	test   %eax,%eax
f010f5c1:	75 0f                	jne    f010f5d2 <tst_kheap+0x368>
	{
		test_kheap_virt_addr();
f010f5c3:	e8 4f d0 00 00       	call   f011c617 <test_kheap_virt_addr>
		return 0;
f010f5c8:	b8 00 00 00 00       	mov    $0x0,%eax
f010f5cd:	e9 d1 00 00 00       	jmp    f010f6a3 <tst_kheap+0x439>
	}
	// Test 5-krealloc: tst kheap BF krealloc
	else if(strcmp(arguments[2], "krealloc") == 0)
f010f5d2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5d5:	83 c0 08             	add    $0x8,%eax
f010f5d8:	8b 00                	mov    (%eax),%eax
f010f5da:	83 ec 08             	sub    $0x8,%esp
f010f5dd:	68 88 74 12 f0       	push   $0xf0127488
f010f5e2:	50                   	push   %eax
f010f5e3:	e8 75 10 01 00       	call   f012065d <strcmp>
f010f5e8:	83 c4 10             	add    $0x10,%esp
f010f5eb:	85 c0                	test   %eax,%eax
f010f5ed:	0f 85 89 00 00 00    	jne    f010f67c <tst_kheap+0x412>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f010f5f3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5f6:	83 c0 0c             	add    $0xc,%eax
f010f5f9:	8b 00                	mov    (%eax),%eax
f010f5fb:	83 ec 04             	sub    $0x4,%esp
f010f5fe:	6a 0a                	push   $0xa
f010f600:	6a 00                	push   $0x0
f010f602:	50                   	push   %eax
f010f603:	e8 a9 12 01 00       	call   f01208b1 <strtol>
f010f608:	83 c4 10             	add    $0x10,%esp
f010f60b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f010f60e:	e8 d6 f5 ff ff       	call   f010ebe9 <isKHeapPlacementStrategyFIRSTFIT>
f010f613:	84 c0                	test   %al,%al
f010f615:	74 42                	je     f010f659 <tst_kheap+0x3ef>
		{
			if (testNum == 0)
f010f617:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f61b:	75 17                	jne    f010f634 <tst_kheap+0x3ca>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f010f61d:	83 ec 0c             	sub    $0xc,%esp
f010f620:	68 74 75 12 f0       	push   $0xf0127574
f010f625:	e8 42 19 ff ff       	call   f0100f6c <cprintf>
f010f62a:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f62d:	b8 00 00 00 00       	mov    $0x0,%eax
f010f632:	eb 6f                	jmp    f010f6a3 <tst_kheap+0x439>
			}
			if (testNum==1)
f010f634:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f010f638:	75 07                	jne    f010f641 <tst_kheap+0x3d7>
				test_krealloc_FF1();
f010f63a:	e8 a7 ea 00 00       	call   f011e0e6 <test_krealloc_FF1>
f010f63f:	eb 18                	jmp    f010f659 <tst_kheap+0x3ef>
			else if (testNum==2)
f010f641:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
f010f645:	75 07                	jne    f010f64e <tst_kheap+0x3e4>
				test_krealloc_FF2();
f010f647:	e8 e7 ea 00 00       	call   f011e133 <test_krealloc_FF2>
f010f64c:	eb 0b                	jmp    f010f659 <tst_kheap+0x3ef>
			else if (testNum==3)
f010f64e:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f010f652:	75 05                	jne    f010f659 <tst_kheap+0x3ef>
				test_krealloc_FF3();
f010f654:	e8 27 eb 00 00       	call   f011e180 <test_krealloc_FF3>
		}
		if (isKHeapPlacementStrategyNEXTFIT())
f010f659:	e8 b5 f5 ff ff       	call   f010ec13 <isKHeapPlacementStrategyNEXTFIT>
f010f65e:	84 c0                	test   %al,%al
f010f660:	74 05                	je     f010f667 <tst_kheap+0x3fd>
		{
			test_krealloc();
f010f662:	e8 e5 e9 00 00       	call   f011e04c <test_krealloc>
		}
		if (isKHeapPlacementStrategyBESTFIT())
f010f667:	e8 92 f5 ff ff       	call   f010ebfe <isKHeapPlacementStrategyBESTFIT>
f010f66c:	84 c0                	test   %al,%al
f010f66e:	74 05                	je     f010f675 <tst_kheap+0x40b>
		{
			test_krealloc_BF();
f010f670:	e8 24 ea 00 00       	call   f011e099 <test_krealloc_BF>
		}
		return 0;
f010f675:	b8 00 00 00 00       	mov    $0x0,%eax
f010f67a:	eb 27                	jmp    f010f6a3 <tst_kheap+0x439>
	}
	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
f010f67c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f67f:	83 c0 08             	add    $0x8,%eax
f010f682:	8b 00                	mov    (%eax),%eax
f010f684:	83 ec 08             	sub    $0x8,%esp
f010f687:	68 7c 76 12 f0       	push   $0xf012767c
f010f68c:	50                   	push   %eax
f010f68d:	e8 cb 0f 01 00       	call   f012065d <strcmp>
f010f692:	83 c4 10             	add    $0x10,%esp
f010f695:	85 c0                	test   %eax,%eax
f010f697:	75 05                	jne    f010f69e <tst_kheap+0x434>
	{
		test_ksbrk();
f010f699:	e8 13 dc 00 00       	call   f011d2b1 <test_ksbrk>
	}
	return 0;
f010f69e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f6a3:	c9                   	leave  
f010f6a4:	c3                   	ret    

f010f6a5 <test_initialize_dynamic_allocator>:

#define Mega  (1024*1024)
#define kilo (1024)

void test_initialize_dynamic_allocator()
{
f010f6a5:	55                   	push   %ebp
f010f6a6:	89 e5                	mov    %esp,%ebp
f010f6a8:	83 ec 28             	sub    $0x28,%esp
	panic("test_initialize_dynamic_allocator: the kernel heap should be diabled. make sure USE_KHEAP = 0");
	return;
#endif

	//write initial data at the start (for checking)
	int* tmp_ptr = (int*)KERNEL_HEAP_START;
f010f6ab:	c7 45 f4 00 00 00 f6 	movl   $0xf6000000,-0xc(%ebp)
	*tmp_ptr = -1 ;
f010f6b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f6b5:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	*(tmp_ptr+1) = 1 ;
f010f6bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f6be:	83 c0 04             	add    $0x4,%eax
f010f6c1:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

	uint32 initAllocatedSpace = 2*Mega;
f010f6c7:	c7 45 f0 00 00 20 00 	movl   $0x200000,-0x10(%ebp)
	initialize_dynamic_allocator(KERNEL_HEAP_START, initAllocatedSpace);
f010f6ce:	83 ec 08             	sub    $0x8,%esp
f010f6d1:	ff 75 f0             	pushl  -0x10(%ebp)
f010f6d4:	68 00 00 00 f6       	push   $0xf6000000
f010f6d9:	e8 42 1a 01 00       	call   f0121120 <initialize_dynamic_allocator>
f010f6de:	83 c4 10             	add    $0x10,%esp


	//Check#1: Metadata
	uint32* daBeg = (uint32*) KERNEL_HEAP_START ;
f010f6e1:	c7 45 ec 00 00 00 f6 	movl   $0xf6000000,-0x14(%ebp)
	uint32* daEnd = (uint32*) (KERNEL_HEAP_START +  initAllocatedSpace - sizeof(int));
f010f6e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f6eb:	2d 04 00 00 0a       	sub    $0xa000004,%eax
f010f6f0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	uint32* blkHeader = (uint32*) (KERNEL_HEAP_START + sizeof(int));
f010f6f3:	c7 45 e4 04 00 00 f6 	movl   $0xf6000004,-0x1c(%ebp)
	uint32* blkFooter = (uint32*) (KERNEL_HEAP_START +  initAllocatedSpace - 2*sizeof(int));
f010f6fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f6fd:	2d 08 00 00 0a       	sub    $0xa000008,%eax
f010f702:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (*daBeg != 1 || *daEnd != 1 || (*blkHeader != initAllocatedSpace - 2*sizeof(int))|| (*blkFooter != initAllocatedSpace - 2*sizeof(int)))
f010f705:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f708:	8b 00                	mov    (%eax),%eax
f010f70a:	83 f8 01             	cmp    $0x1,%eax
f010f70d:	75 28                	jne    f010f737 <test_initialize_dynamic_allocator+0x92>
f010f70f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f712:	8b 00                	mov    (%eax),%eax
f010f714:	83 f8 01             	cmp    $0x1,%eax
f010f717:	75 1e                	jne    f010f737 <test_initialize_dynamic_allocator+0x92>
f010f719:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f71c:	8b 00                	mov    (%eax),%eax
f010f71e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f721:	83 ea 08             	sub    $0x8,%edx
f010f724:	39 d0                	cmp    %edx,%eax
f010f726:	75 0f                	jne    f010f737 <test_initialize_dynamic_allocator+0x92>
f010f728:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f72b:	8b 00                	mov    (%eax),%eax
f010f72d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f730:	83 ea 08             	sub    $0x8,%edx
f010f733:	39 d0                	cmp    %edx,%eax
f010f735:	74 14                	je     f010f74b <test_initialize_dynamic_allocator+0xa6>
	{
		panic("Content of header/footer and/or DA begin/end are not set correctly");
f010f737:	83 ec 04             	sub    $0x4,%esp
f010f73a:	68 84 76 12 f0       	push   $0xf0127684
f010f73f:	6a 2b                	push   $0x2b
f010f741:	68 c8 76 12 f0       	push   $0xf01276c8
f010f746:	e8 cf 0b ff ff       	call   f010031a <_panic>
	}
	if (LIST_SIZE(&freeBlocksList) != 1 || (uint32)LIST_FIRST(&freeBlocksList) != KERNEL_HEAP_START + 2*sizeof(int))
f010f74b:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f010f750:	83 f8 01             	cmp    $0x1,%eax
f010f753:	75 0c                	jne    f010f761 <test_initialize_dynamic_allocator+0xbc>
f010f755:	a1 b0 25 55 f0       	mov    0xf05525b0,%eax
f010f75a:	3d 08 00 00 f6       	cmp    $0xf6000008,%eax
f010f75f:	74 14                	je     f010f775 <test_initialize_dynamic_allocator+0xd0>
	{
		panic("free block is not added correctly");
f010f761:	83 ec 04             	sub    $0x4,%esp
f010f764:	68 ec 76 12 f0       	push   $0xf01276ec
f010f769:	6a 2f                	push   $0x2f
f010f76b:	68 c8 76 12 f0       	push   $0xf01276c8
f010f770:	e8 a5 0b ff ff       	call   f010031a <_panic>
	}

	cprintf("Congratulations!! test initialize_dynamic_allocator completed successfully.\n");
f010f775:	83 ec 0c             	sub    $0xc,%esp
f010f778:	68 10 77 12 f0       	push   $0xf0127710
f010f77d:	e8 ea 17 ff ff       	call   f0100f6c <cprintf>
f010f782:	83 c4 10             	add    $0x10,%esp
}
f010f785:	90                   	nop
f010f786:	c9                   	leave  
f010f787:	c3                   	ret    

f010f788 <test_initial_alloc>:
short* startVAs[numOfAllocs*allocCntPerSize+1] ;
short* midVAs[numOfAllocs*allocCntPerSize+1] ;
short* endVAs[numOfAllocs*allocCntPerSize+1] ;

int test_initial_alloc(int ALLOC_STRATEGY)
{
f010f788:	55                   	push   %ebp
f010f789:	89 e5                	mov    %esp,%ebp
f010f78b:	83 ec 48             	sub    $0x48,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return 0;
#endif

	int eval = 0;
f010f78e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool is_correct = 1;
f010f795:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int initAllocatedSpace = 3*Mega;
f010f79c:	c7 45 d0 00 00 30 00 	movl   $0x300000,-0x30(%ebp)
	initialize_dynamic_allocator(KERNEL_HEAP_START, initAllocatedSpace);
f010f7a3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f7a6:	83 ec 08             	sub    $0x8,%esp
f010f7a9:	50                   	push   %eax
f010f7aa:	68 00 00 00 f6       	push   $0xf6000000
f010f7af:	e8 6c 19 01 00       	call   f0121120 <initialize_dynamic_allocator>
f010f7b4:	83 c4 10             	add    $0x10,%esp

	void * va ;
	//====================================================================//
	/*INITIAL ALLOC Scenario 1: Try to allocate a block with a size greater than the size of any existing free block*/
	cprintf("	1: Try to allocate large block [not fit in any space]\n\n") ;
f010f7b7:	83 ec 0c             	sub    $0xc,%esp
f010f7ba:	68 60 77 12 f0       	push   $0xf0127760
f010f7bf:	e8 a8 17 ff ff       	call   f0100f6c <cprintf>
f010f7c4:	83 c4 10             	add    $0x10,%esp

	is_correct = 1;
f010f7c7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	va = alloc_block(3*initAllocatedSpace, ALLOC_STRATEGY);
f010f7ce:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f7d1:	89 c2                	mov    %eax,%edx
f010f7d3:	01 d2                	add    %edx,%edx
f010f7d5:	01 d0                	add    %edx,%eax
f010f7d7:	83 ec 08             	sub    $0x8,%esp
f010f7da:	ff 75 08             	pushl  0x8(%ebp)
f010f7dd:	50                   	push   %eax
f010f7de:	e8 10 18 01 00       	call   f0120ff3 <alloc_block>
f010f7e3:	83 c4 10             	add    $0x10,%esp
f010f7e6:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//Check returned va
	if(va != NULL)
f010f7e9:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010f7ed:	74 17                	je     f010f806 <test_initial_alloc+0x7e>
	{
		is_correct = 0;
f010f7ef:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("alloc_block_xx #1: should not be allocated.\n");
f010f7f6:	83 ec 0c             	sub    $0xc,%esp
f010f7f9:	68 9c 77 12 f0       	push   $0xf012779c
f010f7fe:	e8 69 17 ff ff       	call   f0100f6c <cprintf>
f010f803:	83 c4 10             	add    $0x10,%esp
	}
	va = alloc_block(initAllocatedSpace, ALLOC_STRATEGY);
f010f806:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f809:	83 ec 08             	sub    $0x8,%esp
f010f80c:	ff 75 08             	pushl  0x8(%ebp)
f010f80f:	50                   	push   %eax
f010f810:	e8 de 17 01 00       	call   f0120ff3 <alloc_block>
f010f815:	83 c4 10             	add    $0x10,%esp
f010f818:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//Check returned va
	if(va != NULL)
f010f81b:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010f81f:	74 17                	je     f010f838 <test_initial_alloc+0xb0>
	{
		is_correct = 0;
f010f821:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("alloc_block_xx #2: should not be allocated.\n");
f010f828:	83 ec 0c             	sub    $0xc,%esp
f010f82b:	68 cc 77 12 f0       	push   $0xf01277cc
f010f830:	e8 37 17 ff ff       	call   f0100f6c <cprintf>
f010f835:	83 c4 10             	add    $0x10,%esp
	}

	if (is_correct)
f010f838:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f83c:	74 04                	je     f010f842 <test_initial_alloc+0xba>
	{
		eval += 5;
f010f83e:	83 45 f4 05          	addl   $0x5,-0xc(%ebp)
	}
	//====================================================================//
	/*INITIAL ALLOC Scenario 2: Try to allocate set of blocks with different sizes*/
	cprintf("	2: Try to allocate set of blocks with different sizes [all should fit]\n\n") ;
f010f842:	83 ec 0c             	sub    $0xc,%esp
f010f845:	68 fc 77 12 f0       	push   $0xf01277fc
f010f84a:	e8 1d 17 ff ff       	call   f0100f6c <cprintf>
f010f84f:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f010f852:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	int totalSizes = 0;
f010f859:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for (int i = 0; i < numOfAllocs; ++i)
f010f860:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010f867:	eb 2a                	jmp    f010f893 <test_initial_alloc+0x10b>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
f010f869:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f86c:	8b 14 85 78 9d 17 f0 	mov    -0xfe86288(,%eax,4),%edx
f010f873:	89 d0                	mov    %edx,%eax
f010f875:	c1 e0 02             	shl    $0x2,%eax
f010f878:	01 d0                	add    %edx,%eax
f010f87a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010f881:	01 d0                	add    %edx,%eax
f010f883:	c1 e0 03             	shl    $0x3,%eax
f010f886:	89 c2                	mov    %eax,%edx
f010f888:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f88b:	01 d0                	add    %edx,%eax
f010f88d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	/*INITIAL ALLOC Scenario 2: Try to allocate set of blocks with different sizes*/
	cprintf("	2: Try to allocate set of blocks with different sizes [all should fit]\n\n") ;
	is_correct = 1;

	int totalSizes = 0;
	for (int i = 0; i < numOfAllocs; ++i)
f010f890:	ff 45 e8             	incl   -0x18(%ebp)
f010f893:	83 7d e8 06          	cmpl   $0x6,-0x18(%ebp)
f010f897:	7e d0                	jle    f010f869 <test_initial_alloc+0xe1>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
	}
	int remainSize = initAllocatedSpace - totalSizes - 2*sizeof(int) ; //exclude size of "DA Begin & End" blocks
f010f899:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f89c:	2b 45 ec             	sub    -0x14(%ebp),%eax
f010f89f:	83 e8 08             	sub    $0x8,%eax
f010f8a2:	89 45 c8             	mov    %eax,-0x38(%ebp)
	//cprintf("\n********* Remaining size = %d\n", remainSize);
	if (remainSize <= 0)
f010f8a5:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f010f8a9:	7f 17                	jg     f010f8c2 <test_initial_alloc+0x13a>
	{
		is_correct = 0;
f010f8ab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("alloc_block_xx test is not configured correctly. Consider updating the initial allocated space OR the required allocations\n");
f010f8b2:	83 ec 0c             	sub    $0xc,%esp
f010f8b5:	68 48 78 12 f0       	push   $0xf0127848
f010f8ba:	e8 ad 16 ff ff       	call   f0100f6c <cprintf>
f010f8bf:	83 c4 10             	add    $0x10,%esp
	}
	int idx = 0;
f010f8c2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
f010f8c9:	c7 45 e0 04 00 00 f6 	movl   $0xf6000004,-0x20(%ebp)
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
f010f8d0:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010f8d7:	e9 fc 00 00 00       	jmp    f010f9d8 <test_initial_alloc+0x250>
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f010f8dc:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010f8e3:	e9 e0 00 00 00       	jmp    f010f9c8 <test_initial_alloc+0x240>
		{
			actualSize = allocSizes[i] - sizeOfMetaData;
f010f8e8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010f8eb:	8b 04 85 78 9d 17 f0 	mov    -0xfe86288(,%eax,4),%eax
f010f8f2:	83 e8 08             	sub    $0x8,%eax
f010f8f5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			va = startVAs[idx] = alloc_block(actualSize, ALLOC_STRATEGY);
f010f8f8:	83 ec 08             	sub    $0x8,%esp
f010f8fb:	ff 75 08             	pushl  0x8(%ebp)
f010f8fe:	ff 75 c4             	pushl  -0x3c(%ebp)
f010f901:	e8 ed 16 01 00       	call   f0120ff3 <alloc_block>
f010f906:	83 c4 10             	add    $0x10,%esp
f010f909:	89 c2                	mov    %eax,%edx
f010f90b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f90e:	89 14 85 e0 36 57 f0 	mov    %edx,-0xfa8c920(,%eax,4)
f010f915:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f918:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f010f91f:	89 45 cc             	mov    %eax,-0x34(%ebp)
			midVAs[idx] = va + actualSize/2 ;
f010f922:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010f925:	d1 e8                	shr    %eax
f010f927:	89 c2                	mov    %eax,%edx
f010f929:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f92c:	01 c2                	add    %eax,%edx
f010f92e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f931:	89 14 85 e0 62 57 f0 	mov    %edx,-0xfa89d20(,%eax,4)
			endVAs[idx] = va + actualSize - sizeof(short);
f010f938:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010f93b:	8d 50 fe             	lea    -0x2(%eax),%edx
f010f93e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f941:	01 c2                	add    %eax,%edx
f010f943:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f946:	89 14 85 e0 4c 57 f0 	mov    %edx,-0xfa8b320(,%eax,4)
			//Check returned va
			if(va == NULL || (va != (curVA + sizeOfMetaData/2)))
f010f94d:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010f951:	74 0b                	je     f010f95e <test_initial_alloc+0x1d6>
f010f953:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f956:	83 c0 04             	add    $0x4,%eax
f010f959:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010f95c:	74 27                	je     f010f985 <test_initial_alloc+0x1fd>
			{
				if (is_correct)
f010f95e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f962:	74 21                	je     f010f985 <test_initial_alloc+0x1fd>
				{
					is_correct = 0;
f010f964:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
					cprintf("alloc_block_xx #3.%d: WRONG ALLOC - alloc_block_xx return wrong address. Expected %x, Actual %x\n", idx, curVA + sizeOfMetaData ,va);
f010f96b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f96e:	83 c0 08             	add    $0x8,%eax
f010f971:	ff 75 cc             	pushl  -0x34(%ebp)
f010f974:	50                   	push   %eax
f010f975:	ff 75 e4             	pushl  -0x1c(%ebp)
f010f978:	68 c4 78 12 f0       	push   $0xf01278c4
f010f97d:	e8 ea 15 ff ff       	call   f0100f6c <cprintf>
f010f982:	83 c4 10             	add    $0x10,%esp
				}
			}
			curVA += allocSizes[i] ;
f010f985:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010f988:	8b 04 85 78 9d 17 f0 	mov    -0xfe86288(,%eax,4),%eax
f010f98f:	01 45 e0             	add    %eax,-0x20(%ebp)
			*(startVAs[idx]) = idx ;
f010f992:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f995:	8b 14 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%edx
f010f99c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f99f:	66 89 02             	mov    %ax,(%edx)
			*(midVAs[idx]) = idx ;
f010f9a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f9a5:	8b 14 85 e0 62 57 f0 	mov    -0xfa89d20(,%eax,4),%edx
f010f9ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f9af:	66 89 02             	mov    %ax,(%edx)
			*(endVAs[idx]) = idx ;
f010f9b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f9b5:	8b 14 85 e0 4c 57 f0 	mov    -0xfa8b320(,%eax,4),%edx
f010f9bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f9bf:	66 89 02             	mov    %ax,(%edx)
			idx++;
f010f9c2:	ff 45 e4             	incl   -0x1c(%ebp)
	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f010f9c5:	ff 45 d8             	incl   -0x28(%ebp)
f010f9c8:	81 7d d8 c7 00 00 00 	cmpl   $0xc7,-0x28(%ebp)
f010f9cf:	0f 8e 13 ff ff ff    	jle    f010f8e8 <test_initial_alloc+0x160>
		cprintf("alloc_block_xx test is not configured correctly. Consider updating the initial allocated space OR the required allocations\n");
	}
	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
f010f9d5:	ff 45 dc             	incl   -0x24(%ebp)
f010f9d8:	83 7d dc 06          	cmpl   $0x6,-0x24(%ebp)
f010f9dc:	0f 8e fa fe ff ff    	jle    f010f8dc <test_initial_alloc+0x154>
			idx++;
		}
		//if (is_correct == 0)
		//break;
	}
	if (is_correct)
f010f9e2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f9e6:	74 04                	je     f010f9ec <test_initial_alloc+0x264>
	{
		eval += 20;
f010f9e8:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)
	}
	//====================================================================//
	/*INITIAL ALLOC Scenario 3: Try to allocate a block with a size equal to the size of the first existing free block*/
	cprintf("	3: Try to allocate a block with equal to the first existing free block\n\n") ;
f010f9ec:	83 ec 0c             	sub    $0xc,%esp
f010f9ef:	68 28 79 12 f0       	push   $0xf0127928
f010f9f4:	e8 73 15 ff ff       	call   f0100f6c <cprintf>
f010f9f9:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f010f9fc:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	actualSize = remainSize - sizeOfMetaData;
f010fa03:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010fa06:	83 e8 08             	sub    $0x8,%eax
f010fa09:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	va = startVAs[idx] = alloc_block(actualSize, ALLOC_STRATEGY);
f010fa0c:	83 ec 08             	sub    $0x8,%esp
f010fa0f:	ff 75 08             	pushl  0x8(%ebp)
f010fa12:	ff 75 c4             	pushl  -0x3c(%ebp)
f010fa15:	e8 d9 15 01 00       	call   f0120ff3 <alloc_block>
f010fa1a:	83 c4 10             	add    $0x10,%esp
f010fa1d:	89 c2                	mov    %eax,%edx
f010fa1f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa22:	89 14 85 e0 36 57 f0 	mov    %edx,-0xfa8c920(,%eax,4)
f010fa29:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa2c:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f010fa33:	89 45 cc             	mov    %eax,-0x34(%ebp)
	midVAs[idx] = va + actualSize/2 ;
f010fa36:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010fa39:	d1 e8                	shr    %eax
f010fa3b:	89 c2                	mov    %eax,%edx
f010fa3d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010fa40:	01 c2                	add    %eax,%edx
f010fa42:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa45:	89 14 85 e0 62 57 f0 	mov    %edx,-0xfa89d20(,%eax,4)
	endVAs[idx] = va + actualSize - sizeof(short);
f010fa4c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010fa4f:	8d 50 fe             	lea    -0x2(%eax),%edx
f010fa52:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010fa55:	01 c2                	add    %eax,%edx
f010fa57:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa5a:	89 14 85 e0 4c 57 f0 	mov    %edx,-0xfa8b320(,%eax,4)
	//Check returned va
	if(va == NULL || (va != (curVA + sizeOfMetaData/2)) || LIST_SIZE(&freeBlocksList) != 0)
f010fa61:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010fa65:	74 14                	je     f010fa7b <test_initial_alloc+0x2f3>
f010fa67:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fa6a:	83 c0 04             	add    $0x4,%eax
f010fa6d:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010fa70:	75 09                	jne    f010fa7b <test_initial_alloc+0x2f3>
f010fa72:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f010fa77:	85 c0                	test   %eax,%eax
f010fa79:	74 17                	je     f010fa92 <test_initial_alloc+0x30a>
	{
		is_correct = 0;
f010fa7b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("alloc_block_xx #4: WRONG ALLOC.\n");
f010fa82:	83 ec 0c             	sub    $0xc,%esp
f010fa85:	68 74 79 12 f0       	push   $0xf0127974
f010fa8a:	e8 dd 14 ff ff       	call   f0100f6c <cprintf>
f010fa8f:	83 c4 10             	add    $0x10,%esp
	}
	*(startVAs[idx]) = idx ;
f010fa92:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa95:	8b 14 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%edx
f010fa9c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa9f:	66 89 02             	mov    %ax,(%edx)
	*(midVAs[idx]) = idx ;
f010faa2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010faa5:	8b 14 85 e0 62 57 f0 	mov    -0xfa89d20(,%eax,4),%edx
f010faac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010faaf:	66 89 02             	mov    %ax,(%edx)
	*(endVAs[idx]) = idx ;
f010fab2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fab5:	8b 14 85 e0 4c 57 f0 	mov    -0xfa8b320(,%eax,4),%edx
f010fabc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fabf:	66 89 02             	mov    %ax,(%edx)
	if (is_correct)
f010fac2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fac6:	74 04                	je     f010facc <test_initial_alloc+0x344>
	{
		eval += 5;
f010fac8:	83 45 f4 05          	addl   $0x5,-0xc(%ebp)
	}
	//====================================================================//
	/*INITIAL ALLOC Scenario 4: Check stored data inside each allocated block*/
	cprintf("	4: Check stored data inside each allocated block\n\n") ;
f010facc:	83 ec 0c             	sub    $0xc,%esp
f010facf:	68 98 79 12 f0       	push   $0xf0127998
f010fad4:	e8 93 14 ff ff       	call   f0100f6c <cprintf>
f010fad9:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f010fadc:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	for (int i = 0; i < idx; ++i)
f010fae3:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f010faea:	eb 5b                	jmp    f010fb47 <test_initial_alloc+0x3bf>
	{
		if (*(startVAs[i]) != i || *(midVAs[i]) != i ||	*(endVAs[i]) != i)
f010faec:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010faef:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f010faf6:	66 8b 00             	mov    (%eax),%ax
f010faf9:	98                   	cwtl   
f010fafa:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010fafd:	75 26                	jne    f010fb25 <test_initial_alloc+0x39d>
f010faff:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010fb02:	8b 04 85 e0 62 57 f0 	mov    -0xfa89d20(,%eax,4),%eax
f010fb09:	66 8b 00             	mov    (%eax),%ax
f010fb0c:	98                   	cwtl   
f010fb0d:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010fb10:	75 13                	jne    f010fb25 <test_initial_alloc+0x39d>
f010fb12:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010fb15:	8b 04 85 e0 4c 57 f0 	mov    -0xfa8b320(,%eax,4),%eax
f010fb1c:	66 8b 00             	mov    (%eax),%ax
f010fb1f:	98                   	cwtl   
f010fb20:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010fb23:	74 1f                	je     f010fb44 <test_initial_alloc+0x3bc>
		{
			is_correct = 0;
f010fb25:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("alloc_block_xx #4.%d: WRONG! content of the block is not correct. Expected %d\n",i, i);
f010fb2c:	83 ec 04             	sub    $0x4,%esp
f010fb2f:	ff 75 d4             	pushl  -0x2c(%ebp)
f010fb32:	ff 75 d4             	pushl  -0x2c(%ebp)
f010fb35:	68 cc 79 12 f0       	push   $0xf01279cc
f010fb3a:	e8 2d 14 ff ff       	call   f0100f6c <cprintf>
f010fb3f:	83 c4 10             	add    $0x10,%esp
			break;
f010fb42:	eb 0b                	jmp    f010fb4f <test_initial_alloc+0x3c7>
	//====================================================================//
	/*INITIAL ALLOC Scenario 4: Check stored data inside each allocated block*/
	cprintf("	4: Check stored data inside each allocated block\n\n") ;
	is_correct = 1;

	for (int i = 0; i < idx; ++i)
f010fb44:	ff 45 d4             	incl   -0x2c(%ebp)
f010fb47:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010fb4a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010fb4d:	7c 9d                	jl     f010faec <test_initial_alloc+0x364>
			is_correct = 0;
			cprintf("alloc_block_xx #4.%d: WRONG! content of the block is not correct. Expected %d\n",i, i);
			break;
		}
	}
	if (is_correct)
f010fb4f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fb53:	74 04                	je     f010fb59 <test_initial_alloc+0x3d1>
	{
		eval += 10;
f010fb55:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}
	return eval;
f010fb59:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010fb5c:	c9                   	leave  
f010fb5d:	c3                   	ret    

f010fb5e <test_alloc_block_FF>:

void test_alloc_block_FF()
{
f010fb5e:	55                   	push   %ebp
f010fb5f:	89 e5                	mov    %esp,%ebp
f010fb61:	57                   	push   %edi
f010fb62:	56                   	push   %esi
f010fb63:	53                   	push   %ebx
f010fb64:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
#if USE_KHEAP
	panic("test_alloc_block_FF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	int eval = 0;
f010fb6a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_correct;
	void* va = NULL;
f010fb71:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 actualSize = 0;
f010fb78:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)

	cprintf("=======================================================\n") ;
f010fb7f:	83 ec 0c             	sub    $0xc,%esp
f010fb82:	68 1c 7a 12 f0       	push   $0xf0127a1c
f010fb87:	e8 e0 13 ff ff       	call   f0100f6c <cprintf>
f010fb8c:	83 c4 10             	add    $0x10,%esp
	cprintf("FIRST: Tests depend on the Allocate Function ONLY [40%]\n") ;
f010fb8f:	83 ec 0c             	sub    $0xc,%esp
f010fb92:	68 58 7a 12 f0       	push   $0xf0127a58
f010fb97:	e8 d0 13 ff ff       	call   f0100f6c <cprintf>
f010fb9c:	83 c4 10             	add    $0x10,%esp
	cprintf("=======================================================\n") ;
f010fb9f:	83 ec 0c             	sub    $0xc,%esp
f010fba2:	68 1c 7a 12 f0       	push   $0xf0127a1c
f010fba7:	e8 c0 13 ff ff       	call   f0100f6c <cprintf>
f010fbac:	83 c4 10             	add    $0x10,%esp
	eval = test_initial_alloc(DA_FF);
f010fbaf:	83 ec 0c             	sub    $0xc,%esp
f010fbb2:	6a 01                	push   $0x1
f010fbb4:	e8 cf fb ff ff       	call   f010f788 <test_initial_alloc>
f010fbb9:	83 c4 10             	add    $0x10,%esp
f010fbbc:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	cprintf("====================================================\n") ;
f010fbbf:	83 ec 0c             	sub    $0xc,%esp
f010fbc2:	68 94 7a 12 f0       	push   $0xf0127a94
f010fbc7:	e8 a0 13 ff ff       	call   f0100f6c <cprintf>
f010fbcc:	83 c4 10             	add    $0x10,%esp
	cprintf("SECOND: Tests depend on BOTH Allocate and Free [60%] \n") ;
f010fbcf:	83 ec 0c             	sub    $0xc,%esp
f010fbd2:	68 cc 7a 12 f0       	push   $0xf0127acc
f010fbd7:	e8 90 13 ff ff       	call   f0100f6c <cprintf>
f010fbdc:	83 c4 10             	add    $0x10,%esp
	cprintf("====================================================\n") ;
f010fbdf:	83 ec 0c             	sub    $0xc,%esp
f010fbe2:	68 94 7a 12 f0       	push   $0xf0127a94
f010fbe7:	e8 80 13 ff ff       	call   f0100f6c <cprintf>
f010fbec:	83 c4 10             	add    $0x10,%esp

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f010fbef:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010fbf6:	eb 2c                	jmp    f010fc24 <test_alloc_block_FF+0xc6>
	{
		free_block(startVAs[i*allocCntPerSize]);
f010fbf8:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fbfb:	89 d0                	mov    %edx,%eax
f010fbfd:	c1 e0 02             	shl    $0x2,%eax
f010fc00:	01 d0                	add    %edx,%eax
f010fc02:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010fc09:	01 d0                	add    %edx,%eax
f010fc0b:	c1 e0 03             	shl    $0x3,%eax
f010fc0e:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f010fc15:	83 ec 0c             	sub    $0xc,%esp
f010fc18:	50                   	push   %eax
f010fc19:	e8 16 16 01 00       	call   f0121234 <free_block>
f010fc1e:	83 c4 10             	add    $0x10,%esp
	cprintf("====================================================\n") ;
	cprintf("SECOND: Tests depend on BOTH Allocate and Free [60%] \n") ;
	cprintf("====================================================\n") ;

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f010fc21:	ff 45 dc             	incl   -0x24(%ebp)
f010fc24:	83 7d dc 06          	cmpl   $0x6,-0x24(%ebp)
f010fc28:	7e ce                	jle    f010fbf8 <test_alloc_block_FF+0x9a>
	{
		free_block(startVAs[i*allocCntPerSize]);
	}
	is_correct = 1;
f010fc2a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//Check number of freed blocks
	if(LIST_SIZE(&freeBlocksList) != numOfAllocs)
f010fc31:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f010fc36:	83 f8 07             	cmp    $0x7,%eax
f010fc39:	74 17                	je     f010fc52 <test_alloc_block_FF+0xf4>
	{
		is_correct = 0;
f010fc3b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		cprintf("alloc_block_FF #5: WRONG FREE. unexpected number of freed blocks\n");
f010fc42:	83 ec 0c             	sub    $0xc,%esp
f010fc45:	68 04 7b 12 f0       	push   $0xf0127b04
f010fc4a:	e8 1d 13 ff ff       	call   f0100f6c <cprintf>
f010fc4f:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f010fc52:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010fc56:	74 04                	je     f010fc5c <test_alloc_block_FF+0xfe>
	{
		eval += 10;
f010fc58:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	//====================================================================//
	/*FF ALLOC Scenario 1: Try to allocate a block with a size greater than the size of any existing free block*/
	cprintf("	1: Try to allocate large block [not fit in any space]\n\n") ;
f010fc5c:	83 ec 0c             	sub    $0xc,%esp
f010fc5f:	68 60 77 12 f0       	push   $0xf0127760
f010fc64:	e8 03 13 ff ff       	call   f0100f6c <cprintf>
f010fc69:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f010fc6c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	uint32 maxSize = 0 ;
f010fc73:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	for (int i = 0; i < numOfAllocs; ++i)
f010fc7a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f010fc81:	eb 1f                	jmp    f010fca2 <test_alloc_block_FF+0x144>
	{
		if (allocSizes[i] > maxSize)
f010fc83:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010fc86:	8b 04 85 78 9d 17 f0 	mov    -0xfe86288(,%eax,4),%eax
f010fc8d:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f010fc90:	76 0d                	jbe    f010fc9f <test_alloc_block_FF+0x141>
			maxSize = allocSizes[i] ;
f010fc92:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010fc95:	8b 04 85 78 9d 17 f0 	mov    -0xfe86288(,%eax,4),%eax
f010fc9c:	89 45 d8             	mov    %eax,-0x28(%ebp)
	/*FF ALLOC Scenario 1: Try to allocate a block with a size greater than the size of any existing free block*/
	cprintf("	1: Try to allocate large block [not fit in any space]\n\n") ;
	is_correct = 1;

	uint32 maxSize = 0 ;
	for (int i = 0; i < numOfAllocs; ++i)
f010fc9f:	ff 45 d4             	incl   -0x2c(%ebp)
f010fca2:	83 7d d4 06          	cmpl   $0x6,-0x2c(%ebp)
f010fca6:	7e db                	jle    f010fc83 <test_alloc_block_FF+0x125>
	{
		if (allocSizes[i] > maxSize)
			maxSize = allocSizes[i] ;
	}
	va = alloc_block(maxSize, DA_FF);
f010fca8:	83 ec 08             	sub    $0x8,%esp
f010fcab:	6a 01                	push   $0x1
f010fcad:	ff 75 d8             	pushl  -0x28(%ebp)
f010fcb0:	e8 3e 13 01 00       	call   f0120ff3 <alloc_block>
f010fcb5:	83 c4 10             	add    $0x10,%esp
f010fcb8:	89 45 c8             	mov    %eax,-0x38(%ebp)

	//Check returned va
	if(va != NULL)
f010fcbb:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f010fcbf:	74 17                	je     f010fcd8 <test_alloc_block_FF+0x17a>
	{
		is_correct = 0;
f010fcc1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		cprintf("alloc_block_FF #5: WRONG FF ALLOC - alloc_block_FF find a block instead no existing free blocks with the given size.\n");
f010fcc8:	83 ec 0c             	sub    $0xc,%esp
f010fccb:	68 48 7b 12 f0       	push   $0xf0127b48
f010fcd0:	e8 97 12 ff ff       	call   f0100f6c <cprintf>
f010fcd5:	83 c4 10             	add    $0x10,%esp
	}

	if (is_correct)
f010fcd8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010fcdc:	74 04                	je     f010fce2 <test_alloc_block_FF+0x184>
	{
		eval += 5;
f010fcde:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	}
	//====================================================================//
	/*FF ALLOC Scenario 2: Try to allocate blocks with sizes smaller than existing free blocks*/
	cprintf("	2: Try to allocate set of blocks with different sizes smaller than existing free blocks\n\n") ;
f010fce2:	83 ec 0c             	sub    $0xc,%esp
f010fce5:	68 c0 7b 12 f0       	push   $0xf0127bc0
f010fcea:	e8 7d 12 ff ff       	call   f0100f6c <cprintf>
f010fcef:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f010fcf2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

#define numOfFFTests 3
	uint32 startVA = KERNEL_HEAP_START + sizeof(int); //just after the DA Begin block
f010fcf9:	c7 45 c0 04 00 00 f6 	movl   $0xf6000004,-0x40(%ebp)
	uint32 testSizes[numOfFFTests] = {1*kilo + kilo/2, 3*kilo, kilo/2} ;
f010fd00:	8d 45 ac             	lea    -0x54(%ebp),%eax
f010fd03:	bb e0 7d 12 f0       	mov    $0xf0127de0,%ebx
f010fd08:	ba 03 00 00 00       	mov    $0x3,%edx
f010fd0d:	89 c7                	mov    %eax,%edi
f010fd0f:	89 de                	mov    %ebx,%esi
f010fd11:	89 d1                	mov    %edx,%ecx
f010fd13:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	uint32 startOf1st7KB = (uint32)startVAs[6*allocCntPerSize];
f010fd15:	a1 a0 49 57 f0       	mov    0xf05749a0,%eax
f010fd1a:	89 45 bc             	mov    %eax,-0x44(%ebp)
	uint32 expectedVAs[numOfFFTests] = {startVA + sizeOfMetaData/2, startOf1st7KB, startVA + testSizes[0] + sizeOfMetaData/2};
f010fd1d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010fd20:	83 c0 04             	add    $0x4,%eax
f010fd23:	89 45 a0             	mov    %eax,-0x60(%ebp)
f010fd26:	8b 45 bc             	mov    -0x44(%ebp),%eax
f010fd29:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f010fd2c:	8b 55 ac             	mov    -0x54(%ebp),%edx
f010fd2f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010fd32:	01 d0                	add    %edx,%eax
f010fd34:	83 c0 04             	add    $0x4,%eax
f010fd37:	89 45 a8             	mov    %eax,-0x58(%ebp)
	short* tstStartVAs[numOfFFTests+1] ;
	short* tstMidVAs[numOfFFTests+1] ;
	short* tstEndVAs[numOfFFTests+1] ;
	for (int i = 0; i < numOfFFTests; ++i)
f010fd3a:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f010fd41:	e9 c6 00 00 00       	jmp    f010fe0c <test_alloc_block_FF+0x2ae>
	{
		actualSize = testSizes[i] - sizeOfMetaData;
f010fd46:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fd49:	8b 44 85 ac          	mov    -0x54(%ebp,%eax,4),%eax
f010fd4d:	83 e8 08             	sub    $0x8,%eax
f010fd50:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		va = tstStartVAs[i] = alloc_block(actualSize, DA_FF);
f010fd53:	83 ec 08             	sub    $0x8,%esp
f010fd56:	6a 01                	push   $0x1
f010fd58:	ff 75 c4             	pushl  -0x3c(%ebp)
f010fd5b:	e8 93 12 01 00       	call   f0120ff3 <alloc_block>
f010fd60:	83 c4 10             	add    $0x10,%esp
f010fd63:	89 c2                	mov    %eax,%edx
f010fd65:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fd68:	89 54 85 90          	mov    %edx,-0x70(%ebp,%eax,4)
f010fd6c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fd6f:	8b 44 85 90          	mov    -0x70(%ebp,%eax,4),%eax
f010fd73:	89 45 c8             	mov    %eax,-0x38(%ebp)
		tstMidVAs[i] = va + actualSize/2 ;
f010fd76:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010fd79:	d1 e8                	shr    %eax
f010fd7b:	89 c2                	mov    %eax,%edx
f010fd7d:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010fd80:	01 c2                	add    %eax,%edx
f010fd82:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fd85:	89 54 85 80          	mov    %edx,-0x80(%ebp,%eax,4)
		tstEndVAs[i] = va + actualSize - sizeof(short);
f010fd89:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010fd8c:	8d 50 fe             	lea    -0x2(%eax),%edx
f010fd8f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010fd92:	01 c2                	add    %eax,%edx
f010fd94:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fd97:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
		//Check returned va
		if(tstStartVAs[i] == NULL || (tstStartVAs[i] != (short*)expectedVAs[i]))
f010fd9e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fda1:	8b 44 85 90          	mov    -0x70(%ebp,%eax,4),%eax
f010fda5:	85 c0                	test   %eax,%eax
f010fda7:	74 12                	je     f010fdbb <test_alloc_block_FF+0x25d>
f010fda9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fdac:	8b 54 85 90          	mov    -0x70(%ebp,%eax,4),%edx
f010fdb0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fdb3:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
f010fdb7:	39 c2                	cmp    %eax,%edx
f010fdb9:	74 27                	je     f010fde2 <test_alloc_block_FF+0x284>
		{
			is_correct = 0;
f010fdbb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("alloc_block_FF #6.%d: WRONG FF ALLOC - alloc_block_FF return wrong address. Expected %x, Actual %x\n", i, expectedVAs[i] ,tstStartVAs[i]);
f010fdc2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fdc5:	8b 54 85 90          	mov    -0x70(%ebp,%eax,4),%edx
f010fdc9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fdcc:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
f010fdd0:	52                   	push   %edx
f010fdd1:	50                   	push   %eax
f010fdd2:	ff 75 d0             	pushl  -0x30(%ebp)
f010fdd5:	68 1c 7c 12 f0       	push   $0xf0127c1c
f010fdda:	e8 8d 11 ff ff       	call   f0100f6c <cprintf>
f010fddf:	83 c4 10             	add    $0x10,%esp
			//break;
		}
		*(tstStartVAs[i]) = 353;
f010fde2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fde5:	8b 44 85 90          	mov    -0x70(%ebp,%eax,4),%eax
f010fde9:	66 c7 00 61 01       	movw   $0x161,(%eax)
		*(tstMidVAs[i]) = 353;
f010fdee:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fdf1:	8b 44 85 80          	mov    -0x80(%ebp,%eax,4),%eax
f010fdf5:	66 c7 00 61 01       	movw   $0x161,(%eax)
		*(tstEndVAs[i]) = 353;
f010fdfa:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fdfd:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
f010fe04:	66 c7 00 61 01       	movw   $0x161,(%eax)
	uint32 startOf1st7KB = (uint32)startVAs[6*allocCntPerSize];
	uint32 expectedVAs[numOfFFTests] = {startVA + sizeOfMetaData/2, startOf1st7KB, startVA + testSizes[0] + sizeOfMetaData/2};
	short* tstStartVAs[numOfFFTests+1] ;
	short* tstMidVAs[numOfFFTests+1] ;
	short* tstEndVAs[numOfFFTests+1] ;
	for (int i = 0; i < numOfFFTests; ++i)
f010fe09:	ff 45 d0             	incl   -0x30(%ebp)
f010fe0c:	83 7d d0 02          	cmpl   $0x2,-0x30(%ebp)
f010fe10:	0f 8e 30 ff ff ff    	jle    f010fd46 <test_alloc_block_FF+0x1e8>
		}
		*(tstStartVAs[i]) = 353;
		*(tstMidVAs[i]) = 353;
		*(tstEndVAs[i]) = 353;
	}
	if (is_correct)
f010fe16:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010fe1a:	74 04                	je     f010fe20 <test_alloc_block_FF+0x2c2>
	{
		eval += 15;
f010fe1c:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	//====================================================================//
	/*FF ALLOC Scenario 3: Try to allocate a block with a size equal to the size of the first existing free block*/
	cprintf("	3: Try to allocate a block with equal to the first existing free block\n\n") ;
f010fe20:	83 ec 0c             	sub    $0xc,%esp
f010fe23:	68 28 79 12 f0       	push   $0xf0127928
f010fe28:	e8 3f 11 ff ff       	call   f0100f6c <cprintf>
f010fe2d:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f010fe30:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	actualSize = 2*kilo - sizeOfMetaData;
f010fe37:	c7 45 c4 f8 07 00 00 	movl   $0x7f8,-0x3c(%ebp)
	va = tstStartVAs[numOfFFTests] = alloc_block(actualSize, DA_FF);
f010fe3e:	83 ec 08             	sub    $0x8,%esp
f010fe41:	6a 01                	push   $0x1
f010fe43:	ff 75 c4             	pushl  -0x3c(%ebp)
f010fe46:	e8 a8 11 01 00       	call   f0120ff3 <alloc_block>
f010fe4b:	83 c4 10             	add    $0x10,%esp
f010fe4e:	89 45 9c             	mov    %eax,-0x64(%ebp)
f010fe51:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010fe54:	89 45 c8             	mov    %eax,-0x38(%ebp)
	tstMidVAs[numOfFFTests] = va + actualSize/2 ;
f010fe57:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010fe5a:	d1 e8                	shr    %eax
f010fe5c:	89 c2                	mov    %eax,%edx
f010fe5e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010fe61:	01 d0                	add    %edx,%eax
f010fe63:	89 45 8c             	mov    %eax,-0x74(%ebp)
	tstEndVAs[numOfFFTests] = va + actualSize - sizeof(short);
f010fe66:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010fe69:	8d 50 fe             	lea    -0x2(%eax),%edx
f010fe6c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010fe6f:	01 d0                	add    %edx,%eax
f010fe71:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
	//Check returned va
	void* expected = (void*)(startVA + testSizes[0] + testSizes[2] + sizeOfMetaData/2) ;
f010fe77:	8b 55 ac             	mov    -0x54(%ebp),%edx
f010fe7a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010fe7d:	01 c2                	add    %eax,%edx
f010fe7f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010fe82:	01 d0                	add    %edx,%eax
f010fe84:	83 c0 04             	add    $0x4,%eax
f010fe87:	89 45 b8             	mov    %eax,-0x48(%ebp)
	if(va == NULL || (va != expected))
f010fe8a:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f010fe8e:	74 08                	je     f010fe98 <test_alloc_block_FF+0x33a>
f010fe90:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010fe93:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f010fe96:	74 1d                	je     f010feb5 <test_alloc_block_FF+0x357>
	{
		is_correct = 0;
f010fe98:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		cprintf("alloc_block_FF #7: WRONG FF ALLOC - alloc_block_FF return wrong address.expected %x, actual %x\n", expected, va);
f010fe9f:	83 ec 04             	sub    $0x4,%esp
f010fea2:	ff 75 c8             	pushl  -0x38(%ebp)
f010fea5:	ff 75 b8             	pushl  -0x48(%ebp)
f010fea8:	68 80 7c 12 f0       	push   $0xf0127c80
f010fead:	e8 ba 10 ff ff       	call   f0100f6c <cprintf>
f010feb2:	83 c4 10             	add    $0x10,%esp
	}
	if(LIST_SIZE(&freeBlocksList) != numOfAllocs - 1)
f010feb5:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f010feba:	83 f8 06             	cmp    $0x6,%eax
f010febd:	74 1f                	je     f010fede <test_alloc_block_FF+0x380>
	{
		is_correct = 0;
f010febf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		cprintf("alloc_block_FF #7: WRONG FF ALLOC - unexpected number of free blocks. expected %d, actual %d\n", numOfAllocs-1, LIST_SIZE(&freeBlocksList));
f010fec6:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f010fecb:	83 ec 04             	sub    $0x4,%esp
f010fece:	50                   	push   %eax
f010fecf:	6a 06                	push   $0x6
f010fed1:	68 e0 7c 12 f0       	push   $0xf0127ce0
f010fed6:	e8 91 10 ff ff       	call   f0100f6c <cprintf>
f010fedb:	83 c4 10             	add    $0x10,%esp
	}

	*(tstStartVAs[numOfFFTests]) = 353 ;
f010fede:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010fee1:	66 c7 00 61 01       	movw   $0x161,(%eax)
	*(tstMidVAs[numOfFFTests]) = 353 ;
f010fee6:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010fee9:	66 c7 00 61 01       	movw   $0x161,(%eax)
	*(tstEndVAs[numOfFFTests]) = 353 ;
f010feee:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010fef4:	66 c7 00 61 01       	movw   $0x161,(%eax)

	if (is_correct)
f010fef9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010fefd:	74 04                	je     f010ff03 <test_alloc_block_FF+0x3a5>
	{
		eval += 15;
f010feff:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	//====================================================================//
	/*FF ALLOC Scenario 4: Check stored data inside each allocated block*/
	cprintf("	4: Check stored data inside each allocated block\n\n") ;
f010ff03:	83 ec 0c             	sub    $0xc,%esp
f010ff06:	68 98 79 12 f0       	push   $0xf0127998
f010ff0b:	e8 5c 10 ff ff       	call   f0100f6c <cprintf>
f010ff10:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f010ff13:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	for (int i = 0; i <= numOfFFTests; ++i)
f010ff1a:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010ff21:	e9 82 00 00 00       	jmp    f010ffa8 <test_alloc_block_FF+0x44a>
	{
		//cprintf("startVA = %x, mid = %x, last = %x\n", tstStartVAs[i], tstMidVAs[i], tstEndVAs[i]);
		if (*(tstStartVAs[i]) != 353 || *(tstMidVAs[i]) != 353 || *(tstEndVAs[i]) != 353)
f010ff26:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ff29:	8b 44 85 90          	mov    -0x70(%ebp,%eax,4),%eax
f010ff2d:	66 8b 00             	mov    (%eax),%ax
f010ff30:	66 3d 61 01          	cmp    $0x161,%ax
f010ff34:	75 23                	jne    f010ff59 <test_alloc_block_FF+0x3fb>
f010ff36:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ff39:	8b 44 85 80          	mov    -0x80(%ebp,%eax,4),%eax
f010ff3d:	66 8b 00             	mov    (%eax),%ax
f010ff40:	66 3d 61 01          	cmp    $0x161,%ax
f010ff44:	75 13                	jne    f010ff59 <test_alloc_block_FF+0x3fb>
f010ff46:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ff49:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
f010ff50:	66 8b 00             	mov    (%eax),%ax
f010ff53:	66 3d 61 01          	cmp    $0x161,%ax
f010ff57:	74 4c                	je     f010ffa5 <test_alloc_block_FF+0x447>
		{
			is_correct = 0;
f010ff59:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("alloc_block_FF #8.%d: WRONG! content of the block is not correct. Expected=%d, val1=%d, val2=%d, val3=%d\n",i, 353, *(tstStartVAs[i]), *(tstMidVAs[i]), *(tstEndVAs[i]));
f010ff60:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ff63:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
f010ff6a:	66 8b 00             	mov    (%eax),%ax
f010ff6d:	0f bf c8             	movswl %ax,%ecx
f010ff70:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ff73:	8b 44 85 80          	mov    -0x80(%ebp,%eax,4),%eax
f010ff77:	66 8b 00             	mov    (%eax),%ax
f010ff7a:	0f bf d0             	movswl %ax,%edx
f010ff7d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ff80:	8b 44 85 90          	mov    -0x70(%ebp,%eax,4),%eax
f010ff84:	66 8b 00             	mov    (%eax),%ax
f010ff87:	98                   	cwtl   
f010ff88:	83 ec 08             	sub    $0x8,%esp
f010ff8b:	51                   	push   %ecx
f010ff8c:	52                   	push   %edx
f010ff8d:	50                   	push   %eax
f010ff8e:	68 61 01 00 00       	push   $0x161
f010ff93:	ff 75 cc             	pushl  -0x34(%ebp)
f010ff96:	68 40 7d 12 f0       	push   $0xf0127d40
f010ff9b:	e8 cc 0f ff ff       	call   f0100f6c <cprintf>
f010ffa0:	83 c4 20             	add    $0x20,%esp
			break;
f010ffa3:	eb 0d                	jmp    f010ffb2 <test_alloc_block_FF+0x454>
	//====================================================================//
	/*FF ALLOC Scenario 4: Check stored data inside each allocated block*/
	cprintf("	4: Check stored data inside each allocated block\n\n") ;
	is_correct = 1;

	for (int i = 0; i <= numOfFFTests; ++i)
f010ffa5:	ff 45 cc             	incl   -0x34(%ebp)
f010ffa8:	83 7d cc 03          	cmpl   $0x3,-0x34(%ebp)
f010ffac:	0f 8e 74 ff ff ff    	jle    f010ff26 <test_alloc_block_FF+0x3c8>
			cprintf("alloc_block_FF #8.%d: WRONG! content of the block is not correct. Expected=%d, val1=%d, val2=%d, val3=%d\n",i, 353, *(tstStartVAs[i]), *(tstMidVAs[i]), *(tstEndVAs[i]));
			break;
		}
	}

	if (is_correct)
f010ffb2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010ffb6:	74 04                	je     f010ffbc <test_alloc_block_FF+0x45e>
	{
		eval += 15;
f010ffb8:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	cprintf("test alloc_block_FF completed. Evaluation = %d%\n", eval);
f010ffbc:	83 ec 08             	sub    $0x8,%esp
f010ffbf:	ff 75 e4             	pushl  -0x1c(%ebp)
f010ffc2:	68 ac 7d 12 f0       	push   $0xf0127dac
f010ffc7:	e8 a0 0f ff ff       	call   f0100f6c <cprintf>
f010ffcc:	83 c4 10             	add    $0x10,%esp
}
f010ffcf:	90                   	nop
f010ffd0:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010ffd3:	5b                   	pop    %ebx
f010ffd4:	5e                   	pop    %esi
f010ffd5:	5f                   	pop    %edi
f010ffd6:	5d                   	pop    %ebp
f010ffd7:	c3                   	ret    

f010ffd8 <test_alloc_block_BF>:

void test_alloc_block_BF()
{
f010ffd8:	55                   	push   %ebp
f010ffd9:	89 e5                	mov    %esp,%ebp
f010ffdb:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_alloc_block_BF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	panic("Test is under construction! will be announced later isA");
f010ffde:	83 ec 04             	sub    $0x4,%esp
f010ffe1:	68 ec 7d 12 f0       	push   $0xf0127dec
f010ffe6:	68 5e 01 00 00       	push   $0x15e
f010ffeb:	68 c8 76 12 f0       	push   $0xf01276c8
f010fff0:	e8 25 03 ff ff       	call   f010031a <_panic>

f010fff5 <test_alloc_block_NF>:
}

void test_alloc_block_NF()
{
f010fff5:	55                   	push   %ebp
f010fff6:	89 e5                	mov    %esp,%ebp
	//====================================================================//
	/*NF ALLOC Scenario 7: Try to allocate a block with a size smaller than the existing blocks .. To try to update head not to remove it*/

	//cprintf("Congratulations!! test alloc_block_NF completed successfully.\n");

}
f010fff8:	90                   	nop
f010fff9:	5d                   	pop    %ebp
f010fffa:	c3                   	ret    

f010fffb <test_free_block_FF>:

void test_free_block_FF()
{
f010fffb:	55                   	push   %ebp
f010fffc:	89 e5                	mov    %esp,%ebp
f010fffe:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	cprintf("===========================================================\n") ;
f0110001:	83 ec 0c             	sub    $0xc,%esp
f0110004:	68 24 7e 12 f0       	push   $0xf0127e24
f0110009:	e8 5e 0f ff ff       	call   f0100f6c <cprintf>
f011000e:	83 c4 10             	add    $0x10,%esp
	cprintf("NOTE: THIS TEST IS DEPEND ON BOTH ALLOCATE & FREE FUNCTIONS\n") ;
f0110011:	83 ec 0c             	sub    $0xc,%esp
f0110014:	68 64 7e 12 f0       	push   $0xf0127e64
f0110019:	e8 4e 0f ff ff       	call   f0100f6c <cprintf>
f011001e:	83 c4 10             	add    $0x10,%esp
	cprintf("===========================================================\n") ;
f0110021:	83 ec 0c             	sub    $0xc,%esp
f0110024:	68 24 7e 12 f0       	push   $0xf0127e24
f0110029:	e8 3e 0f ff ff       	call   f0100f6c <cprintf>
f011002e:	83 c4 10             	add    $0x10,%esp

	int eval = 0;
f0110031:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool is_correct;
	int initAllocatedSpace = 3*Mega;
f0110038:	c7 45 cc 00 00 30 00 	movl   $0x300000,-0x34(%ebp)
	initialize_dynamic_allocator(KERNEL_HEAP_START, initAllocatedSpace);
f011003f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110042:	83 ec 08             	sub    $0x8,%esp
f0110045:	50                   	push   %eax
f0110046:	68 00 00 00 f6       	push   $0xf6000000
f011004b:	e8 d0 10 01 00       	call   f0121120 <initialize_dynamic_allocator>
f0110050:	83 c4 10             	add    $0x10,%esp

	void * va ;
	//====================================================================//
	/* Try to allocate set of blocks with different sizes*/
	cprintf("	1: Try to allocate set of blocks with different sizes to fill-up the allocated space\n\n") ;
f0110053:	83 ec 0c             	sub    $0xc,%esp
f0110056:	68 a4 7e 12 f0       	push   $0xf0127ea4
f011005b:	e8 0c 0f ff ff       	call   f0100f6c <cprintf>
f0110060:	83 c4 10             	add    $0x10,%esp

	int totalSizes = 0;
f0110063:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for (int i = 0; i < numOfAllocs; ++i)
f011006a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0110071:	eb 2a                	jmp    f011009d <test_free_block_FF+0xa2>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
f0110073:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110076:	8b 14 85 78 9d 17 f0 	mov    -0xfe86288(,%eax,4),%edx
f011007d:	89 d0                	mov    %edx,%eax
f011007f:	c1 e0 02             	shl    $0x2,%eax
f0110082:	01 d0                	add    %edx,%eax
f0110084:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011008b:	01 d0                	add    %edx,%eax
f011008d:	c1 e0 03             	shl    $0x3,%eax
f0110090:	89 c2                	mov    %eax,%edx
f0110092:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110095:	01 d0                	add    %edx,%eax
f0110097:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//====================================================================//
	/* Try to allocate set of blocks with different sizes*/
	cprintf("	1: Try to allocate set of blocks with different sizes to fill-up the allocated space\n\n") ;

	int totalSizes = 0;
	for (int i = 0; i < numOfAllocs; ++i)
f011009a:	ff 45 e8             	incl   -0x18(%ebp)
f011009d:	83 7d e8 06          	cmpl   $0x6,-0x18(%ebp)
f01100a1:	7e d0                	jle    f0110073 <test_free_block_FF+0x78>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
	}
	int remainSize = initAllocatedSpace - totalSizes - 2*sizeof(int) ; //exclude size of "DA Begin & End" blocks
f01100a3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01100a6:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01100a9:	83 e8 08             	sub    $0x8,%eax
f01100ac:	89 45 c8             	mov    %eax,-0x38(%ebp)
	if (remainSize <= 0)
f01100af:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f01100b3:	7f 17                	jg     f01100cc <test_free_block_FF+0xd1>
		panic("test_free_block is not configured correctly. Consider updating the initial allocated space OR the required allocations");
f01100b5:	83 ec 04             	sub    $0x4,%esp
f01100b8:	68 fc 7e 12 f0       	push   $0xf0127efc
f01100bd:	68 9a 01 00 00       	push   $0x19a
f01100c2:	68 c8 76 12 f0       	push   $0xf01276c8
f01100c7:	e8 4e 02 ff ff       	call   f010031a <_panic>

	int idx = 0;
f01100cc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
f01100d3:	c7 45 e0 04 00 00 f6 	movl   $0xf6000004,-0x20(%ebp)
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
f01100da:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01100e1:	e9 f8 00 00 00       	jmp    f01101de <test_free_block_FF+0x1e3>
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f01100e6:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f01100ed:	e9 dc 00 00 00       	jmp    f01101ce <test_free_block_FF+0x1d3>
		{
			actualSize = allocSizes[i] - sizeOfMetaData;
f01100f2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01100f5:	8b 04 85 78 9d 17 f0 	mov    -0xfe86288(,%eax,4),%eax
f01100fc:	83 e8 08             	sub    $0x8,%eax
f01100ff:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			va = startVAs[idx] = alloc_block(actualSize, DA_FF);
f0110102:	83 ec 08             	sub    $0x8,%esp
f0110105:	6a 01                	push   $0x1
f0110107:	ff 75 c4             	pushl  -0x3c(%ebp)
f011010a:	e8 e4 0e 01 00       	call   f0120ff3 <alloc_block>
f011010f:	83 c4 10             	add    $0x10,%esp
f0110112:	89 c2                	mov    %eax,%edx
f0110114:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110117:	89 14 85 e0 36 57 f0 	mov    %edx,-0xfa8c920(,%eax,4)
f011011e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110121:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110128:	89 45 c0             	mov    %eax,-0x40(%ebp)
			midVAs[idx] = va + actualSize/2 ;
f011012b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011012e:	d1 e8                	shr    %eax
f0110130:	89 c2                	mov    %eax,%edx
f0110132:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110135:	01 c2                	add    %eax,%edx
f0110137:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011013a:	89 14 85 e0 62 57 f0 	mov    %edx,-0xfa89d20(,%eax,4)
			endVAs[idx] = va + actualSize - sizeof(short);
f0110141:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110144:	8d 50 fe             	lea    -0x2(%eax),%edx
f0110147:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011014a:	01 c2                	add    %eax,%edx
f011014c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011014f:	89 14 85 e0 4c 57 f0 	mov    %edx,-0xfa8b320(,%eax,4)
			//Check returned va
			if(va == NULL || (va != (curVA + sizeOfMetaData/2)))
f0110156:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f011015a:	74 0b                	je     f0110167 <test_free_block_FF+0x16c>
f011015c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011015f:	83 c0 04             	add    $0x4,%eax
f0110162:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0110165:	74 24                	je     f011018b <test_free_block_FF+0x190>
				panic("test_free_block #1.%d: WRONG ALLOC - alloc_block_FF return wrong address. Expected %x, Actual %x", idx, curVA + sizeOfMetaData ,va);
f0110167:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011016a:	83 c0 08             	add    $0x8,%eax
f011016d:	83 ec 08             	sub    $0x8,%esp
f0110170:	ff 75 c0             	pushl  -0x40(%ebp)
f0110173:	50                   	push   %eax
f0110174:	ff 75 e4             	pushl  -0x1c(%ebp)
f0110177:	68 74 7f 12 f0       	push   $0xf0127f74
f011017c:	68 a9 01 00 00       	push   $0x1a9
f0110181:	68 c8 76 12 f0       	push   $0xf01276c8
f0110186:	e8 8f 01 ff ff       	call   f010031a <_panic>
			curVA += allocSizes[i] ;
f011018b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011018e:	8b 04 85 78 9d 17 f0 	mov    -0xfe86288(,%eax,4),%eax
f0110195:	01 45 e0             	add    %eax,-0x20(%ebp)
			*(startVAs[idx]) = idx ;
f0110198:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011019b:	8b 14 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%edx
f01101a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01101a5:	66 89 02             	mov    %ax,(%edx)
			*(midVAs[idx]) = idx ;
f01101a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01101ab:	8b 14 85 e0 62 57 f0 	mov    -0xfa89d20(,%eax,4),%edx
f01101b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01101b5:	66 89 02             	mov    %ax,(%edx)
			*(endVAs[idx]) = idx ;
f01101b8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01101bb:	8b 14 85 e0 4c 57 f0 	mov    -0xfa8b320(,%eax,4),%edx
f01101c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01101c5:	66 89 02             	mov    %ax,(%edx)
			idx++;
f01101c8:	ff 45 e4             	incl   -0x1c(%ebp)
	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f01101cb:	ff 45 d8             	incl   -0x28(%ebp)
f01101ce:	81 7d d8 c7 00 00 00 	cmpl   $0xc7,-0x28(%ebp)
f01101d5:	0f 8e 17 ff ff ff    	jle    f01100f2 <test_free_block_FF+0xf7>
		panic("test_free_block is not configured correctly. Consider updating the initial allocated space OR the required allocations");

	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
f01101db:	ff 45 dc             	incl   -0x24(%ebp)
f01101de:	83 7d dc 06          	cmpl   $0x6,-0x24(%ebp)
f01101e2:	0f 8e fe fe ff ff    	jle    f01100e6 <test_free_block_FF+0xeb>
		}
	}

	//====================================================================//
	/* Try to allocate a block with a size equal to the size of the first existing free block*/
	actualSize = remainSize - sizeOfMetaData;
f01101e8:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01101eb:	83 e8 08             	sub    $0x8,%eax
f01101ee:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	va = startVAs[idx] = alloc_block(actualSize, DA_FF);
f01101f1:	83 ec 08             	sub    $0x8,%esp
f01101f4:	6a 01                	push   $0x1
f01101f6:	ff 75 c4             	pushl  -0x3c(%ebp)
f01101f9:	e8 f5 0d 01 00       	call   f0120ff3 <alloc_block>
f01101fe:	83 c4 10             	add    $0x10,%esp
f0110201:	89 c2                	mov    %eax,%edx
f0110203:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110206:	89 14 85 e0 36 57 f0 	mov    %edx,-0xfa8c920(,%eax,4)
f011020d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110210:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110217:	89 45 c0             	mov    %eax,-0x40(%ebp)
	midVAs[idx] = va + actualSize/2 ;
f011021a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011021d:	d1 e8                	shr    %eax
f011021f:	89 c2                	mov    %eax,%edx
f0110221:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110224:	01 c2                	add    %eax,%edx
f0110226:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110229:	89 14 85 e0 62 57 f0 	mov    %edx,-0xfa89d20(,%eax,4)
	endVAs[idx] = va + actualSize - sizeof(short);
f0110230:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110233:	8d 50 fe             	lea    -0x2(%eax),%edx
f0110236:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110239:	01 c2                	add    %eax,%edx
f011023b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011023e:	89 14 85 e0 4c 57 f0 	mov    %edx,-0xfa8b320(,%eax,4)
	//Check returned va
	if(va == NULL || (va != (curVA + sizeOfMetaData/2)))
f0110245:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f0110249:	74 0b                	je     f0110256 <test_free_block_FF+0x25b>
f011024b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011024e:	83 c0 04             	add    $0x4,%eax
f0110251:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0110254:	74 17                	je     f011026d <test_free_block_FF+0x272>
		panic("test_free_block #2: WRONG ALLOC - alloc_block_FF return wrong address.");
f0110256:	83 ec 04             	sub    $0x4,%esp
f0110259:	68 d8 7f 12 f0       	push   $0xf0127fd8
f011025e:	68 ba 01 00 00       	push   $0x1ba
f0110263:	68 c8 76 12 f0       	push   $0xf01276c8
f0110268:	e8 ad 00 ff ff       	call   f010031a <_panic>
	*(startVAs[idx]) = idx ;
f011026d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110270:	8b 14 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%edx
f0110277:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011027a:	66 89 02             	mov    %ax,(%edx)
	*(midVAs[idx]) = idx ;
f011027d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110280:	8b 14 85 e0 62 57 f0 	mov    -0xfa89d20(,%eax,4),%edx
f0110287:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011028a:	66 89 02             	mov    %ax,(%edx)
	*(endVAs[idx]) = idx ;
f011028d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110290:	8b 14 85 e0 4c 57 f0 	mov    -0xfa8b320(,%eax,4),%edx
f0110297:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011029a:	66 89 02             	mov    %ax,(%edx)

	//====================================================================//
	/* Check stored data inside each allocated block*/
	cprintf("	2: Check stored data inside each allocated block\n\n") ;
f011029d:	83 ec 0c             	sub    $0xc,%esp
f01102a0:	68 20 80 12 f0       	push   $0xf0128020
f01102a5:	e8 c2 0c ff ff       	call   f0100f6c <cprintf>
f01102aa:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f01102ad:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	for (int i = 0; i < idx; ++i)
f01102b4:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f01102bb:	eb 5b                	jmp    f0110318 <test_free_block_FF+0x31d>
	{
		if (*(startVAs[i]) != i || *(midVAs[i]) != i ||	*(endVAs[i]) != i)
f01102bd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01102c0:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f01102c7:	66 8b 00             	mov    (%eax),%ax
f01102ca:	98                   	cwtl   
f01102cb:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01102ce:	75 26                	jne    f01102f6 <test_free_block_FF+0x2fb>
f01102d0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01102d3:	8b 04 85 e0 62 57 f0 	mov    -0xfa89d20(,%eax,4),%eax
f01102da:	66 8b 00             	mov    (%eax),%ax
f01102dd:	98                   	cwtl   
f01102de:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01102e1:	75 13                	jne    f01102f6 <test_free_block_FF+0x2fb>
f01102e3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01102e6:	8b 04 85 e0 4c 57 f0 	mov    -0xfa8b320(,%eax,4),%eax
f01102ed:	66 8b 00             	mov    (%eax),%ax
f01102f0:	98                   	cwtl   
f01102f1:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01102f4:	74 1f                	je     f0110315 <test_free_block_FF+0x31a>
		{
			is_correct = 0;
f01102f6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_free_block #3.%d: WRONG! content of the block is not correct. Expected %d\n",i, i);
f01102fd:	83 ec 04             	sub    $0x4,%esp
f0110300:	ff 75 d4             	pushl  -0x2c(%ebp)
f0110303:	ff 75 d4             	pushl  -0x2c(%ebp)
f0110306:	68 54 80 12 f0       	push   $0xf0128054
f011030b:	e8 5c 0c ff ff       	call   f0100f6c <cprintf>
f0110310:	83 c4 10             	add    $0x10,%esp
			break;
f0110313:	eb 0b                	jmp    f0110320 <test_free_block_FF+0x325>
	//====================================================================//
	/* Check stored data inside each allocated block*/
	cprintf("	2: Check stored data inside each allocated block\n\n") ;
	is_correct = 1;

	for (int i = 0; i < idx; ++i)
f0110315:	ff 45 d4             	incl   -0x2c(%ebp)
f0110318:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011031b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011031e:	7c 9d                	jl     f01102bd <test_free_block_FF+0x2c2>
		}
	}

	//====================================================================//
	/* free_block Scenario 1: Free some allocated blocks [no coalesce]*/
	cprintf("	3: Free some allocated block [no coalesce]\n\n") ;
f0110320:	83 ec 0c             	sub    $0xc,%esp
f0110323:	68 a4 80 12 f0       	push   $0xf01280a4
f0110328:	e8 3f 0c ff ff       	call   f0100f6c <cprintf>
f011032d:	83 c4 10             	add    $0x10,%esp
	uint32 block_size, expected_size, *blk_header, *blk_footer;
	is_correct = 1;
f0110330:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f0110337:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f011033e:	e9 e4 00 00 00       	jmp    f0110427 <test_free_block_FF+0x42c>
	{
		free_block(startVAs[i*allocCntPerSize]);
f0110343:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0110346:	89 d0                	mov    %edx,%eax
f0110348:	c1 e0 02             	shl    $0x2,%eax
f011034b:	01 d0                	add    %edx,%eax
f011034d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110354:	01 d0                	add    %edx,%eax
f0110356:	c1 e0 03             	shl    $0x3,%eax
f0110359:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110360:	83 ec 0c             	sub    $0xc,%esp
f0110363:	50                   	push   %eax
f0110364:	e8 cb 0e 01 00       	call   f0121234 <free_block>
f0110369:	83 c4 10             	add    $0x10,%esp
		uint32 block_size = get_block_size(startVAs[i*allocCntPerSize]) ;
f011036c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011036f:	89 d0                	mov    %edx,%eax
f0110371:	c1 e0 02             	shl    $0x2,%eax
f0110374:	01 d0                	add    %edx,%eax
f0110376:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011037d:	01 d0                	add    %edx,%eax
f011037f:	c1 e0 03             	shl    $0x3,%eax
f0110382:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110389:	83 ec 0c             	sub    $0xc,%esp
f011038c:	50                   	push   %eax
f011038d:	e8 2a 0c 01 00       	call   f0120fbc <get_block_size>
f0110392:	83 c4 10             	add    $0x10,%esp
f0110395:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if (block_size != allocSizes[i])
f0110398:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011039b:	8b 04 85 78 9d 17 f0 	mov    -0xfe86288(,%eax,4),%eax
f01103a2:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f01103a5:	74 2b                	je     f01103d2 <test_free_block_FF+0x3d7>
		{
			if (is_correct)
f01103a7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01103ab:	74 25                	je     f01103d2 <test_free_block_FF+0x3d7>
			{
				is_correct = 0;
f01103ad:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cprintf("test_free_block #4.%d: WRONG FREE! block size after free is not correct. Expected %d, Actual %d\n",i, allocSizes[i],block_size);
f01103b4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01103b7:	8b 04 85 78 9d 17 f0 	mov    -0xfe86288(,%eax,4),%eax
f01103be:	ff 75 bc             	pushl  -0x44(%ebp)
f01103c1:	50                   	push   %eax
f01103c2:	ff 75 d0             	pushl  -0x30(%ebp)
f01103c5:	68 d4 80 12 f0       	push   $0xf01280d4
f01103ca:	e8 9d 0b ff ff       	call   f0100f6c <cprintf>
f01103cf:	83 c4 10             	add    $0x10,%esp
			}
		}
		int8 block_status = is_free_block(startVAs[i*allocCntPerSize]) ;
f01103d2:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01103d5:	89 d0                	mov    %edx,%eax
f01103d7:	c1 e0 02             	shl    $0x2,%eax
f01103da:	01 d0                	add    %edx,%eax
f01103dc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01103e3:	01 d0                	add    %edx,%eax
f01103e5:	c1 e0 03             	shl    $0x3,%eax
f01103e8:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f01103ef:	83 ec 0c             	sub    $0xc,%esp
f01103f2:	50                   	push   %eax
f01103f3:	e8 dd 0b 01 00       	call   f0120fd5 <is_free_block>
f01103f8:	83 c4 10             	add    $0x10,%esp
f01103fb:	88 45 bb             	mov    %al,-0x45(%ebp)
		if (block_status != 1)
f01103fe:	80 7d bb 01          	cmpb   $0x1,-0x45(%ebp)
f0110402:	74 20                	je     f0110424 <test_free_block_FF+0x429>
		{
			if (is_correct)
f0110404:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110408:	74 1a                	je     f0110424 <test_free_block_FF+0x429>
			{
				is_correct = 0;
f011040a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cprintf("test_free_block #5.%d: WRONG FREE! block status not marked as free.\n", i);
f0110411:	83 ec 08             	sub    $0x8,%esp
f0110414:	ff 75 d0             	pushl  -0x30(%ebp)
f0110417:	68 38 81 12 f0       	push   $0xf0128138
f011041c:	e8 4b 0b ff ff       	call   f0100f6c <cprintf>
f0110421:	83 c4 10             	add    $0x10,%esp
	cprintf("	3: Free some allocated block [no coalesce]\n\n") ;
	uint32 block_size, expected_size, *blk_header, *blk_footer;
	is_correct = 1;

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f0110424:	ff 45 d0             	incl   -0x30(%ebp)
f0110427:	83 7d d0 06          	cmpl   $0x6,-0x30(%ebp)
f011042b:	0f 8e 12 ff ff ff    	jle    f0110343 <test_free_block_FF+0x348>
				is_correct = 0;
				cprintf("test_free_block #5.%d: WRONG FREE! block status not marked as free.\n", i);
			}
		}
	}
	uint32 expectedNumOfFreeBlks = numOfAllocs;
f0110431:	c7 45 b4 07 00 00 00 	movl   $0x7,-0x4c(%ebp)
	is_correct = 1;
f0110438:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	if (LIST_SIZE(&freeBlocksList) != expectedNumOfFreeBlks)
f011043f:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f0110444:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0110447:	74 17                	je     f0110460 <test_free_block_FF+0x465>
	{
		is_correct = 0;
f0110449:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #5.oo: WRONG number of freed blocks in the freeBlockList.\n");
f0110450:	83 ec 0c             	sub    $0xc,%esp
f0110453:	68 80 81 12 f0       	push   $0xf0128180
f0110458:	e8 0f 0b ff ff       	call   f0100f6c <cprintf>
f011045d:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f0110460:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110464:	74 04                	je     f011046a <test_free_block_FF+0x46f>
	{
		eval += 10;
f0110466:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	is_correct = 1;
f011046a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Free last block
	free_block(startVAs[numOfAllocs*allocCntPerSize]);
f0110471:	a1 c0 4c 57 f0       	mov    0xf0574cc0,%eax
f0110476:	83 ec 0c             	sub    $0xc,%esp
f0110479:	50                   	push   %eax
f011047a:	e8 b5 0d 01 00       	call   f0121234 <free_block>
f011047f:	83 c4 10             	add    $0x10,%esp
	block_size = get_block_size(startVAs[numOfAllocs*allocCntPerSize]) ;
f0110482:	a1 c0 4c 57 f0       	mov    0xf0574cc0,%eax
f0110487:	83 ec 0c             	sub    $0xc,%esp
f011048a:	50                   	push   %eax
f011048b:	e8 2c 0b 01 00       	call   f0120fbc <get_block_size>
f0110490:	83 c4 10             	add    $0x10,%esp
f0110493:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (block_size != remainSize)
f0110496:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110499:	39 45 b0             	cmp    %eax,-0x50(%ebp)
f011049c:	74 1d                	je     f01104bb <test_free_block_FF+0x4c0>
	{
		is_correct = 0;
f011049e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #6.1: WRONG FREE! block size after free is not correct. Expected %d, Actual %d\n",remainSize,block_size);
f01104a5:	83 ec 04             	sub    $0x4,%esp
f01104a8:	ff 75 b0             	pushl  -0x50(%ebp)
f01104ab:	ff 75 c8             	pushl  -0x38(%ebp)
f01104ae:	68 cc 81 12 f0       	push   $0xf01281cc
f01104b3:	e8 b4 0a ff ff       	call   f0100f6c <cprintf>
f01104b8:	83 c4 10             	add    $0x10,%esp
	}
	int8 block_status = is_free_block(startVAs[numOfAllocs*allocCntPerSize]) ;
f01104bb:	a1 c0 4c 57 f0       	mov    0xf0574cc0,%eax
f01104c0:	83 ec 0c             	sub    $0xc,%esp
f01104c3:	50                   	push   %eax
f01104c4:	e8 0c 0b 01 00       	call   f0120fd5 <is_free_block>
f01104c9:	83 c4 10             	add    $0x10,%esp
f01104cc:	88 45 af             	mov    %al,-0x51(%ebp)
	if (block_status != 1)
f01104cf:	80 7d af 01          	cmpb   $0x1,-0x51(%ebp)
f01104d3:	74 17                	je     f01104ec <test_free_block_FF+0x4f1>
	{
		is_correct = 0;
f01104d5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #6.2: WRONG FREE! WRONG FREE! block status not marked as free.\n");
f01104dc:	83 ec 0c             	sub    $0xc,%esp
f01104df:	68 2c 82 12 f0       	push   $0xf012822c
f01104e4:	e8 83 0a ff ff       	call   f0100f6c <cprintf>
f01104e9:	83 c4 10             	add    $0x10,%esp
	}

	//Reallocate last block
	actualSize = remainSize - sizeOfMetaData;
f01104ec:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01104ef:	83 e8 08             	sub    $0x8,%eax
f01104f2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	va = alloc_block(actualSize, DA_FF);
f01104f5:	83 ec 08             	sub    $0x8,%esp
f01104f8:	6a 01                	push   $0x1
f01104fa:	ff 75 c4             	pushl  -0x3c(%ebp)
f01104fd:	e8 f1 0a 01 00       	call   f0120ff3 <alloc_block>
f0110502:	83 c4 10             	add    $0x10,%esp
f0110505:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	if(va == NULL || (va != (curVA + sizeOfMetaData/2)))
f0110508:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f011050c:	74 0b                	je     f0110519 <test_free_block_FF+0x51e>
f011050e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110511:	83 c0 04             	add    $0x4,%eax
f0110514:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0110517:	74 17                	je     f0110530 <test_free_block_FF+0x535>
	{
		is_correct = 0;
f0110519:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #6.3: WRONG ALLOC - alloc_block_FF return wrong address.\n");
f0110520:	83 ec 0c             	sub    $0xc,%esp
f0110523:	68 7c 82 12 f0       	push   $0xf012827c
f0110528:	e8 3f 0a ff ff       	call   f0100f6c <cprintf>
f011052d:	83 c4 10             	add    $0x10,%esp
	}

	//Free block before last
	free_block(startVAs[numOfAllocs*allocCntPerSize - 1]);
f0110530:	a1 bc 4c 57 f0       	mov    0xf0574cbc,%eax
f0110535:	83 ec 0c             	sub    $0xc,%esp
f0110538:	50                   	push   %eax
f0110539:	e8 f6 0c 01 00       	call   f0121234 <free_block>
f011053e:	83 c4 10             	add    $0x10,%esp
	block_size = get_block_size(startVAs[numOfAllocs*allocCntPerSize - 1]) ;
f0110541:	a1 bc 4c 57 f0       	mov    0xf0574cbc,%eax
f0110546:	83 ec 0c             	sub    $0xc,%esp
f0110549:	50                   	push   %eax
f011054a:	e8 6d 0a 01 00       	call   f0120fbc <get_block_size>
f011054f:	83 c4 10             	add    $0x10,%esp
f0110552:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (block_size != allocSizes[numOfAllocs-1])
f0110555:	a1 90 9d 17 f0       	mov    0xf0179d90,%eax
f011055a:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011055d:	74 20                	je     f011057f <test_free_block_FF+0x584>
	{
		is_correct = 0;
f011055f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #6.4: WRONG FREE! block size after free is not correct. Expected %d, Actual %d\n",allocSizes[numOfAllocs-1],block_size);
f0110566:	a1 90 9d 17 f0       	mov    0xf0179d90,%eax
f011056b:	83 ec 04             	sub    $0x4,%esp
f011056e:	ff 75 b0             	pushl  -0x50(%ebp)
f0110571:	50                   	push   %eax
f0110572:	68 c8 82 12 f0       	push   $0xf01282c8
f0110577:	e8 f0 09 ff ff       	call   f0100f6c <cprintf>
f011057c:	83 c4 10             	add    $0x10,%esp
	}
	block_status = is_free_block(startVAs[numOfAllocs*allocCntPerSize-1]) ;
f011057f:	a1 bc 4c 57 f0       	mov    0xf0574cbc,%eax
f0110584:	83 ec 0c             	sub    $0xc,%esp
f0110587:	50                   	push   %eax
f0110588:	e8 48 0a 01 00       	call   f0120fd5 <is_free_block>
f011058d:	83 c4 10             	add    $0x10,%esp
f0110590:	88 45 af             	mov    %al,-0x51(%ebp)
	if (block_status != 1)
f0110593:	80 7d af 01          	cmpb   $0x1,-0x51(%ebp)
f0110597:	74 17                	je     f01105b0 <test_free_block_FF+0x5b5>
	{
		is_correct = 0;
f0110599:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #6.5: WRONG FREE! block status (is_free) not equal 1 after freeing.\n");
f01105a0:	83 ec 0c             	sub    $0xc,%esp
f01105a3:	68 28 83 12 f0       	push   $0xf0128328
f01105a8:	e8 bf 09 ff ff       	call   f0100f6c <cprintf>
f01105ad:	83 c4 10             	add    $0x10,%esp
	}

	//Reallocate first block
	actualSize = allocSizes[0] - sizeOfMetaData;
f01105b0:	a1 78 9d 17 f0       	mov    0xf0179d78,%eax
f01105b5:	83 e8 08             	sub    $0x8,%eax
f01105b8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	va = alloc_block(actualSize, DA_FF);
f01105bb:	83 ec 08             	sub    $0x8,%esp
f01105be:	6a 01                	push   $0x1
f01105c0:	ff 75 c4             	pushl  -0x3c(%ebp)
f01105c3:	e8 2b 0a 01 00       	call   f0120ff3 <alloc_block>
f01105c8:	83 c4 10             	add    $0x10,%esp
f01105cb:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	if(va == NULL || (va != (void*)(KERNEL_HEAP_START + sizeof(int) + sizeOfMetaData/2)))
f01105ce:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f01105d2:	74 09                	je     f01105dd <test_free_block_FF+0x5e2>
f01105d4:	81 7d c0 08 00 00 f6 	cmpl   $0xf6000008,-0x40(%ebp)
f01105db:	74 17                	je     f01105f4 <test_free_block_FF+0x5f9>
	{
		is_correct = 0;
f01105dd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #7.1: WRONG ALLOC - alloc_block_FF return wrong address.\n");
f01105e4:	83 ec 0c             	sub    $0xc,%esp
f01105e7:	68 80 83 12 f0       	push   $0xf0128380
f01105ec:	e8 7b 09 ff ff       	call   f0100f6c <cprintf>
f01105f1:	83 c4 10             	add    $0x10,%esp
	}

	//Free 2nd block
	free_block(startVAs[1]);
f01105f4:	a1 e4 36 57 f0       	mov    0xf05736e4,%eax
f01105f9:	83 ec 0c             	sub    $0xc,%esp
f01105fc:	50                   	push   %eax
f01105fd:	e8 32 0c 01 00       	call   f0121234 <free_block>
f0110602:	83 c4 10             	add    $0x10,%esp
	block_size = get_block_size(startVAs[1]) ;
f0110605:	a1 e4 36 57 f0       	mov    0xf05736e4,%eax
f011060a:	83 ec 0c             	sub    $0xc,%esp
f011060d:	50                   	push   %eax
f011060e:	e8 a9 09 01 00       	call   f0120fbc <get_block_size>
f0110613:	83 c4 10             	add    $0x10,%esp
f0110616:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (block_size != allocSizes[0])
f0110619:	a1 78 9d 17 f0       	mov    0xf0179d78,%eax
f011061e:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0110621:	74 20                	je     f0110643 <test_free_block_FF+0x648>
	{
		is_correct = 0;
f0110623:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #7.2: WRONG FREE! block size after free is not correct. Expected %d, Actual %d\n",allocSizes[0],block_size);
f011062a:	a1 78 9d 17 f0       	mov    0xf0179d78,%eax
f011062f:	83 ec 04             	sub    $0x4,%esp
f0110632:	ff 75 b0             	pushl  -0x50(%ebp)
f0110635:	50                   	push   %eax
f0110636:	68 cc 83 12 f0       	push   $0xf01283cc
f011063b:	e8 2c 09 ff ff       	call   f0100f6c <cprintf>
f0110640:	83 c4 10             	add    $0x10,%esp
	}
	block_status = is_free_block(startVAs[1]) ;
f0110643:	a1 e4 36 57 f0       	mov    0xf05736e4,%eax
f0110648:	83 ec 0c             	sub    $0xc,%esp
f011064b:	50                   	push   %eax
f011064c:	e8 84 09 01 00       	call   f0120fd5 <is_free_block>
f0110651:	83 c4 10             	add    $0x10,%esp
f0110654:	88 45 af             	mov    %al,-0x51(%ebp)
	if (block_status != 1)
f0110657:	80 7d af 01          	cmpb   $0x1,-0x51(%ebp)
f011065b:	74 17                	je     f0110674 <test_free_block_FF+0x679>
	{
		is_correct = 0;
f011065d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #7.3: WRONG FREE! block status (is_free) not equal 1 after freeing.\n");
f0110664:	83 ec 0c             	sub    $0xc,%esp
f0110667:	68 2c 84 12 f0       	push   $0xf012842c
f011066c:	e8 fb 08 ff ff       	call   f0100f6c <cprintf>
f0110671:	83 c4 10             	add    $0x10,%esp
	}
	is_correct = 1;
f0110674:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	expectedNumOfFreeBlks++ ;
f011067b:	ff 45 b4             	incl   -0x4c(%ebp)
	if (LIST_SIZE(&freeBlocksList) != expectedNumOfFreeBlks)
f011067e:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f0110683:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0110686:	74 17                	je     f011069f <test_free_block_FF+0x6a4>
	{
		is_correct = 0;
f0110688:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #7.4: WRONG number of freed blocks in the freeBlockList.\n");
f011068f:	83 ec 0c             	sub    $0xc,%esp
f0110692:	68 84 84 12 f0       	push   $0xf0128484
f0110697:	e8 d0 08 ff ff       	call   f0100f6c <cprintf>
f011069c:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f011069f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01106a3:	74 04                	je     f01106a9 <test_free_block_FF+0x6ae>
	{
		eval += 10;
f01106a5:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	//====================================================================//
	/*free_block Scenario 2: Merge with previous ONLY (AT the tail)*/
	cprintf("	4: Free some allocated blocks [Merge with previous ONLY]\n\n") ;
f01106a9:	83 ec 0c             	sub    $0xc,%esp
f01106ac:	68 d0 84 12 f0       	push   $0xf01284d0
f01106b1:	e8 b6 08 ff ff       	call   f0100f6c <cprintf>
f01106b6:	83 c4 10             	add    $0x10,%esp
	cprintf("		4.1: at the tail\n\n") ;
f01106b9:	83 ec 0c             	sub    $0xc,%esp
f01106bc:	68 0c 85 12 f0       	push   $0xf012850c
f01106c1:	e8 a6 08 ff ff       	call   f0100f6c <cprintf>
f01106c6:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f01106c9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Free last block (coalesce with previous)
	uint32 blockIndex = numOfAllocs*allocCntPerSize;
f01106d0:	c7 45 a8 78 05 00 00 	movl   $0x578,-0x58(%ebp)
	free_block(startVAs[blockIndex]);
f01106d7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01106da:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f01106e1:	83 ec 0c             	sub    $0xc,%esp
f01106e4:	50                   	push   %eax
f01106e5:	e8 4a 0b 01 00       	call   f0121234 <free_block>
f01106ea:	83 c4 10             	add    $0x10,%esp
	block_size = get_block_size(startVAs[blockIndex-1]) ;
f01106ed:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01106f0:	48                   	dec    %eax
f01106f1:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f01106f8:	83 ec 0c             	sub    $0xc,%esp
f01106fb:	50                   	push   %eax
f01106fc:	e8 bb 08 01 00       	call   f0120fbc <get_block_size>
f0110701:	83 c4 10             	add    $0x10,%esp
f0110704:	89 45 b0             	mov    %eax,-0x50(%ebp)
	expected_size = remainSize + allocSizes[numOfAllocs-1];
f0110707:	8b 15 90 9d 17 f0    	mov    0xf0179d90,%edx
f011070d:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110710:	01 d0                	add    %edx,%eax
f0110712:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	if (block_size != expected_size)
f0110715:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0110718:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011071b:	74 26                	je     f0110743 <test_free_block_FF+0x748>
	{
		is_correct = 0;
f011071d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #8.1: WRONG FREE! block size after free is not correct. Expected %d, Actual %d\n",remainSize + allocSizes[numOfAllocs-1],block_size);
f0110724:	8b 15 90 9d 17 f0    	mov    0xf0179d90,%edx
f011072a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011072d:	01 d0                	add    %edx,%eax
f011072f:	83 ec 04             	sub    $0x4,%esp
f0110732:	ff 75 b0             	pushl  -0x50(%ebp)
f0110735:	50                   	push   %eax
f0110736:	68 24 85 12 f0       	push   $0xf0128524
f011073b:	e8 2c 08 ff ff       	call   f0100f6c <cprintf>
f0110740:	83 c4 10             	add    $0x10,%esp
	}
	block_status = is_free_block(startVAs[blockIndex-1]) ;
f0110743:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110746:	48                   	dec    %eax
f0110747:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f011074e:	83 ec 0c             	sub    $0xc,%esp
f0110751:	50                   	push   %eax
f0110752:	e8 7e 08 01 00       	call   f0120fd5 <is_free_block>
f0110757:	83 c4 10             	add    $0x10,%esp
f011075a:	88 45 af             	mov    %al,-0x51(%ebp)
	if (block_status != 1)
f011075d:	80 7d af 01          	cmpb   $0x1,-0x51(%ebp)
f0110761:	74 17                	je     f011077a <test_free_block_FF+0x77f>
	{
		is_correct = 0;
f0110763:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #8.2: WRONG FREE! block status (is_free) not equal 1 after freeing.\n");
f011076a:	83 ec 0c             	sub    $0xc,%esp
f011076d:	68 84 85 12 f0       	push   $0xf0128584
f0110772:	e8 f5 07 ff ff       	call   f0100f6c <cprintf>
f0110777:	83 c4 10             	add    $0x10,%esp
	}

	blk_header = (uint32*)((uint32)startVAs[blockIndex-1] - sizeof(int));
f011077a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011077d:	48                   	dec    %eax
f011077e:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110785:	83 e8 04             	sub    $0x4,%eax
f0110788:	89 45 a0             	mov    %eax,-0x60(%ebp)
	blk_footer = (uint32*)((uint32)startVAs[blockIndex-1]+expected_size-2*sizeof(int));
f011078b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011078e:	48                   	dec    %eax
f011078f:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110796:	89 c2                	mov    %eax,%edx
f0110798:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011079b:	01 d0                	add    %edx,%eax
f011079d:	83 e8 08             	sub    $0x8,%eax
f01107a0:	89 45 9c             	mov    %eax,-0x64(%ebp)
	if (*(blk_header) != *(blk_footer))
f01107a3:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01107a6:	8b 10                	mov    (%eax),%edx
f01107a8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01107ab:	8b 00                	mov    (%eax),%eax
f01107ad:	39 c2                	cmp    %eax,%edx
f01107af:	74 17                	je     f01107c8 <test_free_block_FF+0x7cd>
	{
		is_correct = 0;
f01107b1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #8.3: WRONG FREE! make sure to set block header and footer with the same values.\n");
f01107b8:	83 ec 0c             	sub    $0xc,%esp
f01107bb:	68 dc 85 12 f0       	push   $0xf01285dc
f01107c0:	e8 a7 07 ff ff       	call   f0100f6c <cprintf>
f01107c5:	83 c4 10             	add    $0x10,%esp
	}

	//====================================================================//
	/*free_block Scenario 3: Merge with previous ONLY (between 2 blocks)*/
	cprintf("		4.2: between 2 blocks\n\n") ;
f01107c8:	83 ec 0c             	sub    $0xc,%esp
f01107cb:	68 3e 86 12 f0       	push   $0xf012863e
f01107d0:	e8 97 07 ff ff       	call   f0100f6c <cprintf>
f01107d5:	83 c4 10             	add    $0x10,%esp
	blockIndex = 2*allocCntPerSize+1 ;
f01107d8:	c7 45 a8 91 01 00 00 	movl   $0x191,-0x58(%ebp)
	free_block(startVAs[blockIndex]);
f01107df:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01107e2:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f01107e9:	83 ec 0c             	sub    $0xc,%esp
f01107ec:	50                   	push   %eax
f01107ed:	e8 42 0a 01 00       	call   f0121234 <free_block>
f01107f2:	83 c4 10             	add    $0x10,%esp
	block_size = get_block_size(startVAs[blockIndex-1]) ;
f01107f5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01107f8:	48                   	dec    %eax
f01107f9:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110800:	83 ec 0c             	sub    $0xc,%esp
f0110803:	50                   	push   %eax
f0110804:	e8 b3 07 01 00       	call   f0120fbc <get_block_size>
f0110809:	83 c4 10             	add    $0x10,%esp
f011080c:	89 45 b0             	mov    %eax,-0x50(%ebp)
	expected_size = allocSizes[2]+allocSizes[2];
f011080f:	8b 15 80 9d 17 f0    	mov    0xf0179d80,%edx
f0110815:	a1 80 9d 17 f0       	mov    0xf0179d80,%eax
f011081a:	01 d0                	add    %edx,%eax
f011081c:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	if (block_size != expected_size)
f011081f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0110822:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0110825:	74 28                	je     f011084f <test_free_block_FF+0x854>
	{
		is_correct = 0;
f0110827:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf	("test_free_block #9.1: WRONG FREE! block size after free is not correct. Expected %d, Actual %d\n",allocSizes[2] + allocSizes[2],block_size);
f011082e:	8b 15 80 9d 17 f0    	mov    0xf0179d80,%edx
f0110834:	a1 80 9d 17 f0       	mov    0xf0179d80,%eax
f0110839:	01 d0                	add    %edx,%eax
f011083b:	83 ec 04             	sub    $0x4,%esp
f011083e:	ff 75 b0             	pushl  -0x50(%ebp)
f0110841:	50                   	push   %eax
f0110842:	68 58 86 12 f0       	push   $0xf0128658
f0110847:	e8 20 07 ff ff       	call   f0100f6c <cprintf>
f011084c:	83 c4 10             	add    $0x10,%esp
	}
	block_status = is_free_block(startVAs[blockIndex-1]) ;
f011084f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110852:	48                   	dec    %eax
f0110853:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f011085a:	83 ec 0c             	sub    $0xc,%esp
f011085d:	50                   	push   %eax
f011085e:	e8 72 07 01 00       	call   f0120fd5 <is_free_block>
f0110863:	83 c4 10             	add    $0x10,%esp
f0110866:	88 45 af             	mov    %al,-0x51(%ebp)
	if (block_status != 1)
f0110869:	80 7d af 01          	cmpb   $0x1,-0x51(%ebp)
f011086d:	74 17                	je     f0110886 <test_free_block_FF+0x88b>
	{
		is_correct = 0;
f011086f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #9.2: WRONG FREE! block status (is_free) not equal 1 after freeing.\n");
f0110876:	83 ec 0c             	sub    $0xc,%esp
f0110879:	68 b8 86 12 f0       	push   $0xf01286b8
f011087e:	e8 e9 06 ff ff       	call   f0100f6c <cprintf>
f0110883:	83 c4 10             	add    $0x10,%esp
	}

	blk_header = (uint32*)((uint32)startVAs[blockIndex-1] - sizeof(int));
f0110886:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110889:	48                   	dec    %eax
f011088a:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110891:	83 e8 04             	sub    $0x4,%eax
f0110894:	89 45 a0             	mov    %eax,-0x60(%ebp)
	blk_footer = (uint32*)((uint32)startVAs[blockIndex-1]+expected_size-2*sizeof(int));
f0110897:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011089a:	48                   	dec    %eax
f011089b:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f01108a2:	89 c2                	mov    %eax,%edx
f01108a4:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01108a7:	01 d0                	add    %edx,%eax
f01108a9:	83 e8 08             	sub    $0x8,%eax
f01108ac:	89 45 9c             	mov    %eax,-0x64(%ebp)
	if (*(blk_header) != *(blk_footer))
f01108af:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01108b2:	8b 10                	mov    (%eax),%edx
f01108b4:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01108b7:	8b 00                	mov    (%eax),%eax
f01108b9:	39 c2                	cmp    %eax,%edx
f01108bb:	74 17                	je     f01108d4 <test_free_block_FF+0x8d9>
	{
		is_correct = 0;
f01108bd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #9.3: WRONG FREE! make sure to set block header and footer with the same values.\n");
f01108c4:	83 ec 0c             	sub    $0xc,%esp
f01108c7:	68 10 87 12 f0       	push   $0xf0128710
f01108cc:	e8 9b 06 ff ff       	call   f0100f6c <cprintf>
f01108d1:	83 c4 10             	add    $0x10,%esp
	}
	is_correct = 1;
f01108d4:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	if (LIST_SIZE(&freeBlocksList) != expectedNumOfFreeBlks)
f01108db:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f01108e0:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f01108e3:	74 17                	je     f01108fc <test_free_block_FF+0x901>
	{
		is_correct = 0;
f01108e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #9.4: WRONG number of freed blocks in the freeBlockList.\n");
f01108ec:	83 ec 0c             	sub    $0xc,%esp
f01108ef:	68 74 87 12 f0       	push   $0xf0128774
f01108f4:	e8 73 06 ff ff       	call   f0100f6c <cprintf>
f01108f9:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f01108fc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110900:	74 04                	je     f0110906 <test_free_block_FF+0x90b>
	{
		eval += 15;
f0110902:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)
	}

	//====================================================================//
	/*free_block Scenario 4: Merge with next ONLY (AT the head)*/
	cprintf("	5: Free some allocated blocks [Merge with next ONLY]\n\n") ;
f0110906:	83 ec 0c             	sub    $0xc,%esp
f0110909:	68 c0 87 12 f0       	push   $0xf01287c0
f011090e:	e8 59 06 ff ff       	call   f0100f6c <cprintf>
f0110913:	83 c4 10             	add    $0x10,%esp
	cprintf("		5.1: at the head\n\n") ;
f0110916:	83 ec 0c             	sub    $0xc,%esp
f0110919:	68 f8 87 12 f0       	push   $0xf01287f8
f011091e:	e8 49 06 ff ff       	call   f0100f6c <cprintf>
f0110923:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110926:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	blockIndex = 0 ;
f011092d:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
	free_block(startVAs[blockIndex]);
f0110934:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110937:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f011093e:	83 ec 0c             	sub    $0xc,%esp
f0110941:	50                   	push   %eax
f0110942:	e8 ed 08 01 00       	call   f0121234 <free_block>
f0110947:	83 c4 10             	add    $0x10,%esp
	block_size = get_block_size(startVAs[blockIndex]) ;
f011094a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011094d:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110954:	83 ec 0c             	sub    $0xc,%esp
f0110957:	50                   	push   %eax
f0110958:	e8 5f 06 01 00       	call   f0120fbc <get_block_size>
f011095d:	83 c4 10             	add    $0x10,%esp
f0110960:	89 45 b0             	mov    %eax,-0x50(%ebp)
	expected_size = allocSizes[0]+allocSizes[0];
f0110963:	8b 15 78 9d 17 f0    	mov    0xf0179d78,%edx
f0110969:	a1 78 9d 17 f0       	mov    0xf0179d78,%eax
f011096e:	01 d0                	add    %edx,%eax
f0110970:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	if (block_size != expected_size)
f0110973:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0110976:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0110979:	74 28                	je     f01109a3 <test_free_block_FF+0x9a8>
	{
		is_correct = 0;
f011097b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #10.1: WRONG FREE! block size after free is not correct. Expected %d, Actual %d\n",allocSizes[0] + allocSizes[0],block_size);
f0110982:	8b 15 78 9d 17 f0    	mov    0xf0179d78,%edx
f0110988:	a1 78 9d 17 f0       	mov    0xf0179d78,%eax
f011098d:	01 d0                	add    %edx,%eax
f011098f:	83 ec 04             	sub    $0x4,%esp
f0110992:	ff 75 b0             	pushl  -0x50(%ebp)
f0110995:	50                   	push   %eax
f0110996:	68 10 88 12 f0       	push   $0xf0128810
f011099b:	e8 cc 05 ff ff       	call   f0100f6c <cprintf>
f01109a0:	83 c4 10             	add    $0x10,%esp
	}
	block_status = is_free_block(startVAs[blockIndex]) ;
f01109a3:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01109a6:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f01109ad:	83 ec 0c             	sub    $0xc,%esp
f01109b0:	50                   	push   %eax
f01109b1:	e8 1f 06 01 00       	call   f0120fd5 <is_free_block>
f01109b6:	83 c4 10             	add    $0x10,%esp
f01109b9:	88 45 af             	mov    %al,-0x51(%ebp)
	if (block_status != 1)
f01109bc:	80 7d af 01          	cmpb   $0x1,-0x51(%ebp)
f01109c0:	74 17                	je     f01109d9 <test_free_block_FF+0x9de>
	{
		is_correct = 0;
f01109c2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #10.2: WRONG FREE! block status (is_free) not equal 1 after freeing.\n");
f01109c9:	83 ec 0c             	sub    $0xc,%esp
f01109cc:	68 74 88 12 f0       	push   $0xf0128874
f01109d1:	e8 96 05 ff ff       	call   f0100f6c <cprintf>
f01109d6:	83 c4 10             	add    $0x10,%esp
	}
	blk_header = (uint32*)((uint32)startVAs[blockIndex] - sizeof(int));
f01109d9:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01109dc:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f01109e3:	83 e8 04             	sub    $0x4,%eax
f01109e6:	89 45 a0             	mov    %eax,-0x60(%ebp)
	blk_footer = (uint32*)((uint32)startVAs[blockIndex]+expected_size-2*sizeof(int));
f01109e9:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01109ec:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f01109f3:	89 c2                	mov    %eax,%edx
f01109f5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01109f8:	01 d0                	add    %edx,%eax
f01109fa:	83 e8 08             	sub    $0x8,%eax
f01109fd:	89 45 9c             	mov    %eax,-0x64(%ebp)
	if (*(blk_header) != *(blk_footer))
f0110a00:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0110a03:	8b 10                	mov    (%eax),%edx
f0110a05:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0110a08:	8b 00                	mov    (%eax),%eax
f0110a0a:	39 c2                	cmp    %eax,%edx
f0110a0c:	74 17                	je     f0110a25 <test_free_block_FF+0xa2a>
	{
		is_correct = 0;
f0110a0e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #10.3: WRONG FREE! make sure to set block header and footer with the same values.\n");
f0110a15:	83 ec 0c             	sub    $0xc,%esp
f0110a18:	68 cc 88 12 f0       	push   $0xf01288cc
f0110a1d:	e8 4a 05 ff ff       	call   f0100f6c <cprintf>
f0110a22:	83 c4 10             	add    $0x10,%esp
	}


	//====================================================================//
	/*free_block Scenario 5: Merge with next ONLY (between 2 blocks)*/
	cprintf("		5.2: between 2 blocks\n\n") ;
f0110a25:	83 ec 0c             	sub    $0xc,%esp
f0110a28:	68 2f 89 12 f0       	push   $0xf012892f
f0110a2d:	e8 3a 05 ff ff       	call   f0100f6c <cprintf>
f0110a32:	83 c4 10             	add    $0x10,%esp
	blockIndex = 1*allocCntPerSize - 1 ;
f0110a35:	c7 45 a8 c7 00 00 00 	movl   $0xc7,-0x58(%ebp)
	free_block(startVAs[blockIndex]);
f0110a3c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110a3f:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110a46:	83 ec 0c             	sub    $0xc,%esp
f0110a49:	50                   	push   %eax
f0110a4a:	e8 e5 07 01 00       	call   f0121234 <free_block>
f0110a4f:	83 c4 10             	add    $0x10,%esp
	block_size = get_block_size(startVAs[blockIndex]) ;
f0110a52:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110a55:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110a5c:	83 ec 0c             	sub    $0xc,%esp
f0110a5f:	50                   	push   %eax
f0110a60:	e8 57 05 01 00       	call   f0120fbc <get_block_size>
f0110a65:	83 c4 10             	add    $0x10,%esp
f0110a68:	89 45 b0             	mov    %eax,-0x50(%ebp)
	expected_size = allocSizes[0]+allocSizes[1];
f0110a6b:	8b 15 78 9d 17 f0    	mov    0xf0179d78,%edx
f0110a71:	a1 7c 9d 17 f0       	mov    0xf0179d7c,%eax
f0110a76:	01 d0                	add    %edx,%eax
f0110a78:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	if (block_size != expected_size)
f0110a7b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0110a7e:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0110a81:	74 28                	je     f0110aab <test_free_block_FF+0xab0>
	{
		is_correct = 0;
f0110a83:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #11.1: WRONG FREE! block size after free is not correct. Expected %d, Actual %d\n",allocSizes[0] + allocSizes[1],block_size);
f0110a8a:	8b 15 78 9d 17 f0    	mov    0xf0179d78,%edx
f0110a90:	a1 7c 9d 17 f0       	mov    0xf0179d7c,%eax
f0110a95:	01 d0                	add    %edx,%eax
f0110a97:	83 ec 04             	sub    $0x4,%esp
f0110a9a:	ff 75 b0             	pushl  -0x50(%ebp)
f0110a9d:	50                   	push   %eax
f0110a9e:	68 4c 89 12 f0       	push   $0xf012894c
f0110aa3:	e8 c4 04 ff ff       	call   f0100f6c <cprintf>
f0110aa8:	83 c4 10             	add    $0x10,%esp
	}
	block_status = is_free_block(startVAs[blockIndex]) ;
f0110aab:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110aae:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110ab5:	83 ec 0c             	sub    $0xc,%esp
f0110ab8:	50                   	push   %eax
f0110ab9:	e8 17 05 01 00       	call   f0120fd5 <is_free_block>
f0110abe:	83 c4 10             	add    $0x10,%esp
f0110ac1:	88 45 af             	mov    %al,-0x51(%ebp)
	if (block_status != 1)
f0110ac4:	80 7d af 01          	cmpb   $0x1,-0x51(%ebp)
f0110ac8:	74 17                	je     f0110ae1 <test_free_block_FF+0xae6>
	{
		is_correct = 0;
f0110aca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #11.2: WRONG FREE! block status (is_free) not equal 1 after freeing.\n");
f0110ad1:	83 ec 0c             	sub    $0xc,%esp
f0110ad4:	68 b0 89 12 f0       	push   $0xf01289b0
f0110ad9:	e8 8e 04 ff ff       	call   f0100f6c <cprintf>
f0110ade:	83 c4 10             	add    $0x10,%esp
	}
	blk_header = (uint32*)((uint32)startVAs[blockIndex] - sizeof(int));
f0110ae1:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110ae4:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110aeb:	83 e8 04             	sub    $0x4,%eax
f0110aee:	89 45 a0             	mov    %eax,-0x60(%ebp)
	blk_footer = (uint32*)((uint32)startVAs[blockIndex]+expected_size-2*sizeof(int));
f0110af1:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110af4:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110afb:	89 c2                	mov    %eax,%edx
f0110afd:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0110b00:	01 d0                	add    %edx,%eax
f0110b02:	83 e8 08             	sub    $0x8,%eax
f0110b05:	89 45 9c             	mov    %eax,-0x64(%ebp)
	if (*(blk_header) != *(blk_footer))
f0110b08:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0110b0b:	8b 10                	mov    (%eax),%edx
f0110b0d:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0110b10:	8b 00                	mov    (%eax),%eax
f0110b12:	39 c2                	cmp    %eax,%edx
f0110b14:	74 17                	je     f0110b2d <test_free_block_FF+0xb32>
	{
		is_correct = 0;
f0110b16:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #11.3: WRONG FREE! make sure to set block header and footer with the same values.\n");
f0110b1d:	83 ec 0c             	sub    $0xc,%esp
f0110b20:	68 08 8a 12 f0       	push   $0xf0128a08
f0110b25:	e8 42 04 ff ff       	call   f0100f6c <cprintf>
f0110b2a:	83 c4 10             	add    $0x10,%esp
	}

	is_correct = 1;
f0110b2d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	if (LIST_SIZE(&freeBlocksList) != expectedNumOfFreeBlks)
f0110b34:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f0110b39:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0110b3c:	74 17                	je     f0110b55 <test_free_block_FF+0xb5a>
	{
		is_correct = 0;
f0110b3e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #11.4: WRONG number of freed blocks in the freeBlockList.\n");
f0110b45:	83 ec 0c             	sub    $0xc,%esp
f0110b48:	68 6c 8a 12 f0       	push   $0xf0128a6c
f0110b4d:	e8 1a 04 ff ff       	call   f0100f6c <cprintf>
f0110b52:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f0110b55:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110b59:	74 04                	je     f0110b5f <test_free_block_FF+0xb64>
	{
		eval += 15;
f0110b5b:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)
	}

	//====================================================================//
	/*free_block Scenario 6: Merge with prev & next */
	cprintf("	6: Free some allocated blocks [Merge with previous & next]\n\n") ;
f0110b5f:	83 ec 0c             	sub    $0xc,%esp
f0110b62:	68 b8 8a 12 f0       	push   $0xf0128ab8
f0110b67:	e8 00 04 ff ff       	call   f0100f6c <cprintf>
f0110b6c:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110b6f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	blockIndex = 4*allocCntPerSize - 2 ;
f0110b76:	c7 45 a8 1e 03 00 00 	movl   $0x31e,-0x58(%ebp)
	free_block(startVAs[blockIndex]);	//no merge
f0110b7d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110b80:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110b87:	83 ec 0c             	sub    $0xc,%esp
f0110b8a:	50                   	push   %eax
f0110b8b:	e8 a4 06 01 00       	call   f0121234 <free_block>
f0110b90:	83 c4 10             	add    $0x10,%esp
	expectedNumOfFreeBlks++;
f0110b93:	ff 45 b4             	incl   -0x4c(%ebp)

	blockIndex = 4*allocCntPerSize - 1 ;
f0110b96:	c7 45 a8 1f 03 00 00 	movl   $0x31f,-0x58(%ebp)
	free_block(startVAs[blockIndex]);	//merge with prev & next
f0110b9d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110ba0:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110ba7:	83 ec 0c             	sub    $0xc,%esp
f0110baa:	50                   	push   %eax
f0110bab:	e8 84 06 01 00       	call   f0121234 <free_block>
f0110bb0:	83 c4 10             	add    $0x10,%esp
	expectedNumOfFreeBlks--;
f0110bb3:	ff 4d b4             	decl   -0x4c(%ebp)

	block_size = get_block_size(startVAs[blockIndex-1]) ;
f0110bb6:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110bb9:	48                   	dec    %eax
f0110bba:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110bc1:	83 ec 0c             	sub    $0xc,%esp
f0110bc4:	50                   	push   %eax
f0110bc5:	e8 f2 03 01 00       	call   f0120fbc <get_block_size>
f0110bca:	83 c4 10             	add    $0x10,%esp
f0110bcd:	89 45 b0             	mov    %eax,-0x50(%ebp)
	expected_size = allocSizes[3]+allocSizes[3]+allocSizes[4];
f0110bd0:	8b 15 84 9d 17 f0    	mov    0xf0179d84,%edx
f0110bd6:	a1 84 9d 17 f0       	mov    0xf0179d84,%eax
f0110bdb:	01 c2                	add    %eax,%edx
f0110bdd:	a1 88 9d 17 f0       	mov    0xf0179d88,%eax
f0110be2:	01 d0                	add    %edx,%eax
f0110be4:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	if (block_size != expected_size)
f0110be7:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0110bea:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0110bed:	74 2f                	je     f0110c1e <test_free_block_FF+0xc23>
	{
		is_correct = 0;
f0110bef:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #12.1: WRONG FREE! block size after free is not correct. Expected %d, Actual %d\n",allocSizes[3]+allocSizes[3]+allocSizes[4],block_size);
f0110bf6:	8b 15 84 9d 17 f0    	mov    0xf0179d84,%edx
f0110bfc:	a1 84 9d 17 f0       	mov    0xf0179d84,%eax
f0110c01:	01 c2                	add    %eax,%edx
f0110c03:	a1 88 9d 17 f0       	mov    0xf0179d88,%eax
f0110c08:	01 d0                	add    %edx,%eax
f0110c0a:	83 ec 04             	sub    $0x4,%esp
f0110c0d:	ff 75 b0             	pushl  -0x50(%ebp)
f0110c10:	50                   	push   %eax
f0110c11:	68 f8 8a 12 f0       	push   $0xf0128af8
f0110c16:	e8 51 03 ff ff       	call   f0100f6c <cprintf>
f0110c1b:	83 c4 10             	add    $0x10,%esp
	}
	block_status = is_free_block(startVAs[blockIndex-1]) ;
f0110c1e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110c21:	48                   	dec    %eax
f0110c22:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110c29:	83 ec 0c             	sub    $0xc,%esp
f0110c2c:	50                   	push   %eax
f0110c2d:	e8 a3 03 01 00       	call   f0120fd5 <is_free_block>
f0110c32:	83 c4 10             	add    $0x10,%esp
f0110c35:	88 45 af             	mov    %al,-0x51(%ebp)
	if (block_status != 1)
f0110c38:	80 7d af 01          	cmpb   $0x1,-0x51(%ebp)
f0110c3c:	74 17                	je     f0110c55 <test_free_block_FF+0xc5a>
	{
		is_correct = 0;
f0110c3e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #12.2: WRONG FREE! block status (is_free) not equal 1 after freeing.\n");
f0110c45:	83 ec 0c             	sub    $0xc,%esp
f0110c48:	68 5c 8b 12 f0       	push   $0xf0128b5c
f0110c4d:	e8 1a 03 ff ff       	call   f0100f6c <cprintf>
f0110c52:	83 c4 10             	add    $0x10,%esp
	}
	blk_header = (uint32*)((uint32)startVAs[blockIndex-1] - sizeof(int));
f0110c55:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110c58:	48                   	dec    %eax
f0110c59:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110c60:	83 e8 04             	sub    $0x4,%eax
f0110c63:	89 45 a0             	mov    %eax,-0x60(%ebp)
	blk_footer = (uint32*)((uint32)startVAs[blockIndex-1]+expected_size-2*sizeof(int));
f0110c66:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110c69:	48                   	dec    %eax
f0110c6a:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110c71:	89 c2                	mov    %eax,%edx
f0110c73:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0110c76:	01 d0                	add    %edx,%eax
f0110c78:	83 e8 08             	sub    $0x8,%eax
f0110c7b:	89 45 9c             	mov    %eax,-0x64(%ebp)
	if (*(blk_header) != *(blk_footer))
f0110c7e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0110c81:	8b 10                	mov    (%eax),%edx
f0110c83:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0110c86:	8b 00                	mov    (%eax),%eax
f0110c88:	39 c2                	cmp    %eax,%edx
f0110c8a:	74 17                	je     f0110ca3 <test_free_block_FF+0xca8>
	{
		is_correct = 0;
f0110c8c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #12.3: WRONG FREE! make sure to set block header and footer with the same values.\n");
f0110c93:	83 ec 0c             	sub    $0xc,%esp
f0110c96:	68 b4 8b 12 f0       	push   $0xf0128bb4
f0110c9b:	e8 cc 02 ff ff       	call   f0100f6c <cprintf>
f0110ca0:	83 c4 10             	add    $0x10,%esp
	}

	is_correct = 1;
f0110ca3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	if (LIST_SIZE(&freeBlocksList) != expectedNumOfFreeBlks)
f0110caa:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f0110caf:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0110cb2:	74 20                	je     f0110cd4 <test_free_block_FF+0xcd9>
	{
		is_correct = 0;
f0110cb4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #12.4: WRONG number of freed blocks in the freeBlockList. expected = %d, actual = %d\n", expectedNumOfFreeBlks, LIST_SIZE(&freeBlocksList));
f0110cbb:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f0110cc0:	83 ec 04             	sub    $0x4,%esp
f0110cc3:	50                   	push   %eax
f0110cc4:	ff 75 b4             	pushl  -0x4c(%ebp)
f0110cc7:	68 18 8c 12 f0       	push   $0xf0128c18
f0110ccc:	e8 9b 02 ff ff       	call   f0100f6c <cprintf>
f0110cd1:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f0110cd4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110cd8:	74 04                	je     f0110cde <test_free_block_FF+0xce3>
	{
		eval += 20;
f0110cda:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)
	}

	//====================================================================//
	/*Allocate After Free Scenarios */
	cprintf("	7: Allocate After Free [should be placed in coalesced blocks]\n\n") ;
f0110cde:	83 ec 0c             	sub    $0xc,%esp
f0110ce1:	68 80 8c 12 f0       	push   $0xf0128c80
f0110ce6:	e8 81 02 ff ff       	call   f0100f6c <cprintf>
f0110ceb:	83 c4 10             	add    $0x10,%esp

	cprintf("		7.1: in block coalesces with NEXT\n\n") ;
f0110cee:	83 ec 0c             	sub    $0xc,%esp
f0110cf1:	68 c4 8c 12 f0       	push   $0xf0128cc4
f0110cf6:	e8 71 02 ff ff       	call   f0100f6c <cprintf>
f0110cfb:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110cfe:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	actualSize = 5*kilo - sizeOfMetaData;
f0110d05:	c7 45 c4 f8 13 00 00 	movl   $0x13f8,-0x3c(%ebp)
	va = alloc_block(actualSize, DA_FF);
f0110d0c:	83 ec 08             	sub    $0x8,%esp
f0110d0f:	6a 01                	push   $0x1
f0110d11:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110d14:	e8 da 02 01 00       	call   f0120ff3 <alloc_block>
f0110d19:	83 c4 10             	add    $0x10,%esp
f0110d1c:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	void* expected = (void*)(KERNEL_HEAP_START + sizeof(int) + sizeOfMetaData/2);
f0110d1f:	c7 45 98 08 00 00 f6 	movl   $0xf6000008,-0x68(%ebp)
	if(va == NULL || (va != expected))
f0110d26:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f0110d2a:	74 08                	je     f0110d34 <test_free_block_FF+0xd39>
f0110d2c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110d2f:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0110d32:	74 1d                	je     f0110d51 <test_free_block_FF+0xd56>
	{
		is_correct = 0;
f0110d34:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #13.1: WRONG ALLOC - alloc_block_FF return wrong address. Expected %x, Actual %x\n", expected, va);
f0110d3b:	83 ec 04             	sub    $0x4,%esp
f0110d3e:	ff 75 c0             	pushl  -0x40(%ebp)
f0110d41:	ff 75 98             	pushl  -0x68(%ebp)
f0110d44:	68 ec 8c 12 f0       	push   $0xf0128cec
f0110d49:	e8 1e 02 ff ff       	call   f0100f6c <cprintf>
f0110d4e:	83 c4 10             	add    $0x10,%esp
	}
	actualSize = 3*kilo - sizeOfMetaData;
f0110d51:	c7 45 c4 f8 0b 00 00 	movl   $0xbf8,-0x3c(%ebp)
	va = alloc_block(actualSize, DA_FF);
f0110d58:	83 ec 08             	sub    $0x8,%esp
f0110d5b:	6a 01                	push   $0x1
f0110d5d:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110d60:	e8 8e 02 01 00       	call   f0120ff3 <alloc_block>
f0110d65:	83 c4 10             	add    $0x10,%esp
f0110d68:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected = (void*)(KERNEL_HEAP_START + sizeof(int) + 5*kilo + sizeOfMetaData/2);
f0110d6b:	c7 45 98 08 14 00 f6 	movl   $0xf6001408,-0x68(%ebp)
	if(va == NULL || (va != expected))
f0110d72:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f0110d76:	74 08                	je     f0110d80 <test_free_block_FF+0xd85>
f0110d78:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110d7b:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0110d7e:	74 1d                	je     f0110d9d <test_free_block_FF+0xda2>
	{
		is_correct = 0;
f0110d80:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #13.2: WRONG ALLOC - alloc_block_FF return wrong address. Expected %x, Actual %x\n", expected, va);
f0110d87:	83 ec 04             	sub    $0x4,%esp
f0110d8a:	ff 75 c0             	pushl  -0x40(%ebp)
f0110d8d:	ff 75 98             	pushl  -0x68(%ebp)
f0110d90:	68 50 8d 12 f0       	push   $0xf0128d50
f0110d95:	e8 d2 01 ff ff       	call   f0100f6c <cprintf>
f0110d9a:	83 c4 10             	add    $0x10,%esp
	}
	actualSize = 4*kilo + 10;
f0110d9d:	c7 45 c4 0a 10 00 00 	movl   $0x100a,-0x3c(%ebp)
	va = alloc_block(actualSize, DA_FF);
f0110da4:	83 ec 08             	sub    $0x8,%esp
f0110da7:	6a 01                	push   $0x1
f0110da9:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110dac:	e8 42 02 01 00       	call   f0120ff3 <alloc_block>
f0110db1:	83 c4 10             	add    $0x10,%esp
f0110db4:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected = startVAs[1*allocCntPerSize - 1];
f0110db7:	a1 fc 39 57 f0       	mov    0xf05739fc,%eax
f0110dbc:	89 45 98             	mov    %eax,-0x68(%ebp)
	if(va == NULL || (va != expected))
f0110dbf:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f0110dc3:	74 08                	je     f0110dcd <test_free_block_FF+0xdd2>
f0110dc5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110dc8:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0110dcb:	74 1d                	je     f0110dea <test_free_block_FF+0xdef>
	{
		is_correct = 0;
f0110dcd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #13.3: WRONG ALLOC - alloc_block_FF return wrong address. Expected %x, Actual %x\n", expected, va);
f0110dd4:	83 ec 04             	sub    $0x4,%esp
f0110dd7:	ff 75 c0             	pushl  -0x40(%ebp)
f0110dda:	ff 75 98             	pushl  -0x68(%ebp)
f0110ddd:	68 b4 8d 12 f0       	push   $0xf0128db4
f0110de2:	e8 85 01 ff ff       	call   f0100f6c <cprintf>
f0110de7:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f0110dea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110dee:	74 04                	je     f0110df4 <test_free_block_FF+0xdf9>
	{
		eval += 10;
f0110df0:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	cprintf("		7.2: in block coalesces with PREV & NEXT\n\n") ;
f0110df4:	83 ec 0c             	sub    $0xc,%esp
f0110df7:	68 18 8e 12 f0       	push   $0xf0128e18
f0110dfc:	e8 6b 01 ff ff       	call   f0100f6c <cprintf>
f0110e01:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110e04:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	actualSize = 2*kilo + 1;
f0110e0b:	c7 45 c4 01 08 00 00 	movl   $0x801,-0x3c(%ebp)
	va = alloc_block(actualSize, DA_FF);
f0110e12:	83 ec 08             	sub    $0x8,%esp
f0110e15:	6a 01                	push   $0x1
f0110e17:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110e1a:	e8 d4 01 01 00       	call   f0120ff3 <alloc_block>
f0110e1f:	83 c4 10             	add    $0x10,%esp
f0110e22:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected = startVAs[4*allocCntPerSize - 2];
f0110e25:	a1 58 43 57 f0       	mov    0xf0574358,%eax
f0110e2a:	89 45 98             	mov    %eax,-0x68(%ebp)
	if(va == NULL || (va != expected))
f0110e2d:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f0110e31:	74 08                	je     f0110e3b <test_free_block_FF+0xe40>
f0110e33:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110e36:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0110e39:	74 1d                	je     f0110e58 <test_free_block_FF+0xe5d>
	{
		is_correct = 0;
f0110e3b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #13.4: WRONG ALLOC - alloc_block_FF return wrong address. Expected %x, Actual %x\n", expected, va);
f0110e42:	83 ec 04             	sub    $0x4,%esp
f0110e45:	ff 75 c0             	pushl  -0x40(%ebp)
f0110e48:	ff 75 98             	pushl  -0x68(%ebp)
f0110e4b:	68 48 8e 12 f0       	push   $0xf0128e48
f0110e50:	e8 17 01 ff ff       	call   f0100f6c <cprintf>
f0110e55:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f0110e58:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110e5c:	74 04                	je     f0110e62 <test_free_block_FF+0xe67>
	{
		eval += 10;
f0110e5e:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	cprintf("		7.3: in block coalesces with PREV\n\n") ;
f0110e62:	83 ec 0c             	sub    $0xc,%esp
f0110e65:	68 ac 8e 12 f0       	push   $0xf0128eac
f0110e6a:	e8 fd 00 ff ff       	call   f0100f6c <cprintf>
f0110e6f:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110e72:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	actualSize = 2*kilo - sizeOfMetaData;
f0110e79:	c7 45 c4 f8 07 00 00 	movl   $0x7f8,-0x3c(%ebp)
	va = alloc_block(actualSize, DA_FF);
f0110e80:	83 ec 08             	sub    $0x8,%esp
f0110e83:	6a 01                	push   $0x1
f0110e85:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110e88:	e8 66 01 01 00       	call   f0120ff3 <alloc_block>
f0110e8d:	83 c4 10             	add    $0x10,%esp
f0110e90:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected = startVAs[2*allocCntPerSize];
f0110e93:	a1 20 3d 57 f0       	mov    0xf0573d20,%eax
f0110e98:	89 45 98             	mov    %eax,-0x68(%ebp)
	if(va == NULL || (va != expected))
f0110e9b:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f0110e9f:	74 08                	je     f0110ea9 <test_free_block_FF+0xeae>
f0110ea1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110ea4:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0110ea7:	74 1d                	je     f0110ec6 <test_free_block_FF+0xecb>
	{
		is_correct = 0;
f0110ea9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #13.5: WRONG ALLOC - alloc_block_FF return wrong address. Expected %x, Actual %x\n", expected, va);
f0110eb0:	83 ec 04             	sub    $0x4,%esp
f0110eb3:	ff 75 c0             	pushl  -0x40(%ebp)
f0110eb6:	ff 75 98             	pushl  -0x68(%ebp)
f0110eb9:	68 d4 8e 12 f0       	push   $0xf0128ed4
f0110ebe:	e8 a9 00 ff ff       	call   f0100f6c <cprintf>
f0110ec3:	83 c4 10             	add    $0x10,%esp
	}
	actualSize = 8*kilo - sizeOfMetaData;
f0110ec6:	c7 45 c4 f8 1f 00 00 	movl   $0x1ff8,-0x3c(%ebp)
	va = alloc_block(actualSize, DA_FF);
f0110ecd:	83 ec 08             	sub    $0x8,%esp
f0110ed0:	6a 01                	push   $0x1
f0110ed2:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110ed5:	e8 19 01 01 00       	call   f0120ff3 <alloc_block>
f0110eda:	83 c4 10             	add    $0x10,%esp
f0110edd:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected = startVAs[numOfAllocs*allocCntPerSize-1];
f0110ee0:	a1 bc 4c 57 f0       	mov    0xf0574cbc,%eax
f0110ee5:	89 45 98             	mov    %eax,-0x68(%ebp)
	if(va == NULL || (va != expected))
f0110ee8:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f0110eec:	74 08                	je     f0110ef6 <test_free_block_FF+0xefb>
f0110eee:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110ef1:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0110ef4:	74 1d                	je     f0110f13 <test_free_block_FF+0xf18>
	{
		is_correct = 0;
f0110ef6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #13.6: WRONG ALLOC - alloc_block_FF return wrong address. Expected %x, Actual %x\n", expected, va);
f0110efd:	83 ec 04             	sub    $0x4,%esp
f0110f00:	ff 75 c0             	pushl  -0x40(%ebp)
f0110f03:	ff 75 98             	pushl  -0x68(%ebp)
f0110f06:	68 38 8f 12 f0       	push   $0xf0128f38
f0110f0b:	e8 5c 00 ff ff       	call   f0100f6c <cprintf>
f0110f10:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f0110f13:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110f17:	74 04                	je     f0110f1d <test_free_block_FF+0xf22>
	{
		eval += 10;
f0110f19:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	cprintf("test free_block with FIRST FIT completed. Evaluation = %d%\n", eval);
f0110f1d:	83 ec 08             	sub    $0x8,%esp
f0110f20:	ff 75 f4             	pushl  -0xc(%ebp)
f0110f23:	68 9c 8f 12 f0       	push   $0xf0128f9c
f0110f28:	e8 3f 00 ff ff       	call   f0100f6c <cprintf>
f0110f2d:	83 c4 10             	add    $0x10,%esp

}
f0110f30:	90                   	nop
f0110f31:	c9                   	leave  
f0110f32:	c3                   	ret    

f0110f33 <test_free_block_BF>:

void test_free_block_BF()
{
f0110f33:	55                   	push   %ebp
f0110f34:	89 e5                	mov    %esp,%ebp
f0110f36:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	cprintf("===========================================================\n") ;
f0110f39:	83 ec 0c             	sub    $0xc,%esp
f0110f3c:	68 24 7e 12 f0       	push   $0xf0127e24
f0110f41:	e8 26 00 ff ff       	call   f0100f6c <cprintf>
f0110f46:	83 c4 10             	add    $0x10,%esp
	cprintf("NOTE: THIS TEST IS DEPEND ON BOTH ALLOCATE & FREE FUNCTIONS\n") ;
f0110f49:	83 ec 0c             	sub    $0xc,%esp
f0110f4c:	68 64 7e 12 f0       	push   $0xf0127e64
f0110f51:	e8 16 00 ff ff       	call   f0100f6c <cprintf>
f0110f56:	83 c4 10             	add    $0x10,%esp
	cprintf("===========================================================\n") ;
f0110f59:	83 ec 0c             	sub    $0xc,%esp
f0110f5c:	68 24 7e 12 f0       	push   $0xf0127e24
f0110f61:	e8 06 00 ff ff       	call   f0100f6c <cprintf>
f0110f66:	83 c4 10             	add    $0x10,%esp

	panic("Test is under construction! will be announced later isA");
f0110f69:	83 ec 04             	sub    $0x4,%esp
f0110f6c:	68 ec 7d 12 f0       	push   $0xf0127dec
f0110f71:	68 53 03 00 00       	push   $0x353
f0110f76:	68 c8 76 12 f0       	push   $0xf01276c8
f0110f7b:	e8 9a f3 fe ff       	call   f010031a <_panic>

f0110f80 <test_free_block_NF>:

}

void test_free_block_NF()
{
f0110f80:	55                   	push   %ebp
f0110f81:	89 e5                	mov    %esp,%ebp
f0110f83:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f0110f86:	83 ec 04             	sub    $0x4,%esp
f0110f89:	68 d8 8f 12 f0       	push   $0xf0128fd8
f0110f8e:	68 59 03 00 00       	push   $0x359
f0110f93:	68 c8 76 12 f0       	push   $0xf01276c8
f0110f98:	e8 7d f3 fe ff       	call   f010031a <_panic>

f0110f9d <test_realloc_block_FF>:
}

void test_realloc_block_FF()
{
f0110f9d:	55                   	push   %ebp
f0110f9e:	89 e5                	mov    %esp,%ebp
f0110fa0:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	cprintf("===================================================\n");
f0110fa3:	83 ec 0c             	sub    $0xc,%esp
f0110fa6:	68 e8 8f 12 f0       	push   $0xf0128fe8
f0110fab:	e8 bc ff fe ff       	call   f0100f6c <cprintf>
f0110fb0:	83 c4 10             	add    $0x10,%esp
	cprintf("*****NOTE: THIS IS A PARTIAL TEST FOR REALLOC******\n") ;
f0110fb3:	83 ec 0c             	sub    $0xc,%esp
f0110fb6:	68 20 90 12 f0       	push   $0xf0129020
f0110fbb:	e8 ac ff fe ff       	call   f0100f6c <cprintf>
f0110fc0:	83 c4 10             	add    $0x10,%esp
	cprintf("You need to pick-up the missing tests and test them\n") ;
f0110fc3:	83 ec 0c             	sub    $0xc,%esp
f0110fc6:	68 58 90 12 f0       	push   $0xf0129058
f0110fcb:	e8 9c ff fe ff       	call   f0100f6c <cprintf>
f0110fd0:	83 c4 10             	add    $0x10,%esp
	cprintf("===================================================\n");
f0110fd3:	83 ec 0c             	sub    $0xc,%esp
f0110fd6:	68 e8 8f 12 f0       	push   $0xf0128fe8
f0110fdb:	e8 8c ff fe ff       	call   f0100f6c <cprintf>
f0110fe0:	83 c4 10             	add    $0x10,%esp

	//TODO: [PROJECT'24.MS1 - #09] [3] DYNAMIC ALLOCATOR - test_realloc_block_FF()
	//CHECK MISSING CASES AND TRY TO TEST THEM !

	panic("Test is under construction! will be announced later isA");
f0110fe3:	83 ec 04             	sub    $0x4,%esp
f0110fe6:	68 ec 7d 12 f0       	push   $0xf0127dec
f0110feb:	68 6b 03 00 00       	push   $0x36b
f0110ff0:	68 c8 76 12 f0       	push   $0xf01276c8
f0110ff5:	e8 20 f3 fe ff       	call   f010031a <_panic>

f0110ffa <test_realloc_block_FF_COMPLETE>:

}


void test_realloc_block_FF_COMPLETE()
{
f0110ffa:	55                   	push   %ebp
f0110ffb:	89 e5                	mov    %esp,%ebp
f0110ffd:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	panic("this is unseen test");
f0111000:	83 ec 04             	sub    $0x4,%esp
f0111003:	68 8d 90 12 f0       	push   $0xf012908d
f0111008:	68 77 03 00 00       	push   $0x377
f011100d:	68 c8 76 12 f0       	push   $0xf01276c8
f0111012:	e8 03 f3 fe ff       	call   f010031a <_panic>

f0111017 <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f0111017:	55                   	push   %ebp
f0111018:	89 e5                	mov    %esp,%ebp
f011101a:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f011101d:	e8 6c 94 ff ff       	call   f010a48e <get_cpu_proc>
f0111022:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f0111025:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111029:	75 16                	jne    f0111041 <sys_check_LRU_lists+0x2a>
f011102b:	68 a4 90 12 f0       	push   $0xf01290a4
f0111030:	68 b4 90 12 f0       	push   $0xf01290b4
f0111035:	6a 10                	push   $0x10
f0111037:	68 c9 90 12 f0       	push   $0xf01290c9
f011103c:	e8 d9 f2 fe ff       	call   f010031a <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f0111041:	83 ec 0c             	sub    $0xc,%esp
f0111044:	68 e8 90 12 f0       	push   $0xf01290e8
f0111049:	e8 1e ff fe ff       	call   f0100f6c <cprintf>
f011104e:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f0111051:	83 ec 0c             	sub    $0xc,%esp
f0111054:	ff 75 e0             	pushl  -0x20(%ebp)
f0111057:	e8 ca 7c ff ff       	call   f0108d26 <env_page_ws_print>
f011105c:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f011105f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111062:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f0111065:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f011106c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f0111073:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0111077:	0f 84 a5 00 00 00    	je     f0111122 <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f011107d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111084:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111087:	8b 80 10 da 01 00    	mov    0x1da10(%eax),%eax
f011108d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0111090:	eb 4a                	jmp    f01110dc <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f0111092:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111095:	8b 00                	mov    (%eax),%eax
f0111097:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011109a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011109d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01110a2:	89 c2                	mov    %eax,%edx
f01110a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01110a7:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01110ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01110b1:	01 c8                	add    %ecx,%eax
f01110b3:	8b 00                	mov    (%eax),%eax
f01110b5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01110b8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01110bb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01110c0:	39 c2                	cmp    %eax,%edx
f01110c2:	74 09                	je     f01110cd <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f01110c4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f01110cb:	eb 3e                	jmp    f011110b <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f01110cd:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01110d0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01110d3:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f01110d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01110dc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01110e0:	74 08                	je     f01110ea <sys_check_LRU_lists+0xd3>
f01110e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01110e5:	8b 40 10             	mov    0x10(%eax),%eax
f01110e8:	eb 05                	jmp    f01110ef <sys_check_LRU_lists+0xd8>
f01110ea:	b8 00 00 00 00       	mov    $0x0,%eax
f01110ef:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01110f2:	89 82 18 da 01 00    	mov    %eax,0x1da18(%edx)
f01110f8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01110fb:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f0111101:	85 c0                	test   %eax,%eax
f0111103:	75 8d                	jne    f0111092 <sys_check_LRU_lists+0x7b>
f0111105:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111109:	75 87                	jne    f0111092 <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f011110b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011110e:	8b 90 1c da 01 00    	mov    0x1da1c(%eax),%edx
f0111114:	8b 45 10             	mov    0x10(%ebp),%eax
f0111117:	39 c2                	cmp    %eax,%edx
f0111119:	74 07                	je     f0111122 <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f011111b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f0111122:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0111126:	0f 84 a5 00 00 00    	je     f01111d1 <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f011112c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111133:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111136:	8b 80 20 da 01 00    	mov    0x1da20(%eax),%eax
f011113c:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011113f:	eb 4a                	jmp    f011118b <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f0111141:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111144:	8b 00                	mov    (%eax),%eax
f0111146:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0111149:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011114c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111151:	89 c2                	mov    %eax,%edx
f0111153:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111156:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011115d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111160:	01 c8                	add    %ecx,%eax
f0111162:	8b 00                	mov    (%eax),%eax
f0111164:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0111167:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011116a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011116f:	39 c2                	cmp    %eax,%edx
f0111171:	74 09                	je     f011117c <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f0111173:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f011117a:	eb 3e                	jmp    f01111ba <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f011117c:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f011117f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111182:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f0111188:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011118b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011118f:	74 08                	je     f0111199 <sys_check_LRU_lists+0x182>
f0111191:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111194:	8b 40 10             	mov    0x10(%eax),%eax
f0111197:	eb 05                	jmp    f011119e <sys_check_LRU_lists+0x187>
f0111199:	b8 00 00 00 00       	mov    $0x0,%eax
f011119e:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01111a1:	89 82 28 da 01 00    	mov    %eax,0x1da28(%edx)
f01111a7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01111aa:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f01111b0:	85 c0                	test   %eax,%eax
f01111b2:	75 8d                	jne    f0111141 <sys_check_LRU_lists+0x12a>
f01111b4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01111b8:	75 87                	jne    f0111141 <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f01111ba:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01111bd:	8b 90 2c da 01 00    	mov    0x1da2c(%eax),%edx
f01111c3:	8b 45 14             	mov    0x14(%ebp),%eax
f01111c6:	39 c2                	cmp    %eax,%edx
f01111c8:	74 07                	je     f01111d1 <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f01111ca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f01111d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01111d4:	23 45 f0             	and    -0x10(%ebp),%eax
}
f01111d7:	c9                   	leave  
f01111d8:	c3                   	ret    

f01111d9 <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f01111d9:	55                   	push   %ebp
f01111da:	89 e5                	mov    %esp,%ebp
f01111dc:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f01111df:	e8 aa 92 ff ff       	call   f010a48e <get_cpu_proc>
f01111e4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f01111e7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01111eb:	75 16                	jne    f0111203 <sys_check_LRU_lists_free+0x2a>
f01111ed:	68 a4 90 12 f0       	push   $0xf01290a4
f01111f2:	68 b4 90 12 f0       	push   $0xf01290b4
f01111f7:	6a 45                	push   $0x45
f01111f9:	68 c9 90 12 f0       	push   $0xf01290c9
f01111fe:	e8 17 f1 fe ff       	call   f010031a <_panic>
	struct Env* env = cur_env;
f0111203:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111206:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f0111209:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111210:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111213:	8b 80 10 da 01 00    	mov    0x1da10(%eax),%eax
f0111219:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011121c:	eb 65                	jmp    f0111283 <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f011121e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0111225:	eb 3a                	jmp    f0111261 <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0111227:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011122a:	8b 00                	mov    (%eax),%eax
f011122c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011122f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0111232:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111237:	89 c2                	mov    %eax,%edx
f0111239:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011123c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111243:	8b 45 08             	mov    0x8(%ebp),%eax
f0111246:	01 c8                	add    %ecx,%eax
f0111248:	8b 00                	mov    (%eax),%eax
f011124a:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011124d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111250:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111255:	39 c2                	cmp    %eax,%edx
f0111257:	75 05                	jne    f011125e <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f0111259:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f011125c:	eb 0b                	jmp    f0111269 <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f011125e:	ff 45 ec             	incl   -0x14(%ebp)
f0111261:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111264:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111267:	7c be                	jl     f0111227 <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0111269:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011126d:	7e 08                	jle    f0111277 <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f011126f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111272:	e9 ed 00 00 00       	jmp    f0111364 <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111277:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011127a:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f0111280:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111283:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111287:	74 08                	je     f0111291 <sys_check_LRU_lists_free+0xb8>
f0111289:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011128c:	8b 40 10             	mov    0x10(%eax),%eax
f011128f:	eb 05                	jmp    f0111296 <sys_check_LRU_lists_free+0xbd>
f0111291:	b8 00 00 00 00       	mov    $0x0,%eax
f0111296:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0111299:	89 82 18 da 01 00    	mov    %eax,0x1da18(%edx)
f011129f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01112a2:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f01112a8:	85 c0                	test   %eax,%eax
f01112aa:	0f 85 6e ff ff ff    	jne    f011121e <sys_check_LRU_lists_free+0x45>
f01112b0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01112b4:	0f 85 64 ff ff ff    	jne    f011121e <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01112ba:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01112bd:	8b 80 20 da 01 00    	mov    0x1da20(%eax),%eax
f01112c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01112c6:	eb 62                	jmp    f011132a <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f01112c8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f01112cf:	eb 3a                	jmp    f011130b <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f01112d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01112d4:	8b 00                	mov    (%eax),%eax
f01112d6:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01112d9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01112dc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01112e1:	89 c2                	mov    %eax,%edx
f01112e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01112e6:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01112ed:	8b 45 08             	mov    0x8(%ebp),%eax
f01112f0:	01 c8                	add    %ecx,%eax
f01112f2:	8b 00                	mov    (%eax),%eax
f01112f4:	89 45 d8             	mov    %eax,-0x28(%ebp)
f01112f7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01112fa:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01112ff:	39 c2                	cmp    %eax,%edx
f0111301:	75 05                	jne    f0111308 <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f0111303:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f0111306:	eb 0b                	jmp    f0111313 <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f0111308:	ff 45 e8             	incl   -0x18(%ebp)
f011130b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011130e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111311:	7c be                	jl     f01112d1 <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0111313:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0111317:	7e 05                	jle    f011131e <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f0111319:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011131c:	eb 46                	jmp    f0111364 <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f011131e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111321:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f0111327:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011132a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011132e:	74 08                	je     f0111338 <sys_check_LRU_lists_free+0x15f>
f0111330:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111333:	8b 40 10             	mov    0x10(%eax),%eax
f0111336:	eb 05                	jmp    f011133d <sys_check_LRU_lists_free+0x164>
f0111338:	b8 00 00 00 00       	mov    $0x0,%eax
f011133d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0111340:	89 82 28 da 01 00    	mov    %eax,0x1da28(%edx)
f0111346:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111349:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f011134f:	85 c0                	test   %eax,%eax
f0111351:	0f 85 71 ff ff ff    	jne    f01112c8 <sys_check_LRU_lists_free+0xef>
f0111357:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011135b:	0f 85 67 ff ff ff    	jne    f01112c8 <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f0111361:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0111364:	c9                   	leave  
f0111365:	c3                   	ret    

f0111366 <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f0111366:	55                   	push   %ebp
f0111367:	89 e5                	mov    %esp,%ebp
f0111369:	83 ec 08             	sub    $0x8,%esp
		}
	}

	return WS_list_validation;
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
f011136c:	83 ec 04             	sub    $0x4,%esp
f011136f:	68 10 91 12 f0       	push   $0xf0129110
f0111374:	68 ea 00 00 00       	push   $0xea
f0111379:	68 c9 90 12 f0       	push   $0xf01290c9
f011137e:	e8 97 ef fe ff       	call   f010031a <_panic>

f0111383 <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f0111383:	55                   	push   %ebp
f0111384:	89 e5                	mov    %esp,%ebp
f0111386:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f0111389:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f0111390:	8b 15 78 51 55 f0    	mov    0xf0555178,%edx
f0111396:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111399:	39 c2                	cmp    %eax,%edx
f011139b:	74 0a                	je     f01113a7 <hasExpectedCommands+0x24>
		return 0;
f011139d:	b8 00 00 00 00       	mov    $0x0,%eax
f01113a2:	e9 8b 00 00 00       	jmp    f0111432 <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f01113a7:	a1 6c 51 55 f0       	mov    0xf055516c,%eax
f01113ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01113af:	eb 55                	jmp    f0111406 <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f01113b1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01113b8:	eb 2a                	jmp    f01113e4 <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f01113ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01113bd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01113c4:	8b 45 08             	mov    0x8(%ebp),%eax
f01113c7:	01 d0                	add    %edx,%eax
f01113c9:	8b 10                	mov    (%eax),%edx
f01113cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01113ce:	8b 00                	mov    (%eax),%eax
f01113d0:	83 ec 08             	sub    $0x8,%esp
f01113d3:	52                   	push   %edx
f01113d4:	50                   	push   %eax
f01113d5:	e8 83 f2 00 00       	call   f012065d <strcmp>
f01113da:	83 c4 10             	add    $0x10,%esp
f01113dd:	85 c0                	test   %eax,%eax
f01113df:	74 0d                	je     f01113ee <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f01113e1:	ff 45 f0             	incl   -0x10(%ebp)
f01113e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01113e7:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01113ea:	7c ce                	jl     f01113ba <hasExpectedCommands+0x37>
f01113ec:	eb 01                	jmp    f01113ef <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f01113ee:	90                   	nop
		if (i == commandsCount)
f01113ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01113f2:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01113f5:	75 07                	jne    f01113fe <hasExpectedCommands+0x7b>
			return 0;
f01113f7:	b8 00 00 00 00       	mov    $0x0,%eax
f01113fc:	eb 34                	jmp    f0111432 <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f01113fe:	a1 74 51 55 f0       	mov    0xf0555174,%eax
f0111403:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0111406:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011140a:	74 08                	je     f0111414 <hasExpectedCommands+0x91>
f011140c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011140f:	8b 40 10             	mov    0x10(%eax),%eax
f0111412:	eb 05                	jmp    f0111419 <hasExpectedCommands+0x96>
f0111414:	b8 00 00 00 00       	mov    $0x0,%eax
f0111419:	a3 74 51 55 f0       	mov    %eax,0xf0555174
f011141e:	a1 74 51 55 f0       	mov    0xf0555174,%eax
f0111423:	85 c0                	test   %eax,%eax
f0111425:	75 8a                	jne    f01113b1 <hasExpectedCommands+0x2e>
f0111427:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011142b:	75 84                	jne    f01113b1 <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f011142d:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0111432:	c9                   	leave  
f0111433:	c3                   	ret    

f0111434 <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f0111434:	55                   	push   %ebp
f0111435:	89 e5                	mov    %esp,%ebp
f0111437:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f011143a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0111441:	eb 2e                	jmp    f0111471 <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f0111443:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0111446:	89 d0                	mov    %edx,%eax
f0111448:	01 c0                	add    %eax,%eax
f011144a:	01 d0                	add    %edx,%eax
f011144c:	c1 e0 03             	shl    $0x3,%eax
f011144f:	05 40 95 17 f0       	add    $0xf0179540,%eax
f0111454:	8b 00                	mov    (%eax),%eax
f0111456:	83 ec 08             	sub    $0x8,%esp
f0111459:	ff 75 08             	pushl  0x8(%ebp)
f011145c:	50                   	push   %eax
f011145d:	e8 fb f1 00 00       	call   f012065d <strcmp>
f0111462:	83 c4 10             	add    $0x10,%esp
f0111465:	85 c0                	test   %eax,%eax
f0111467:	75 05                	jne    f011146e <getIndexOfCommand+0x3a>
			return i;
f0111469:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011146c:	eb 14                	jmp    f0111482 <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f011146e:	ff 45 f4             	incl   -0xc(%ebp)
f0111471:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0111474:	a1 60 99 17 f0       	mov    0xf0179960,%eax
f0111479:	39 c2                	cmp    %eax,%edx
f011147b:	72 c6                	jb     f0111443 <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f011147d:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f0111482:	c9                   	leave  
f0111483:	c3                   	ret    

f0111484 <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f0111484:	55                   	push   %ebp
f0111485:	89 e5                	mov    %esp,%ebp
f0111487:	57                   	push   %edi
f0111488:	56                   	push   %esi
f0111489:	53                   	push   %ebx
f011148a:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f0111490:	83 ec 0c             	sub    $0xc,%esp
f0111493:	68 60 91 12 f0       	push   $0xf0129160
f0111498:	e8 cf fa fe ff       	call   f0100f6c <cprintf>
f011149d:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f01114a0:	83 ec 0c             	sub    $0xc,%esp
f01114a3:	68 84 91 12 f0       	push   $0xf0129184
f01114a8:	e8 bf fa fe ff       	call   f0100f6c <cprintf>
f01114ad:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f01114b0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f01114b7:	c7 45 8c 9f 91 12 f0 	movl   $0xf012919f,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f01114be:	83 ec 08             	sub    $0x8,%esp
f01114c1:	8d 45 8c             	lea    -0x74(%ebp),%eax
f01114c4:	50                   	push   %eax
f01114c5:	6a 01                	push   $0x1
f01114c7:	e8 e5 0c ff ff       	call   f01021b1 <process_command>
f01114cc:	83 c4 10             	add    $0x10,%esp
f01114cf:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f01114d2:	83 ec 0c             	sub    $0xc,%esp
f01114d5:	68 ac 91 12 f0       	push   $0xf01291ac
f01114da:	e8 8d fa fe ff       	call   f0100f6c <cprintf>
f01114df:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f01114e2:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01114e5:	83 ec 0c             	sub    $0xc,%esp
f01114e8:	50                   	push   %eax
f01114e9:	e8 46 ff ff ff       	call   f0111434 <getIndexOfCommand>
f01114ee:	83 c4 10             	add    $0x10,%esp
f01114f1:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01114f4:	75 0f                	jne    f0111505 <TestAutoCompleteCommand+0x81>
f01114f6:	a1 6c 51 55 f0       	mov    0xf055516c,%eax
f01114fb:	85 c0                	test   %eax,%eax
f01114fd:	75 06                	jne    f0111505 <TestAutoCompleteCommand+0x81>
		eval += 15;
f01114ff:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111503:	eb 10                	jmp    f0111515 <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111505:	83 ec 0c             	sub    $0xc,%esp
f0111508:	68 dc 91 12 f0       	push   $0xf01291dc
f011150d:	e8 5a fa fe ff       	call   f0100f6c <cprintf>
f0111512:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f0111515:	83 ec 0c             	sub    $0xc,%esp
f0111518:	68 2c 92 12 f0       	push   $0xf012922c
f011151d:	e8 4a fa fe ff       	call   f0100f6c <cprintf>
f0111522:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f0111525:	c7 45 88 52 92 12 f0 	movl   $0xf0129252,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f011152c:	83 ec 08             	sub    $0x8,%esp
f011152f:	8d 45 88             	lea    -0x78(%ebp),%eax
f0111532:	50                   	push   %eax
f0111533:	6a 01                	push   $0x1
f0111535:	e8 77 0c ff ff       	call   f01021b1 <process_command>
f011153a:	83 c4 10             	add    $0x10,%esp
f011153d:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f0111540:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111544:	75 30                	jne    f0111576 <TestAutoCompleteCommand+0xf2>
f0111546:	8d 45 90             	lea    -0x70(%ebp),%eax
f0111549:	bb 30 96 12 f0       	mov    $0xf0129630,%ebx
f011154e:	ba 03 00 00 00       	mov    $0x3,%edx
f0111553:	89 c7                	mov    %eax,%edi
f0111555:	89 de                	mov    %ebx,%esi
f0111557:	89 d1                	mov    %edx,%ecx
f0111559:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011155b:	83 ec 08             	sub    $0x8,%esp
f011155e:	6a 03                	push   $0x3
f0111560:	8d 45 90             	lea    -0x70(%ebp),%eax
f0111563:	50                   	push   %eax
f0111564:	e8 1a fe ff ff       	call   f0111383 <hasExpectedCommands>
f0111569:	83 c4 10             	add    $0x10,%esp
f011156c:	85 c0                	test   %eax,%eax
f011156e:	74 06                	je     f0111576 <TestAutoCompleteCommand+0xf2>
		eval += 15;
f0111570:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111574:	eb 10                	jmp    f0111586 <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111576:	83 ec 0c             	sub    $0xc,%esp
f0111579:	68 58 92 12 f0       	push   $0xf0129258
f011157e:	e8 e9 f9 fe ff       	call   f0100f6c <cprintf>
f0111583:	83 c4 10             	add    $0x10,%esp

	// CASE3: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f0111586:	83 ec 0c             	sub    $0xc,%esp
f0111589:	68 a8 92 12 f0       	push   $0xf01292a8
f011158e:	e8 d9 f9 fe ff       	call   f0100f6c <cprintf>
f0111593:	83 c4 10             	add    $0x10,%esp
	char *args3[] = {"wm"};
f0111596:	c7 45 84 cd 92 12 f0 	movl   $0xf01292cd,-0x7c(%ebp)
	cprintf("va of args3 = %x, *args3 = %x\n", args3, *args3);
f011159d:	8b 45 84             	mov    -0x7c(%ebp),%eax
f01115a0:	83 ec 04             	sub    $0x4,%esp
f01115a3:	50                   	push   %eax
f01115a4:	8d 45 84             	lea    -0x7c(%ebp),%eax
f01115a7:	50                   	push   %eax
f01115a8:	68 d0 92 12 f0       	push   $0xf01292d0
f01115ad:	e8 ba f9 fe ff       	call   f0100f6c <cprintf>
f01115b2:	83 c4 10             	add    $0x10,%esp
	ret = process_command(ARRAY_LENGTH(args3), args3);
f01115b5:	83 ec 08             	sub    $0x8,%esp
f01115b8:	8d 45 84             	lea    -0x7c(%ebp),%eax
f01115bb:	50                   	push   %eax
f01115bc:	6a 01                	push   $0x1
f01115be:	e8 ee 0b ff ff       	call   f01021b1 <process_command>
f01115c3:	83 c4 10             	add    $0x10,%esp
f01115c6:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3, 1))
f01115c9:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f01115cd:	75 1b                	jne    f01115ea <TestAutoCompleteCommand+0x166>
f01115cf:	83 ec 08             	sub    $0x8,%esp
f01115d2:	6a 01                	push   $0x1
f01115d4:	8d 45 84             	lea    -0x7c(%ebp),%eax
f01115d7:	50                   	push   %eax
f01115d8:	e8 a6 fd ff ff       	call   f0111383 <hasExpectedCommands>
f01115dd:	83 c4 10             	add    $0x10,%esp
f01115e0:	85 c0                	test   %eax,%eax
f01115e2:	74 06                	je     f01115ea <TestAutoCompleteCommand+0x166>
		eval += 15;
f01115e4:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01115e8:	eb 10                	jmp    f01115fa <TestAutoCompleteCommand+0x176>
	else
		cprintf("#3: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f01115ea:	83 ec 0c             	sub    $0xc,%esp
f01115ed:	68 f0 92 12 f0       	push   $0xf01292f0
f01115f2:	e8 75 f9 fe ff       	call   f0100f6c <cprintf>
f01115f7:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f01115fa:	83 ec 0c             	sub    $0xc,%esp
f01115fd:	68 48 93 12 f0       	push   $0xf0129348
f0111602:	e8 65 f9 fe ff       	call   f0100f6c <cprintf>
f0111607:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f011160a:	c7 45 80 6e 93 12 f0 	movl   $0xf012936e,-0x80(%ebp)
	ret = process_command(ARRAY_LENGTH(args4), args4);
f0111611:	83 ec 08             	sub    $0x8,%esp
f0111614:	8d 45 80             	lea    -0x80(%ebp),%eax
f0111617:	50                   	push   %eax
f0111618:	6a 01                	push   $0x1
f011161a:	e8 92 0b ff ff       	call   f01021b1 <process_command>
f011161f:	83 c4 10             	add    $0x10,%esp
f0111622:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f0111625:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0111629:	75 0f                	jne    f011163a <TestAutoCompleteCommand+0x1b6>
f011162b:	a1 78 51 55 f0       	mov    0xf0555178,%eax
f0111630:	85 c0                	test   %eax,%eax
f0111632:	75 06                	jne    f011163a <TestAutoCompleteCommand+0x1b6>
		eval += 15;
f0111634:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111638:	eb 10                	jmp    f011164a <TestAutoCompleteCommand+0x1c6>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011163a:	83 ec 0c             	sub    $0xc,%esp
f011163d:	68 74 93 12 f0       	push   $0xf0129374
f0111642:	e8 25 f9 fe ff       	call   f0100f6c <cprintf>
f0111647:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that start with he ---> Shall print (help)
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f011164a:	83 ec 0c             	sub    $0xc,%esp
f011164d:	68 c4 93 12 f0       	push   $0xf01293c4
f0111652:	e8 15 f9 fe ff       	call   f0100f6c <cprintf>
f0111657:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f011165a:	c7 85 7c ff ff ff e9 	movl   $0xf01293e9,-0x84(%ebp)
f0111661:	93 12 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f0111664:	83 ec 08             	sub    $0x8,%esp
f0111667:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f011166d:	50                   	push   %eax
f011166e:	6a 01                	push   $0x1
f0111670:	e8 3c 0b ff ff       	call   f01021b1 <process_command>
f0111675:	83 c4 10             	add    $0x10,%esp
f0111678:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f011167b:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f011167f:	75 30                	jne    f01116b1 <TestAutoCompleteCommand+0x22d>
f0111681:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111684:	bb c0 96 12 f0       	mov    $0xf01296c0,%ebx
f0111689:	ba 0c 00 00 00       	mov    $0xc,%edx
f011168e:	89 c7                	mov    %eax,%edi
f0111690:	89 de                	mov    %ebx,%esi
f0111692:	89 d1                	mov    %edx,%ecx
f0111694:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111696:	83 ec 08             	sub    $0x8,%esp
f0111699:	6a 0c                	push   $0xc
f011169b:	8d 45 9c             	lea    -0x64(%ebp),%eax
f011169e:	50                   	push   %eax
f011169f:	e8 df fc ff ff       	call   f0111383 <hasExpectedCommands>
f01116a4:	83 c4 10             	add    $0x10,%esp
f01116a7:	85 c0                	test   %eax,%eax
f01116a9:	74 06                	je     f01116b1 <TestAutoCompleteCommand+0x22d>
		eval += 10;
f01116ab:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01116af:	eb 10                	jmp    f01116c1 <TestAutoCompleteCommand+0x23d>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f01116b1:	83 ec 0c             	sub    $0xc,%esp
f01116b4:	68 ec 93 12 f0       	push   $0xf01293ec
f01116b9:	e8 ae f8 fe ff       	call   f0100f6c <cprintf>
f01116be:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that start with ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f01116c1:	83 ec 0c             	sub    $0xc,%esp
f01116c4:	68 44 94 12 f0       	push   $0xf0129444
f01116c9:	e8 9e f8 fe ff       	call   f0100f6c <cprintf>
f01116ce:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f01116d1:	c7 85 78 ff ff ff 69 	movl   $0xf0129469,-0x88(%ebp)
f01116d8:	94 12 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f01116db:	83 ec 08             	sub    $0x8,%esp
f01116de:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f01116e4:	50                   	push   %eax
f01116e5:	6a 01                	push   $0x1
f01116e7:	e8 c5 0a ff ff       	call   f01021b1 <process_command>
f01116ec:	83 c4 10             	add    $0x10,%esp
f01116ef:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f01116f2:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01116f6:	75 30                	jne    f0111728 <TestAutoCompleteCommand+0x2a4>
f01116f8:	8d 45 cc             	lea    -0x34(%ebp),%eax
f01116fb:	bb 08 97 12 f0       	mov    $0xf0129708,%ebx
f0111700:	ba 05 00 00 00       	mov    $0x5,%edx
f0111705:	89 c7                	mov    %eax,%edi
f0111707:	89 de                	mov    %ebx,%esi
f0111709:	89 d1                	mov    %edx,%ecx
f011170b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011170d:	83 ec 08             	sub    $0x8,%esp
f0111710:	6a 05                	push   $0x5
f0111712:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0111715:	50                   	push   %eax
f0111716:	e8 68 fc ff ff       	call   f0111383 <hasExpectedCommands>
f011171b:	83 c4 10             	add    $0x10,%esp
f011171e:	85 c0                	test   %eax,%eax
f0111720:	74 06                	je     f0111728 <TestAutoCompleteCommand+0x2a4>
		eval += 10;
f0111722:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111726:	eb 10                	jmp    f0111738 <TestAutoCompleteCommand+0x2b4>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f0111728:	83 ec 0c             	sub    $0xc,%esp
f011172b:	68 6c 94 12 f0       	push   $0xf012946c
f0111730:	e8 37 f8 fe ff       	call   f0100f6c <cprintf>
f0111735:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f0111738:	83 ec 0c             	sub    $0xc,%esp
f011173b:	68 c4 94 12 f0       	push   $0xf01294c4
f0111740:	e8 27 f8 fe ff       	call   f0100f6c <cprintf>
f0111745:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f0111748:	c7 85 70 ff ff ff f0 	movl   $0xf01294f0,-0x90(%ebp)
f011174f:	94 12 f0 
f0111752:	c7 85 74 ff ff ff f5 	movl   $0xf01294f5,-0x8c(%ebp)
f0111759:	94 12 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f011175c:	83 ec 08             	sub    $0x8,%esp
f011175f:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f0111765:	50                   	push   %eax
f0111766:	6a 02                	push   $0x2
f0111768:	e8 44 0a ff ff       	call   f01021b1 <process_command>
f011176d:	83 c4 10             	add    $0x10,%esp
f0111770:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f0111773:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0111779:	83 ec 0c             	sub    $0xc,%esp
f011177c:	50                   	push   %eax
f011177d:	e8 b2 fc ff ff       	call   f0111434 <getIndexOfCommand>
f0111782:	83 c4 10             	add    $0x10,%esp
f0111785:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111788:	75 0f                	jne    f0111799 <TestAutoCompleteCommand+0x315>
f011178a:	a1 6c 51 55 f0       	mov    0xf055516c,%eax
f011178f:	85 c0                	test   %eax,%eax
f0111791:	75 06                	jne    f0111799 <TestAutoCompleteCommand+0x315>
		eval += 10;
f0111793:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111797:	eb 10                	jmp    f01117a9 <TestAutoCompleteCommand+0x325>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111799:	83 ec 0c             	sub    $0xc,%esp
f011179c:	68 fc 94 12 f0       	push   $0xf01294fc
f01117a1:	e8 c6 f7 fe ff       	call   f0100f6c <cprintf>
f01117a6:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f01117a9:	83 ec 0c             	sub    $0xc,%esp
f01117ac:	68 4c 95 12 f0       	push   $0xf012954c
f01117b1:	e8 b6 f7 fe ff       	call   f0100f6c <cprintf>
f01117b6:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f01117b9:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f01117bf:	bb 30 97 12 f0       	mov    $0xf0129730,%ebx
f01117c4:	ba 03 00 00 00       	mov    $0x3,%edx
f01117c9:	89 c7                	mov    %eax,%edi
f01117cb:	89 de                	mov    %ebx,%esi
f01117cd:	89 d1                	mov    %edx,%ecx
f01117cf:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f01117d1:	83 ec 08             	sub    $0x8,%esp
f01117d4:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f01117da:	50                   	push   %eax
f01117db:	6a 03                	push   $0x3
f01117dd:	e8 cf 09 ff ff       	call   f01021b1 <process_command>
f01117e2:	83 c4 10             	add    $0x10,%esp
f01117e5:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f01117e8:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f01117ee:	83 ec 0c             	sub    $0xc,%esp
f01117f1:	50                   	push   %eax
f01117f2:	e8 3d fc ff ff       	call   f0111434 <getIndexOfCommand>
f01117f7:	83 c4 10             	add    $0x10,%esp
f01117fa:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01117fd:	75 0f                	jne    f011180e <TestAutoCompleteCommand+0x38a>
f01117ff:	a1 6c 51 55 f0       	mov    0xf055516c,%eax
f0111804:	85 c0                	test   %eax,%eax
f0111806:	75 06                	jne    f011180e <TestAutoCompleteCommand+0x38a>
		eval += 10;
f0111808:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f011180c:	eb 10                	jmp    f011181e <TestAutoCompleteCommand+0x39a>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011180e:	83 ec 0c             	sub    $0xc,%esp
f0111811:	68 80 95 12 f0       	push   $0xf0129580
f0111816:	e8 51 f7 fe ff       	call   f0100f6c <cprintf>
f011181b:	83 c4 10             	add    $0x10,%esp

	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
f011181e:	83 ec 08             	sub    $0x8,%esp
f0111821:	ff 75 e4             	pushl  -0x1c(%ebp)
f0111824:	68 d0 95 12 f0       	push   $0xf01295d0
f0111829:	e8 3e f7 fe ff       	call   f0100f6c <cprintf>
f011182e:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111831:	83 ec 0c             	sub    $0xc,%esp
f0111834:	68 00 96 12 f0       	push   $0xf0129600
f0111839:	e8 2e f7 fe ff       	call   f0100f6c <cprintf>
f011183e:	83 c4 10             	add    $0x10,%esp

	return 0;
f0111841:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111846:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0111849:	5b                   	pop    %ebx
f011184a:	5e                   	pop    %esi
f011184b:	5f                   	pop    %edi
f011184c:	5d                   	pop    %ebp
f011184d:	c3                   	ret    

f011184e <test_str2lower_function>:

int test_str2lower_function()
{
f011184e:	55                   	push   %ebp
f011184f:	89 e5                	mov    %esp,%ebp
f0111851:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f0111857:	83 ec 0c             	sub    $0xc,%esp
f011185a:	68 3c 97 12 f0       	push   $0xf012973c
f011185f:	e8 08 f7 fe ff       	call   f0100f6c <cprintf>
f0111864:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f0111867:	83 ec 0c             	sub    $0xc,%esp
f011186a:	68 5d 97 12 f0       	push   $0xf012975d
f011186f:	e8 f8 f6 fe ff       	call   f0100f6c <cprintf>
f0111874:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f0111877:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f011187e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f0111885:	c7 45 ec 77 97 12 f0 	movl   $0xf0129777,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f011188c:	83 ec 08             	sub    $0x8,%esp
f011188f:	ff 75 ec             	pushl  -0x14(%ebp)
f0111892:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f0111898:	50                   	push   %eax
f0111899:	e8 9c f3 00 00       	call   f0120c3a <str2lower>
f011189e:	83 c4 10             	add    $0x10,%esp
f01118a1:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f01118a4:	83 ec 0c             	sub    $0xc,%esp
f01118a7:	ff 75 e8             	pushl  -0x18(%ebp)
f01118aa:	e8 a2 ec 00 00       	call   f0120551 <strlen>
f01118af:	83 c4 10             	add    $0x10,%esp
f01118b2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f01118b5:	83 ec 08             	sub    $0x8,%esp
f01118b8:	68 82 97 12 f0       	push   $0xf0129782
f01118bd:	ff 75 e8             	pushl  -0x18(%ebp)
f01118c0:	e8 98 ed 00 00       	call   f012065d <strcmp>
f01118c5:	83 c4 10             	add    $0x10,%esp
f01118c8:	85 c0                	test   %eax,%eax
f01118ca:	75 13                	jne    f01118df <test_str2lower_function+0x91>
f01118cc:	83 ec 0c             	sub    $0xc,%esp
f01118cf:	ff 75 ec             	pushl  -0x14(%ebp)
f01118d2:	e8 7a ec 00 00       	call   f0120551 <strlen>
f01118d7:	83 c4 10             	add    $0x10,%esp
f01118da:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01118dd:	74 15                	je     f01118f4 <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f01118df:	83 ec 08             	sub    $0x8,%esp
f01118e2:	ff 75 e8             	pushl  -0x18(%ebp)
f01118e5:	68 90 97 12 f0       	push   $0xf0129790
f01118ea:	e8 7d f6 fe ff       	call   f0100f6c <cprintf>
f01118ef:	83 c4 10             	add    $0x10,%esp
f01118f2:	eb 04                	jmp    f01118f8 <test_str2lower_function+0xaa>
	else
		eval += 10;
f01118f4:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f01118f8:	c7 45 e0 f2 97 12 f0 	movl   $0xf01297f2,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f01118ff:	83 ec 08             	sub    $0x8,%esp
f0111902:	ff 75 e0             	pushl  -0x20(%ebp)
f0111905:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011190b:	50                   	push   %eax
f011190c:	e8 29 f3 00 00       	call   f0120c3a <str2lower>
f0111911:	83 c4 10             	add    $0x10,%esp
f0111914:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111917:	83 ec 0c             	sub    $0xc,%esp
f011191a:	ff 75 e8             	pushl  -0x18(%ebp)
f011191d:	e8 2f ec 00 00       	call   f0120551 <strlen>
f0111922:	83 c4 10             	add    $0x10,%esp
f0111925:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f0111928:	83 ec 08             	sub    $0x8,%esp
f011192b:	68 f2 97 12 f0       	push   $0xf01297f2
f0111930:	ff 75 e8             	pushl  -0x18(%ebp)
f0111933:	e8 25 ed 00 00       	call   f012065d <strcmp>
f0111938:	83 c4 10             	add    $0x10,%esp
f011193b:	85 c0                	test   %eax,%eax
f011193d:	75 13                	jne    f0111952 <test_str2lower_function+0x104>
f011193f:	83 ec 0c             	sub    $0xc,%esp
f0111942:	ff 75 e0             	pushl  -0x20(%ebp)
f0111945:	e8 07 ec 00 00       	call   f0120551 <strlen>
f011194a:	83 c4 10             	add    $0x10,%esp
f011194d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111950:	74 15                	je     f0111967 <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0111952:	83 ec 08             	sub    $0x8,%esp
f0111955:	ff 75 e8             	pushl  -0x18(%ebp)
f0111958:	68 f4 97 12 f0       	push   $0xf01297f4
f011195d:	e8 0a f6 fe ff       	call   f0100f6c <cprintf>
f0111962:	83 c4 10             	add    $0x10,%esp
f0111965:	eb 04                	jmp    f011196b <test_str2lower_function+0x11d>
	else
		eval += 10;
f0111967:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f011196b:	c7 45 dc 4c 98 12 f0 	movl   $0xf012984c,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f0111972:	83 ec 08             	sub    $0x8,%esp
f0111975:	ff 75 dc             	pushl  -0x24(%ebp)
f0111978:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f011197e:	50                   	push   %eax
f011197f:	e8 b6 f2 00 00       	call   f0120c3a <str2lower>
f0111984:	83 c4 10             	add    $0x10,%esp
f0111987:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f011198a:	83 ec 0c             	sub    $0xc,%esp
f011198d:	ff 75 e8             	pushl  -0x18(%ebp)
f0111990:	e8 bc eb 00 00       	call   f0120551 <strlen>
f0111995:	83 c4 10             	add    $0x10,%esp
f0111998:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f011199b:	83 ec 08             	sub    $0x8,%esp
f011199e:	68 4c 98 12 f0       	push   $0xf012984c
f01119a3:	ff 75 e8             	pushl  -0x18(%ebp)
f01119a6:	e8 b2 ec 00 00       	call   f012065d <strcmp>
f01119ab:	83 c4 10             	add    $0x10,%esp
f01119ae:	85 c0                	test   %eax,%eax
f01119b0:	75 13                	jne    f01119c5 <test_str2lower_function+0x177>
f01119b2:	83 ec 0c             	sub    $0xc,%esp
f01119b5:	ff 75 dc             	pushl  -0x24(%ebp)
f01119b8:	e8 94 eb 00 00       	call   f0120551 <strlen>
f01119bd:	83 c4 10             	add    $0x10,%esp
f01119c0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01119c3:	74 15                	je     f01119da <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f01119c5:	83 ec 08             	sub    $0x8,%esp
f01119c8:	ff 75 e8             	pushl  -0x18(%ebp)
f01119cb:	68 58 98 12 f0       	push   $0xf0129858
f01119d0:	e8 97 f5 fe ff       	call   f0100f6c <cprintf>
f01119d5:	83 c4 10             	add    $0x10,%esp
f01119d8:	eb 04                	jmp    f01119de <test_str2lower_function+0x190>
	else
		eval += 15;
f01119da:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f01119de:	c7 45 d8 bb 98 12 f0 	movl   $0xf01298bb,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f01119e5:	83 ec 08             	sub    $0x8,%esp
f01119e8:	ff 75 d8             	pushl  -0x28(%ebp)
f01119eb:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f01119f1:	50                   	push   %eax
f01119f2:	e8 43 f2 00 00       	call   f0120c3a <str2lower>
f01119f7:	83 c4 10             	add    $0x10,%esp
f01119fa:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01119fd:	83 ec 0c             	sub    $0xc,%esp
f0111a00:	ff 75 e8             	pushl  -0x18(%ebp)
f0111a03:	e8 49 eb 00 00       	call   f0120551 <strlen>
f0111a08:	83 c4 10             	add    $0x10,%esp
f0111a0b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f0111a0e:	83 ec 08             	sub    $0x8,%esp
f0111a11:	68 bb 98 12 f0       	push   $0xf01298bb
f0111a16:	ff 75 e8             	pushl  -0x18(%ebp)
f0111a19:	e8 3f ec 00 00       	call   f012065d <strcmp>
f0111a1e:	83 c4 10             	add    $0x10,%esp
f0111a21:	85 c0                	test   %eax,%eax
f0111a23:	75 13                	jne    f0111a38 <test_str2lower_function+0x1ea>
f0111a25:	83 ec 0c             	sub    $0xc,%esp
f0111a28:	ff 75 d8             	pushl  -0x28(%ebp)
f0111a2b:	e8 21 eb 00 00       	call   f0120551 <strlen>
f0111a30:	83 c4 10             	add    $0x10,%esp
f0111a33:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111a36:	74 15                	je     f0111a4d <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f0111a38:	83 ec 08             	sub    $0x8,%esp
f0111a3b:	ff 75 e8             	pushl  -0x18(%ebp)
f0111a3e:	68 c8 98 12 f0       	push   $0xf01298c8
f0111a43:	e8 24 f5 fe ff       	call   f0100f6c <cprintf>
f0111a48:	83 c4 10             	add    $0x10,%esp
f0111a4b:	eb 04                	jmp    f0111a51 <test_str2lower_function+0x203>
	else
		eval += 15;
f0111a4d:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f0111a51:	c7 45 d4 2a 99 12 f0 	movl   $0xf012992a,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f0111a58:	83 ec 08             	sub    $0x8,%esp
f0111a5b:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111a5e:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f0111a64:	50                   	push   %eax
f0111a65:	e8 d0 f1 00 00       	call   f0120c3a <str2lower>
f0111a6a:	83 c4 10             	add    $0x10,%esp
f0111a6d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111a70:	83 ec 0c             	sub    $0xc,%esp
f0111a73:	ff 75 e8             	pushl  -0x18(%ebp)
f0111a76:	e8 d6 ea 00 00       	call   f0120551 <strlen>
f0111a7b:	83 c4 10             	add    $0x10,%esp
f0111a7e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f0111a81:	83 ec 08             	sub    $0x8,%esp
f0111a84:	68 40 99 12 f0       	push   $0xf0129940
f0111a89:	ff 75 e8             	pushl  -0x18(%ebp)
f0111a8c:	e8 cc eb 00 00       	call   f012065d <strcmp>
f0111a91:	83 c4 10             	add    $0x10,%esp
f0111a94:	85 c0                	test   %eax,%eax
f0111a96:	75 13                	jne    f0111aab <test_str2lower_function+0x25d>
f0111a98:	83 ec 0c             	sub    $0xc,%esp
f0111a9b:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111a9e:	e8 ae ea 00 00       	call   f0120551 <strlen>
f0111aa3:	83 c4 10             	add    $0x10,%esp
f0111aa6:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111aa9:	74 15                	je     f0111ac0 <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f0111aab:	83 ec 08             	sub    $0x8,%esp
f0111aae:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ab1:	68 58 99 12 f0       	push   $0xf0129958
f0111ab6:	e8 b1 f4 fe ff       	call   f0100f6c <cprintf>
f0111abb:	83 c4 10             	add    $0x10,%esp
f0111abe:	eb 04                	jmp    f0111ac4 <test_str2lower_function+0x276>
	else
		eval += 15;
f0111ac0:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f0111ac4:	c7 45 d0 c5 99 12 f0 	movl   $0xf01299c5,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f0111acb:	83 ec 08             	sub    $0x8,%esp
f0111ace:	ff 75 d0             	pushl  -0x30(%ebp)
f0111ad1:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f0111ad7:	50                   	push   %eax
f0111ad8:	e8 5d f1 00 00       	call   f0120c3a <str2lower>
f0111add:	83 c4 10             	add    $0x10,%esp
f0111ae0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111ae3:	83 ec 0c             	sub    $0xc,%esp
f0111ae6:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ae9:	e8 63 ea 00 00       	call   f0120551 <strlen>
f0111aee:	83 c4 10             	add    $0x10,%esp
f0111af1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f0111af4:	83 ec 08             	sub    $0x8,%esp
f0111af7:	68 d1 99 12 f0       	push   $0xf01299d1
f0111afc:	ff 75 e8             	pushl  -0x18(%ebp)
f0111aff:	e8 59 eb 00 00       	call   f012065d <strcmp>
f0111b04:	83 c4 10             	add    $0x10,%esp
f0111b07:	85 c0                	test   %eax,%eax
f0111b09:	75 13                	jne    f0111b1e <test_str2lower_function+0x2d0>
f0111b0b:	83 ec 0c             	sub    $0xc,%esp
f0111b0e:	ff 75 d0             	pushl  -0x30(%ebp)
f0111b11:	e8 3b ea 00 00       	call   f0120551 <strlen>
f0111b16:	83 c4 10             	add    $0x10,%esp
f0111b19:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111b1c:	74 15                	je     f0111b33 <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f0111b1e:	83 ec 08             	sub    $0x8,%esp
f0111b21:	ff 75 e8             	pushl  -0x18(%ebp)
f0111b24:	68 e0 99 12 f0       	push   $0xf01299e0
f0111b29:	e8 3e f4 fe ff       	call   f0100f6c <cprintf>
f0111b2e:	83 c4 10             	add    $0x10,%esp
f0111b31:	eb 04                	jmp    f0111b37 <test_str2lower_function+0x2e9>
	else
		eval += 15;
f0111b33:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f0111b37:	c7 45 cc 43 9a 12 f0 	movl   $0xf0129a43,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f0111b3e:	83 ec 08             	sub    $0x8,%esp
f0111b41:	ff 75 cc             	pushl  -0x34(%ebp)
f0111b44:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f0111b4a:	50                   	push   %eax
f0111b4b:	e8 ea f0 00 00       	call   f0120c3a <str2lower>
f0111b50:	83 c4 10             	add    $0x10,%esp
f0111b53:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111b56:	83 ec 0c             	sub    $0xc,%esp
f0111b59:	ff 75 e8             	pushl  -0x18(%ebp)
f0111b5c:	e8 f0 e9 00 00       	call   f0120551 <strlen>
f0111b61:	83 c4 10             	add    $0x10,%esp
f0111b64:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f0111b67:	83 ec 08             	sub    $0x8,%esp
f0111b6a:	68 5e 9a 12 f0       	push   $0xf0129a5e
f0111b6f:	ff 75 e8             	pushl  -0x18(%ebp)
f0111b72:	e8 e6 ea 00 00       	call   f012065d <strcmp>
f0111b77:	83 c4 10             	add    $0x10,%esp
f0111b7a:	85 c0                	test   %eax,%eax
f0111b7c:	75 13                	jne    f0111b91 <test_str2lower_function+0x343>
f0111b7e:	83 ec 0c             	sub    $0xc,%esp
f0111b81:	ff 75 cc             	pushl  -0x34(%ebp)
f0111b84:	e8 c8 e9 00 00       	call   f0120551 <strlen>
f0111b89:	83 c4 10             	add    $0x10,%esp
f0111b8c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111b8f:	74 15                	je     f0111ba6 <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f0111b91:	83 ec 08             	sub    $0x8,%esp
f0111b94:	ff 75 e8             	pushl  -0x18(%ebp)
f0111b97:	68 7c 9a 12 f0       	push   $0xf0129a7c
f0111b9c:	e8 cb f3 fe ff       	call   f0100f6c <cprintf>
f0111ba1:	83 c4 10             	add    $0x10,%esp
f0111ba4:	eb 04                	jmp    f0111baa <test_str2lower_function+0x35c>
	else
		eval += 20;
f0111ba6:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f0111baa:	83 ec 08             	sub    $0x8,%esp
f0111bad:	ff 75 f4             	pushl  -0xc(%ebp)
f0111bb0:	68 f0 9a 12 f0       	push   $0xf0129af0
f0111bb5:	e8 b2 f3 fe ff       	call   f0100f6c <cprintf>
f0111bba:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111bbd:	83 ec 0c             	sub    $0xc,%esp
f0111bc0:	68 00 96 12 f0       	push   $0xf0129600
f0111bc5:	e8 a2 f3 fe ff       	call   f0100f6c <cprintf>
f0111bca:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111bcd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111bd2:	c9                   	leave  
f0111bd3:	c3                   	ret    

f0111bd4 <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f0111bd4:	55                   	push   %ebp
f0111bd5:	89 e5                	mov    %esp,%ebp
f0111bd7:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f0111bda:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0111be1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0111be8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111bef:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111bf4:	ff 75 ec             	pushl  -0x14(%ebp)
f0111bf7:	ff 75 f0             	pushl  -0x10(%ebp)
f0111bfa:	ff 75 f4             	pushl  -0xc(%ebp)
f0111bfd:	50                   	push   %eax
f0111bfe:	e8 43 6c ff ff       	call   f0108846 <pt_set_page_permissions>
f0111c03:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111c06:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111c0b:	ff 75 ec             	pushl  -0x14(%ebp)
f0111c0e:	ff 75 f0             	pushl  -0x10(%ebp)
f0111c11:	ff 75 f4             	pushl  -0xc(%ebp)
f0111c14:	50                   	push   %eax
f0111c15:	e8 a0 4d 00 00       	call   f01169ba <CP>
f0111c1a:	83 c4 10             	add    $0x10,%esp
f0111c1d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111c20:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111c24:	74 17                	je     f0111c3d <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f0111c26:	83 ec 04             	sub    $0x4,%esp
f0111c29:	68 20 9b 12 f0       	push   $0xf0129b20
f0111c2e:	68 23 01 00 00       	push   $0x123
f0111c33:	68 42 9b 12 f0       	push   $0xf0129b42
f0111c38:	e8 dd e6 fe ff       	call   f010031a <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f0111c3d:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f0111c44:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f0111c4b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111c52:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111c57:	ff 75 ec             	pushl  -0x14(%ebp)
f0111c5a:	ff 75 f0             	pushl  -0x10(%ebp)
f0111c5d:	ff 75 f4             	pushl  -0xc(%ebp)
f0111c60:	50                   	push   %eax
f0111c61:	e8 e0 6b ff ff       	call   f0108846 <pt_set_page_permissions>
f0111c66:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111c69:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111c6e:	ff 75 ec             	pushl  -0x14(%ebp)
f0111c71:	ff 75 f0             	pushl  -0x10(%ebp)
f0111c74:	ff 75 f4             	pushl  -0xc(%ebp)
f0111c77:	50                   	push   %eax
f0111c78:	e8 3d 4d 00 00       	call   f01169ba <CP>
f0111c7d:	83 c4 10             	add    $0x10,%esp
f0111c80:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111c83:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111c87:	74 17                	je     f0111ca0 <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f0111c89:	83 ec 04             	sub    $0x4,%esp
f0111c8c:	68 60 9b 12 f0       	push   $0xf0129b60
f0111c91:	68 2f 01 00 00       	push   $0x12f
f0111c96:	68 42 9b 12 f0       	push   $0xf0129b42
f0111c9b:	e8 7a e6 fe ff       	call   f010031a <_panic>
	}

	va = 0xEF800000;
f0111ca0:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f0111ca7:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f0111cae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111cb5:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111cba:	ff 75 ec             	pushl  -0x14(%ebp)
f0111cbd:	ff 75 f0             	pushl  -0x10(%ebp)
f0111cc0:	ff 75 f4             	pushl  -0xc(%ebp)
f0111cc3:	50                   	push   %eax
f0111cc4:	e8 7d 6b ff ff       	call   f0108846 <pt_set_page_permissions>
f0111cc9:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111ccc:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111cd1:	ff 75 ec             	pushl  -0x14(%ebp)
f0111cd4:	ff 75 f0             	pushl  -0x10(%ebp)
f0111cd7:	ff 75 f4             	pushl  -0xc(%ebp)
f0111cda:	50                   	push   %eax
f0111cdb:	e8 da 4c 00 00       	call   f01169ba <CP>
f0111ce0:	83 c4 10             	add    $0x10,%esp
f0111ce3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111ce6:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111cea:	74 17                	je     f0111d03 <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f0111cec:	83 ec 04             	sub    $0x4,%esp
f0111cef:	68 84 9b 12 f0       	push   $0xf0129b84
f0111cf4:	68 3a 01 00 00       	push   $0x13a
f0111cf9:	68 42 9b 12 f0       	push   $0xf0129b42
f0111cfe:	e8 17 e6 fe ff       	call   f010031a <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f0111d03:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f0111d0a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f0111d11:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111d18:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111d1d:	ff 75 ec             	pushl  -0x14(%ebp)
f0111d20:	ff 75 f0             	pushl  -0x10(%ebp)
f0111d23:	ff 75 f4             	pushl  -0xc(%ebp)
f0111d26:	50                   	push   %eax
f0111d27:	e8 1a 6b ff ff       	call   f0108846 <pt_set_page_permissions>
f0111d2c:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111d2f:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111d34:	ff 75 ec             	pushl  -0x14(%ebp)
f0111d37:	ff 75 f0             	pushl  -0x10(%ebp)
f0111d3a:	ff 75 f4             	pushl  -0xc(%ebp)
f0111d3d:	50                   	push   %eax
f0111d3e:	e8 77 4c 00 00       	call   f01169ba <CP>
f0111d43:	83 c4 10             	add    $0x10,%esp
f0111d46:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111d49:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111d4d:	74 17                	je     f0111d66 <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0111d4f:	83 ec 04             	sub    $0x4,%esp
f0111d52:	68 a8 9b 12 f0       	push   $0xf0129ba8
f0111d57:	68 46 01 00 00       	push   $0x146
f0111d5c:	68 42 9b 12 f0       	push   $0xf0129b42
f0111d61:	e8 b4 e5 fe ff       	call   f010031a <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f0111d66:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f0111d6d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f0111d74:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111d7b:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111d80:	ff 75 ec             	pushl  -0x14(%ebp)
f0111d83:	ff 75 f0             	pushl  -0x10(%ebp)
f0111d86:	ff 75 f4             	pushl  -0xc(%ebp)
f0111d89:	50                   	push   %eax
f0111d8a:	e8 b7 6a ff ff       	call   f0108846 <pt_set_page_permissions>
f0111d8f:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111d92:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111d97:	ff 75 ec             	pushl  -0x14(%ebp)
f0111d9a:	ff 75 f0             	pushl  -0x10(%ebp)
f0111d9d:	ff 75 f4             	pushl  -0xc(%ebp)
f0111da0:	50                   	push   %eax
f0111da1:	e8 14 4c 00 00       	call   f01169ba <CP>
f0111da6:	83 c4 10             	add    $0x10,%esp
f0111da9:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111dac:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111db0:	74 17                	je     f0111dc9 <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f0111db2:	83 ec 04             	sub    $0x4,%esp
f0111db5:	68 cc 9b 12 f0       	push   $0xf0129bcc
f0111dba:	68 52 01 00 00       	push   $0x152
f0111dbf:	68 42 9b 12 f0       	push   $0xf0129b42
f0111dc4:	e8 51 e5 fe ff       	call   f010031a <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f0111dc9:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f0111dd0:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f0111dd7:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111dde:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111de3:	ff 75 ec             	pushl  -0x14(%ebp)
f0111de6:	ff 75 f0             	pushl  -0x10(%ebp)
f0111de9:	ff 75 f4             	pushl  -0xc(%ebp)
f0111dec:	50                   	push   %eax
f0111ded:	e8 54 6a ff ff       	call   f0108846 <pt_set_page_permissions>
f0111df2:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111df5:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111dfa:	ff 75 ec             	pushl  -0x14(%ebp)
f0111dfd:	ff 75 f0             	pushl  -0x10(%ebp)
f0111e00:	ff 75 f4             	pushl  -0xc(%ebp)
f0111e03:	50                   	push   %eax
f0111e04:	e8 b1 4b 00 00       	call   f01169ba <CP>
f0111e09:	83 c4 10             	add    $0x10,%esp
f0111e0c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111e0f:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111e13:	74 17                	je     f0111e2c <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f0111e15:	83 ec 04             	sub    $0x4,%esp
f0111e18:	68 f0 9b 12 f0       	push   $0xf0129bf0
f0111e1d:	68 5e 01 00 00       	push   $0x15e
f0111e22:	68 42 9b 12 f0       	push   $0xf0129b42
f0111e27:	e8 ee e4 fe ff       	call   f010031a <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f0111e2c:	83 ec 0c             	sub    $0xc,%esp
f0111e2f:	68 1c 9c 12 f0       	push   $0xf0129c1c
f0111e34:	e8 33 f1 fe ff       	call   f0100f6c <cprintf>
f0111e39:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111e3c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111e41:	c9                   	leave  
f0111e42:	c3                   	ret    

f0111e43 <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f0111e43:	55                   	push   %ebp
f0111e44:	89 e5                	mov    %esp,%ebp
f0111e46:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f0111e49:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0111e50:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0111e57:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111e5e:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111e63:	ff 75 ec             	pushl  -0x14(%ebp)
f0111e66:	ff 75 f0             	pushl  -0x10(%ebp)
f0111e69:	ff 75 f4             	pushl  -0xc(%ebp)
f0111e6c:	50                   	push   %eax
f0111e6d:	e8 d4 69 ff ff       	call   f0108846 <pt_set_page_permissions>
f0111e72:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f0111e75:	83 ec 04             	sub    $0x4,%esp
f0111e78:	68 6c 9c 12 f0       	push   $0xf0129c6c
f0111e7d:	68 6b 01 00 00       	push   $0x16b
f0111e82:	68 42 9b 12 f0       	push   $0xf0129b42
f0111e87:	e8 8e e4 fe ff       	call   f010031a <_panic>

f0111e8c <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f0111e8c:	55                   	push   %ebp
f0111e8d:	89 e5                	mov    %esp,%ebp
f0111e8f:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f0111e92:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f0111e99:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111e9e:	83 ec 08             	sub    $0x8,%esp
f0111ea1:	ff 75 f4             	pushl  -0xc(%ebp)
f0111ea4:	50                   	push   %eax
f0111ea5:	e8 60 6a ff ff       	call   f010890a <pt_get_page_permissions>
f0111eaa:	83 c4 10             	add    $0x10,%esp
f0111ead:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f0111eb0:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f0111eb4:	74 17                	je     f0111ecd <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f0111eb6:	83 ec 04             	sub    $0x4,%esp
f0111eb9:	68 08 9d 12 f0       	push   $0xf0129d08
f0111ebe:	68 79 01 00 00       	push   $0x179
f0111ec3:	68 42 9b 12 f0       	push   $0xf0129b42
f0111ec8:	e8 4d e4 fe ff       	call   f010031a <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f0111ecd:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111ed4:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111ed9:	83 ec 08             	sub    $0x8,%esp
f0111edc:	ff 75 f4             	pushl  -0xc(%ebp)
f0111edf:	50                   	push   %eax
f0111ee0:	e8 25 6a ff ff       	call   f010890a <pt_get_page_permissions>
f0111ee5:	83 c4 10             	add    $0x10,%esp
f0111ee8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f0111eeb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111eef:	74 17                	je     f0111f08 <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f0111ef1:	83 ec 04             	sub    $0x4,%esp
f0111ef4:	68 2c 9d 12 f0       	push   $0xf0129d2c
f0111ef9:	68 81 01 00 00       	push   $0x181
f0111efe:	68 42 9b 12 f0       	push   $0xf0129b42
f0111f03:	e8 12 e4 fe ff       	call   f010031a <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f0111f08:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111f0f:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111f14:	83 ec 08             	sub    $0x8,%esp
f0111f17:	ff 75 f4             	pushl  -0xc(%ebp)
f0111f1a:	50                   	push   %eax
f0111f1b:	e8 ea 69 ff ff       	call   f010890a <pt_get_page_permissions>
f0111f20:	83 c4 10             	add    $0x10,%esp
f0111f23:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0111f26:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0111f2a:	74 17                	je     f0111f43 <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f0111f2c:	83 ec 04             	sub    $0x4,%esp
f0111f2f:	68 50 9d 12 f0       	push   $0xf0129d50
f0111f34:	68 89 01 00 00       	push   $0x189
f0111f39:	68 42 9b 12 f0       	push   $0xf0129b42
f0111f3e:	e8 d7 e3 fe ff       	call   f010031a <_panic>
	}

	va = 0xF1000000;
f0111f43:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111f4a:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111f4f:	83 ec 08             	sub    $0x8,%esp
f0111f52:	ff 75 f4             	pushl  -0xc(%ebp)
f0111f55:	50                   	push   %eax
f0111f56:	e8 af 69 ff ff       	call   f010890a <pt_get_page_permissions>
f0111f5b:	83 c4 10             	add    $0x10,%esp
f0111f5e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0111f61:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0111f65:	74 17                	je     f0111f7e <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f0111f67:	83 ec 04             	sub    $0x4,%esp
f0111f6a:	68 74 9d 12 f0       	push   $0xf0129d74
f0111f6f:	68 90 01 00 00       	push   $0x190
f0111f74:	68 42 9b 12 f0       	push   $0xf0129b42
f0111f79:	e8 9c e3 fe ff       	call   f010031a <_panic>
	}

	va = 0xF0001000;
f0111f7e:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111f85:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111f8a:	83 ec 08             	sub    $0x8,%esp
f0111f8d:	ff 75 f4             	pushl  -0xc(%ebp)
f0111f90:	50                   	push   %eax
f0111f91:	e8 74 69 ff ff       	call   f010890a <pt_get_page_permissions>
f0111f96:	83 c4 10             	add    $0x10,%esp
f0111f99:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f0111f9c:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f0111fa0:	74 17                	je     f0111fb9 <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f0111fa2:	83 ec 04             	sub    $0x4,%esp
f0111fa5:	68 98 9d 12 f0       	push   $0xf0129d98
f0111faa:	68 97 01 00 00       	push   $0x197
f0111faf:	68 42 9b 12 f0       	push   $0xf0129b42
f0111fb4:	e8 61 e3 fe ff       	call   f010031a <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f0111fb9:	83 ec 0c             	sub    $0xc,%esp
f0111fbc:	68 bc 9d 12 f0       	push   $0xf0129dbc
f0111fc1:	e8 a6 ef fe ff       	call   f0100f6c <cprintf>
f0111fc6:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111fc9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111fce:	c9                   	leave  
f0111fcf:	c3                   	ret    

f0111fd0 <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f0111fd0:	55                   	push   %ebp
f0111fd1:	89 e5                	mov    %esp,%ebp
f0111fd3:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f0111fd6:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111fdd:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111fe2:	83 ec 08             	sub    $0x8,%esp
f0111fe5:	ff 75 f4             	pushl  -0xc(%ebp)
f0111fe8:	50                   	push   %eax
f0111fe9:	e8 65 69 ff ff       	call   f0108953 <pt_clear_page_table_entry>
f0111fee:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f0111ff1:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111ff6:	83 ec 08             	sub    $0x8,%esp
f0111ff9:	ff 75 f4             	pushl  -0xc(%ebp)
f0111ffc:	50                   	push   %eax
f0111ffd:	e8 14 49 00 00       	call   f0116916 <CE>
f0112002:	83 c4 10             	add    $0x10,%esp
f0112005:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0112008:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f011200c:	74 17                	je     f0112025 <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f011200e:	83 ec 04             	sub    $0x4,%esp
f0112011:	68 04 9e 12 f0       	push   $0xf0129e04
f0112016:	68 a7 01 00 00       	push   $0x1a7
f011201b:	68 42 9b 12 f0       	push   $0xf0129b42
f0112020:	e8 f5 e2 fe ff       	call   f010031a <_panic>
	}

	va = 0xF0001000;
f0112025:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011202c:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0112031:	83 ec 08             	sub    $0x8,%esp
f0112034:	ff 75 f4             	pushl  -0xc(%ebp)
f0112037:	50                   	push   %eax
f0112038:	e8 16 69 ff ff       	call   f0108953 <pt_clear_page_table_entry>
f011203d:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0112040:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0112045:	83 ec 08             	sub    $0x8,%esp
f0112048:	ff 75 f4             	pushl  -0xc(%ebp)
f011204b:	50                   	push   %eax
f011204c:	e8 c5 48 00 00       	call   f0116916 <CE>
f0112051:	83 c4 10             	add    $0x10,%esp
f0112054:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0112057:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f011205b:	74 17                	je     f0112074 <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f011205d:	83 ec 04             	sub    $0x4,%esp
f0112060:	68 30 9e 12 f0       	push   $0xf0129e30
f0112065:	68 af 01 00 00       	push   $0x1af
f011206a:	68 42 9b 12 f0       	push   $0xf0129b42
f011206f:	e8 a6 e2 fe ff       	call   f010031a <_panic>
	}

	va = 0xEF800000;
f0112074:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011207b:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0112080:	83 ec 08             	sub    $0x8,%esp
f0112083:	ff 75 f4             	pushl  -0xc(%ebp)
f0112086:	50                   	push   %eax
f0112087:	e8 c7 68 ff ff       	call   f0108953 <pt_clear_page_table_entry>
f011208c:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f011208f:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0112094:	83 ec 08             	sub    $0x8,%esp
f0112097:	ff 75 f4             	pushl  -0xc(%ebp)
f011209a:	50                   	push   %eax
f011209b:	e8 76 48 00 00       	call   f0116916 <CE>
f01120a0:	83 c4 10             	add    $0x10,%esp
f01120a3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01120a6:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01120aa:	74 17                	je     f01120c3 <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f01120ac:	83 ec 04             	sub    $0x4,%esp
f01120af:	68 5c 9e 12 f0       	push   $0xf0129e5c
f01120b4:	68 b7 01 00 00       	push   $0x1b7
f01120b9:	68 42 9b 12 f0       	push   $0xf0129b42
f01120be:	e8 57 e2 fe ff       	call   f010031a <_panic>
	}

	va = 0xF0000000;
f01120c3:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01120ca:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f01120cf:	83 ec 08             	sub    $0x8,%esp
f01120d2:	ff 75 f4             	pushl  -0xc(%ebp)
f01120d5:	50                   	push   %eax
f01120d6:	e8 78 68 ff ff       	call   f0108953 <pt_clear_page_table_entry>
f01120db:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f01120de:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f01120e3:	83 ec 08             	sub    $0x8,%esp
f01120e6:	ff 75 f4             	pushl  -0xc(%ebp)
f01120e9:	50                   	push   %eax
f01120ea:	e8 27 48 00 00       	call   f0116916 <CE>
f01120ef:	83 c4 10             	add    $0x10,%esp
f01120f2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01120f5:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01120f9:	74 17                	je     f0112112 <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f01120fb:	83 ec 04             	sub    $0x4,%esp
f01120fe:	68 88 9e 12 f0       	push   $0xf0129e88
f0112103:	68 bf 01 00 00       	push   $0x1bf
f0112108:	68 42 9b 12 f0       	push   $0xf0129b42
f011210d:	e8 08 e2 fe ff       	call   f010031a <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f0112112:	83 ec 0c             	sub    $0xc,%esp
f0112115:	68 b4 9e 12 f0       	push   $0xf0129eb4
f011211a:	e8 4d ee fe ff       	call   f0100f6c <cprintf>
f011211f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112122:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112127:	c9                   	leave  
f0112128:	c3                   	ret    

f0112129 <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f0112129:	55                   	push   %ebp
f011212a:	89 e5                	mov    %esp,%ebp
f011212c:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f011212f:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112136:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011213b:	83 ec 08             	sub    $0x8,%esp
f011213e:	ff 75 f4             	pushl  -0xc(%ebp)
f0112141:	50                   	push   %eax
f0112142:	e8 0c 68 ff ff       	call   f0108953 <pt_clear_page_table_entry>
f0112147:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f011214a:	83 ec 04             	sub    $0x4,%esp
f011214d:	68 00 9f 12 f0       	push   $0xf0129f00
f0112152:	68 ca 01 00 00       	push   $0x1ca
f0112157:	68 42 9b 12 f0       	push   $0xf0129b42
f011215c:	e8 b9 e1 fe ff       	call   f010031a <_panic>

f0112161 <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f0112161:	55                   	push   %ebp
f0112162:	89 e5                	mov    %esp,%ebp
f0112164:	57                   	push   %edi
f0112165:	56                   	push   %esi
f0112166:	53                   	push   %ebx
f0112167:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011216d:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0112173:	bb 44 a2 12 f0       	mov    $0xf012a244,%ebx
f0112178:	ba 0f 00 00 00       	mov    $0xf,%edx
f011217d:	89 c7                	mov    %eax,%edi
f011217f:	89 de                	mov    %ebx,%esi
f0112181:	89 d1                	mov    %edx,%ecx
f0112183:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112185:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f011218b:	b9 23 00 00 00       	mov    $0x23,%ecx
f0112190:	b0 00                	mov    $0x0,%al
f0112192:	89 d7                	mov    %edx,%edi
f0112194:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0112196:	6a 00                	push   $0x0
f0112198:	6a 0a                	push   $0xa
f011219a:	6a 14                	push   $0x14
f011219c:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01121a2:	50                   	push   %eax
f01121a3:	e8 e6 75 ff ff       	call   f010978e <env_create>
f01121a8:	83 c4 10             	add    $0x10,%esp
f01121ab:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f01121ae:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01121b1:	8b 40 64             	mov    0x64(%eax),%eax
f01121b4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f01121b7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01121ba:	8b 40 68             	mov    0x68(%eax),%eax
f01121bd:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01121c0:	8b 45 90             	mov    -0x70(%ebp),%eax
f01121c3:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01121c6:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f01121cd:	75 70 20 
f01121d0:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f01121d7:	00 00 00 
f01121da:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f01121e0:	b9 03 00 00 00       	mov    $0x3,%ecx
f01121e5:	b8 00 00 00 00       	mov    $0x0,%eax
f01121ea:	89 d7                	mov    %edx,%edi
f01121ec:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01121ee:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01121f1:	8b 40 10             	mov    0x10(%eax),%eax
f01121f4:	83 ec 08             	sub    $0x8,%esp
f01121f7:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f01121fd:	52                   	push   %edx
f01121fe:	50                   	push   %eax
f01121ff:	e8 f3 e7 00 00       	call   f01209f7 <ltostr>
f0112204:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0112207:	83 ec 04             	sub    $0x4,%esp
f011220a:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112210:	50                   	push   %eax
f0112211:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f0112217:	50                   	push   %eax
f0112218:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f011221e:	50                   	push   %eax
f011221f:	e8 ac e8 00 00       	call   f0120ad0 <strcconcat>
f0112224:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f0112227:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f011222e:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f0112235:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f011223c:	83 ec 0c             	sub    $0xc,%esp
f011223f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112242:	e8 d0 48 00 00       	call   f0116b17 <ClearUserSpace>
f0112247:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f011224a:	83 ec 04             	sub    $0x4,%esp
f011224d:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0112253:	50                   	push   %eax
f0112254:	68 96 9f 12 f0       	push   $0xf0129f96
f0112259:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011225f:	50                   	push   %eax
f0112260:	e8 6b e8 00 00       	call   f0120ad0 <strcconcat>
f0112265:	83 c4 10             	add    $0x10,%esp
f0112268:	83 ec 0c             	sub    $0xc,%esp
f011226b:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0112271:	50                   	push   %eax
f0112272:	e8 65 fc fe ff       	call   f0101edc <execute_command>
f0112277:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f011227a:	83 ec 04             	sub    $0x4,%esp
f011227d:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0112283:	50                   	push   %eax
f0112284:	68 a1 9f 12 f0       	push   $0xf0129fa1
f0112289:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011228f:	50                   	push   %eax
f0112290:	e8 3b e8 00 00       	call   f0120ad0 <strcconcat>
f0112295:	83 c4 10             	add    $0x10,%esp
f0112298:	83 ec 0c             	sub    $0xc,%esp
f011229b:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f01122a1:	50                   	push   %eax
f01122a2:	e8 35 fc fe ff       	call   f0101edc <execute_command>
f01122a7:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f01122aa:	83 ec 04             	sub    $0x4,%esp
f01122ad:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f01122b3:	50                   	push   %eax
f01122b4:	68 ac 9f 12 f0       	push   $0xf0129fac
f01122b9:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01122bf:	50                   	push   %eax
f01122c0:	e8 0b e8 00 00       	call   f0120ad0 <strcconcat>
f01122c5:	83 c4 10             	add    $0x10,%esp
f01122c8:	83 ec 0c             	sub    $0xc,%esp
f01122cb:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f01122d1:	50                   	push   %eax
f01122d2:	e8 05 fc fe ff       	call   f0101edc <execute_command>
f01122d7:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f01122da:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f01122e1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01122e4:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f01122e7:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f01122ee:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01122f1:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f01122f4:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f01122fb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01122fe:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f0112301:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112304:	83 ec 08             	sub    $0x8,%esp
f0112307:	50                   	push   %eax
f0112308:	ff 75 d4             	pushl  -0x2c(%ebp)
f011230b:	e8 6e 47 00 00       	call   f0116a7e <GP>
f0112310:	83 c4 10             	add    $0x10,%esp
f0112313:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f0112316:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f011231d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f0112324:	e8 fe b3 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0112329:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f011232c:	83 ec 0c             	sub    $0xc,%esp
f011232f:	68 b8 9f 12 f0       	push   $0xf0129fb8
f0112334:	e8 33 ec fe ff       	call   f0100f6c <cprintf>
f0112339:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f011233c:	6a 03                	push   $0x3
f011233e:	68 00 00 90 02       	push   $0x2900000
f0112343:	68 00 00 80 02       	push   $0x2800000
f0112348:	ff 75 d4             	pushl  -0x2c(%ebp)
f011234b:	e8 9e 70 ff ff       	call   f01093ee <cut_paste_pages>
f0112350:	83 c4 10             	add    $0x10,%esp
f0112353:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f0112356:	e8 cc b3 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011235b:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f011235e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f0112365:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0112369:	75 08                	jne    f0112373 <test_cut_paste_pages+0x212>
f011236b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011236e:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112371:	74 2b                	je     f011239e <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112373:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112376:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112379:	83 ec 0c             	sub    $0xc,%esp
f011237c:	50                   	push   %eax
f011237d:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112380:	68 e8 9f 12 f0       	push   $0xf0129fe8
f0112385:	68 04 02 00 00       	push   $0x204
f011238a:	68 42 9b 12 f0       	push   $0xf0129b42
f011238f:	e8 23 e1 fe ff       	call   f01004b7 <_warn>
f0112394:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112397:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f011239e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01123a2:	74 04                	je     f01123a8 <test_cut_paste_pages+0x247>
f01123a4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f01123a8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f01123af:	83 ec 08             	sub    $0x8,%esp
f01123b2:	6a 00                	push   $0x0
f01123b4:	6a 01                	push   $0x1
f01123b6:	6a 00                	push   $0x0
f01123b8:	68 ff 0f 00 00       	push   $0xfff
f01123bd:	ff 75 bc             	pushl  -0x44(%ebp)
f01123c0:	6a 01                	push   $0x1
f01123c2:	68 00 30 00 00       	push   $0x3000
f01123c7:	68 00 00 90 02       	push   $0x2900000
f01123cc:	68 00 00 80 02       	push   $0x2800000
f01123d1:	ff 75 d4             	pushl  -0x2c(%ebp)
f01123d4:	e8 72 47 00 00       	call   f0116b4b <CCP>
f01123d9:	83 c4 30             	add    $0x30,%esp
f01123dc:	83 f8 01             	cmp    $0x1,%eax
f01123df:	74 21                	je     f0112402 <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f01123e1:	83 ec 04             	sub    $0x4,%esp
f01123e4:	68 3c a0 12 f0       	push   $0xf012a03c
f01123e9:	68 0c 02 00 00       	push   $0x20c
f01123ee:	68 42 9b 12 f0       	push   $0xf0129b42
f01123f3:	e8 bf e0 fe ff       	call   f01004b7 <_warn>
f01123f8:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01123fb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f0112402:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112406:	74 04                	je     f011240c <test_cut_paste_pages+0x2ab>
f0112408:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f011240c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f0112413:	83 ec 04             	sub    $0x4,%esp
f0112416:	6a 00                	push   $0x0
f0112418:	68 00 00 90 02       	push   $0x2900000
f011241d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112420:	e8 b7 41 00 00       	call   f01165dc <CB>
f0112425:	83 c4 10             	add    $0x10,%esp
f0112428:	85 c0                	test   %eax,%eax
f011242a:	0f 84 f6 00 00 00    	je     f0112526 <test_cut_paste_pages+0x3c5>
f0112430:	83 ec 04             	sub    $0x4,%esp
f0112433:	6a 00                	push   $0x0
f0112435:	68 00 10 90 02       	push   $0x2901000
f011243a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011243d:	e8 9a 41 00 00       	call   f01165dc <CB>
f0112442:	83 c4 10             	add    $0x10,%esp
f0112445:	85 c0                	test   %eax,%eax
f0112447:	0f 84 d9 00 00 00    	je     f0112526 <test_cut_paste_pages+0x3c5>
f011244d:	83 ec 04             	sub    $0x4,%esp
f0112450:	6a 00                	push   $0x0
f0112452:	68 00 20 90 02       	push   $0x2902000
f0112457:	ff 75 d4             	pushl  -0x2c(%ebp)
f011245a:	e8 7d 41 00 00       	call   f01165dc <CB>
f011245f:	83 c4 10             	add    $0x10,%esp
f0112462:	85 c0                	test   %eax,%eax
f0112464:	0f 84 bc 00 00 00    	je     f0112526 <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f011246a:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f0112471:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f0112478:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f011247f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112482:	8a 00                	mov    (%eax),%al
f0112484:	3c 61                	cmp    $0x61,%al
f0112486:	75 12                	jne    f011249a <test_cut_paste_pages+0x339>
f0112488:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011248b:	8a 00                	mov    (%eax),%al
f011248d:	3c 62                	cmp    $0x62,%al
f011248f:	75 09                	jne    f011249a <test_cut_paste_pages+0x339>
f0112491:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112494:	8a 00                	mov    (%eax),%al
f0112496:	3c 63                	cmp    $0x63,%al
f0112498:	74 21                	je     f01124bb <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f011249a:	83 ec 04             	sub    $0x4,%esp
f011249d:	68 88 a0 12 f0       	push   $0xf012a088
f01124a2:	68 19 02 00 00       	push   $0x219
f01124a7:	68 42 9b 12 f0       	push   $0xf0129b42
f01124ac:	e8 06 e0 fe ff       	call   f01004b7 <_warn>
f01124b1:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01124b4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01124bb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01124bf:	74 04                	je     f01124c5 <test_cut_paste_pages+0x364>
f01124c1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01124c5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f01124cc:	83 ec 04             	sub    $0x4,%esp
f01124cf:	6a 01                	push   $0x1
f01124d1:	68 00 10 90 02       	push   $0x2901000
f01124d6:	ff 75 d4             	pushl  -0x2c(%ebp)
f01124d9:	e8 fe 40 00 00       	call   f01165dc <CB>
f01124de:	83 c4 10             	add    $0x10,%esp
f01124e1:	85 c0                	test   %eax,%eax
f01124e3:	74 41                	je     f0112526 <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f01124e5:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01124e8:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f01124eb:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01124ee:	8a 00                	mov    (%eax),%al
f01124f0:	3c 79                	cmp    $0x79,%al
f01124f2:	74 21                	je     f0112515 <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01124f4:	83 ec 04             	sub    $0x4,%esp
f01124f7:	68 88 a0 12 f0       	push   $0xf012a088
f01124fc:	68 24 02 00 00       	push   $0x224
f0112501:	68 42 9b 12 f0       	push   $0xf0129b42
f0112506:	e8 ac df fe ff       	call   f01004b7 <_warn>
f011250b:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011250e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0112515:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112519:	74 04                	je     f011251f <test_cut_paste_pages+0x3be>
f011251b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011251f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f0112526:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0112529:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f011252c:	6a 02                	push   $0x2
f011252e:	68 00 f0 bf 02       	push   $0x2bff000
f0112533:	68 00 10 90 02       	push   $0x2901000
f0112538:	ff 75 d4             	pushl  -0x2c(%ebp)
f011253b:	e8 ae 6e ff ff       	call   f01093ee <cut_paste_pages>
f0112540:	83 c4 10             	add    $0x10,%esp
f0112543:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112546:	e8 dc b1 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011254b:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f011254e:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0112552:	75 0b                	jne    f011255f <test_cut_paste_pages+0x3fe>
f0112554:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112557:	2b 45 b0             	sub    -0x50(%ebp),%eax
f011255a:	83 f8 01             	cmp    $0x1,%eax
f011255d:	74 2b                	je     f011258a <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f011255f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112562:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112565:	83 ec 0c             	sub    $0xc,%esp
f0112568:	50                   	push   %eax
f0112569:	ff 75 b4             	pushl  -0x4c(%ebp)
f011256c:	68 e8 9f 12 f0       	push   $0xf0129fe8
f0112571:	68 35 02 00 00       	push   $0x235
f0112576:	68 42 9b 12 f0       	push   $0xf0129b42
f011257b:	e8 37 df fe ff       	call   f01004b7 <_warn>
f0112580:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112583:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f011258a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011258e:	74 04                	je     f0112594 <test_cut_paste_pages+0x433>
f0112590:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112594:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f011259b:	83 ec 08             	sub    $0x8,%esp
f011259e:	6a 00                	push   $0x0
f01125a0:	6a 01                	push   $0x1
f01125a2:	6a 00                	push   $0x0
f01125a4:	68 ff 0f 00 00       	push   $0xfff
f01125a9:	ff 75 bc             	pushl  -0x44(%ebp)
f01125ac:	6a 01                	push   $0x1
f01125ae:	68 00 20 00 00       	push   $0x2000
f01125b3:	68 00 f0 bf 02       	push   $0x2bff000
f01125b8:	68 00 10 90 02       	push   $0x2901000
f01125bd:	ff 75 d4             	pushl  -0x2c(%ebp)
f01125c0:	e8 86 45 00 00       	call   f0116b4b <CCP>
f01125c5:	83 c4 30             	add    $0x30,%esp
f01125c8:	83 f8 01             	cmp    $0x1,%eax
f01125cb:	74 21                	je     f01125ee <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f01125cd:	83 ec 04             	sub    $0x4,%esp
f01125d0:	68 3c a0 12 f0       	push   $0xf012a03c
f01125d5:	68 3d 02 00 00       	push   $0x23d
f01125da:	68 42 9b 12 f0       	push   $0xf0129b42
f01125df:	e8 d3 de fe ff       	call   f01004b7 <_warn>
f01125e4:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01125e7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01125ee:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01125f2:	74 04                	je     f01125f8 <test_cut_paste_pages+0x497>
f01125f4:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01125f8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f01125ff:	83 ec 04             	sub    $0x4,%esp
f0112602:	6a 00                	push   $0x0
f0112604:	68 ff f7 bf 02       	push   $0x2bff7ff
f0112609:	ff 75 d4             	pushl  -0x2c(%ebp)
f011260c:	e8 cb 3f 00 00       	call   f01165dc <CB>
f0112611:	83 c4 10             	add    $0x10,%esp
f0112614:	85 c0                	test   %eax,%eax
f0112616:	74 6b                	je     f0112683 <test_cut_paste_pages+0x522>
f0112618:	83 ec 04             	sub    $0x4,%esp
f011261b:	6a 00                	push   $0x0
f011261d:	68 ff 0f c0 02       	push   $0x2c00fff
f0112622:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112625:	e8 b2 3f 00 00       	call   f01165dc <CB>
f011262a:	83 c4 10             	add    $0x10,%esp
f011262d:	85 c0                	test   %eax,%eax
f011262f:	74 52                	je     f0112683 <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f0112631:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f0112638:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f011263f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112642:	8a 00                	mov    (%eax),%al
f0112644:	3c 79                	cmp    $0x79,%al
f0112646:	75 09                	jne    f0112651 <test_cut_paste_pages+0x4f0>
f0112648:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011264b:	8a 00                	mov    (%eax),%al
f011264d:	3c 63                	cmp    $0x63,%al
f011264f:	74 21                	je     f0112672 <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112651:	83 ec 04             	sub    $0x4,%esp
f0112654:	68 88 a0 12 f0       	push   $0xf012a088
f0112659:	68 49 02 00 00       	push   $0x249
f011265e:	68 42 9b 12 f0       	push   $0xf0129b42
f0112663:	e8 4f de fe ff       	call   f01004b7 <_warn>
f0112668:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011266b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112672:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112676:	74 04                	je     f011267c <test_cut_paste_pages+0x51b>
f0112678:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011267c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f0112683:	83 ec 0c             	sub    $0xc,%esp
f0112686:	68 c1 a0 12 f0       	push   $0xf012a0c1
f011268b:	e8 dc e8 fe ff       	call   f0100f6c <cprintf>
f0112690:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f0112693:	83 ec 0c             	sub    $0xc,%esp
f0112696:	68 d0 a0 12 f0       	push   $0xf012a0d0
f011269b:	e8 cc e8 fe ff       	call   f0100f6c <cprintf>
f01126a0:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f01126a3:	83 ec 04             	sub    $0x4,%esp
f01126a6:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f01126ac:	50                   	push   %eax
f01126ad:	68 f9 a0 12 f0       	push   $0xf012a0f9
f01126b2:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01126b8:	50                   	push   %eax
f01126b9:	e8 12 e4 00 00       	call   f0120ad0 <strcconcat>
f01126be:	83 c4 10             	add    $0x10,%esp
f01126c1:	83 ec 0c             	sub    $0xc,%esp
f01126c4:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f01126ca:	50                   	push   %eax
f01126cb:	e8 0c f8 fe ff       	call   f0101edc <execute_command>
f01126d0:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f01126d3:	83 ec 04             	sub    $0x4,%esp
f01126d6:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f01126dc:	50                   	push   %eax
f01126dd:	68 04 a1 12 f0       	push   $0xf012a104
f01126e2:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01126e8:	50                   	push   %eax
f01126e9:	e8 e2 e3 00 00       	call   f0120ad0 <strcconcat>
f01126ee:	83 c4 10             	add    $0x10,%esp
f01126f1:	83 ec 0c             	sub    $0xc,%esp
f01126f4:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f01126fa:	50                   	push   %eax
f01126fb:	e8 dc f7 fe ff       	call   f0101edc <execute_command>
f0112700:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f0112703:	83 ec 04             	sub    $0x4,%esp
f0112706:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f011270c:	50                   	push   %eax
f011270d:	68 0f a1 12 f0       	push   $0xf012a10f
f0112712:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112718:	50                   	push   %eax
f0112719:	e8 b2 e3 00 00       	call   f0120ad0 <strcconcat>
f011271e:	83 c4 10             	add    $0x10,%esp
f0112721:	83 ec 0c             	sub    $0xc,%esp
f0112724:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f011272a:	50                   	push   %eax
f011272b:	e8 ac f7 fe ff       	call   f0101edc <execute_command>
f0112730:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f0112733:	83 ec 04             	sub    $0x4,%esp
f0112736:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f011273c:	50                   	push   %eax
f011273d:	68 1a a1 12 f0       	push   $0xf012a11a
f0112742:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112748:	50                   	push   %eax
f0112749:	e8 82 e3 00 00       	call   f0120ad0 <strcconcat>
f011274e:	83 c4 10             	add    $0x10,%esp
f0112751:	83 ec 0c             	sub    $0xc,%esp
f0112754:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f011275a:	50                   	push   %eax
f011275b:	e8 7c f7 fe ff       	call   f0101edc <execute_command>
f0112760:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f0112763:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f011276a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011276d:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f0112770:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f0112777:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011277a:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f011277d:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f0112784:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112787:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f011278a:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f0112791:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112794:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f0112797:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f011279e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01127a1:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f01127a4:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f01127ab:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01127ae:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f01127b1:	83 ec 08             	sub    $0x8,%esp
f01127b4:	68 00 00 c0 01       	push   $0x1c00000
f01127b9:	ff 75 d4             	pushl  -0x2c(%ebp)
f01127bc:	e8 bd 42 00 00       	call   f0116a7e <GP>
f01127c1:	83 c4 10             	add    $0x10,%esp
f01127c4:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f01127c7:	83 ec 08             	sub    $0x8,%esp
f01127ca:	68 00 00 40 01       	push   $0x1400000
f01127cf:	ff 75 d4             	pushl  -0x2c(%ebp)
f01127d2:	e8 a7 42 00 00       	call   f0116a7e <GP>
f01127d7:	83 c4 10             	add    $0x10,%esp
f01127da:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f01127dd:	e8 45 af ff ff       	call   f010d727 <sys_calculate_free_frames>
f01127e2:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f01127e5:	6a 01                	push   $0x1
f01127e7:	68 00 00 40 01       	push   $0x1400000
f01127ec:	68 00 00 c0 01       	push   $0x1c00000
f01127f1:	ff 75 d4             	pushl  -0x2c(%ebp)
f01127f4:	e8 f5 6b ff ff       	call   f01093ee <cut_paste_pages>
f01127f9:	83 c4 10             	add    $0x10,%esp
f01127fc:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f01127ff:	e8 23 af ff ff       	call   f010d727 <sys_calculate_free_frames>
f0112804:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0112807:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f011280b:	75 08                	jne    f0112815 <test_cut_paste_pages+0x6b4>
f011280d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112810:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112813:	74 2b                	je     f0112840 <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112815:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112818:	2b 45 b0             	sub    -0x50(%ebp),%eax
f011281b:	83 ec 0c             	sub    $0xc,%esp
f011281e:	50                   	push   %eax
f011281f:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112822:	68 28 a1 12 f0       	push   $0xf012a128
f0112827:	68 6c 02 00 00       	push   $0x26c
f011282c:	68 42 9b 12 f0       	push   $0xf0129b42
f0112831:	e8 81 dc fe ff       	call   f01004b7 <_warn>
f0112836:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112839:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112840:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112844:	74 04                	je     f011284a <test_cut_paste_pages+0x6e9>
f0112846:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f011284a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f0112851:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f0112858:	83 ec 08             	sub    $0x8,%esp
f011285b:	6a 00                	push   $0x0
f011285d:	68 ff 0f 00 00       	push   $0xfff
f0112862:	ff 75 a4             	pushl  -0x5c(%ebp)
f0112865:	68 ff 0f 00 00       	push   $0xfff
f011286a:	ff 75 a0             	pushl  -0x60(%ebp)
f011286d:	6a 01                	push   $0x1
f011286f:	68 00 10 00 00       	push   $0x1000
f0112874:	68 00 00 40 01       	push   $0x1400000
f0112879:	68 00 00 c0 01       	push   $0x1c00000
f011287e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112881:	e8 c5 42 00 00       	call   f0116b4b <CCP>
f0112886:	83 c4 30             	add    $0x30,%esp
f0112889:	83 f8 01             	cmp    $0x1,%eax
f011288c:	74 28                	je     f01128b6 <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f011288e:	83 ec 04             	sub    $0x4,%esp
f0112891:	68 3c a0 12 f0       	push   $0xf012a03c
f0112896:	68 75 02 00 00       	push   $0x275
f011289b:	68 42 9b 12 f0       	push   $0xf0129b42
f01128a0:	e8 12 dc fe ff       	call   f01004b7 <_warn>
f01128a5:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01128a8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f01128af:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f01128b6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01128ba:	74 04                	je     f01128c0 <test_cut_paste_pages+0x75f>
f01128bc:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f01128c0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f01128c7:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01128cb:	0f 84 92 00 00 00    	je     f0112963 <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f01128d1:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f01128d8:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f01128df:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f01128e6:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f01128ed:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f01128f4:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f01128fb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01128fe:	8a 00                	mov    (%eax),%al
f0112900:	3c 61                	cmp    $0x61,%al
f0112902:	75 2d                	jne    f0112931 <test_cut_paste_pages+0x7d0>
f0112904:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112907:	8a 00                	mov    (%eax),%al
f0112909:	3c 78                	cmp    $0x78,%al
f011290b:	75 24                	jne    f0112931 <test_cut_paste_pages+0x7d0>
f011290d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112910:	8a 00                	mov    (%eax),%al
f0112912:	3c 62                	cmp    $0x62,%al
f0112914:	75 1b                	jne    f0112931 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112916:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112919:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f011291b:	3c 79                	cmp    $0x79,%al
f011291d:	75 12                	jne    f0112931 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f011291f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112922:	8a 00                	mov    (%eax),%al
f0112924:	3c 63                	cmp    $0x63,%al
f0112926:	75 09                	jne    f0112931 <test_cut_paste_pages+0x7d0>
f0112928:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011292b:	8a 00                	mov    (%eax),%al
f011292d:	3c 7a                	cmp    $0x7a,%al
f011292f:	74 21                	je     f0112952 <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112931:	83 ec 04             	sub    $0x4,%esp
f0112934:	68 88 a0 12 f0       	push   $0xf012a088
f0112939:	68 87 02 00 00       	push   $0x287
f011293e:	68 42 9b 12 f0       	push   $0xf0129b42
f0112943:	e8 6f db fe ff       	call   f01004b7 <_warn>
f0112948:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011294b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112952:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112956:	74 04                	je     f011295c <test_cut_paste_pages+0x7fb>
f0112958:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011295c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f0112963:	e8 bf ad ff ff       	call   f010d727 <sys_calculate_free_frames>
f0112968:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f011296b:	6a 03                	push   $0x3
f011296d:	68 00 f0 bf 01       	push   $0x1bff000
f0112972:	68 00 00 40 01       	push   $0x1400000
f0112977:	ff 75 d4             	pushl  -0x2c(%ebp)
f011297a:	e8 6f 6a ff ff       	call   f01093ee <cut_paste_pages>
f011297f:	83 c4 10             	add    $0x10,%esp
f0112982:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112985:	e8 9d ad ff ff       	call   f010d727 <sys_calculate_free_frames>
f011298a:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f011298d:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0112991:	75 08                	jne    f011299b <test_cut_paste_pages+0x83a>
f0112993:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112996:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112999:	74 2b                	je     f01129c6 <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f011299b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011299e:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01129a1:	83 ec 0c             	sub    $0xc,%esp
f01129a4:	50                   	push   %eax
f01129a5:	ff 75 b4             	pushl  -0x4c(%ebp)
f01129a8:	68 28 a1 12 f0       	push   $0xf012a128
f01129ad:	68 96 02 00 00       	push   $0x296
f01129b2:	68 42 9b 12 f0       	push   $0xf0129b42
f01129b7:	e8 fb da fe ff       	call   f01004b7 <_warn>
f01129bc:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01129bf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01129c6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01129ca:	74 04                	je     f01129d0 <test_cut_paste_pages+0x86f>
f01129cc:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01129d0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f01129d7:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f01129de:	83 ec 04             	sub    $0x4,%esp
f01129e1:	6a 00                	push   $0x0
f01129e3:	68 00 00 40 01       	push   $0x1400000
f01129e8:	ff 75 d4             	pushl  -0x2c(%ebp)
f01129eb:	e8 ec 3b 00 00       	call   f01165dc <CB>
f01129f0:	83 c4 10             	add    $0x10,%esp
f01129f3:	83 f8 01             	cmp    $0x1,%eax
f01129f6:	0f 85 80 00 00 00    	jne    f0112a7c <test_cut_paste_pages+0x91b>
f01129fc:	83 ec 04             	sub    $0x4,%esp
f01129ff:	6a 00                	push   $0x0
f0112a01:	68 00 10 40 01       	push   $0x1401000
f0112a06:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a09:	e8 ce 3b 00 00       	call   f01165dc <CB>
f0112a0e:	83 c4 10             	add    $0x10,%esp
f0112a11:	83 f8 01             	cmp    $0x1,%eax
f0112a14:	75 66                	jne    f0112a7c <test_cut_paste_pages+0x91b>
f0112a16:	83 ec 04             	sub    $0x4,%esp
f0112a19:	6a 00                	push   $0x0
f0112a1b:	68 00 20 40 01       	push   $0x1402000
f0112a20:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a23:	e8 b4 3b 00 00       	call   f01165dc <CB>
f0112a28:	83 c4 10             	add    $0x10,%esp
f0112a2b:	83 f8 01             	cmp    $0x1,%eax
f0112a2e:	75 4c                	jne    f0112a7c <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0112a30:	83 ec 04             	sub    $0x4,%esp
f0112a33:	6a 00                	push   $0x0
f0112a35:	68 00 f0 bf 01       	push   $0x1bff000
f0112a3a:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a3d:	e8 9a 3b 00 00       	call   f01165dc <CB>
f0112a42:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0112a45:	85 c0                	test   %eax,%eax
f0112a47:	75 33                	jne    f0112a7c <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0112a49:	83 ec 04             	sub    $0x4,%esp
f0112a4c:	6a 00                	push   $0x0
f0112a4e:	68 00 00 c0 01       	push   $0x1c00000
f0112a53:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a56:	e8 81 3b 00 00       	call   f01165dc <CB>
f0112a5b:	83 c4 10             	add    $0x10,%esp
f0112a5e:	83 f8 01             	cmp    $0x1,%eax
f0112a61:	75 19                	jne    f0112a7c <test_cut_paste_pages+0x91b>
f0112a63:	83 ec 04             	sub    $0x4,%esp
f0112a66:	6a 00                	push   $0x0
f0112a68:	68 00 10 c0 01       	push   $0x1c01000
f0112a6d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a70:	e8 67 3b 00 00       	call   f01165dc <CB>
f0112a75:	83 c4 10             	add    $0x10,%esp
f0112a78:	85 c0                	test   %eax,%eax
f0112a7a:	74 28                	je     f0112aa4 <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f0112a7c:	83 ec 04             	sub    $0x4,%esp
f0112a7f:	68 88 a1 12 f0       	push   $0xf012a188
f0112a84:	68 9f 02 00 00       	push   $0x29f
f0112a89:	68 42 9b 12 f0       	push   $0xf0129b42
f0112a8e:	e8 24 da fe ff       	call   f01004b7 <_warn>
f0112a93:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112a96:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0112a9d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0112aa4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112aa8:	74 04                	je     f0112aae <test_cut_paste_pages+0x94d>
f0112aaa:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112aae:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0112ab5:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112ab9:	0f 84 99 00 00 00    	je     f0112b58 <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f0112abf:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0112ac6:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0112acd:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0112ad4:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0112adb:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0112ae2:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112ae9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112aec:	8a 00                	mov    (%eax),%al
f0112aee:	3c 61                	cmp    $0x61,%al
f0112af0:	75 2d                	jne    f0112b1f <test_cut_paste_pages+0x9be>
f0112af2:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112af5:	8a 00                	mov    (%eax),%al
f0112af7:	3c 78                	cmp    $0x78,%al
f0112af9:	75 24                	jne    f0112b1f <test_cut_paste_pages+0x9be>
f0112afb:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112afe:	8a 00                	mov    (%eax),%al
f0112b00:	3c 62                	cmp    $0x62,%al
f0112b02:	75 1b                	jne    f0112b1f <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112b04:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112b07:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112b09:	3c 79                	cmp    $0x79,%al
f0112b0b:	75 12                	jne    f0112b1f <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112b0d:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112b10:	8a 00                	mov    (%eax),%al
f0112b12:	3c 63                	cmp    $0x63,%al
f0112b14:	75 09                	jne    f0112b1f <test_cut_paste_pages+0x9be>
f0112b16:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112b19:	8a 00                	mov    (%eax),%al
f0112b1b:	3c 7a                	cmp    $0x7a,%al
f0112b1d:	74 28                	je     f0112b47 <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f0112b1f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f0112b26:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112b2d:	83 ec 04             	sub    $0x4,%esp
f0112b30:	68 88 a0 12 f0       	push   $0xf012a088
f0112b35:	68 b3 02 00 00       	push   $0x2b3
f0112b3a:	68 42 9b 12 f0       	push   $0xf0129b42
f0112b3f:	e8 73 d9 fe ff       	call   f01004b7 <_warn>
f0112b44:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f0112b47:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112b4b:	74 04                	je     f0112b51 <test_cut_paste_pages+0x9f0>
f0112b4d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112b51:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f0112b58:	83 ec 0c             	sub    $0xc,%esp
f0112b5b:	68 c1 a1 12 f0       	push   $0xf012a1c1
f0112b60:	e8 07 e4 fe ff       	call   f0100f6c <cprintf>
f0112b65:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f0112b68:	83 ec 08             	sub    $0x8,%esp
f0112b6b:	ff 75 e4             	pushl  -0x1c(%ebp)
f0112b6e:	68 d0 a1 12 f0       	push   $0xf012a1d0
f0112b73:	e8 f4 e3 fe ff       	call   f0100f6c <cprintf>
f0112b78:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0112b7b:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0112b7f:	75 10                	jne    f0112b91 <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f0112b81:	83 ec 0c             	sub    $0xc,%esp
f0112b84:	68 04 a2 12 f0       	push   $0xf012a204
f0112b89:	e8 de e3 fe ff       	call   f0100f6c <cprintf>
f0112b8e:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0112b91:	a1 e4 51 55 f0       	mov    0xf05551e4,%eax
f0112b96:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0112b99:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0112b9c:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0112b9f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112ba4:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0112ba7:	5b                   	pop    %ebx
f0112ba8:	5e                   	pop    %esi
f0112ba9:	5f                   	pop    %edi
f0112baa:	5d                   	pop    %ebp
f0112bab:	c3                   	ret    

f0112bac <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f0112bac:	55                   	push   %ebp
f0112bad:	89 e5                	mov    %esp,%ebp
f0112baf:	57                   	push   %edi
f0112bb0:	56                   	push   %esi
f0112bb1:	53                   	push   %ebx
f0112bb2:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0112bb8:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0112bbe:	bb 44 a2 12 f0       	mov    $0xf012a244,%ebx
f0112bc3:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112bc8:	89 c7                	mov    %eax,%edi
f0112bca:	89 de                	mov    %ebx,%esi
f0112bcc:	89 d1                	mov    %edx,%ecx
f0112bce:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112bd0:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f0112bd6:	b9 23 00 00 00       	mov    $0x23,%ecx
f0112bdb:	b0 00                	mov    $0x0,%al
f0112bdd:	89 d7                	mov    %edx,%edi
f0112bdf:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0112be1:	6a 00                	push   $0x0
f0112be3:	6a 0a                	push   $0xa
f0112be5:	6a 14                	push   $0x14
f0112be7:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0112bed:	50                   	push   %eax
f0112bee:	e8 9b 6b ff ff       	call   f010978e <env_create>
f0112bf3:	83 c4 10             	add    $0x10,%esp
f0112bf6:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0112bf9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112bfc:	8b 40 64             	mov    0x64(%eax),%eax
f0112bff:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0112c02:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112c05:	8b 40 68             	mov    0x68(%eax),%eax
f0112c08:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0112c0e:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0112c14:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0112c17:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f0112c1e:	75 70 20 
f0112c21:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f0112c28:	00 00 00 
f0112c2b:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0112c31:	b9 03 00 00 00       	mov    $0x3,%ecx
f0112c36:	b8 00 00 00 00       	mov    $0x0,%eax
f0112c3b:	89 d7                	mov    %edx,%edi
f0112c3d:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0112c3f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112c42:	8b 40 10             	mov    0x10(%eax),%eax
f0112c45:	83 ec 08             	sub    $0x8,%esp
f0112c48:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f0112c4e:	52                   	push   %edx
f0112c4f:	50                   	push   %eax
f0112c50:	e8 a2 dd 00 00       	call   f01209f7 <ltostr>
f0112c55:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0112c58:	83 ec 04             	sub    $0x4,%esp
f0112c5b:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112c61:	50                   	push   %eax
f0112c62:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f0112c68:	50                   	push   %eax
f0112c69:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f0112c6f:	50                   	push   %eax
f0112c70:	e8 5b de 00 00       	call   f0120ad0 <strcconcat>
f0112c75:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f0112c78:	83 ec 0c             	sub    $0xc,%esp
f0112c7b:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c7e:	e8 94 3e 00 00       	call   f0116b17 <ClearUserSpace>
f0112c83:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f0112c86:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f0112c8d:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f0112c94:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0112c9b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f0112ca2:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0112ca9:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f0112cb0:	83 ec 0c             	sub    $0xc,%esp
f0112cb3:	68 78 a2 12 f0       	push   $0xf012a278
f0112cb8:	e8 af e2 fe ff       	call   f0100f6c <cprintf>
f0112cbd:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0112cc0:	83 ec 04             	sub    $0x4,%esp
f0112cc3:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112cc9:	50                   	push   %eax
f0112cca:	68 ae a2 12 f0       	push   $0xf012a2ae
f0112ccf:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112cd5:	50                   	push   %eax
f0112cd6:	e8 f5 dd 00 00       	call   f0120ad0 <strcconcat>
f0112cdb:	83 c4 10             	add    $0x10,%esp
f0112cde:	83 ec 0c             	sub    $0xc,%esp
f0112ce1:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112ce7:	50                   	push   %eax
f0112ce8:	e8 ef f1 fe ff       	call   f0101edc <execute_command>
f0112ced:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f0112cf0:	83 ec 04             	sub    $0x4,%esp
f0112cf3:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112cf9:	50                   	push   %eax
f0112cfa:	68 b3 a2 12 f0       	push   $0xf012a2b3
f0112cff:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112d05:	50                   	push   %eax
f0112d06:	e8 c5 dd 00 00       	call   f0120ad0 <strcconcat>
f0112d0b:	83 c4 10             	add    $0x10,%esp
f0112d0e:	83 ec 0c             	sub    $0xc,%esp
f0112d11:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112d17:	50                   	push   %eax
f0112d18:	e8 bf f1 fe ff       	call   f0101edc <execute_command>
f0112d1d:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f0112d20:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112d26:	bb b9 a5 12 f0       	mov    $0xf012a5b9,%ebx
f0112d2b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112d30:	89 c7                	mov    %eax,%edi
f0112d32:	89 de                	mov    %ebx,%esi
f0112d34:	89 d1                	mov    %edx,%ecx
f0112d36:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112d38:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0112d3e:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112d43:	b0 00                	mov    $0x0,%al
f0112d45:	89 d7                	mov    %edx,%edi
f0112d47:	f3 aa                	rep stos %al,%es:(%edi)
f0112d49:	83 ec 0c             	sub    $0xc,%esp
f0112d4c:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112d52:	50                   	push   %eax
f0112d53:	e8 84 f1 fe ff       	call   f0101edc <execute_command>
f0112d58:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f0112d5b:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112d61:	bb 1d a6 12 f0       	mov    $0xf012a61d,%ebx
f0112d66:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112d6b:	89 c7                	mov    %eax,%edi
f0112d6d:	89 de                	mov    %ebx,%esi
f0112d6f:	89 d1                	mov    %edx,%ecx
f0112d71:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112d73:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0112d79:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112d7e:	b0 00                	mov    $0x0,%al
f0112d80:	89 d7                	mov    %edx,%edi
f0112d82:	f3 aa                	rep stos %al,%es:(%edi)
f0112d84:	83 ec 0c             	sub    $0xc,%esp
f0112d87:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112d8d:	50                   	push   %eax
f0112d8e:	e8 49 f1 fe ff       	call   f0101edc <execute_command>
f0112d93:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f0112d96:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0112d9c:	bb 81 a6 12 f0       	mov    $0xf012a681,%ebx
f0112da1:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112da6:	89 c7                	mov    %eax,%edi
f0112da8:	89 de                	mov    %ebx,%esi
f0112daa:	89 d1                	mov    %edx,%ecx
f0112dac:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112dae:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0112db4:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112db9:	b0 00                	mov    $0x0,%al
f0112dbb:	89 d7                	mov    %edx,%edi
f0112dbd:	f3 aa                	rep stos %al,%es:(%edi)
f0112dbf:	83 ec 0c             	sub    $0xc,%esp
f0112dc2:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0112dc8:	50                   	push   %eax
f0112dc9:	e8 0e f1 fe ff       	call   f0101edc <execute_command>
f0112dce:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f0112dd1:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0112dd7:	bb e5 a6 12 f0       	mov    $0xf012a6e5,%ebx
f0112ddc:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112de1:	89 c7                	mov    %eax,%edi
f0112de3:	89 de                	mov    %ebx,%esi
f0112de5:	89 d1                	mov    %edx,%ecx
f0112de7:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112de9:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0112def:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112df4:	b0 00                	mov    $0x0,%al
f0112df6:	89 d7                	mov    %edx,%edi
f0112df8:	f3 aa                	rep stos %al,%es:(%edi)
f0112dfa:	83 ec 0c             	sub    $0xc,%esp
f0112dfd:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0112e03:	50                   	push   %eax
f0112e04:	e8 d3 f0 fe ff       	call   f0101edc <execute_command>
f0112e09:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f0112e0c:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0112e12:	bb 49 a7 12 f0       	mov    $0xf012a749,%ebx
f0112e17:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112e1c:	89 c7                	mov    %eax,%edi
f0112e1e:	89 de                	mov    %ebx,%esi
f0112e20:	89 d1                	mov    %edx,%ecx
f0112e22:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112e24:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0112e2a:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112e2f:	b0 00                	mov    $0x0,%al
f0112e31:	89 d7                	mov    %edx,%edi
f0112e33:	f3 aa                	rep stos %al,%es:(%edi)
f0112e35:	83 ec 0c             	sub    $0xc,%esp
f0112e38:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0112e3e:	50                   	push   %eax
f0112e3f:	e8 98 f0 fe ff       	call   f0101edc <execute_command>
f0112e44:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f0112e47:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0112e4d:	bb ad a7 12 f0       	mov    $0xf012a7ad,%ebx
f0112e52:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112e57:	89 c7                	mov    %eax,%edi
f0112e59:	89 de                	mov    %ebx,%esi
f0112e5b:	89 d1                	mov    %edx,%ecx
f0112e5d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112e5f:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0112e65:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112e6a:	b0 00                	mov    $0x0,%al
f0112e6c:	89 d7                	mov    %edx,%edi
f0112e6e:	f3 aa                	rep stos %al,%es:(%edi)
f0112e70:	83 ec 0c             	sub    $0xc,%esp
f0112e73:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0112e79:	50                   	push   %eax
f0112e7a:	e8 5d f0 fe ff       	call   f0101edc <execute_command>
f0112e7f:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f0112e82:	83 ec 04             	sub    $0x4,%esp
f0112e85:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112e8b:	50                   	push   %eax
f0112e8c:	68 bb a2 12 f0       	push   $0xf012a2bb
f0112e91:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112e97:	50                   	push   %eax
f0112e98:	e8 33 dc 00 00       	call   f0120ad0 <strcconcat>
f0112e9d:	83 c4 10             	add    $0x10,%esp
f0112ea0:	83 ec 0c             	sub    $0xc,%esp
f0112ea3:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112ea9:	50                   	push   %eax
f0112eaa:	e8 2d f0 fe ff       	call   f0101edc <execute_command>
f0112eaf:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f0112eb2:	83 ec 04             	sub    $0x4,%esp
f0112eb5:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112ebb:	50                   	push   %eax
f0112ebc:	68 c5 a2 12 f0       	push   $0xf012a2c5
f0112ec1:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112ec7:	50                   	push   %eax
f0112ec8:	e8 03 dc 00 00       	call   f0120ad0 <strcconcat>
f0112ecd:	83 c4 10             	add    $0x10,%esp
f0112ed0:	83 ec 0c             	sub    $0xc,%esp
f0112ed3:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112ed9:	50                   	push   %eax
f0112eda:	e8 fd ef fe ff       	call   f0101edc <execute_command>
f0112edf:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f0112ee2:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0112ee8:	bb 11 a8 12 f0       	mov    $0xf012a811,%ebx
f0112eed:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112ef2:	89 c7                	mov    %eax,%edi
f0112ef4:	89 de                	mov    %ebx,%esi
f0112ef6:	89 d1                	mov    %edx,%ecx
f0112ef8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112efa:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0112f00:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112f05:	b0 00                	mov    $0x0,%al
f0112f07:	89 d7                	mov    %edx,%edi
f0112f09:	f3 aa                	rep stos %al,%es:(%edi)
f0112f0b:	83 ec 0c             	sub    $0xc,%esp
f0112f0e:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0112f14:	50                   	push   %eax
f0112f15:	e8 c2 ef fe ff       	call   f0101edc <execute_command>
f0112f1a:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f0112f1d:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112f23:	bb 75 a8 12 f0       	mov    $0xf012a875,%ebx
f0112f28:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112f2d:	89 c7                	mov    %eax,%edi
f0112f2f:	89 de                	mov    %ebx,%esi
f0112f31:	89 d1                	mov    %edx,%ecx
f0112f33:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112f35:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0112f3b:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112f40:	b0 00                	mov    $0x0,%al
f0112f42:	89 d7                	mov    %edx,%edi
f0112f44:	f3 aa                	rep stos %al,%es:(%edi)
f0112f46:	83 ec 0c             	sub    $0xc,%esp
f0112f49:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112f4f:	50                   	push   %eax
f0112f50:	e8 87 ef fe ff       	call   f0101edc <execute_command>
f0112f55:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f0112f58:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112f5e:	bb d9 a8 12 f0       	mov    $0xf012a8d9,%ebx
f0112f63:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112f68:	89 c7                	mov    %eax,%edi
f0112f6a:	89 de                	mov    %ebx,%esi
f0112f6c:	89 d1                	mov    %edx,%ecx
f0112f6e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112f70:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0112f76:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112f7b:	b0 00                	mov    $0x0,%al
f0112f7d:	89 d7                	mov    %edx,%edi
f0112f7f:	f3 aa                	rep stos %al,%es:(%edi)
f0112f81:	83 ec 0c             	sub    $0xc,%esp
f0112f84:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112f8a:	50                   	push   %eax
f0112f8b:	e8 4c ef fe ff       	call   f0101edc <execute_command>
f0112f90:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f0112f93:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0112f9a:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f0112fa1:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f0112fa8:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f0112faf:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f0112fb6:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f0112fbd:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f0112fc4:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f0112fcb:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f0112fd2:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f0112fd9:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f0112fe0:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f0112fe7:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0112fea:	8a 00                	mov    (%eax),%al
f0112fec:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f0112ff2:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112ff5:	8a 00                	mov    (%eax),%al
f0112ff7:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f0112ffd:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113000:	8a 00                	mov    (%eax),%al
f0113002:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113008:	e8 1a a7 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011300d:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f0113010:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113013:	89 d0                	mov    %edx,%eax
f0113015:	01 c0                	add    %eax,%eax
f0113017:	01 d0                	add    %edx,%eax
f0113019:	01 c0                	add    %eax,%eax
f011301b:	50                   	push   %eax
f011301c:	68 00 00 10 00       	push   $0x100000
f0113021:	6a 00                	push   $0x0
f0113023:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113026:	e8 dd 63 ff ff       	call   f0109408 <copy_paste_chunk>
f011302b:	83 c4 10             	add    $0x10,%esp
f011302e:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113031:	e8 f1 a6 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0113036:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0113039:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113040:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f0113044:	75 08                	jne    f011304e <test_copy_paste_chunk+0x4a2>
f0113046:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113049:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011304c:	74 2b                	je     f0113079 <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011304e:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113051:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113054:	83 ec 0c             	sub    $0xc,%esp
f0113057:	50                   	push   %eax
f0113058:	ff 75 88             	pushl  -0x78(%ebp)
f011305b:	68 d4 a2 12 f0       	push   $0xf012a2d4
f0113060:	68 06 03 00 00       	push   $0x306
f0113065:	68 42 9b 12 f0       	push   $0xf0129b42
f011306a:	e8 48 d4 fe ff       	call   f01004b7 <_warn>
f011306f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113072:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113079:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011307d:	74 04                	je     f0113083 <test_copy_paste_chunk+0x4d7>
f011307f:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113083:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f011308a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011308d:	8a 00                	mov    (%eax),%al
f011308f:	3c 61                	cmp    $0x61,%al
f0113091:	75 75                	jne    f0113108 <test_copy_paste_chunk+0x55c>
f0113093:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113096:	8a 00                	mov    (%eax),%al
f0113098:	3c 78                	cmp    $0x78,%al
f011309a:	75 6c                	jne    f0113108 <test_copy_paste_chunk+0x55c>
f011309c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011309f:	8a 00                	mov    (%eax),%al
f01130a1:	3c 62                	cmp    $0x62,%al
f01130a3:	75 63                	jne    f0113108 <test_copy_paste_chunk+0x55c>
f01130a5:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01130a8:	8a 00                	mov    (%eax),%al
f01130aa:	3c 79                	cmp    $0x79,%al
f01130ac:	75 5a                	jne    f0113108 <test_copy_paste_chunk+0x55c>
f01130ae:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01130b1:	8a 00                	mov    (%eax),%al
f01130b3:	3c 63                	cmp    $0x63,%al
f01130b5:	75 51                	jne    f0113108 <test_copy_paste_chunk+0x55c>
f01130b7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01130ba:	8a 00                	mov    (%eax),%al
f01130bc:	3c 7a                	cmp    $0x7a,%al
f01130be:	75 48                	jne    f0113108 <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f01130c0:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01130c3:	8a 00                	mov    (%eax),%al
f01130c5:	3c 64                	cmp    $0x64,%al
f01130c7:	75 3f                	jne    f0113108 <test_copy_paste_chunk+0x55c>
f01130c9:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01130cc:	8a 10                	mov    (%eax),%dl
f01130ce:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f01130d4:	38 c2                	cmp    %al,%dl
f01130d6:	75 30                	jne    f0113108 <test_copy_paste_chunk+0x55c>
f01130d8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01130db:	8a 00                	mov    (%eax),%al
f01130dd:	3c 65                	cmp    $0x65,%al
f01130df:	75 27                	jne    f0113108 <test_copy_paste_chunk+0x55c>
f01130e1:	8b 45 98             	mov    -0x68(%ebp),%eax
f01130e4:	8a 10                	mov    (%eax),%dl
f01130e6:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f01130ec:	38 c2                	cmp    %al,%dl
f01130ee:	75 18                	jne    f0113108 <test_copy_paste_chunk+0x55c>
f01130f0:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01130f3:	8a 00                	mov    (%eax),%al
f01130f5:	3c 66                	cmp    $0x66,%al
f01130f7:	75 0f                	jne    f0113108 <test_copy_paste_chunk+0x55c>
f01130f9:	8b 45 90             	mov    -0x70(%ebp),%eax
f01130fc:	8a 10                	mov    (%eax),%dl
f01130fe:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113104:	38 c2                	cmp    %al,%dl
f0113106:	74 21                	je     f0113129 <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113108:	83 ec 04             	sub    $0x4,%esp
f011310b:	68 38 a3 12 f0       	push   $0xf012a338
f0113110:	68 0f 03 00 00       	push   $0x30f
f0113115:	68 42 9b 12 f0       	push   $0xf0129b42
f011311a:	e8 98 d3 fe ff       	call   f01004b7 <_warn>
f011311f:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113122:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113129:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011312d:	74 04                	je     f0113133 <test_copy_paste_chunk+0x587>
f011312f:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113133:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f011313a:	83 ec 0c             	sub    $0xc,%esp
f011313d:	68 72 a3 12 f0       	push   $0xf012a372
f0113142:	e8 25 de fe ff       	call   f0100f6c <cprintf>
f0113147:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f011314a:	83 ec 0c             	sub    $0xc,%esp
f011314d:	68 84 a3 12 f0       	push   $0xf012a384
f0113152:	e8 15 de fe ff       	call   f0100f6c <cprintf>
f0113157:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f011315a:	83 ec 04             	sub    $0x4,%esp
f011315d:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113163:	50                   	push   %eax
f0113164:	68 ba a3 12 f0       	push   $0xf012a3ba
f0113169:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011316f:	50                   	push   %eax
f0113170:	e8 5b d9 00 00       	call   f0120ad0 <strcconcat>
f0113175:	83 c4 10             	add    $0x10,%esp
f0113178:	83 ec 0c             	sub    $0xc,%esp
f011317b:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113181:	50                   	push   %eax
f0113182:	e8 55 ed fe ff       	call   f0101edc <execute_command>
f0113187:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f011318a:	83 ec 04             	sub    $0x4,%esp
f011318d:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113193:	50                   	push   %eax
f0113194:	68 c4 a3 12 f0       	push   $0xf012a3c4
f0113199:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011319f:	50                   	push   %eax
f01131a0:	e8 2b d9 00 00       	call   f0120ad0 <strcconcat>
f01131a5:	83 c4 10             	add    $0x10,%esp
f01131a8:	83 ec 0c             	sub    $0xc,%esp
f01131ab:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01131b1:	50                   	push   %eax
f01131b2:	e8 25 ed fe ff       	call   f0101edc <execute_command>
f01131b7:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f01131ba:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f01131c0:	bb 3d a9 12 f0       	mov    $0xf012a93d,%ebx
f01131c5:	ba 0f 00 00 00       	mov    $0xf,%edx
f01131ca:	89 c7                	mov    %eax,%edi
f01131cc:	89 de                	mov    %ebx,%esi
f01131ce:	89 d1                	mov    %edx,%ecx
f01131d0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01131d2:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f01131d8:	b9 55 00 00 00       	mov    $0x55,%ecx
f01131dd:	b0 00                	mov    $0x0,%al
f01131df:	89 d7                	mov    %edx,%edi
f01131e1:	f3 aa                	rep stos %al,%es:(%edi)
f01131e3:	83 ec 0c             	sub    $0xc,%esp
f01131e6:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f01131ec:	50                   	push   %eax
f01131ed:	e8 ea ec fe ff       	call   f0101edc <execute_command>
f01131f2:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f01131f5:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f01131fb:	bb a1 a9 12 f0       	mov    $0xf012a9a1,%ebx
f0113200:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113205:	89 c7                	mov    %eax,%edi
f0113207:	89 de                	mov    %ebx,%esi
f0113209:	89 d1                	mov    %edx,%ecx
f011320b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011320d:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0113213:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113218:	b0 00                	mov    $0x0,%al
f011321a:	89 d7                	mov    %edx,%edi
f011321c:	f3 aa                	rep stos %al,%es:(%edi)
f011321e:	83 ec 0c             	sub    $0xc,%esp
f0113221:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0113227:	50                   	push   %eax
f0113228:	e8 af ec fe ff       	call   f0101edc <execute_command>
f011322d:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f0113230:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0113236:	bb 05 aa 12 f0       	mov    $0xf012aa05,%ebx
f011323b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113240:	89 c7                	mov    %eax,%edi
f0113242:	89 de                	mov    %ebx,%esi
f0113244:	89 d1                	mov    %edx,%ecx
f0113246:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113248:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f011324e:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113253:	b0 00                	mov    $0x0,%al
f0113255:	89 d7                	mov    %edx,%edi
f0113257:	f3 aa                	rep stos %al,%es:(%edi)
f0113259:	83 ec 0c             	sub    $0xc,%esp
f011325c:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0113262:	50                   	push   %eax
f0113263:	e8 74 ec fe ff       	call   f0101edc <execute_command>
f0113268:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f011326b:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113271:	bb 69 aa 12 f0       	mov    $0xf012aa69,%ebx
f0113276:	ba 0f 00 00 00       	mov    $0xf,%edx
f011327b:	89 c7                	mov    %eax,%edi
f011327d:	89 de                	mov    %ebx,%esi
f011327f:	89 d1                	mov    %edx,%ecx
f0113281:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113283:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0113289:	b9 55 00 00 00       	mov    $0x55,%ecx
f011328e:	b0 00                	mov    $0x0,%al
f0113290:	89 d7                	mov    %edx,%edi
f0113292:	f3 aa                	rep stos %al,%es:(%edi)
f0113294:	83 ec 0c             	sub    $0xc,%esp
f0113297:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f011329d:	50                   	push   %eax
f011329e:	e8 39 ec fe ff       	call   f0101edc <execute_command>
f01132a3:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f01132a6:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01132ac:	bb cd aa 12 f0       	mov    $0xf012aacd,%ebx
f01132b1:	ba 0f 00 00 00       	mov    $0xf,%edx
f01132b6:	89 c7                	mov    %eax,%edi
f01132b8:	89 de                	mov    %ebx,%esi
f01132ba:	89 d1                	mov    %edx,%ecx
f01132bc:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01132be:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f01132c4:	b9 55 00 00 00       	mov    $0x55,%ecx
f01132c9:	b0 00                	mov    $0x0,%al
f01132cb:	89 d7                	mov    %edx,%edi
f01132cd:	f3 aa                	rep stos %al,%es:(%edi)
f01132cf:	83 ec 0c             	sub    $0xc,%esp
f01132d2:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01132d8:	50                   	push   %eax
f01132d9:	e8 fe eb fe ff       	call   f0101edc <execute_command>
f01132de:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f01132e1:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01132e7:	bb 31 ab 12 f0       	mov    $0xf012ab31,%ebx
f01132ec:	ba 0f 00 00 00       	mov    $0xf,%edx
f01132f1:	89 c7                	mov    %eax,%edi
f01132f3:	89 de                	mov    %ebx,%esi
f01132f5:	89 d1                	mov    %edx,%ecx
f01132f7:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01132f9:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f01132ff:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113304:	b0 00                	mov    $0x0,%al
f0113306:	89 d7                	mov    %edx,%edi
f0113308:	f3 aa                	rep stos %al,%es:(%edi)
f011330a:	83 ec 0c             	sub    $0xc,%esp
f011330d:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113313:	50                   	push   %eax
f0113314:	e8 c3 eb fe ff       	call   f0101edc <execute_command>
f0113319:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f011331c:	83 ec 04             	sub    $0x4,%esp
f011331f:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113325:	50                   	push   %eax
f0113326:	68 ce a3 12 f0       	push   $0xf012a3ce
f011332b:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113331:	50                   	push   %eax
f0113332:	e8 99 d7 00 00       	call   f0120ad0 <strcconcat>
f0113337:	83 c4 10             	add    $0x10,%esp
f011333a:	83 ec 0c             	sub    $0xc,%esp
f011333d:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113343:	50                   	push   %eax
f0113344:	e8 93 eb fe ff       	call   f0101edc <execute_command>
f0113349:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f011334c:	83 ec 04             	sub    $0x4,%esp
f011334f:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113355:	50                   	push   %eax
f0113356:	68 d8 a3 12 f0       	push   $0xf012a3d8
f011335b:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113361:	50                   	push   %eax
f0113362:	e8 69 d7 00 00       	call   f0120ad0 <strcconcat>
f0113367:	83 c4 10             	add    $0x10,%esp
f011336a:	83 ec 0c             	sub    $0xc,%esp
f011336d:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113373:	50                   	push   %eax
f0113374:	e8 63 eb fe ff       	call   f0101edc <execute_command>
f0113379:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f011337c:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113382:	bb 95 ab 12 f0       	mov    $0xf012ab95,%ebx
f0113387:	ba 0f 00 00 00       	mov    $0xf,%edx
f011338c:	89 c7                	mov    %eax,%edi
f011338e:	89 de                	mov    %ebx,%esi
f0113390:	89 d1                	mov    %edx,%ecx
f0113392:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113394:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f011339a:	b9 55 00 00 00       	mov    $0x55,%ecx
f011339f:	b0 00                	mov    $0x0,%al
f01133a1:	89 d7                	mov    %edx,%edi
f01133a3:	f3 aa                	rep stos %al,%es:(%edi)
f01133a5:	83 ec 0c             	sub    $0xc,%esp
f01133a8:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01133ae:	50                   	push   %eax
f01133af:	e8 28 eb fe ff       	call   f0101edc <execute_command>
f01133b4:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f01133b7:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01133bd:	bb f9 ab 12 f0       	mov    $0xf012abf9,%ebx
f01133c2:	ba 0f 00 00 00       	mov    $0xf,%edx
f01133c7:	89 c7                	mov    %eax,%edi
f01133c9:	89 de                	mov    %ebx,%esi
f01133cb:	89 d1                	mov    %edx,%ecx
f01133cd:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01133cf:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f01133d5:	b9 55 00 00 00       	mov    $0x55,%ecx
f01133da:	b0 00                	mov    $0x0,%al
f01133dc:	89 d7                	mov    %edx,%edi
f01133de:	f3 aa                	rep stos %al,%es:(%edi)
f01133e0:	83 ec 0c             	sub    $0xc,%esp
f01133e3:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01133e9:	50                   	push   %eax
f01133ea:	e8 ed ea fe ff       	call   f0101edc <execute_command>
f01133ef:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f01133f2:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01133f8:	bb 5d ac 12 f0       	mov    $0xf012ac5d,%ebx
f01133fd:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113402:	89 c7                	mov    %eax,%edi
f0113404:	89 de                	mov    %ebx,%esi
f0113406:	89 d1                	mov    %edx,%ecx
f0113408:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011340a:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0113410:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113415:	b0 00                	mov    $0x0,%al
f0113417:	89 d7                	mov    %edx,%edi
f0113419:	f3 aa                	rep stos %al,%es:(%edi)
f011341b:	83 ec 0c             	sub    $0xc,%esp
f011341e:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113424:	50                   	push   %eax
f0113425:	e8 b2 ea fe ff       	call   f0101edc <execute_command>
f011342a:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f011342d:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f0113434:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f011343b:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f0113442:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f0113449:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f0113450:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f0113457:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f011345e:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f0113465:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f011346c:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f0113473:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f011347a:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f0113481:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113484:	8a 00                	mov    (%eax),%al
f0113486:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011348c:	e8 96 a2 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0113491:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f0113494:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113497:	89 d0                	mov    %edx,%eax
f0113499:	01 c0                	add    %eax,%eax
f011349b:	01 d0                	add    %edx,%eax
f011349d:	01 c0                	add    %eax,%eax
f011349f:	50                   	push   %eax
f01134a0:	68 00 00 40 00       	push   $0x400000
f01134a5:	68 00 00 20 00       	push   $0x200000
f01134aa:	ff 75 d4             	pushl  -0x2c(%ebp)
f01134ad:	e8 56 5f ff ff       	call   f0109408 <copy_paste_chunk>
f01134b2:	83 c4 10             	add    $0x10,%esp
f01134b5:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01134b8:	e8 6a a2 ff ff       	call   f010d727 <sys_calculate_free_frames>
f01134bd:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f01134c0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f01134c7:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01134cb:	75 08                	jne    f01134d5 <test_copy_paste_chunk+0x929>
f01134cd:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01134d0:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01134d3:	74 2b                	je     f0113500 <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01134d5:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01134d8:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01134db:	83 ec 0c             	sub    $0xc,%esp
f01134de:	50                   	push   %eax
f01134df:	ff 75 80             	pushl  -0x80(%ebp)
f01134e2:	68 e4 a3 12 f0       	push   $0xf012a3e4
f01134e7:	68 3f 03 00 00       	push   $0x33f
f01134ec:	68 42 9b 12 f0       	push   $0xf0129b42
f01134f1:	e8 c1 cf fe ff       	call   f01004b7 <_warn>
f01134f6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01134f9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113500:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113504:	74 04                	je     f011350a <test_copy_paste_chunk+0x95e>
f0113506:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011350a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f0113511:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f0113518:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f011351b:	83 ec 08             	sub    $0x8,%esp
f011351e:	6a 01                	push   $0x1
f0113520:	6a 07                	push   $0x7
f0113522:	6a 07                	push   $0x7
f0113524:	6a 07                	push   $0x7
f0113526:	6a 07                	push   $0x7
f0113528:	6a 01                	push   $0x1
f011352a:	68 00 20 00 00       	push   $0x2000
f011352f:	68 00 00 40 00       	push   $0x400000
f0113534:	68 00 00 20 00       	push   $0x200000
f0113539:	ff 75 d4             	pushl  -0x2c(%ebp)
f011353c:	e8 0a 36 00 00       	call   f0116b4b <CCP>
f0113541:	83 c4 30             	add    $0x30,%esp
f0113544:	83 f8 01             	cmp    $0x1,%eax
f0113547:	74 2b                	je     f0113574 <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f0113549:	83 ec 04             	sub    $0x4,%esp
f011354c:	68 38 a4 12 f0       	push   $0xf012a438
f0113551:	68 48 03 00 00       	push   $0x348
f0113556:	68 42 9b 12 f0       	push   $0xf0129b42
f011355b:	e8 57 cf fe ff       	call   f01004b7 <_warn>
f0113560:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113563:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f011356a:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f0113571:	00 00 00 
		}
		if (correct) eval += 5 ;
f0113574:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113578:	74 04                	je     f011357e <test_copy_paste_chunk+0x9d2>
f011357a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011357e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f0113585:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113588:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f011358b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011358e:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f0113591:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113594:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f0113597:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011359a:	8a 00                	mov    (%eax),%al
f011359c:	3c 61                	cmp    $0x61,%al
f011359e:	75 69                	jne    f0113609 <test_copy_paste_chunk+0xa5d>
f01135a0:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01135a3:	8a 00                	mov    (%eax),%al
f01135a5:	3c 61                	cmp    $0x61,%al
f01135a7:	75 60                	jne    f0113609 <test_copy_paste_chunk+0xa5d>
f01135a9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01135ac:	8a 00                	mov    (%eax),%al
f01135ae:	3c 79                	cmp    $0x79,%al
f01135b0:	75 57                	jne    f0113609 <test_copy_paste_chunk+0xa5d>
f01135b2:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01135b5:	8a 00                	mov    (%eax),%al
f01135b7:	3c 62                	cmp    $0x62,%al
f01135b9:	75 4e                	jne    f0113609 <test_copy_paste_chunk+0xa5d>
f01135bb:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01135be:	8a 00                	mov    (%eax),%al
f01135c0:	3c 63                	cmp    $0x63,%al
f01135c2:	75 45                	jne    f0113609 <test_copy_paste_chunk+0xa5d>
f01135c4:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01135c7:	8a 00                	mov    (%eax),%al
f01135c9:	3c 7a                	cmp    $0x7a,%al
f01135cb:	75 3c                	jne    f0113609 <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f01135cd:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01135d0:	8a 00                	mov    (%eax),%al
f01135d2:	3c 77                	cmp    $0x77,%al
f01135d4:	75 33                	jne    f0113609 <test_copy_paste_chunk+0xa5d>
f01135d6:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01135d9:	8a 00                	mov    (%eax),%al
f01135db:	3c 64                	cmp    $0x64,%al
f01135dd:	75 2a                	jne    f0113609 <test_copy_paste_chunk+0xa5d>
f01135df:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01135e2:	8a 00                	mov    (%eax),%al
f01135e4:	3c 65                	cmp    $0x65,%al
f01135e6:	75 21                	jne    f0113609 <test_copy_paste_chunk+0xa5d>
f01135e8:	8b 45 98             	mov    -0x68(%ebp),%eax
f01135eb:	8a 00                	mov    (%eax),%al
f01135ed:	3c 65                	cmp    $0x65,%al
f01135ef:	75 18                	jne    f0113609 <test_copy_paste_chunk+0xa5d>
f01135f1:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01135f4:	8a 00                	mov    (%eax),%al
f01135f6:	3c 66                	cmp    $0x66,%al
f01135f8:	75 0f                	jne    f0113609 <test_copy_paste_chunk+0xa5d>
f01135fa:	8b 45 90             	mov    -0x70(%ebp),%eax
f01135fd:	8a 10                	mov    (%eax),%dl
f01135ff:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113605:	38 c2                	cmp    %al,%dl
f0113607:	74 21                	je     f011362a <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113609:	83 ec 04             	sub    $0x4,%esp
f011360c:	68 38 a3 12 f0       	push   $0xf012a338
f0113611:	68 56 03 00 00       	push   $0x356
f0113616:	68 42 9b 12 f0       	push   $0xf0129b42
f011361b:	e8 97 ce fe ff       	call   f01004b7 <_warn>
f0113620:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113623:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f011362a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011362e:	74 04                	je     f0113634 <test_copy_paste_chunk+0xa88>
f0113630:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113634:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f011363b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011363e:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113641:	e8 e1 a0 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0113646:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f0113649:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011364c:	89 c2                	mov    %eax,%edx
f011364e:	01 d2                	add    %edx,%edx
f0113650:	01 d0                	add    %edx,%eax
f0113652:	50                   	push   %eax
f0113653:	68 00 08 20 00       	push   $0x200800
f0113658:	68 00 08 40 00       	push   $0x400800
f011365d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113660:	e8 a3 5d ff ff       	call   f0109408 <copy_paste_chunk>
f0113665:	83 c4 10             	add    $0x10,%esp
f0113668:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011366b:	e8 b7 a0 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0113670:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113673:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0113677:	75 08                	jne    f0113681 <test_copy_paste_chunk+0xad5>
f0113679:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011367c:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011367f:	74 2b                	je     f01136ac <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113681:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113684:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113687:	83 ec 0c             	sub    $0xc,%esp
f011368a:	50                   	push   %eax
f011368b:	ff 75 80             	pushl  -0x80(%ebp)
f011368e:	68 e4 a3 12 f0       	push   $0xf012a3e4
f0113693:	68 66 03 00 00       	push   $0x366
f0113698:	68 42 9b 12 f0       	push   $0xf0129b42
f011369d:	e8 15 ce fe ff       	call   f01004b7 <_warn>
f01136a2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01136a5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01136ac:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01136b0:	74 04                	je     f01136b6 <test_copy_paste_chunk+0xb0a>
f01136b2:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01136b6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f01136bd:	83 ec 08             	sub    $0x8,%esp
f01136c0:	6a 01                	push   $0x1
f01136c2:	6a 07                	push   $0x7
f01136c4:	6a 07                	push   $0x7
f01136c6:	6a 07                	push   $0x7
f01136c8:	6a 07                	push   $0x7
f01136ca:	6a 01                	push   $0x1
f01136cc:	68 00 20 00 00       	push   $0x2000
f01136d1:	68 00 00 20 00       	push   $0x200000
f01136d6:	68 00 00 40 00       	push   $0x400000
f01136db:	ff 75 d4             	pushl  -0x2c(%ebp)
f01136de:	e8 68 34 00 00       	call   f0116b4b <CCP>
f01136e3:	83 c4 30             	add    $0x30,%esp
f01136e6:	83 f8 01             	cmp    $0x1,%eax
f01136e9:	74 21                	je     f011370c <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f01136eb:	83 ec 04             	sub    $0x4,%esp
f01136ee:	68 84 a4 12 f0       	push   $0xf012a484
f01136f3:	68 6e 03 00 00       	push   $0x36e
f01136f8:	68 42 9b 12 f0       	push   $0xf0129b42
f01136fd:	e8 b5 cd fe ff       	call   f01004b7 <_warn>
f0113702:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113705:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011370c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113710:	74 04                	je     f0113716 <test_copy_paste_chunk+0xb6a>
f0113712:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113716:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f011371d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113720:	8a 00                	mov    (%eax),%al
f0113722:	3c 61                	cmp    $0x61,%al
f0113724:	75 69                	jne    f011378f <test_copy_paste_chunk+0xbe3>
f0113726:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113729:	8a 00                	mov    (%eax),%al
f011372b:	3c 61                	cmp    $0x61,%al
f011372d:	75 60                	jne    f011378f <test_copy_paste_chunk+0xbe3>
f011372f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113732:	8a 00                	mov    (%eax),%al
f0113734:	3c 79                	cmp    $0x79,%al
f0113736:	75 57                	jne    f011378f <test_copy_paste_chunk+0xbe3>
f0113738:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011373b:	8a 00                	mov    (%eax),%al
f011373d:	3c 62                	cmp    $0x62,%al
f011373f:	75 4e                	jne    f011378f <test_copy_paste_chunk+0xbe3>
f0113741:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113744:	8a 00                	mov    (%eax),%al
f0113746:	3c 7a                	cmp    $0x7a,%al
f0113748:	75 45                	jne    f011378f <test_copy_paste_chunk+0xbe3>
f011374a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011374d:	8a 00                	mov    (%eax),%al
f011374f:	3c 7a                	cmp    $0x7a,%al
f0113751:	75 3c                	jne    f011378f <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113753:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113756:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0113758:	3c 64                	cmp    $0x64,%al
f011375a:	75 33                	jne    f011378f <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f011375c:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011375f:	8a 00                	mov    (%eax),%al
f0113761:	3c 64                	cmp    $0x64,%al
f0113763:	75 2a                	jne    f011378f <test_copy_paste_chunk+0xbe3>
f0113765:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113768:	8a 00                	mov    (%eax),%al
f011376a:	3c 65                	cmp    $0x65,%al
f011376c:	75 21                	jne    f011378f <test_copy_paste_chunk+0xbe3>
f011376e:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113771:	8a 00                	mov    (%eax),%al
f0113773:	3c 78                	cmp    $0x78,%al
f0113775:	75 18                	jne    f011378f <test_copy_paste_chunk+0xbe3>
f0113777:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011377a:	8a 00                	mov    (%eax),%al
f011377c:	3c 66                	cmp    $0x66,%al
f011377e:	75 0f                	jne    f011378f <test_copy_paste_chunk+0xbe3>
f0113780:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113783:	8a 10                	mov    (%eax),%dl
f0113785:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f011378b:	38 c2                	cmp    %al,%dl
f011378d:	74 21                	je     f01137b0 <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f011378f:	83 ec 04             	sub    $0x4,%esp
f0113792:	68 38 a3 12 f0       	push   $0xf012a338
f0113797:	68 77 03 00 00       	push   $0x377
f011379c:	68 42 9b 12 f0       	push   $0xf0129b42
f01137a1:	e8 11 cd fe ff       	call   f01004b7 <_warn>
f01137a6:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01137a9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01137b0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01137b4:	74 04                	je     f01137ba <test_copy_paste_chunk+0xc0e>
f01137b6:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01137ba:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f01137c1:	83 ec 0c             	sub    $0xc,%esp
f01137c4:	68 cf a4 12 f0       	push   $0xf012a4cf
f01137c9:	e8 9e d7 fe ff       	call   f0100f6c <cprintf>
f01137ce:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f01137d1:	83 ec 0c             	sub    $0xc,%esp
f01137d4:	68 e0 a4 12 f0       	push   $0xf012a4e0
f01137d9:	e8 8e d7 fe ff       	call   f0100f6c <cprintf>
f01137de:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f01137e1:	83 ec 04             	sub    $0x4,%esp
f01137e4:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01137ea:	50                   	push   %eax
f01137eb:	68 14 a5 12 f0       	push   $0xf012a514
f01137f0:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01137f6:	50                   	push   %eax
f01137f7:	e8 d4 d2 00 00       	call   f0120ad0 <strcconcat>
f01137fc:	83 c4 10             	add    $0x10,%esp
f01137ff:	83 ec 0c             	sub    $0xc,%esp
f0113802:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113808:	50                   	push   %eax
f0113809:	e8 ce e6 fe ff       	call   f0101edc <execute_command>
f011380e:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f0113811:	83 ec 04             	sub    $0x4,%esp
f0113814:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011381a:	50                   	push   %eax
f011381b:	68 1e a5 12 f0       	push   $0xf012a51e
f0113820:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113826:	50                   	push   %eax
f0113827:	e8 a4 d2 00 00       	call   f0120ad0 <strcconcat>
f011382c:	83 c4 10             	add    $0x10,%esp
f011382f:	83 ec 0c             	sub    $0xc,%esp
f0113832:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113838:	50                   	push   %eax
f0113839:	e8 9e e6 fe ff       	call   f0101edc <execute_command>
f011383e:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f0113841:	83 ec 04             	sub    $0x4,%esp
f0113844:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011384a:	50                   	push   %eax
f011384b:	68 28 a5 12 f0       	push   $0xf012a528
f0113850:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113856:	50                   	push   %eax
f0113857:	e8 74 d2 00 00       	call   f0120ad0 <strcconcat>
f011385c:	83 c4 10             	add    $0x10,%esp
f011385f:	83 ec 0c             	sub    $0xc,%esp
f0113862:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113868:	50                   	push   %eax
f0113869:	e8 6e e6 fe ff       	call   f0101edc <execute_command>
f011386e:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f0113871:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113877:	bb c1 ac 12 f0       	mov    $0xf012acc1,%ebx
f011387c:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113881:	89 c7                	mov    %eax,%edi
f0113883:	89 de                	mov    %ebx,%esi
f0113885:	89 d1                	mov    %edx,%ecx
f0113887:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113889:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f011388f:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113894:	b0 00                	mov    $0x0,%al
f0113896:	89 d7                	mov    %edx,%edi
f0113898:	f3 aa                	rep stos %al,%es:(%edi)
f011389a:	83 ec 0c             	sub    $0xc,%esp
f011389d:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01138a3:	50                   	push   %eax
f01138a4:	e8 33 e6 fe ff       	call   f0101edc <execute_command>
f01138a9:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f01138ac:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01138b2:	bb 25 ad 12 f0       	mov    $0xf012ad25,%ebx
f01138b7:	ba 0f 00 00 00       	mov    $0xf,%edx
f01138bc:	89 c7                	mov    %eax,%edi
f01138be:	89 de                	mov    %ebx,%esi
f01138c0:	89 d1                	mov    %edx,%ecx
f01138c2:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01138c4:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f01138ca:	b9 55 00 00 00       	mov    $0x55,%ecx
f01138cf:	b0 00                	mov    $0x0,%al
f01138d1:	89 d7                	mov    %edx,%edi
f01138d3:	f3 aa                	rep stos %al,%es:(%edi)
f01138d5:	83 ec 0c             	sub    $0xc,%esp
f01138d8:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01138de:	50                   	push   %eax
f01138df:	e8 f8 e5 fe ff       	call   f0101edc <execute_command>
f01138e4:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f01138e7:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01138ed:	bb 89 ad 12 f0       	mov    $0xf012ad89,%ebx
f01138f2:	ba 0f 00 00 00       	mov    $0xf,%edx
f01138f7:	89 c7                	mov    %eax,%edi
f01138f9:	89 de                	mov    %ebx,%esi
f01138fb:	89 d1                	mov    %edx,%ecx
f01138fd:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01138ff:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0113905:	b9 55 00 00 00       	mov    $0x55,%ecx
f011390a:	b0 00                	mov    $0x0,%al
f011390c:	89 d7                	mov    %edx,%edi
f011390e:	f3 aa                	rep stos %al,%es:(%edi)
f0113910:	83 ec 0c             	sub    $0xc,%esp
f0113913:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113919:	50                   	push   %eax
f011391a:	e8 bd e5 fe ff       	call   f0101edc <execute_command>
f011391f:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113922:	e8 00 9e ff ff       	call   f010d727 <sys_calculate_free_frames>
f0113927:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f011392a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011392d:	89 d0                	mov    %edx,%eax
f011392f:	01 c0                	add    %eax,%eax
f0113931:	01 d0                	add    %edx,%eax
f0113933:	c1 e0 02             	shl    $0x2,%eax
f0113936:	50                   	push   %eax
f0113937:	68 00 00 90 00       	push   $0x900000
f011393c:	68 00 00 80 00       	push   $0x800000
f0113941:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113944:	e8 bf 5a ff ff       	call   f0109408 <copy_paste_chunk>
f0113949:	83 c4 10             	add    $0x10,%esp
f011394c:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113952:	e8 d0 9d ff ff       	call   f010d727 <sys_calculate_free_frames>
f0113957:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f011395a:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0113961:	75 0b                	jne    f011396e <test_copy_paste_chunk+0xdc2>
f0113963:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113966:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113969:	83 f8 03             	cmp    $0x3,%eax
f011396c:	74 2e                	je     f011399c <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011396e:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113971:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113974:	83 ec 0c             	sub    $0xc,%esp
f0113977:	50                   	push   %eax
f0113978:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f011397e:	68 e4 a3 12 f0       	push   $0xf012a3e4
f0113983:	68 95 03 00 00       	push   $0x395
f0113988:	68 42 9b 12 f0       	push   $0xf0129b42
f011398d:	e8 25 cb fe ff       	call   f01004b7 <_warn>
f0113992:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113995:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011399c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01139a0:	74 04                	je     f01139a6 <test_copy_paste_chunk+0xdfa>
f01139a2:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01139a6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f01139ad:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f01139b4:	83 ec 08             	sub    $0x8,%esp
f01139b7:	6a 01                	push   $0x1
f01139b9:	6a 07                	push   $0x7
f01139bb:	6a 07                	push   $0x7
f01139bd:	6a 07                	push   $0x7
f01139bf:	6a 07                	push   $0x7
f01139c1:	6a 01                	push   $0x1
f01139c3:	68 00 30 00 00       	push   $0x3000
f01139c8:	68 00 00 90 00       	push   $0x900000
f01139cd:	68 00 00 80 00       	push   $0x800000
f01139d2:	ff 75 d4             	pushl  -0x2c(%ebp)
f01139d5:	e8 71 31 00 00       	call   f0116b4b <CCP>
f01139da:	83 c4 30             	add    $0x30,%esp
f01139dd:	83 f8 01             	cmp    $0x1,%eax
f01139e0:	74 28                	je     f0113a0a <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f01139e2:	83 ec 04             	sub    $0x4,%esp
f01139e5:	68 84 a4 12 f0       	push   $0xf012a484
f01139ea:	68 9e 03 00 00       	push   $0x39e
f01139ef:	68 42 9b 12 f0       	push   $0xf0129b42
f01139f4:	e8 be ca fe ff       	call   f01004b7 <_warn>
f01139f9:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01139fc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0113a03:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f0113a0a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113a0e:	74 04                	je     f0113a14 <test_copy_paste_chunk+0xe68>
f0113a10:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113a14:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0113a1b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0113a1f:	0f 84 9e 00 00 00    	je     f0113ac3 <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f0113a25:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f0113a2c:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f0113a33:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f0113a3a:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f0113a41:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f0113a48:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f0113a4f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113a52:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f0113a55:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113a58:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f0113a5b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113a5e:	8a 00                	mov    (%eax),%al
f0113a60:	3c 61                	cmp    $0x61,%al
f0113a62:	75 2d                	jne    f0113a91 <test_copy_paste_chunk+0xee5>
f0113a64:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113a67:	8a 00                	mov    (%eax),%al
f0113a69:	3c 61                	cmp    $0x61,%al
f0113a6b:	75 24                	jne    f0113a91 <test_copy_paste_chunk+0xee5>
f0113a6d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113a70:	8a 00                	mov    (%eax),%al
f0113a72:	3c 79                	cmp    $0x79,%al
f0113a74:	75 1b                	jne    f0113a91 <test_copy_paste_chunk+0xee5>
f0113a76:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113a79:	8a 00                	mov    (%eax),%al
f0113a7b:	3c 62                	cmp    $0x62,%al
f0113a7d:	75 12                	jne    f0113a91 <test_copy_paste_chunk+0xee5>
f0113a7f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113a82:	8a 00                	mov    (%eax),%al
f0113a84:	3c 63                	cmp    $0x63,%al
f0113a86:	75 09                	jne    f0113a91 <test_copy_paste_chunk+0xee5>
f0113a88:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113a8b:	8a 00                	mov    (%eax),%al
f0113a8d:	3c 7a                	cmp    $0x7a,%al
f0113a8f:	74 21                	je     f0113ab2 <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113a91:	83 ec 04             	sub    $0x4,%esp
f0113a94:	68 38 a3 12 f0       	push   $0xf012a338
f0113a99:	68 b0 03 00 00       	push   $0x3b0
f0113a9e:	68 42 9b 12 f0       	push   $0xf0129b42
f0113aa3:	e8 0f ca fe ff       	call   f01004b7 <_warn>
f0113aa8:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113aab:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f0113ab2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113ab6:	74 04                	je     f0113abc <test_copy_paste_chunk+0xf10>
f0113ab8:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f0113abc:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113ac3:	e8 5f 9c ff ff       	call   f010d727 <sys_calculate_free_frames>
f0113ac8:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f0113acb:	6a 00                	push   $0x0
f0113acd:	6a 02                	push   $0x2
f0113acf:	68 00 10 90 00       	push   $0x901000
f0113ad4:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113ad7:	e8 b1 2b 00 00       	call   f011668d <SB>
f0113adc:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f0113adf:	6a 00                	push   $0x0
f0113ae1:	6a 02                	push   $0x2
f0113ae3:	68 00 20 90 00       	push   $0x902000
f0113ae8:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113aeb:	e8 9d 2b 00 00       	call   f011668d <SB>
f0113af0:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f0113af3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113af6:	c1 e0 03             	shl    $0x3,%eax
f0113af9:	50                   	push   %eax
f0113afa:	68 00 f0 bf 00       	push   $0xbff000
f0113aff:	68 00 10 90 00       	push   $0x901000
f0113b04:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113b07:	e8 fc 58 ff ff       	call   f0109408 <copy_paste_chunk>
f0113b0c:	83 c4 10             	add    $0x10,%esp
f0113b0f:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113b15:	e8 0d 9c ff ff       	call   f010d727 <sys_calculate_free_frames>
f0113b1a:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0113b1d:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0113b24:	75 0b                	jne    f0113b31 <test_copy_paste_chunk+0xf85>
f0113b26:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113b29:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113b2c:	83 f8 03             	cmp    $0x3,%eax
f0113b2f:	74 2e                	je     f0113b5f <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113b31:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113b34:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113b37:	83 ec 0c             	sub    $0xc,%esp
f0113b3a:	50                   	push   %eax
f0113b3b:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0113b41:	68 e4 a3 12 f0       	push   $0xf012a3e4
f0113b46:	68 c0 03 00 00       	push   $0x3c0
f0113b4b:	68 42 9b 12 f0       	push   $0xf0129b42
f0113b50:	e8 62 c9 fe ff       	call   f01004b7 <_warn>
f0113b55:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113b58:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113b5f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113b63:	74 04                	je     f0113b69 <test_copy_paste_chunk+0xfbd>
f0113b65:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113b69:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f0113b70:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f0113b77:	83 ec 08             	sub    $0x8,%esp
f0113b7a:	6a 01                	push   $0x1
f0113b7c:	6a 07                	push   $0x7
f0113b7e:	6a 03                	push   $0x3
f0113b80:	6a 07                	push   $0x7
f0113b82:	6a 03                	push   $0x3
f0113b84:	6a 01                	push   $0x1
f0113b86:	68 00 20 00 00       	push   $0x2000
f0113b8b:	68 00 f0 bf 00       	push   $0xbff000
f0113b90:	68 00 10 90 00       	push   $0x901000
f0113b95:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113b98:	e8 ae 2f 00 00       	call   f0116b4b <CCP>
f0113b9d:	83 c4 30             	add    $0x30,%esp
f0113ba0:	83 f8 01             	cmp    $0x1,%eax
f0113ba3:	74 28                	je     f0113bcd <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113ba5:	83 ec 04             	sub    $0x4,%esp
f0113ba8:	68 84 a4 12 f0       	push   $0xf012a484
f0113bad:	68 c9 03 00 00       	push   $0x3c9
f0113bb2:	68 42 9b 12 f0       	push   $0xf0129b42
f0113bb7:	e8 fb c8 fe ff       	call   f01004b7 <_warn>
f0113bbc:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113bbf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0113bc6:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f0113bcd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113bd1:	74 04                	je     f0113bd7 <test_copy_paste_chunk+0x102b>
f0113bd3:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113bd7:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0113bde:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0113be2:	74 72                	je     f0113c56 <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f0113be4:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f0113beb:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f0113bf2:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f0113bf9:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f0113c00:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113c03:	8a 00                	mov    (%eax),%al
f0113c05:	3c 62                	cmp    $0x62,%al
f0113c07:	75 1b                	jne    f0113c24 <test_copy_paste_chunk+0x1078>
f0113c09:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113c0c:	8a 00                	mov    (%eax),%al
f0113c0e:	3c 62                	cmp    $0x62,%al
f0113c10:	75 12                	jne    f0113c24 <test_copy_paste_chunk+0x1078>
f0113c12:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113c15:	8a 00                	mov    (%eax),%al
f0113c17:	3c 7a                	cmp    $0x7a,%al
f0113c19:	75 09                	jne    f0113c24 <test_copy_paste_chunk+0x1078>
f0113c1b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113c1e:	8a 00                	mov    (%eax),%al
f0113c20:	3c 7a                	cmp    $0x7a,%al
f0113c22:	74 21                	je     f0113c45 <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113c24:	83 ec 04             	sub    $0x4,%esp
f0113c27:	68 38 a3 12 f0       	push   $0xf012a338
f0113c2c:	68 d5 03 00 00       	push   $0x3d5
f0113c31:	68 42 9b 12 f0       	push   $0xf0129b42
f0113c36:	e8 7c c8 fe ff       	call   f01004b7 <_warn>
f0113c3b:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113c3e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0113c45:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113c49:	74 04                	je     f0113c4f <test_copy_paste_chunk+0x10a3>
f0113c4b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113c4f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0113c56:	83 ec 0c             	sub    $0xc,%esp
f0113c59:	68 32 a5 12 f0       	push   $0xf012a532
f0113c5e:	e8 09 d3 fe ff       	call   f0100f6c <cprintf>
f0113c63:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f0113c66:	83 ec 08             	sub    $0x8,%esp
f0113c69:	ff 75 e4             	pushl  -0x1c(%ebp)
f0113c6c:	68 44 a5 12 f0       	push   $0xf012a544
f0113c71:	e8 f6 d2 fe ff       	call   f0100f6c <cprintf>
f0113c76:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0113c79:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0113c7d:	75 10                	jne    f0113c8f <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f0113c7f:	83 ec 0c             	sub    $0xc,%esp
f0113c82:	68 78 a5 12 f0       	push   $0xf012a578
f0113c87:	e8 e0 d2 fe ff       	call   f0100f6c <cprintf>
f0113c8c:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0113c8f:	a1 e4 51 55 f0       	mov    0xf05551e4,%eax
f0113c94:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0113c97:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113c9a:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0113c9d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113ca2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0113ca5:	5b                   	pop    %ebx
f0113ca6:	5e                   	pop    %esi
f0113ca7:	5f                   	pop    %edi
f0113ca8:	5d                   	pop    %ebp
f0113ca9:	c3                   	ret    

f0113caa <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f0113caa:	55                   	push   %ebp
f0113cab:	89 e5                	mov    %esp,%ebp
f0113cad:	57                   	push   %edi
f0113cae:	56                   	push   %esi
f0113caf:	53                   	push   %ebx
f0113cb0:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0113cb6:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0113cbc:	bb 44 a2 12 f0       	mov    $0xf012a244,%ebx
f0113cc1:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113cc6:	89 c7                	mov    %eax,%edi
f0113cc8:	89 de                	mov    %ebx,%esi
f0113cca:	89 d1                	mov    %edx,%ecx
f0113ccc:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113cce:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f0113cd4:	b9 23 00 00 00       	mov    $0x23,%ecx
f0113cd9:	b0 00                	mov    $0x0,%al
f0113cdb:	89 d7                	mov    %edx,%edi
f0113cdd:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0113cdf:	6a 00                	push   $0x0
f0113ce1:	6a 0a                	push   $0xa
f0113ce3:	6a 14                	push   $0x14
f0113ce5:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0113ceb:	50                   	push   %eax
f0113cec:	e8 9d 5a ff ff       	call   f010978e <env_create>
f0113cf1:	83 c4 10             	add    $0x10,%esp
f0113cf4:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0113cf7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113cfa:	8b 40 64             	mov    0x64(%eax),%eax
f0113cfd:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0113d00:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113d03:	8b 40 68             	mov    0x68(%eax),%eax
f0113d06:	89 45 80             	mov    %eax,-0x80(%ebp)
f0113d09:	8b 45 80             	mov    -0x80(%ebp),%eax
f0113d0c:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0113d0f:	83 ec 0c             	sub    $0xc,%esp
f0113d12:	ff 75 cc             	pushl  -0x34(%ebp)
f0113d15:	e8 fd 2d 00 00       	call   f0116b17 <ClearUserSpace>
f0113d1a:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0113d1d:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0113d24:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0113d2b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f0113d32:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f0113d36:	83 ec 0c             	sub    $0xc,%esp
f0113d39:	68 f0 ad 12 f0       	push   $0xf012adf0
f0113d3e:	e8 29 d2 fe ff       	call   f0100f6c <cprintf>
f0113d43:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f0113d46:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f0113d4d:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f0113d54:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113d57:	8a 00                	mov    (%eax),%al
f0113d59:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f0113d5f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113d62:	8a 00                	mov    (%eax),%al
f0113d64:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113d6a:	e8 b8 99 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0113d6f:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f0113d72:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113d75:	89 d0                	mov    %edx,%eax
f0113d77:	01 c0                	add    %eax,%eax
f0113d79:	01 d0                	add    %edx,%eax
f0113d7b:	01 c0                	add    %eax,%eax
f0113d7d:	83 ec 0c             	sub    $0xc,%esp
f0113d80:	6a 02                	push   $0x2
f0113d82:	50                   	push   %eax
f0113d83:	68 00 40 10 f0       	push   $0xf0104000
f0113d88:	68 00 00 10 f0       	push   $0xf0100000
f0113d8d:	ff 75 cc             	pushl  -0x34(%ebp)
f0113d90:	e8 8d 56 ff ff       	call   f0109422 <share_chunk>
f0113d95:	83 c4 20             	add    $0x20,%esp
f0113d98:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113d9b:	e8 87 99 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0113da0:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0113da3:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0113da7:	75 08                	jne    f0113db1 <test_share_chunk+0x107>
f0113da9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113dac:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0113daf:	74 28                	je     f0113dd9 <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f0113db1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113db4:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113db7:	83 ec 0c             	sub    $0xc,%esp
f0113dba:	50                   	push   %eax
f0113dbb:	ff 75 b0             	pushl  -0x50(%ebp)
f0113dbe:	68 1c ae 12 f0       	push   $0xf012ae1c
f0113dc3:	68 11 04 00 00       	push   $0x411
f0113dc8:	68 42 9b 12 f0       	push   $0xf0129b42
f0113dcd:	e8 e5 c6 fe ff       	call   f01004b7 <_warn>
f0113dd2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113dd5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113dd9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113ddd:	74 04                	je     f0113de3 <test_share_chunk+0x139>
f0113ddf:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113de3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f0113de7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113dea:	c1 e0 03             	shl    $0x3,%eax
f0113ded:	83 ec 08             	sub    $0x8,%esp
f0113df0:	68 fd 00 00 00       	push   $0xfd
f0113df5:	6a 07                	push   $0x7
f0113df7:	6a 03                	push   $0x3
f0113df9:	6a 07                	push   $0x7
f0113dfb:	6a 03                	push   $0x3
f0113dfd:	6a 01                	push   $0x1
f0113dff:	50                   	push   %eax
f0113e00:	68 00 40 10 f0       	push   $0xf0104000
f0113e05:	68 00 00 10 f0       	push   $0xf0100000
f0113e0a:	ff 75 cc             	pushl  -0x34(%ebp)
f0113e0d:	e8 39 2d 00 00       	call   f0116b4b <CCP>
f0113e12:	83 c4 30             	add    $0x30,%esp
f0113e15:	85 c0                	test   %eax,%eax
f0113e17:	75 1e                	jne    f0113e37 <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113e19:	83 ec 04             	sub    $0x4,%esp
f0113e1c:	68 78 ae 12 f0       	push   $0xf012ae78
f0113e21:	68 19 04 00 00       	push   $0x419
f0113e26:	68 42 9b 12 f0       	push   $0xf0129b42
f0113e2b:	e8 87 c6 fe ff       	call   f01004b7 <_warn>
f0113e30:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113e33:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113e37:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113e3b:	74 04                	je     f0113e41 <test_share_chunk+0x197>
f0113e3d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f0113e41:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113e44:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f0113e47:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113e4a:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f0113e4d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113e50:	8a 00                	mov    (%eax),%al
f0113e52:	3c 41                	cmp    $0x41,%al
f0113e54:	75 09                	jne    f0113e5f <test_share_chunk+0x1b5>
f0113e56:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113e59:	8a 00                	mov    (%eax),%al
f0113e5b:	3c 42                	cmp    $0x42,%al
f0113e5d:	74 1e                	je     f0113e7d <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113e5f:	83 ec 04             	sub    $0x4,%esp
f0113e62:	68 c0 ae 12 f0       	push   $0xf012aec0
f0113e67:	68 23 04 00 00       	push   $0x423
f0113e6c:	68 42 9b 12 f0       	push   $0xf0129b42
f0113e71:	e8 41 c6 fe ff       	call   f01004b7 <_warn>
f0113e76:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113e79:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0113e7d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113e81:	74 04                	je     f0113e87 <test_share_chunk+0x1dd>
f0113e83:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113e87:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f0113e8b:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f0113e91:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113e94:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f0113e96:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f0113e9c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113e9f:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f0113ea1:	83 ec 0c             	sub    $0xc,%esp
f0113ea4:	68 f5 ae 12 f0       	push   $0xf012aef5
f0113ea9:	e8 be d0 fe ff       	call   f0100f6c <cprintf>
f0113eae:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f0113eb1:	83 ec 0c             	sub    $0xc,%esp
f0113eb4:	68 04 af 12 f0       	push   $0xf012af04
f0113eb9:	e8 ae d0 fe ff       	call   f0100f6c <cprintf>
f0113ebe:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113ec1:	e8 61 98 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0113ec6:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0113ec9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113ecc:	c1 e0 05             	shl    $0x5,%eax
f0113ecf:	83 ec 0c             	sub    $0xc,%esp
f0113ed2:	68 02 0e 00 00       	push   $0xe02
f0113ed7:	50                   	push   %eax
f0113ed8:	68 00 00 00 40       	push   $0x40000000
f0113edd:	68 00 00 00 f0       	push   $0xf0000000
f0113ee2:	ff 75 cc             	pushl  -0x34(%ebp)
f0113ee5:	e8 38 55 ff ff       	call   f0109422 <share_chunk>
f0113eea:	83 c4 20             	add    $0x20,%esp
f0113eed:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113ef0:	e8 32 98 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0113ef5:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f0113ef8:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0113efc:	75 1f                	jne    f0113f1d <test_share_chunk+0x273>
f0113efe:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113f01:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113f04:	89 c1                	mov    %eax,%ecx
f0113f06:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113f09:	c1 e0 05             	shl    $0x5,%eax
f0113f0c:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113f0f:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0113f16:	99                   	cltd   
f0113f17:	f7 fb                	idiv   %ebx
f0113f19:	39 c1                	cmp    %eax,%ecx
f0113f1b:	74 28                	je     f0113f45 <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113f1d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113f20:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113f23:	83 ec 0c             	sub    $0xc,%esp
f0113f26:	50                   	push   %eax
f0113f27:	ff 75 a8             	pushl  -0x58(%ebp)
f0113f2a:	68 40 af 12 f0       	push   $0xf012af40
f0113f2f:	68 3b 04 00 00       	push   $0x43b
f0113f34:	68 42 9b 12 f0       	push   $0xf0129b42
f0113f39:	e8 79 c5 fe ff       	call   f01004b7 <_warn>
f0113f3e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113f41:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113f45:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113f49:	74 04                	je     f0113f4f <test_share_chunk+0x2a5>
f0113f4b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113f4f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0113f53:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0113f5a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113f5d:	c1 e0 05             	shl    $0x5,%eax
f0113f60:	83 ec 08             	sub    $0x8,%esp
f0113f63:	6a 02                	push   $0x2
f0113f65:	6a 07                	push   $0x7
f0113f67:	6a 03                	push   $0x3
f0113f69:	68 07 0e 00 00       	push   $0xe07
f0113f6e:	68 03 0e 00 00       	push   $0xe03
f0113f73:	6a ff                	push   $0xffffffff
f0113f75:	50                   	push   %eax
f0113f76:	68 00 00 00 40       	push   $0x40000000
f0113f7b:	68 00 00 00 f0       	push   $0xf0000000
f0113f80:	ff 75 cc             	pushl  -0x34(%ebp)
f0113f83:	e8 c3 2b 00 00       	call   f0116b4b <CCP>
f0113f88:	83 c4 30             	add    $0x30,%esp
f0113f8b:	85 c0                	test   %eax,%eax
f0113f8d:	75 25                	jne    f0113fb4 <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113f8f:	83 ec 04             	sub    $0x4,%esp
f0113f92:	68 78 ae 12 f0       	push   $0xf012ae78
f0113f97:	68 44 04 00 00       	push   $0x444
f0113f9c:	68 42 9b 12 f0       	push   $0xf0129b42
f0113fa1:	e8 11 c5 fe ff       	call   f01004b7 <_warn>
f0113fa6:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113fa9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0113fad:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0113fb4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113fb7:	89 d0                	mov    %edx,%eax
f0113fb9:	01 c0                	add    %eax,%eax
f0113fbb:	01 d0                	add    %edx,%eax
f0113fbd:	c1 e0 02             	shl    $0x2,%eax
f0113fc0:	83 ec 08             	sub    $0x8,%esp
f0113fc3:	6a 02                	push   $0x2
f0113fc5:	6a 07                	push   $0x7
f0113fc7:	6a 03                	push   $0x3
f0113fc9:	68 07 0e 00 00       	push   $0xe07
f0113fce:	68 03 0e 00 00       	push   $0xe03
f0113fd3:	6a 02                	push   $0x2
f0113fd5:	50                   	push   %eax
f0113fd6:	68 00 00 00 40       	push   $0x40000000
f0113fdb:	68 00 00 00 f0       	push   $0xf0000000
f0113fe0:	ff 75 cc             	pushl  -0x34(%ebp)
f0113fe3:	e8 63 2b 00 00       	call   f0116b4b <CCP>
f0113fe8:	83 c4 30             	add    $0x30,%esp
f0113feb:	85 c0                	test   %eax,%eax
f0113fed:	75 1e                	jne    f011400d <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113fef:	83 ec 04             	sub    $0x4,%esp
f0113ff2:	68 78 ae 12 f0       	push   $0xf012ae78
f0113ff7:	68 4b 04 00 00       	push   $0x44b
f0113ffc:	68 42 9b 12 f0       	push   $0xf0129b42
f0114001:	e8 b1 c4 fe ff       	call   f01004b7 <_warn>
f0114006:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114009:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011400d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114011:	74 04                	je     f0114017 <test_share_chunk+0x36d>
f0114013:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114017:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f011401b:	b8 a8 79 57 f0       	mov    $0xf05779a8,%eax
f0114020:	05 00 00 00 10       	add    $0x10000000,%eax
f0114025:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0114028:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011402b:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f0114030:	83 ec 08             	sub    $0x8,%esp
f0114033:	6a 02                	push   $0x2
f0114035:	6a 07                	push   $0x7
f0114037:	6a 03                	push   $0x3
f0114039:	68 07 0e 00 00       	push   $0xe07
f011403e:	68 03 0e 00 00       	push   $0xe03
f0114043:	6a 02                	push   $0x2
f0114045:	50                   	push   %eax
f0114046:	68 00 00 0a 40       	push   $0x400a0000
f011404b:	68 00 00 0a f0       	push   $0xf00a0000
f0114050:	ff 75 cc             	pushl  -0x34(%ebp)
f0114053:	e8 f3 2a 00 00       	call   f0116b4b <CCP>
f0114058:	83 c4 30             	add    $0x30,%esp
f011405b:	85 c0                	test   %eax,%eax
f011405d:	75 1e                	jne    f011407d <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011405f:	83 ec 04             	sub    $0x4,%esp
f0114062:	68 78 ae 12 f0       	push   $0xf012ae78
f0114067:	68 55 04 00 00       	push   $0x455
f011406c:	68 42 9b 12 f0       	push   $0xf0129b42
f0114071:	e8 41 c4 fe ff       	call   f01004b7 <_warn>
f0114076:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114079:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011407d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114081:	74 04                	je     f0114087 <test_share_chunk+0x3dd>
f0114083:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114087:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f011408b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011408f:	0f 84 a4 00 00 00    	je     f0114139 <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f0114095:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f011409c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011409f:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f01140a2:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f01140a9:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01140ac:	8a 00                	mov    (%eax),%al
f01140ae:	3c 41                	cmp    $0x41,%al
f01140b0:	75 09                	jne    f01140bb <test_share_chunk+0x411>
f01140b2:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01140b5:	8a 00                	mov    (%eax),%al
f01140b7:	3c 41                	cmp    $0x41,%al
f01140b9:	74 1e                	je     f01140d9 <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01140bb:	83 ec 04             	sub    $0x4,%esp
f01140be:	68 c0 ae 12 f0       	push   $0xf012aec0
f01140c3:	68 62 04 00 00       	push   $0x462
f01140c8:	68 42 9b 12 f0       	push   $0xf0129b42
f01140cd:	e8 e5 c3 fe ff       	call   f01004b7 <_warn>
f01140d2:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01140d5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f01140d9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01140dd:	74 04                	je     f01140e3 <test_share_chunk+0x439>
f01140df:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01140e3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f01140e7:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f01140ee:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01140f1:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f01140f4:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f01140fb:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01140fe:	8a 00                	mov    (%eax),%al
f0114100:	3c 43                	cmp    $0x43,%al
f0114102:	75 09                	jne    f011410d <test_share_chunk+0x463>
f0114104:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114107:	8a 00                	mov    (%eax),%al
f0114109:	3c 43                	cmp    $0x43,%al
f011410b:	74 1e                	je     f011412b <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011410d:	83 ec 04             	sub    $0x4,%esp
f0114110:	68 c0 ae 12 f0       	push   $0xf012aec0
f0114115:	68 6d 04 00 00       	push   $0x46d
f011411a:	68 42 9b 12 f0       	push   $0xf0129b42
f011411f:	e8 93 c3 fe ff       	call   f01004b7 <_warn>
f0114124:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114127:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f011412b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011412f:	74 04                	je     f0114135 <test_share_chunk+0x48b>
f0114131:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114135:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0114139:	83 ec 0c             	sub    $0xc,%esp
f011413c:	68 cf a4 12 f0       	push   $0xf012a4cf
f0114141:	e8 26 ce fe ff       	call   f0100f6c <cprintf>
f0114146:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f0114149:	83 ec 0c             	sub    $0xc,%esp
f011414c:	68 90 af 12 f0       	push   $0xf012af90
f0114151:	e8 16 ce fe ff       	call   f0100f6c <cprintf>
f0114156:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114159:	e8 c9 95 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011415e:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f0114161:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114164:	89 d0                	mov    %edx,%eax
f0114166:	c1 e0 03             	shl    $0x3,%eax
f0114169:	01 d0                	add    %edx,%eax
f011416b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0114172:	01 d0                	add    %edx,%eax
f0114174:	c1 e0 03             	shl    $0x3,%eax
f0114177:	83 ec 0c             	sub    $0xc,%esp
f011417a:	6a 06                	push   $0x6
f011417c:	50                   	push   %eax
f011417d:	6a 00                	push   $0x0
f011417f:	68 00 00 00 40       	push   $0x40000000
f0114184:	ff 75 cc             	pushl  -0x34(%ebp)
f0114187:	e8 96 52 ff ff       	call   f0109422 <share_chunk>
f011418c:	83 c4 20             	add    $0x20,%esp
f011418f:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114192:	e8 90 95 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0114197:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f011419a:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f011419e:	75 0b                	jne    f01141ab <test_share_chunk+0x501>
f01141a0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01141a3:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01141a6:	83 f8 01             	cmp    $0x1,%eax
f01141a9:	74 28                	je     f01141d3 <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01141ab:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01141ae:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01141b1:	83 ec 0c             	sub    $0xc,%esp
f01141b4:	50                   	push   %eax
f01141b5:	ff 75 a0             	pushl  -0x60(%ebp)
f01141b8:	68 40 af 12 f0       	push   $0xf012af40
f01141bd:	68 83 04 00 00       	push   $0x483
f01141c2:	68 42 9b 12 f0       	push   $0xf0129b42
f01141c7:	e8 eb c2 fe ff       	call   f01004b7 <_warn>
f01141cc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01141cf:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01141d3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01141d7:	74 04                	je     f01141dd <test_share_chunk+0x533>
f01141d9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01141dd:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f01141e1:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01141e8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01141eb:	05 00 80 02 00       	add    $0x28000,%eax
f01141f0:	c1 e0 02             	shl    $0x2,%eax
f01141f3:	83 ec 08             	sub    $0x8,%esp
f01141f6:	6a 02                	push   $0x2
f01141f8:	6a 07                	push   $0x7
f01141fa:	6a 03                	push   $0x3
f01141fc:	6a 07                	push   $0x7
f01141fe:	6a 07                	push   $0x7
f0114200:	6a ff                	push   $0xffffffff
f0114202:	50                   	push   %eax
f0114203:	6a 00                	push   $0x0
f0114205:	68 00 00 00 40       	push   $0x40000000
f011420a:	ff 75 cc             	pushl  -0x34(%ebp)
f011420d:	e8 39 29 00 00       	call   f0116b4b <CCP>
f0114212:	83 c4 30             	add    $0x30,%esp
f0114215:	85 c0                	test   %eax,%eax
f0114217:	75 25                	jne    f011423e <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114219:	83 ec 04             	sub    $0x4,%esp
f011421c:	68 78 ae 12 f0       	push   $0xf012ae78
f0114221:	68 8c 04 00 00       	push   $0x48c
f0114226:	68 42 9b 12 f0       	push   $0xf0129b42
f011422b:	e8 87 c2 fe ff       	call   f01004b7 <_warn>
f0114230:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114233:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0114237:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f011423e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114241:	89 d0                	mov    %edx,%eax
f0114243:	01 c0                	add    %eax,%eax
f0114245:	01 d0                	add    %edx,%eax
f0114247:	c1 e0 02             	shl    $0x2,%eax
f011424a:	83 ec 08             	sub    $0x8,%esp
f011424d:	6a 02                	push   $0x2
f011424f:	6a 07                	push   $0x7
f0114251:	6a 03                	push   $0x3
f0114253:	6a 07                	push   $0x7
f0114255:	6a 07                	push   $0x7
f0114257:	6a 03                	push   $0x3
f0114259:	50                   	push   %eax
f011425a:	6a 00                	push   $0x0
f011425c:	68 00 00 00 40       	push   $0x40000000
f0114261:	ff 75 cc             	pushl  -0x34(%ebp)
f0114264:	e8 e2 28 00 00       	call   f0116b4b <CCP>
f0114269:	83 c4 30             	add    $0x30,%esp
f011426c:	85 c0                	test   %eax,%eax
f011426e:	75 1e                	jne    f011428e <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114270:	83 ec 04             	sub    $0x4,%esp
f0114273:	68 78 ae 12 f0       	push   $0xf012ae78
f0114278:	68 93 04 00 00       	push   $0x493
f011427d:	68 42 9b 12 f0       	push   $0xf0129b42
f0114282:	e8 30 c2 fe ff       	call   f01004b7 <_warn>
f0114287:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011428a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011428e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114292:	74 04                	je     f0114298 <test_share_chunk+0x5ee>
f0114294:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114298:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f011429c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011429f:	89 d0                	mov    %edx,%eax
f01142a1:	01 c0                	add    %eax,%eax
f01142a3:	01 d0                	add    %edx,%eax
f01142a5:	c1 e0 02             	shl    $0x2,%eax
f01142a8:	f7 d8                	neg    %eax
f01142aa:	05 00 00 0a 00       	add    $0xa0000,%eax
f01142af:	83 ec 08             	sub    $0x8,%esp
f01142b2:	6a 02                	push   $0x2
f01142b4:	6a 07                	push   $0x7
f01142b6:	6a 03                	push   $0x3
f01142b8:	6a 07                	push   $0x7
f01142ba:	6a 07                	push   $0x7
f01142bc:	6a 02                	push   $0x2
f01142be:	50                   	push   %eax
f01142bf:	68 00 30 00 00       	push   $0x3000
f01142c4:	68 00 30 00 40       	push   $0x40003000
f01142c9:	ff 75 cc             	pushl  -0x34(%ebp)
f01142cc:	e8 7a 28 00 00       	call   f0116b4b <CCP>
f01142d1:	83 c4 30             	add    $0x30,%esp
f01142d4:	85 c0                	test   %eax,%eax
f01142d6:	75 1e                	jne    f01142f6 <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01142d8:	83 ec 04             	sub    $0x4,%esp
f01142db:	68 78 ae 12 f0       	push   $0xf012ae78
f01142e0:	68 9b 04 00 00       	push   $0x49b
f01142e5:	68 42 9b 12 f0       	push   $0xf0129b42
f01142ea:	e8 c8 c1 fe ff       	call   f01004b7 <_warn>
f01142ef:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01142f2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01142f6:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01142fa:	74 04                	je     f0114300 <test_share_chunk+0x656>
f01142fc:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114300:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114304:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114307:	c1 e0 02             	shl    $0x2,%eax
f011430a:	83 ec 08             	sub    $0x8,%esp
f011430d:	6a 02                	push   $0x2
f011430f:	6a 07                	push   $0x7
f0114311:	6a 03                	push   $0x3
f0114313:	6a 07                	push   $0x7
f0114315:	6a 07                	push   $0x7
f0114317:	6a 03                	push   $0x3
f0114319:	50                   	push   %eax
f011431a:	68 00 00 0a 00       	push   $0xa0000
f011431f:	68 00 00 0a 40       	push   $0x400a0000
f0114324:	ff 75 cc             	pushl  -0x34(%ebp)
f0114327:	e8 1f 28 00 00       	call   f0116b4b <CCP>
f011432c:	83 c4 30             	add    $0x30,%esp
f011432f:	85 c0                	test   %eax,%eax
f0114331:	75 1e                	jne    f0114351 <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114333:	83 ec 04             	sub    $0x4,%esp
f0114336:	68 78 ae 12 f0       	push   $0xf012ae78
f011433b:	68 a3 04 00 00       	push   $0x4a3
f0114340:	68 42 9b 12 f0       	push   $0xf0129b42
f0114345:	e8 6d c1 fe ff       	call   f01004b7 <_warn>
f011434a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011434d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114351:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114355:	74 04                	je     f011435b <test_share_chunk+0x6b1>
f0114357:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011435b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f011435f:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0114363:	0f 84 92 00 00 00    	je     f01143fb <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f0114369:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f0114370:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f0114377:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f011437e:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f0114385:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114388:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f011438b:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f0114392:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0114399:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011439c:	8a 00                	mov    (%eax),%al
f011439e:	3c 41                	cmp    $0x41,%al
f01143a0:	75 2d                	jne    f01143cf <test_share_chunk+0x725>
f01143a2:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01143a5:	8a 00                	mov    (%eax),%al
f01143a7:	3c 41                	cmp    $0x41,%al
f01143a9:	75 24                	jne    f01143cf <test_share_chunk+0x725>
f01143ab:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01143ae:	8a 00                	mov    (%eax),%al
f01143b0:	3c 41                	cmp    $0x41,%al
f01143b2:	75 1b                	jne    f01143cf <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f01143b4:	8b 45 98             	mov    -0x68(%ebp),%eax
f01143b7:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f01143b9:	3c 44                	cmp    $0x44,%al
f01143bb:	75 12                	jne    f01143cf <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f01143bd:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01143c0:	8a 00                	mov    (%eax),%al
f01143c2:	3c 44                	cmp    $0x44,%al
f01143c4:	75 09                	jne    f01143cf <test_share_chunk+0x725>
f01143c6:	8b 45 90             	mov    -0x70(%ebp),%eax
f01143c9:	8a 00                	mov    (%eax),%al
f01143cb:	3c 44                	cmp    $0x44,%al
f01143cd:	74 1e                	je     f01143ed <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01143cf:	83 ec 04             	sub    $0x4,%esp
f01143d2:	68 c0 ae 12 f0       	push   $0xf012aec0
f01143d7:	68 b5 04 00 00       	push   $0x4b5
f01143dc:	68 42 9b 12 f0       	push   $0xf0129b42
f01143e1:	e8 d1 c0 fe ff       	call   f01004b7 <_warn>
f01143e6:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01143e9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f01143ed:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01143f1:	74 04                	je     f01143f7 <test_share_chunk+0x74d>
f01143f3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01143f7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f01143fb:	83 ec 0c             	sub    $0xc,%esp
f01143fe:	68 32 a5 12 f0       	push   $0xf012a532
f0114403:	e8 64 cb fe ff       	call   f0100f6c <cprintf>
f0114408:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f011440b:	83 ec 0c             	sub    $0xc,%esp
f011440e:	68 cc af 12 f0       	push   $0xf012afcc
f0114413:	e8 54 cb fe ff       	call   f0100f6c <cprintf>
f0114418:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011441b:	e8 07 93 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0114420:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f0114423:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114426:	89 d0                	mov    %edx,%eax
f0114428:	01 c0                	add    %eax,%eax
f011442a:	01 d0                	add    %edx,%eax
f011442c:	01 c0                	add    %eax,%eax
f011442e:	01 d0                	add    %edx,%eax
f0114430:	83 ec 0c             	sub    $0xc,%esp
f0114433:	6a 04                	push   $0x4
f0114435:	50                   	push   %eax
f0114436:	68 00 fc 3f 00       	push   $0x3ffc00
f011443b:	68 00 fc 09 00       	push   $0x9fc00
f0114440:	ff 75 cc             	pushl  -0x34(%ebp)
f0114443:	e8 da 4f ff ff       	call   f0109422 <share_chunk>
f0114448:	83 c4 20             	add    $0x20,%esp
f011444b:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011444e:	e8 d4 92 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0114453:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0114456:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f011445a:	75 0b                	jne    f0114467 <test_share_chunk+0x7bd>
f011445c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011445f:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114462:	83 f8 01             	cmp    $0x1,%eax
f0114465:	74 28                	je     f011448f <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114467:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011446a:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011446d:	83 ec 0c             	sub    $0xc,%esp
f0114470:	50                   	push   %eax
f0114471:	ff 75 8c             	pushl  -0x74(%ebp)
f0114474:	68 40 af 12 f0       	push   $0xf012af40
f0114479:	68 cb 04 00 00       	push   $0x4cb
f011447e:	68 42 9b 12 f0       	push   $0xf0129b42
f0114483:	e8 2f c0 fe ff       	call   f01004b7 <_warn>
f0114488:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011448b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011448f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114493:	74 04                	je     f0114499 <test_share_chunk+0x7ef>
f0114495:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114499:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f011449d:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f01144a4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01144a7:	89 d0                	mov    %edx,%eax
f01144a9:	01 c0                	add    %eax,%eax
f01144ab:	01 d0                	add    %edx,%eax
f01144ad:	c1 e0 02             	shl    $0x2,%eax
f01144b0:	83 ec 08             	sub    $0x8,%esp
f01144b3:	6a 02                	push   $0x2
f01144b5:	6a 07                	push   $0x7
f01144b7:	6a 07                	push   $0x7
f01144b9:	6a 07                	push   $0x7
f01144bb:	6a 05                	push   $0x5
f01144bd:	6a ff                	push   $0xffffffff
f01144bf:	50                   	push   %eax
f01144c0:	68 00 f0 3f 00       	push   $0x3ff000
f01144c5:	68 00 f0 09 00       	push   $0x9f000
f01144ca:	ff 75 cc             	pushl  -0x34(%ebp)
f01144cd:	e8 79 26 00 00       	call   f0116b4b <CCP>
f01144d2:	83 c4 30             	add    $0x30,%esp
f01144d5:	85 c0                	test   %eax,%eax
f01144d7:	75 25                	jne    f01144fe <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01144d9:	83 ec 04             	sub    $0x4,%esp
f01144dc:	68 78 ae 12 f0       	push   $0xf012ae78
f01144e1:	68 d4 04 00 00       	push   $0x4d4
f01144e6:	68 42 9b 12 f0       	push   $0xf0129b42
f01144eb:	e8 c7 bf fe ff       	call   f01004b7 <_warn>
f01144f0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01144f3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f01144f7:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f01144fe:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114502:	74 04                	je     f0114508 <test_share_chunk+0x85e>
f0114504:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114508:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f011450c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011450f:	c1 e0 02             	shl    $0x2,%eax
f0114512:	83 ec 08             	sub    $0x8,%esp
f0114515:	6a 02                	push   $0x2
f0114517:	6a 07                	push   $0x7
f0114519:	6a 07                	push   $0x7
f011451b:	6a 07                	push   $0x7
f011451d:	6a 05                	push   $0x5
f011451f:	6a 03                	push   $0x3
f0114521:	50                   	push   %eax
f0114522:	68 00 f0 3f 00       	push   $0x3ff000
f0114527:	68 00 f0 09 00       	push   $0x9f000
f011452c:	ff 75 cc             	pushl  -0x34(%ebp)
f011452f:	e8 17 26 00 00       	call   f0116b4b <CCP>
f0114534:	83 c4 30             	add    $0x30,%esp
f0114537:	85 c0                	test   %eax,%eax
f0114539:	75 1e                	jne    f0114559 <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011453b:	83 ec 04             	sub    $0x4,%esp
f011453e:	68 78 ae 12 f0       	push   $0xf012ae78
f0114543:	68 dd 04 00 00       	push   $0x4dd
f0114548:	68 42 9b 12 f0       	push   $0xf0129b42
f011454d:	e8 65 bf fe ff       	call   f01004b7 <_warn>
f0114552:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114555:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114559:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011455d:	74 04                	je     f0114563 <test_share_chunk+0x8b9>
f011455f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114563:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114567:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011456a:	c1 e0 03             	shl    $0x3,%eax
f011456d:	83 ec 08             	sub    $0x8,%esp
f0114570:	6a 02                	push   $0x2
f0114572:	6a 07                	push   $0x7
f0114574:	6a 07                	push   $0x7
f0114576:	6a 07                	push   $0x7
f0114578:	6a 05                	push   $0x5
f011457a:	6a 04                	push   $0x4
f011457c:	50                   	push   %eax
f011457d:	68 00 00 40 00       	push   $0x400000
f0114582:	68 00 00 0a 00       	push   $0xa0000
f0114587:	ff 75 cc             	pushl  -0x34(%ebp)
f011458a:	e8 bc 25 00 00       	call   f0116b4b <CCP>
f011458f:	83 c4 30             	add    $0x30,%esp
f0114592:	85 c0                	test   %eax,%eax
f0114594:	75 1e                	jne    f01145b4 <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114596:	83 ec 04             	sub    $0x4,%esp
f0114599:	68 78 ae 12 f0       	push   $0xf012ae78
f011459e:	68 e5 04 00 00       	push   $0x4e5
f01145a3:	68 42 9b 12 f0       	push   $0xf0129b42
f01145a8:	e8 0a bf fe ff       	call   f01004b7 <_warn>
f01145ad:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01145b0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01145b4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01145b8:	74 04                	je     f01145be <test_share_chunk+0x914>
f01145ba:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01145be:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01145c2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01145c6:	0f 84 b2 00 00 00    	je     f011467e <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f01145cc:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f01145d3:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f01145da:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f01145e1:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f01145e8:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f01145ef:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f01145f6:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f01145fd:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114604:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114607:	8a 00                	mov    (%eax),%al
f0114609:	3c 44                	cmp    $0x44,%al
f011460b:	75 45                	jne    f0114652 <test_share_chunk+0x9a8>
f011460d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114610:	8a 00                	mov    (%eax),%al
f0114612:	3c 44                	cmp    $0x44,%al
f0114614:	75 3c                	jne    f0114652 <test_share_chunk+0x9a8>
f0114616:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114619:	8a 00                	mov    (%eax),%al
f011461b:	3c 44                	cmp    $0x44,%al
f011461d:	75 33                	jne    f0114652 <test_share_chunk+0x9a8>
f011461f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114622:	8a 00                	mov    (%eax),%al
f0114624:	3c 44                	cmp    $0x44,%al
f0114626:	75 2a                	jne    f0114652 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0114628:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011462b:	8a 10                	mov    (%eax),%dl
f011462d:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114630:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114632:	38 c2                	cmp    %al,%dl
f0114634:	75 1c                	jne    f0114652 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0114636:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114639:	8a 10                	mov    (%eax),%dl
f011463b:	8b 45 88             	mov    -0x78(%ebp),%eax
f011463e:	8a 00                	mov    (%eax),%al
f0114640:	38 c2                	cmp    %al,%dl
f0114642:	75 0e                	jne    f0114652 <test_share_chunk+0x9a8>
f0114644:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114647:	8a 10                	mov    (%eax),%dl
f0114649:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011464c:	8a 00                	mov    (%eax),%al
f011464e:	38 c2                	cmp    %al,%dl
f0114650:	74 1e                	je     f0114670 <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114652:	83 ec 04             	sub    $0x4,%esp
f0114655:	68 c0 ae 12 f0       	push   $0xf012aec0
f011465a:	68 fa 04 00 00       	push   $0x4fa
f011465f:	68 42 9b 12 f0       	push   $0xf0129b42
f0114664:	e8 4e be fe ff       	call   f01004b7 <_warn>
f0114669:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011466c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114670:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114674:	74 04                	je     f011467a <test_share_chunk+0x9d0>
f0114676:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011467a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f011467e:	83 ec 0c             	sub    $0xc,%esp
f0114681:	68 04 b0 12 f0       	push   $0xf012b004
f0114686:	e8 e1 c8 fe ff       	call   f0100f6c <cprintf>
f011468b:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f011468e:	83 ec 08             	sub    $0x8,%esp
f0114691:	ff 75 e4             	pushl  -0x1c(%ebp)
f0114694:	68 14 b0 12 f0       	push   $0xf012b014
f0114699:	e8 ce c8 fe ff       	call   f0100f6c <cprintf>
f011469e:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01146a1:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01146a5:	75 10                	jne    f01146b7 <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f01146a7:	83 ec 0c             	sub    $0xc,%esp
f01146aa:	68 44 b0 12 f0       	push   $0xf012b044
f01146af:	e8 b8 c8 fe ff       	call   f0100f6c <cprintf>
f01146b4:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01146b7:	a1 e4 51 55 f0       	mov    0xf05551e4,%eax
f01146bc:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01146bf:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01146c2:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01146c5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01146ca:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01146cd:	5b                   	pop    %ebx
f01146ce:	5e                   	pop    %esi
f01146cf:	5f                   	pop    %edi
f01146d0:	5d                   	pop    %ebp
f01146d1:	c3                   	ret    

f01146d2 <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f01146d2:	55                   	push   %ebp
f01146d3:	89 e5                	mov    %esp,%ebp
f01146d5:	57                   	push   %edi
f01146d6:	56                   	push   %esi
f01146d7:	53                   	push   %ebx
f01146d8:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01146de:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01146e4:	bb 44 a2 12 f0       	mov    $0xf012a244,%ebx
f01146e9:	ba 0f 00 00 00       	mov    $0xf,%edx
f01146ee:	89 c7                	mov    %eax,%edi
f01146f0:	89 de                	mov    %ebx,%esi
f01146f2:	89 d1                	mov    %edx,%ecx
f01146f4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01146f6:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f01146fc:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114701:	b0 00                	mov    $0x0,%al
f0114703:	89 d7                	mov    %edx,%edi
f0114705:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114707:	6a 00                	push   $0x0
f0114709:	6a 0a                	push   $0xa
f011470b:	6a 14                	push   $0x14
f011470d:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0114713:	50                   	push   %eax
f0114714:	e8 75 50 ff ff       	call   f010978e <env_create>
f0114719:	83 c4 10             	add    $0x10,%esp
f011471c:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f011471f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114722:	8b 40 64             	mov    0x64(%eax),%eax
f0114725:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0114728:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011472b:	8b 40 68             	mov    0x68(%eax),%eax
f011472e:	89 45 90             	mov    %eax,-0x70(%ebp)
f0114731:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114734:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0114737:	83 ec 0c             	sub    $0xc,%esp
f011473a:	ff 75 cc             	pushl  -0x34(%ebp)
f011473d:	e8 d5 23 00 00       	call   f0116b17 <ClearUserSpace>
f0114742:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114745:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f011474c:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0114753:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f011475a:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f011475e:	83 ec 0c             	sub    $0xc,%esp
f0114761:	68 80 b0 12 f0       	push   $0xf012b080
f0114766:	e8 01 c8 fe ff       	call   f0100f6c <cprintf>
f011476b:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f011476e:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f0114775:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f011477c:	eb 03                	jmp    f0114781 <test_allocate_chunk+0xaf>
f011477e:	ff 4d e4             	decl   -0x1c(%ebp)
f0114781:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0114788:	76 09                	jbe    f0114793 <test_allocate_chunk+0xc1>
f011478a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011478d:	8a 00                	mov    (%eax),%al
f011478f:	84 c0                	test   %al,%al
f0114791:	74 eb                	je     f011477e <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f0114793:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f011479a:	75 06                	jne    f01147a2 <test_allocate_chunk+0xd0>
f011479c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011479f:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f01147a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01147a5:	8a 00                	mov    (%eax),%al
f01147a7:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f01147ad:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01147b0:	8a 00                	mov    (%eax),%al
f01147b2:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f01147b8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01147bb:	8a 00                	mov    (%eax),%al
f01147bd:	0f be c0             	movsbl %al,%eax
f01147c0:	83 ec 08             	sub    $0x8,%esp
f01147c3:	50                   	push   %eax
f01147c4:	68 aa b0 12 f0       	push   $0xf012b0aa
f01147c9:	e8 9e c7 fe ff       	call   f0100f6c <cprintf>
f01147ce:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f01147d1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01147d4:	8a 00                	mov    (%eax),%al
f01147d6:	0f be c0             	movsbl %al,%eax
f01147d9:	83 ec 08             	sub    $0x8,%esp
f01147dc:	50                   	push   %eax
f01147dd:	68 b6 b0 12 f0       	push   $0xf012b0b6
f01147e2:	e8 85 c7 fe ff       	call   f0100f6c <cprintf>
f01147e7:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f01147ea:	83 ec 08             	sub    $0x8,%esp
f01147ed:	68 00 f0 bf ef       	push   $0xefbff000
f01147f2:	ff 75 cc             	pushl  -0x34(%ebp)
f01147f5:	e8 84 22 00 00       	call   f0116a7e <GP>
f01147fa:	83 c4 10             	add    $0x10,%esp
f01147fd:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114800:	e8 22 8f ff ff       	call   f010d727 <sys_calculate_free_frames>
f0114805:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f0114808:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011480b:	c1 e0 02             	shl    $0x2,%eax
f011480e:	6a 02                	push   $0x2
f0114810:	50                   	push   %eax
f0114811:	68 00 f0 bf ef       	push   $0xefbff000
f0114816:	ff 75 cc             	pushl  -0x34(%ebp)
f0114819:	e8 1e 4c ff ff       	call   f010943c <allocate_chunk>
f011481e:	83 c4 10             	add    $0x10,%esp
f0114821:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114824:	e8 fe 8e ff ff       	call   f010d727 <sys_calculate_free_frames>
f0114829:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f011482c:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114830:	75 08                	jne    f011483a <test_allocate_chunk+0x168>
f0114832:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114835:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114838:	74 2a                	je     f0114864 <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f011483a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011483d:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114840:	83 ec 08             	sub    $0x8,%esp
f0114843:	6a 00                	push   $0x0
f0114845:	50                   	push   %eax
f0114846:	ff 75 b0             	pushl  -0x50(%ebp)
f0114849:	68 c4 b0 12 f0       	push   $0xf012b0c4
f011484e:	68 3a 05 00 00       	push   $0x53a
f0114853:	68 42 9b 12 f0       	push   $0xf0129b42
f0114858:	e8 5a bc fe ff       	call   f01004b7 <_warn>
f011485d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114860:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114864:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114868:	74 04                	je     f011486e <test_allocate_chunk+0x19c>
f011486a:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f011486e:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114872:	e8 b0 8e ff ff       	call   f010d727 <sys_calculate_free_frames>
f0114877:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f011487a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011487d:	01 c0                	add    %eax,%eax
f011487f:	89 c1                	mov    %eax,%ecx
f0114881:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114884:	89 d0                	mov    %edx,%eax
f0114886:	c1 e0 02             	shl    $0x2,%eax
f0114889:	01 d0                	add    %edx,%eax
f011488b:	f7 d8                	neg    %eax
f011488d:	2d 00 00 40 10       	sub    $0x10400000,%eax
f0114892:	6a 02                	push   $0x2
f0114894:	51                   	push   %ecx
f0114895:	50                   	push   %eax
f0114896:	ff 75 cc             	pushl  -0x34(%ebp)
f0114899:	e8 9e 4b ff ff       	call   f010943c <allocate_chunk>
f011489e:	83 c4 10             	add    $0x10,%esp
f01148a1:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01148a4:	e8 7e 8e ff ff       	call   f010d727 <sys_calculate_free_frames>
f01148a9:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f01148ac:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f01148b0:	75 08                	jne    f01148ba <test_allocate_chunk+0x1e8>
f01148b2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01148b5:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f01148b8:	74 2a                	je     f01148e4 <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f01148ba:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01148bd:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01148c0:	83 ec 08             	sub    $0x8,%esp
f01148c3:	6a 00                	push   $0x0
f01148c5:	50                   	push   %eax
f01148c6:	ff 75 b0             	pushl  -0x50(%ebp)
f01148c9:	68 c4 b0 12 f0       	push   $0xf012b0c4
f01148ce:	68 48 05 00 00       	push   $0x548
f01148d3:	68 42 9b 12 f0       	push   $0xf0129b42
f01148d8:	e8 da bb fe ff       	call   f01004b7 <_warn>
f01148dd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01148e0:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f01148e4:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01148e8:	74 04                	je     f01148ee <test_allocate_chunk+0x21c>
f01148ea:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01148ee:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f01148f2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01148f5:	c1 e0 02             	shl    $0x2,%eax
f01148f8:	83 ec 08             	sub    $0x8,%esp
f01148fb:	6a 03                	push   $0x3
f01148fd:	6a 00                	push   $0x0
f01148ff:	6a 00                	push   $0x0
f0114901:	68 ff 0f 00 00       	push   $0xfff
f0114906:	ff 75 b8             	pushl  -0x48(%ebp)
f0114909:	6a 01                	push   $0x1
f011490b:	50                   	push   %eax
f011490c:	68 00 f0 bf ef       	push   $0xefbff000
f0114911:	6a 00                	push   $0x0
f0114913:	ff 75 cc             	pushl  -0x34(%ebp)
f0114916:	e8 30 22 00 00       	call   f0116b4b <CCP>
f011491b:	83 c4 30             	add    $0x30,%esp
f011491e:	85 c0                	test   %eax,%eax
f0114920:	75 1e                	jne    f0114940 <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114922:	83 ec 04             	sub    $0x4,%esp
f0114925:	68 2c b1 12 f0       	push   $0xf012b12c
f011492a:	68 50 05 00 00       	push   $0x550
f011492f:	68 42 9b 12 f0       	push   $0xf0129b42
f0114934:	e8 7e bb fe ff       	call   f01004b7 <_warn>
f0114939:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011493c:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114940:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114944:	74 04                	je     f011494a <test_allocate_chunk+0x278>
f0114946:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f011494a:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f011494e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114951:	8a 10                	mov    (%eax),%dl
f0114953:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f0114959:	38 c2                	cmp    %al,%dl
f011495b:	75 0f                	jne    f011496c <test_allocate_chunk+0x29a>
f011495d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114960:	8a 10                	mov    (%eax),%dl
f0114962:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f0114968:	38 c2                	cmp    %al,%dl
f011496a:	74 1e                	je     f011498a <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f011496c:	83 ec 04             	sub    $0x4,%esp
f011496f:	68 78 b1 12 f0       	push   $0xf012b178
f0114974:	68 58 05 00 00       	push   $0x558
f0114979:	68 42 9b 12 f0       	push   $0xf0129b42
f011497e:	e8 34 bb fe ff       	call   f01004b7 <_warn>
f0114983:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114986:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f011498a:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011498e:	74 04                	je     f0114994 <test_allocate_chunk+0x2c2>
f0114990:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114994:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0114998:	83 ec 0c             	sub    $0xc,%esp
f011499b:	68 f5 ae 12 f0       	push   $0xf012aef5
f01149a0:	e8 c7 c5 fe ff       	call   f0100f6c <cprintf>
f01149a5:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f01149a8:	83 ec 0c             	sub    $0xc,%esp
f01149ab:	68 b0 b1 12 f0       	push   $0xf012b1b0
f01149b0:	e8 b7 c5 fe ff       	call   f0100f6c <cprintf>
f01149b5:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01149b8:	e8 6a 8d ff ff       	call   f010d727 <sys_calculate_free_frames>
f01149bd:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f01149c0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01149c3:	c1 e0 05             	shl    $0x5,%eax
f01149c6:	68 02 0e 00 00       	push   $0xe02
f01149cb:	50                   	push   %eax
f01149cc:	6a 00                	push   $0x0
f01149ce:	ff 75 cc             	pushl  -0x34(%ebp)
f01149d1:	e8 66 4a ff ff       	call   f010943c <allocate_chunk>
f01149d6:	83 c4 10             	add    $0x10,%esp
f01149d9:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01149dc:	e8 46 8d ff ff       	call   f010d727 <sys_calculate_free_frames>
f01149e1:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f01149e4:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f01149e8:	75 36                	jne    f0114a20 <test_allocate_chunk+0x34e>
f01149ea:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01149ed:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01149f0:	89 c1                	mov    %eax,%ecx
f01149f2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01149f5:	c1 e0 05             	shl    $0x5,%eax
f01149f8:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01149fb:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114a02:	99                   	cltd   
f0114a03:	f7 fe                	idiv   %esi
f0114a05:	89 c3                	mov    %eax,%ebx
f0114a07:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114a0a:	c1 e0 05             	shl    $0x5,%eax
f0114a0d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114a10:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114a17:	99                   	cltd   
f0114a18:	f7 fe                	idiv   %esi
f0114a1a:	01 d8                	add    %ebx,%eax
f0114a1c:	39 c1                	cmp    %eax,%ecx
f0114a1e:	74 54                	je     f0114a74 <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f0114a20:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114a23:	c1 e0 05             	shl    $0x5,%eax
f0114a26:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114a29:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114a30:	99                   	cltd   
f0114a31:	f7 ff                	idiv   %edi
f0114a33:	89 c1                	mov    %eax,%ecx
f0114a35:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114a38:	c1 e0 05             	shl    $0x5,%eax
f0114a3b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114a3e:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114a45:	99                   	cltd   
f0114a46:	f7 fe                	idiv   %esi
f0114a48:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114a4b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114a4e:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114a51:	83 ec 08             	sub    $0x8,%esp
f0114a54:	52                   	push   %edx
f0114a55:	50                   	push   %eax
f0114a56:	ff 75 a8             	pushl  -0x58(%ebp)
f0114a59:	68 f0 b1 12 f0       	push   $0xf012b1f0
f0114a5e:	68 6d 05 00 00       	push   $0x56d
f0114a63:	68 42 9b 12 f0       	push   $0xf0129b42
f0114a68:	e8 4a ba fe ff       	call   f01004b7 <_warn>
f0114a6d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114a70:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114a74:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114a78:	74 04                	je     f0114a7e <test_allocate_chunk+0x3ac>
f0114a7a:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114a7e:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114a82:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114a89:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114a8c:	c1 e0 05             	shl    $0x5,%eax
f0114a8f:	83 ec 08             	sub    $0x8,%esp
f0114a92:	6a 03                	push   $0x3
f0114a94:	6a 00                	push   $0x0
f0114a96:	6a 00                	push   $0x0
f0114a98:	68 07 0e 00 00       	push   $0xe07
f0114a9d:	68 03 0e 00 00       	push   $0xe03
f0114aa2:	6a 01                	push   $0x1
f0114aa4:	50                   	push   %eax
f0114aa5:	6a 00                	push   $0x0
f0114aa7:	6a 00                	push   $0x0
f0114aa9:	ff 75 cc             	pushl  -0x34(%ebp)
f0114aac:	e8 9a 20 00 00       	call   f0116b4b <CCP>
f0114ab1:	83 c4 30             	add    $0x30,%esp
f0114ab4:	85 c0                	test   %eax,%eax
f0114ab6:	75 25                	jne    f0114add <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114ab8:	83 ec 04             	sub    $0x4,%esp
f0114abb:	68 2c b1 12 f0       	push   $0xf012b12c
f0114ac0:	68 76 05 00 00       	push   $0x576
f0114ac5:	68 42 9b 12 f0       	push   $0xf0129b42
f0114aca:	e8 e8 b9 fe ff       	call   f01004b7 <_warn>
f0114acf:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114ad2:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114ad6:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f0114add:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114ae1:	74 04                	je     f0114ae7 <test_allocate_chunk+0x415>
f0114ae3:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114ae7:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0114aeb:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0114aef:	74 5a                	je     f0114b4b <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f0114af1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114af4:	01 c0                	add    %eax,%eax
f0114af6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0114af9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114afc:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f0114aff:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114b02:	01 c0                	add    %eax,%eax
f0114b04:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0114b07:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114b0a:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0114b0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114b10:	8a 00                	mov    (%eax),%al
f0114b12:	3c 4b                	cmp    $0x4b,%al
f0114b14:	75 09                	jne    f0114b1f <test_allocate_chunk+0x44d>
f0114b16:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114b19:	8a 00                	mov    (%eax),%al
f0114b1b:	3c 4d                	cmp    $0x4d,%al
f0114b1d:	74 1e                	je     f0114b3d <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0114b1f:	83 ec 04             	sub    $0x4,%esp
f0114b22:	68 78 b1 12 f0       	push   $0xf012b178
f0114b27:	68 84 05 00 00       	push   $0x584
f0114b2c:	68 42 9b 12 f0       	push   $0xf0129b42
f0114b31:	e8 81 b9 fe ff       	call   f01004b7 <_warn>
f0114b36:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114b39:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0114b3d:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114b41:	74 04                	je     f0114b47 <test_allocate_chunk+0x475>
f0114b43:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0114b47:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0114b4b:	83 ec 0c             	sub    $0xc,%esp
f0114b4e:	68 cf a4 12 f0       	push   $0xf012a4cf
f0114b53:	e8 14 c4 fe ff       	call   f0100f6c <cprintf>
f0114b58:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f0114b5b:	83 ec 0c             	sub    $0xc,%esp
f0114b5e:	68 50 b2 12 f0       	push   $0xf012b250
f0114b63:	e8 04 c4 fe ff       	call   f0100f6c <cprintf>
f0114b68:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114b6b:	e8 b7 8b ff ff       	call   f010d727 <sys_calculate_free_frames>
f0114b70:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f0114b73:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114b76:	c1 e0 06             	shl    $0x6,%eax
f0114b79:	89 c2                	mov    %eax,%edx
f0114b7b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114b7e:	c1 e0 05             	shl    $0x5,%eax
f0114b81:	6a 00                	push   $0x0
f0114b83:	52                   	push   %edx
f0114b84:	50                   	push   %eax
f0114b85:	ff 75 cc             	pushl  -0x34(%ebp)
f0114b88:	e8 af 48 ff ff       	call   f010943c <allocate_chunk>
f0114b8d:	83 c4 10             	add    $0x10,%esp
f0114b90:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114b93:	e8 8f 8b ff ff       	call   f010d727 <sys_calculate_free_frames>
f0114b98:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f0114b9b:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f0114b9f:	75 36                	jne    f0114bd7 <test_allocate_chunk+0x505>
f0114ba1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114ba4:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114ba7:	89 c1                	mov    %eax,%ecx
f0114ba9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114bac:	c1 e0 06             	shl    $0x6,%eax
f0114baf:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114bb2:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114bb9:	99                   	cltd   
f0114bba:	f7 ff                	idiv   %edi
f0114bbc:	89 c3                	mov    %eax,%ebx
f0114bbe:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114bc1:	c1 e0 06             	shl    $0x6,%eax
f0114bc4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114bc7:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114bce:	99                   	cltd   
f0114bcf:	f7 fe                	idiv   %esi
f0114bd1:	01 d8                	add    %ebx,%eax
f0114bd3:	39 c1                	cmp    %eax,%ecx
f0114bd5:	74 54                	je     f0114c2b <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f0114bd7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114bda:	c1 e0 06             	shl    $0x6,%eax
f0114bdd:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114be0:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114be7:	99                   	cltd   
f0114be8:	f7 fb                	idiv   %ebx
f0114bea:	89 c1                	mov    %eax,%ecx
f0114bec:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114bef:	c1 e0 06             	shl    $0x6,%eax
f0114bf2:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114bf5:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114bfc:	99                   	cltd   
f0114bfd:	f7 ff                	idiv   %edi
f0114bff:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114c02:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114c05:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114c08:	83 ec 08             	sub    $0x8,%esp
f0114c0b:	52                   	push   %edx
f0114c0c:	50                   	push   %eax
f0114c0d:	ff 75 a4             	pushl  -0x5c(%ebp)
f0114c10:	68 f0 b1 12 f0       	push   $0xf012b1f0
f0114c15:	68 9a 05 00 00       	push   $0x59a
f0114c1a:	68 42 9b 12 f0       	push   $0xf0129b42
f0114c1f:	e8 93 b8 fe ff       	call   f01004b7 <_warn>
f0114c24:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114c27:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114c2b:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114c2f:	74 04                	je     f0114c35 <test_allocate_chunk+0x563>
f0114c31:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114c35:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114c39:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114c40:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114c43:	c1 e0 06             	shl    $0x6,%eax
f0114c46:	89 c2                	mov    %eax,%edx
f0114c48:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114c4b:	c1 e0 05             	shl    $0x5,%eax
f0114c4e:	83 ec 08             	sub    $0x8,%esp
f0114c51:	6a 03                	push   $0x3
f0114c53:	6a 00                	push   $0x0
f0114c55:	6a 00                	push   $0x0
f0114c57:	68 07 0e 00 00       	push   $0xe07
f0114c5c:	6a 01                	push   $0x1
f0114c5e:	6a 01                	push   $0x1
f0114c60:	52                   	push   %edx
f0114c61:	50                   	push   %eax
f0114c62:	6a 00                	push   $0x0
f0114c64:	ff 75 cc             	pushl  -0x34(%ebp)
f0114c67:	e8 df 1e 00 00       	call   f0116b4b <CCP>
f0114c6c:	83 c4 30             	add    $0x30,%esp
f0114c6f:	85 c0                	test   %eax,%eax
f0114c71:	75 25                	jne    f0114c98 <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114c73:	83 ec 04             	sub    $0x4,%esp
f0114c76:	68 2c b1 12 f0       	push   $0xf012b12c
f0114c7b:	68 a3 05 00 00       	push   $0x5a3
f0114c80:	68 42 9b 12 f0       	push   $0xf0129b42
f0114c85:	e8 2d b8 fe ff       	call   f01004b7 <_warn>
f0114c8a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114c8d:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114c91:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f0114c98:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114c9c:	74 04                	je     f0114ca2 <test_allocate_chunk+0x5d0>
f0114c9e:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114ca2:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f0114ca6:	83 ec 0c             	sub    $0xc,%esp
f0114ca9:	68 32 a5 12 f0       	push   $0xf012a532
f0114cae:	e8 b9 c2 fe ff       	call   f0100f6c <cprintf>
f0114cb3:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f0114cb6:	83 ec 0c             	sub    $0xc,%esp
f0114cb9:	68 90 b2 12 f0       	push   $0xf012b290
f0114cbe:	e8 a9 c2 fe ff       	call   f0100f6c <cprintf>
f0114cc3:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114cc6:	e8 5c 8a ff ff       	call   f010d727 <sys_calculate_free_frames>
f0114ccb:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f0114cce:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114cd1:	c1 e0 06             	shl    $0x6,%eax
f0114cd4:	68 06 0e 00 00       	push   $0xe06
f0114cd9:	50                   	push   %eax
f0114cda:	68 00 00 00 80       	push   $0x80000000
f0114cdf:	ff 75 cc             	pushl  -0x34(%ebp)
f0114ce2:	e8 55 47 ff ff       	call   f010943c <allocate_chunk>
f0114ce7:	83 c4 10             	add    $0x10,%esp
f0114cea:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114ced:	e8 35 8a ff ff       	call   f010d727 <sys_calculate_free_frames>
f0114cf2:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f0114cf5:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f0114cf9:	75 36                	jne    f0114d31 <test_allocate_chunk+0x65f>
f0114cfb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114cfe:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114d01:	89 c1                	mov    %eax,%ecx
f0114d03:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114d06:	c1 e0 06             	shl    $0x6,%eax
f0114d09:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114d0c:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114d13:	99                   	cltd   
f0114d14:	f7 fb                	idiv   %ebx
f0114d16:	89 c3                	mov    %eax,%ebx
f0114d18:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114d1b:	c1 e0 06             	shl    $0x6,%eax
f0114d1e:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114d21:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114d28:	99                   	cltd   
f0114d29:	f7 fe                	idiv   %esi
f0114d2b:	01 d8                	add    %ebx,%eax
f0114d2d:	39 c1                	cmp    %eax,%ecx
f0114d2f:	74 54                	je     f0114d85 <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f0114d31:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114d34:	c1 e0 06             	shl    $0x6,%eax
f0114d37:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114d3a:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114d41:	99                   	cltd   
f0114d42:	f7 ff                	idiv   %edi
f0114d44:	89 c1                	mov    %eax,%ecx
f0114d46:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114d49:	c1 e0 06             	shl    $0x6,%eax
f0114d4c:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114d4f:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114d56:	99                   	cltd   
f0114d57:	f7 fb                	idiv   %ebx
f0114d59:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114d5c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114d5f:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114d62:	83 ec 08             	sub    $0x8,%esp
f0114d65:	52                   	push   %edx
f0114d66:	50                   	push   %eax
f0114d67:	ff 75 9c             	pushl  -0x64(%ebp)
f0114d6a:	68 f0 b1 12 f0       	push   $0xf012b1f0
f0114d6f:	68 b9 05 00 00       	push   $0x5b9
f0114d74:	68 42 9b 12 f0       	push   $0xf0129b42
f0114d79:	e8 39 b7 fe ff       	call   f01004b7 <_warn>
f0114d7e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114d81:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114d85:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114d89:	74 04                	je     f0114d8f <test_allocate_chunk+0x6bd>
f0114d8b:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114d8f:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114d93:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114d9a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114d9d:	c1 e0 06             	shl    $0x6,%eax
f0114da0:	83 ec 08             	sub    $0x8,%esp
f0114da3:	6a 03                	push   $0x3
f0114da5:	6a 00                	push   $0x0
f0114da7:	6a 00                	push   $0x0
f0114da9:	68 07 0e 00 00       	push   $0xe07
f0114dae:	68 07 0e 00 00       	push   $0xe07
f0114db3:	6a 01                	push   $0x1
f0114db5:	50                   	push   %eax
f0114db6:	68 00 00 00 80       	push   $0x80000000
f0114dbb:	6a 00                	push   $0x0
f0114dbd:	ff 75 cc             	pushl  -0x34(%ebp)
f0114dc0:	e8 86 1d 00 00       	call   f0116b4b <CCP>
f0114dc5:	83 c4 30             	add    $0x30,%esp
f0114dc8:	85 c0                	test   %eax,%eax
f0114dca:	75 25                	jne    f0114df1 <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114dcc:	83 ec 04             	sub    $0x4,%esp
f0114dcf:	68 2c b1 12 f0       	push   $0xf012b12c
f0114dd4:	68 c2 05 00 00       	push   $0x5c2
f0114dd9:	68 42 9b 12 f0       	push   $0xf0129b42
f0114dde:	e8 d4 b6 fe ff       	call   f01004b7 <_warn>
f0114de3:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114de6:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114dea:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f0114df1:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114df5:	74 04                	je     f0114dfb <test_allocate_chunk+0x729>
f0114df7:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114dfb:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0114dff:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0114e03:	74 6f                	je     f0114e74 <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f0114e05:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114e08:	01 c0                	add    %eax,%eax
f0114e0a:	05 00 00 00 80       	add    $0x80000000,%eax
f0114e0f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0114e12:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114e15:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f0114e18:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114e1b:	89 d0                	mov    %edx,%eax
f0114e1d:	c1 e0 02             	shl    $0x2,%eax
f0114e20:	01 d0                	add    %edx,%eax
f0114e22:	01 c0                	add    %eax,%eax
f0114e24:	01 d0                	add    %edx,%eax
f0114e26:	01 c0                	add    %eax,%eax
f0114e28:	05 00 00 00 80       	add    $0x80000000,%eax
f0114e2d:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0114e30:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114e33:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0114e36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114e39:	8a 00                	mov    (%eax),%al
f0114e3b:	3c 4b                	cmp    $0x4b,%al
f0114e3d:	75 09                	jne    f0114e48 <test_allocate_chunk+0x776>
f0114e3f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114e42:	8a 00                	mov    (%eax),%al
f0114e44:	3c 4d                	cmp    $0x4d,%al
f0114e46:	74 1e                	je     f0114e66 <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0114e48:	83 ec 04             	sub    $0x4,%esp
f0114e4b:	68 78 b1 12 f0       	push   $0xf012b178
f0114e50:	68 d0 05 00 00       	push   $0x5d0
f0114e55:	68 42 9b 12 f0       	push   $0xf0129b42
f0114e5a:	e8 58 b6 fe ff       	call   f01004b7 <_warn>
f0114e5f:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114e62:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0114e66:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114e6a:	74 04                	je     f0114e70 <test_allocate_chunk+0x79e>
f0114e6c:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0114e70:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f0114e74:	83 ec 0c             	sub    $0xc,%esp
f0114e77:	68 04 b0 12 f0       	push   $0xf012b004
f0114e7c:	e8 eb c0 fe ff       	call   f0100f6c <cprintf>
f0114e81:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f0114e84:	83 ec 0c             	sub    $0xc,%esp
f0114e87:	68 cc b2 12 f0       	push   $0xf012b2cc
f0114e8c:	e8 db c0 fe ff       	call   f0100f6c <cprintf>
f0114e91:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114e94:	e8 8e 88 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0114e99:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f0114e9c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114e9f:	89 d0                	mov    %edx,%eax
f0114ea1:	01 c0                	add    %eax,%eax
f0114ea3:	01 d0                	add    %edx,%eax
f0114ea5:	01 c0                	add    %eax,%eax
f0114ea7:	01 d0                	add    %edx,%eax
f0114ea9:	68 04 0e 00 00       	push   $0xe04
f0114eae:	50                   	push   %eax
f0114eaf:	68 00 fc 3f 40       	push   $0x403ffc00
f0114eb4:	ff 75 cc             	pushl  -0x34(%ebp)
f0114eb7:	e8 80 45 ff ff       	call   f010943c <allocate_chunk>
f0114ebc:	83 c4 10             	add    $0x10,%esp
f0114ebf:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114ec2:	e8 60 88 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0114ec7:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f0114eca:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0114ece:	75 0b                	jne    f0114edb <test_allocate_chunk+0x809>
f0114ed0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114ed3:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114ed6:	83 f8 05             	cmp    $0x5,%eax
f0114ed9:	74 2a                	je     f0114f05 <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f0114edb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114ede:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114ee1:	83 ec 08             	sub    $0x8,%esp
f0114ee4:	6a 05                	push   $0x5
f0114ee6:	50                   	push   %eax
f0114ee7:	ff 75 98             	pushl  -0x68(%ebp)
f0114eea:	68 f0 b1 12 f0       	push   $0xf012b1f0
f0114eef:	68 e7 05 00 00       	push   $0x5e7
f0114ef4:	68 42 9b 12 f0       	push   $0xf0129b42
f0114ef9:	e8 b9 b5 fe ff       	call   f01004b7 <_warn>
f0114efe:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114f01:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0114f05:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114f09:	74 04                	je     f0114f0f <test_allocate_chunk+0x83d>
f0114f0b:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114f0f:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114f13:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114f1a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114f1d:	89 d0                	mov    %edx,%eax
f0114f1f:	01 c0                	add    %eax,%eax
f0114f21:	01 d0                	add    %edx,%eax
f0114f23:	c1 e0 02             	shl    $0x2,%eax
f0114f26:	83 ec 08             	sub    $0x8,%esp
f0114f29:	6a 03                	push   $0x3
f0114f2b:	6a 00                	push   $0x0
f0114f2d:	6a 00                	push   $0x0
f0114f2f:	68 07 0e 00 00       	push   $0xe07
f0114f34:	68 05 0e 00 00       	push   $0xe05
f0114f39:	6a 01                	push   $0x1
f0114f3b:	50                   	push   %eax
f0114f3c:	68 00 f0 3f 40       	push   $0x403ff000
f0114f41:	6a 00                	push   $0x0
f0114f43:	ff 75 cc             	pushl  -0x34(%ebp)
f0114f46:	e8 00 1c 00 00       	call   f0116b4b <CCP>
f0114f4b:	83 c4 30             	add    $0x30,%esp
f0114f4e:	85 c0                	test   %eax,%eax
f0114f50:	75 25                	jne    f0114f77 <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114f52:	83 ec 04             	sub    $0x4,%esp
f0114f55:	68 2c b1 12 f0       	push   $0xf012b12c
f0114f5a:	68 f0 05 00 00       	push   $0x5f0
f0114f5f:	68 42 9b 12 f0       	push   $0xf0129b42
f0114f64:	e8 4e b5 fe ff       	call   f01004b7 <_warn>
f0114f69:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114f6c:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114f70:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f0114f77:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114f7b:	74 04                	je     f0114f81 <test_allocate_chunk+0x8af>
f0114f7d:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114f81:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f0114f85:	83 ec 0c             	sub    $0xc,%esp
f0114f88:	68 03 b3 12 f0       	push   $0xf012b303
f0114f8d:	e8 da bf fe ff       	call   f0100f6c <cprintf>
f0114f92:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f0114f95:	83 ec 08             	sub    $0x8,%esp
f0114f98:	ff 75 e0             	pushl  -0x20(%ebp)
f0114f9b:	68 14 b3 12 f0       	push   $0xf012b314
f0114fa0:	e8 c7 bf fe ff       	call   f0100f6c <cprintf>
f0114fa5:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114fa8:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f0114fac:	75 10                	jne    f0114fbe <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f0114fae:	83 ec 0c             	sub    $0xc,%esp
f0114fb1:	68 48 b3 12 f0       	push   $0xf012b348
f0114fb6:	e8 b1 bf fe ff       	call   f0100f6c <cprintf>
f0114fbb:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114fbe:	a1 e4 51 55 f0       	mov    0xf05551e4,%eax
f0114fc3:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0114fc6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114fc9:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114fcc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114fd1:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0114fd4:	5b                   	pop    %ebx
f0114fd5:	5e                   	pop    %esi
f0114fd6:	5f                   	pop    %edi
f0114fd7:	5d                   	pop    %ebp
f0114fd8:	c3                   	ret    

f0114fd9 <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f0114fd9:	55                   	push   %ebp
f0114fda:	89 e5                	mov    %esp,%ebp
f0114fdc:	57                   	push   %edi
f0114fdd:	56                   	push   %esi
f0114fde:	53                   	push   %ebx
f0114fdf:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0114fe5:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0114fe8:	bb 44 a2 12 f0       	mov    $0xf012a244,%ebx
f0114fed:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114ff2:	89 c7                	mov    %eax,%edi
f0114ff4:	89 de                	mov    %ebx,%esi
f0114ff6:	89 d1                	mov    %edx,%ecx
f0114ff8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114ffa:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0114ffd:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115002:	b0 00                	mov    $0x0,%al
f0115004:	89 d7                	mov    %edx,%edi
f0115006:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0115008:	6a 00                	push   $0x0
f011500a:	6a 0a                	push   $0xa
f011500c:	6a 14                	push   $0x14
f011500e:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115011:	50                   	push   %eax
f0115012:	e8 77 47 ff ff       	call   f010978e <env_create>
f0115017:	83 c4 10             	add    $0x10,%esp
f011501a:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f011501d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115020:	8b 40 64             	mov    0x64(%eax),%eax
f0115023:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0115026:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115029:	8b 40 68             	mov    0x68(%eax),%eax
f011502c:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011502f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115032:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0115035:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f011503c:	75 70 20 
f011503f:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0115046:	00 00 00 
f0115049:	8d 55 82             	lea    -0x7e(%ebp),%edx
f011504c:	b9 03 00 00 00       	mov    $0x3,%ecx
f0115051:	b8 00 00 00 00       	mov    $0x0,%eax
f0115056:	89 d7                	mov    %edx,%edi
f0115058:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f011505a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011505d:	8b 40 10             	mov    0x10(%eax),%eax
f0115060:	83 ec 08             	sub    $0x8,%esp
f0115063:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0115069:	52                   	push   %edx
f011506a:	50                   	push   %eax
f011506b:	e8 87 b9 00 00       	call   f01209f7 <ltostr>
f0115070:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0115073:	83 ec 04             	sub    $0x4,%esp
f0115076:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011507c:	50                   	push   %eax
f011507d:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0115083:	50                   	push   %eax
f0115084:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f011508a:	50                   	push   %eax
f011508b:	e8 40 ba 00 00       	call   f0120ad0 <strcconcat>
f0115090:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115093:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f011509a:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f01150a1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f01150a8:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f01150af:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f01150b3:	83 ec 0c             	sub    $0xc,%esp
f01150b6:	ff 75 d8             	pushl  -0x28(%ebp)
f01150b9:	e8 59 1a 00 00       	call   f0116b17 <ClearUserSpace>
f01150be:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f01150c1:	83 ec 0c             	sub    $0xc,%esp
f01150c4:	68 88 b3 12 f0       	push   $0xf012b388
f01150c9:	e8 9e be fe ff       	call   f0100f6c <cprintf>
f01150ce:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f01150d1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01150d4:	c1 e0 03             	shl    $0x3,%eax
f01150d7:	83 ec 04             	sub    $0x4,%esp
f01150da:	50                   	push   %eax
f01150db:	6a 00                	push   $0x0
f01150dd:	ff 75 d8             	pushl  -0x28(%ebp)
f01150e0:	e8 8b 43 ff ff       	call   f0109470 <calculate_required_frames>
f01150e5:	83 c4 10             	add    $0x10,%esp
f01150e8:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f01150eb:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f01150ef:	74 23                	je     f0115114 <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f01150f1:	83 ec 0c             	sub    $0xc,%esp
f01150f4:	6a 03                	push   $0x3
f01150f6:	ff 75 c8             	pushl  -0x38(%ebp)
f01150f9:	68 bc b3 12 f0       	push   $0xf012b3bc
f01150fe:	68 29 06 00 00       	push   $0x629
f0115103:	68 42 9b 12 f0       	push   $0xf0129b42
f0115108:	e8 aa b3 fe ff       	call   f01004b7 <_warn>
f011510d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115110:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115114:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115118:	74 04                	je     f011511e <test_calculate_required_frames+0x145>
f011511a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011511e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f0115122:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115125:	c1 e0 02             	shl    $0x2,%eax
f0115128:	83 ec 04             	sub    $0x4,%esp
f011512b:	50                   	push   %eax
f011512c:	6a 00                	push   $0x0
f011512e:	ff 75 d8             	pushl  -0x28(%ebp)
f0115131:	e8 3a 43 ff ff       	call   f0109470 <calculate_required_frames>
f0115136:	83 c4 10             	add    $0x10,%esp
f0115139:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f011513c:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f0115143:	74 26                	je     f011516b <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f0115145:	83 ec 0c             	sub    $0xc,%esp
f0115148:	68 01 04 00 00       	push   $0x401
f011514d:	ff 75 c8             	pushl  -0x38(%ebp)
f0115150:	68 bc b3 12 f0       	push   $0xf012b3bc
f0115155:	68 33 06 00 00       	push   $0x633
f011515a:	68 42 9b 12 f0       	push   $0xf0129b42
f011515f:	e8 53 b3 fe ff       	call   f01004b7 <_warn>
f0115164:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115167:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011516b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011516f:	74 04                	je     f0115175 <test_calculate_required_frames+0x19c>
f0115171:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115175:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0115179:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011517c:	c1 e0 0a             	shl    $0xa,%eax
f011517f:	83 ec 04             	sub    $0x4,%esp
f0115182:	50                   	push   %eax
f0115183:	6a 00                	push   $0x0
f0115185:	ff 75 d8             	pushl  -0x28(%ebp)
f0115188:	e8 e3 42 ff ff       	call   f0109470 <calculate_required_frames>
f011518d:	83 c4 10             	add    $0x10,%esp
f0115190:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f0115193:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115196:	c1 e0 0a             	shl    $0xa,%eax
f0115199:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011519c:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01151a3:	99                   	cltd   
f01151a4:	f7 fb                	idiv   %ebx
f01151a6:	89 c1                	mov    %eax,%ecx
f01151a8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01151ab:	c1 e0 0a             	shl    $0xa,%eax
f01151ae:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01151b1:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01151b8:	99                   	cltd   
f01151b9:	f7 fe                	idiv   %esi
f01151bb:	01 c8                	add    %ecx,%eax
f01151bd:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01151c0:	74 4c                	je     f011520e <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f01151c2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01151c5:	c1 e0 0a             	shl    $0xa,%eax
f01151c8:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01151cb:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01151d2:	99                   	cltd   
f01151d3:	f7 fb                	idiv   %ebx
f01151d5:	89 c1                	mov    %eax,%ecx
f01151d7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01151da:	c1 e0 0a             	shl    $0xa,%eax
f01151dd:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01151e0:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01151e7:	99                   	cltd   
f01151e8:	f7 fe                	idiv   %esi
f01151ea:	01 c8                	add    %ecx,%eax
f01151ec:	83 ec 0c             	sub    $0xc,%esp
f01151ef:	50                   	push   %eax
f01151f0:	ff 75 c8             	pushl  -0x38(%ebp)
f01151f3:	68 bc b3 12 f0       	push   $0xf012b3bc
f01151f8:	68 3d 06 00 00       	push   $0x63d
f01151fd:	68 42 9b 12 f0       	push   $0xf0129b42
f0115202:	e8 b0 b2 fe ff       	call   f01004b7 <_warn>
f0115207:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011520a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011520e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115212:	74 04                	je     f0115218 <test_calculate_required_frames+0x23f>
f0115214:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115218:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f011521c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011521f:	89 d0                	mov    %edx,%eax
f0115221:	01 c0                	add    %eax,%eax
f0115223:	01 d0                	add    %edx,%eax
f0115225:	01 c0                	add    %eax,%eax
f0115227:	83 ec 04             	sub    $0x4,%esp
f011522a:	50                   	push   %eax
f011522b:	68 00 10 00 00       	push   $0x1000
f0115230:	ff 75 d8             	pushl  -0x28(%ebp)
f0115233:	e8 38 42 ff ff       	call   f0109470 <calculate_required_frames>
f0115238:	83 c4 10             	add    $0x10,%esp
f011523b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f011523e:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0115242:	74 23                	je     f0115267 <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0115244:	83 ec 0c             	sub    $0xc,%esp
f0115247:	6a 03                	push   $0x3
f0115249:	ff 75 c8             	pushl  -0x38(%ebp)
f011524c:	68 bc b3 12 f0       	push   $0xf012b3bc
f0115251:	68 49 06 00 00       	push   $0x649
f0115256:	68 42 9b 12 f0       	push   $0xf0129b42
f011525b:	e8 57 b2 fe ff       	call   f01004b7 <_warn>
f0115260:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115263:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115267:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011526b:	74 04                	je     f0115271 <test_calculate_required_frames+0x298>
f011526d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115271:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0115275:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115278:	89 c2                	mov    %eax,%edx
f011527a:	01 d2                	add    %edx,%edx
f011527c:	01 d0                	add    %edx,%eax
f011527e:	83 ec 04             	sub    $0x4,%esp
f0115281:	50                   	push   %eax
f0115282:	68 00 18 00 00       	push   $0x1800
f0115287:	ff 75 d8             	pushl  -0x28(%ebp)
f011528a:	e8 e1 41 ff ff       	call   f0109470 <calculate_required_frames>
f011528f:	83 c4 10             	add    $0x10,%esp
f0115292:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0115295:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0115299:	74 23                	je     f01152be <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f011529b:	83 ec 0c             	sub    $0xc,%esp
f011529e:	6a 03                	push   $0x3
f01152a0:	ff 75 c8             	pushl  -0x38(%ebp)
f01152a3:	68 bc b3 12 f0       	push   $0xf012b3bc
f01152a8:	68 53 06 00 00       	push   $0x653
f01152ad:	68 42 9b 12 f0       	push   $0xf0129b42
f01152b2:	e8 00 b2 fe ff       	call   f01004b7 <_warn>
f01152b7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01152ba:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01152be:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01152c2:	74 04                	je     f01152c8 <test_calculate_required_frames+0x2ef>
f01152c4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01152c8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f01152cc:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01152cf:	89 d0                	mov    %edx,%eax
f01152d1:	c1 e0 02             	shl    $0x2,%eax
f01152d4:	01 d0                	add    %edx,%eax
f01152d6:	01 c0                	add    %eax,%eax
f01152d8:	83 ec 04             	sub    $0x4,%esp
f01152db:	50                   	push   %eax
f01152dc:	68 00 00 40 00       	push   $0x400000
f01152e1:	ff 75 d8             	pushl  -0x28(%ebp)
f01152e4:	e8 87 41 ff ff       	call   f0109470 <calculate_required_frames>
f01152e9:	83 c4 10             	add    $0x10,%esp
f01152ec:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f01152ef:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f01152f6:	74 26                	je     f011531e <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f01152f8:	83 ec 0c             	sub    $0xc,%esp
f01152fb:	68 03 0a 00 00       	push   $0xa03
f0115300:	ff 75 c8             	pushl  -0x38(%ebp)
f0115303:	68 bc b3 12 f0       	push   $0xf012b3bc
f0115308:	68 5d 06 00 00       	push   $0x65d
f011530d:	68 42 9b 12 f0       	push   $0xf0129b42
f0115312:	e8 a0 b1 fe ff       	call   f01004b7 <_warn>
f0115317:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011531a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011531e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115322:	74 04                	je     f0115328 <test_calculate_required_frames+0x34f>
f0115324:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115328:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f011532c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011532f:	01 c0                	add    %eax,%eax
f0115331:	83 ec 04             	sub    $0x4,%esp
f0115334:	50                   	push   %eax
f0115335:	68 00 00 70 00       	push   $0x700000
f011533a:	ff 75 d8             	pushl  -0x28(%ebp)
f011533d:	e8 2e 41 ff ff       	call   f0109470 <calculate_required_frames>
f0115342:	83 c4 10             	add    $0x10,%esp
f0115345:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f0115348:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f011534f:	74 26                	je     f0115377 <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f0115351:	83 ec 0c             	sub    $0xc,%esp
f0115354:	68 02 02 00 00       	push   $0x202
f0115359:	ff 75 c8             	pushl  -0x38(%ebp)
f011535c:	68 bc b3 12 f0       	push   $0xf012b3bc
f0115361:	68 69 06 00 00       	push   $0x669
f0115366:	68 42 9b 12 f0       	push   $0xf0129b42
f011536b:	e8 47 b1 fe ff       	call   f01004b7 <_warn>
f0115370:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115373:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115377:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011537b:	74 04                	je     f0115381 <test_calculate_required_frames+0x3a8>
f011537d:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115381:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0115385:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115388:	83 ec 04             	sub    $0x4,%esp
f011538b:	50                   	push   %eax
f011538c:	68 ff ff 3f 00       	push   $0x3fffff
f0115391:	ff 75 d8             	pushl  -0x28(%ebp)
f0115394:	e8 d7 40 ff ff       	call   f0109470 <calculate_required_frames>
f0115399:	83 c4 10             	add    $0x10,%esp
f011539c:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f011539f:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f01153a3:	74 23                	je     f01153c8 <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f01153a5:	83 ec 0c             	sub    $0xc,%esp
f01153a8:	6a 04                	push   $0x4
f01153aa:	ff 75 c8             	pushl  -0x38(%ebp)
f01153ad:	68 bc b3 12 f0       	push   $0xf012b3bc
f01153b2:	68 73 06 00 00       	push   $0x673
f01153b7:	68 42 9b 12 f0       	push   $0xf0129b42
f01153bc:	e8 f6 b0 fe ff       	call   f01004b7 <_warn>
f01153c1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01153c4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01153c8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01153cc:	74 04                	je     f01153d2 <test_calculate_required_frames+0x3f9>
f01153ce:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01153d2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f01153d6:	83 ec 0c             	sub    $0xc,%esp
f01153d9:	68 f5 ae 12 f0       	push   $0xf012aef5
f01153de:	e8 89 bb fe ff       	call   f0100f6c <cprintf>
f01153e3:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f01153e6:	83 ec 0c             	sub    $0xc,%esp
f01153e9:	68 14 b4 12 f0       	push   $0xf012b414
f01153ee:	e8 79 bb fe ff       	call   f0100f6c <cprintf>
f01153f3:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f01153f6:	83 ec 04             	sub    $0x4,%esp
f01153f9:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f01153ff:	50                   	push   %eax
f0115400:	68 ae a2 12 f0       	push   $0xf012a2ae
f0115405:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011540b:	50                   	push   %eax
f011540c:	e8 bf b6 00 00       	call   f0120ad0 <strcconcat>
f0115411:	83 c4 10             	add    $0x10,%esp
f0115414:	83 ec 0c             	sub    $0xc,%esp
f0115417:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f011541d:	50                   	push   %eax
f011541e:	e8 b9 ca fe ff       	call   f0101edc <execute_command>
f0115423:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0115426:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115429:	c1 e0 03             	shl    $0x3,%eax
f011542c:	83 ec 04             	sub    $0x4,%esp
f011542f:	50                   	push   %eax
f0115430:	6a 00                	push   $0x0
f0115432:	ff 75 d8             	pushl  -0x28(%ebp)
f0115435:	e8 36 40 ff ff       	call   f0109470 <calculate_required_frames>
f011543a:	83 c4 10             	add    $0x10,%esp
f011543d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0115440:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0115447:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011544a:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011544d:	74 24                	je     f0115473 <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011544f:	83 ec 0c             	sub    $0xc,%esp
f0115452:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115455:	ff 75 c8             	pushl  -0x38(%ebp)
f0115458:	68 bc b3 12 f0       	push   $0xf012b3bc
f011545d:	68 87 06 00 00       	push   $0x687
f0115462:	68 42 9b 12 f0       	push   $0xf0129b42
f0115467:	e8 4b b0 fe ff       	call   f01004b7 <_warn>
f011546c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011546f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115473:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115477:	74 04                	je     f011547d <test_calculate_required_frames+0x4a4>
f0115479:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011547d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0115481:	83 ec 04             	sub    $0x4,%esp
f0115484:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011548a:	50                   	push   %eax
f011548b:	68 bb a2 12 f0       	push   $0xf012a2bb
f0115490:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115496:	50                   	push   %eax
f0115497:	e8 34 b6 00 00       	call   f0120ad0 <strcconcat>
f011549c:	83 c4 10             	add    $0x10,%esp
f011549f:	83 ec 0c             	sub    $0xc,%esp
f01154a2:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01154a8:	50                   	push   %eax
f01154a9:	e8 2e ca fe ff       	call   f0101edc <execute_command>
f01154ae:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f01154b1:	83 ec 04             	sub    $0x4,%esp
f01154b4:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01154ba:	50                   	push   %eax
f01154bb:	68 48 b4 12 f0       	push   $0xf012b448
f01154c0:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01154c6:	50                   	push   %eax
f01154c7:	e8 04 b6 00 00       	call   f0120ad0 <strcconcat>
f01154cc:	83 c4 10             	add    $0x10,%esp
f01154cf:	83 ec 0c             	sub    $0xc,%esp
f01154d2:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01154d8:	50                   	push   %eax
f01154d9:	e8 fe c9 fe ff       	call   f0101edc <execute_command>
f01154de:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f01154e1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01154e4:	c1 e0 03             	shl    $0x3,%eax
f01154e7:	83 ec 04             	sub    $0x4,%esp
f01154ea:	50                   	push   %eax
f01154eb:	6a 00                	push   $0x0
f01154ed:	ff 75 d8             	pushl  -0x28(%ebp)
f01154f0:	e8 7b 3f ff ff       	call   f0109470 <calculate_required_frames>
f01154f5:	83 c4 10             	add    $0x10,%esp
f01154f8:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f01154fb:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f0115502:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115505:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115508:	74 24                	je     f011552e <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011550a:	83 ec 0c             	sub    $0xc,%esp
f011550d:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115510:	ff 75 c8             	pushl  -0x38(%ebp)
f0115513:	68 bc b3 12 f0       	push   $0xf012b3bc
f0115518:	68 95 06 00 00       	push   $0x695
f011551d:	68 42 9b 12 f0       	push   $0xf0129b42
f0115522:	e8 90 af fe ff       	call   f01004b7 <_warn>
f0115527:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011552a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011552e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115532:	74 04                	je     f0115538 <test_calculate_required_frames+0x55f>
f0115534:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115538:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f011553c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011553f:	c1 e0 0a             	shl    $0xa,%eax
f0115542:	83 ec 04             	sub    $0x4,%esp
f0115545:	50                   	push   %eax
f0115546:	6a 00                	push   $0x0
f0115548:	ff 75 d8             	pushl  -0x28(%ebp)
f011554b:	e8 20 3f ff ff       	call   f0109470 <calculate_required_frames>
f0115550:	83 c4 10             	add    $0x10,%esp
f0115553:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f0115556:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115559:	c1 e0 0a             	shl    $0xa,%eax
f011555c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011555f:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115566:	99                   	cltd   
f0115567:	f7 fb                	idiv   %ebx
f0115569:	89 c1                	mov    %eax,%ecx
f011556b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011556e:	c1 e0 0a             	shl    $0xa,%eax
f0115571:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115574:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011557b:	99                   	cltd   
f011557c:	f7 fe                	idiv   %esi
f011557e:	01 c8                	add    %ecx,%eax
f0115580:	83 e8 05             	sub    $0x5,%eax
f0115583:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f0115586:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115589:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011558c:	74 24                	je     f01155b2 <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011558e:	83 ec 0c             	sub    $0xc,%esp
f0115591:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115594:	ff 75 c8             	pushl  -0x38(%ebp)
f0115597:	68 bc b3 12 f0       	push   $0xf012b3bc
f011559c:	68 a0 06 00 00       	push   $0x6a0
f01155a1:	68 42 9b 12 f0       	push   $0xf0129b42
f01155a6:	e8 0c af fe ff       	call   f01004b7 <_warn>
f01155ab:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01155ae:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01155b2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01155b6:	74 04                	je     f01155bc <test_calculate_required_frames+0x5e3>
f01155b8:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01155bc:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f01155c0:	83 ec 04             	sub    $0x4,%esp
f01155c3:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01155c9:	50                   	push   %eax
f01155ca:	68 54 b4 12 f0       	push   $0xf012b454
f01155cf:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01155d5:	50                   	push   %eax
f01155d6:	e8 f5 b4 00 00       	call   f0120ad0 <strcconcat>
f01155db:	83 c4 10             	add    $0x10,%esp
f01155de:	83 ec 0c             	sub    $0xc,%esp
f01155e1:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01155e7:	50                   	push   %eax
f01155e8:	e8 ef c8 fe ff       	call   f0101edc <execute_command>
f01155ed:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f01155f0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01155f3:	89 c2                	mov    %eax,%edx
f01155f5:	01 d2                	add    %edx,%edx
f01155f7:	01 d0                	add    %edx,%eax
f01155f9:	83 ec 04             	sub    $0x4,%esp
f01155fc:	50                   	push   %eax
f01155fd:	68 00 18 00 00       	push   $0x1800
f0115602:	ff 75 d8             	pushl  -0x28(%ebp)
f0115605:	e8 66 3e ff ff       	call   f0109470 <calculate_required_frames>
f011560a:	83 c4 10             	add    $0x10,%esp
f011560d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0115610:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0115617:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011561a:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011561d:	74 24                	je     f0115643 <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011561f:	83 ec 0c             	sub    $0xc,%esp
f0115622:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115625:	ff 75 c8             	pushl  -0x38(%ebp)
f0115628:	68 bc b3 12 f0       	push   $0xf012b3bc
f011562d:	68 af 06 00 00       	push   $0x6af
f0115632:	68 42 9b 12 f0       	push   $0xf0129b42
f0115637:	e8 7b ae fe ff       	call   f01004b7 <_warn>
f011563c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011563f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115643:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115647:	74 04                	je     f011564d <test_calculate_required_frames+0x674>
f0115649:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011564d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0115651:	83 ec 04             	sub    $0x4,%esp
f0115654:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011565a:	50                   	push   %eax
f011565b:	68 14 a5 12 f0       	push   $0xf012a514
f0115660:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115666:	50                   	push   %eax
f0115667:	e8 64 b4 00 00       	call   f0120ad0 <strcconcat>
f011566c:	83 c4 10             	add    $0x10,%esp
f011566f:	83 ec 0c             	sub    $0xc,%esp
f0115672:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115678:	50                   	push   %eax
f0115679:	e8 5e c8 fe ff       	call   f0101edc <execute_command>
f011567e:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0115681:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115684:	89 d0                	mov    %edx,%eax
f0115686:	c1 e0 02             	shl    $0x2,%eax
f0115689:	01 d0                	add    %edx,%eax
f011568b:	01 c0                	add    %eax,%eax
f011568d:	83 ec 04             	sub    $0x4,%esp
f0115690:	50                   	push   %eax
f0115691:	68 00 00 40 00       	push   $0x400000
f0115696:	ff 75 d8             	pushl  -0x28(%ebp)
f0115699:	e8 d2 3d ff ff       	call   f0109470 <calculate_required_frames>
f011569e:	83 c4 10             	add    $0x10,%esp
f01156a1:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f01156a4:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f01156ab:	74 26                	je     f01156d3 <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f01156ad:	83 ec 0c             	sub    $0xc,%esp
f01156b0:	68 03 0a 00 00       	push   $0xa03
f01156b5:	ff 75 c8             	pushl  -0x38(%ebp)
f01156b8:	68 bc b3 12 f0       	push   $0xf012b3bc
f01156bd:	68 bb 06 00 00       	push   $0x6bb
f01156c2:	68 42 9b 12 f0       	push   $0xf0129b42
f01156c7:	e8 eb ad fe ff       	call   f01004b7 <_warn>
f01156cc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01156cf:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01156d3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01156d7:	74 04                	je     f01156dd <test_calculate_required_frames+0x704>
f01156d9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01156dd:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f01156e1:	83 ec 04             	sub    $0x4,%esp
f01156e4:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01156ea:	50                   	push   %eax
f01156eb:	68 1e a5 12 f0       	push   $0xf012a51e
f01156f0:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01156f6:	50                   	push   %eax
f01156f7:	e8 d4 b3 00 00       	call   f0120ad0 <strcconcat>
f01156fc:	83 c4 10             	add    $0x10,%esp
f01156ff:	83 ec 0c             	sub    $0xc,%esp
f0115702:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115708:	50                   	push   %eax
f0115709:	e8 ce c7 fe ff       	call   f0101edc <execute_command>
f011570e:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0115711:	83 ec 04             	sub    $0x4,%esp
f0115714:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011571a:	50                   	push   %eax
f011571b:	68 5c b4 12 f0       	push   $0xf012b45c
f0115720:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115726:	50                   	push   %eax
f0115727:	e8 a4 b3 00 00       	call   f0120ad0 <strcconcat>
f011572c:	83 c4 10             	add    $0x10,%esp
f011572f:	83 ec 0c             	sub    $0xc,%esp
f0115732:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115738:	50                   	push   %eax
f0115739:	e8 9e c7 fe ff       	call   f0101edc <execute_command>
f011573e:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0115741:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115744:	01 c0                	add    %eax,%eax
f0115746:	83 ec 04             	sub    $0x4,%esp
f0115749:	50                   	push   %eax
f011574a:	68 00 00 70 00       	push   $0x700000
f011574f:	ff 75 d8             	pushl  -0x28(%ebp)
f0115752:	e8 19 3d ff ff       	call   f0109470 <calculate_required_frames>
f0115757:	83 c4 10             	add    $0x10,%esp
f011575a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f011575d:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f0115764:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115767:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011576a:	74 24                	je     f0115790 <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011576c:	83 ec 0c             	sub    $0xc,%esp
f011576f:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115772:	ff 75 c8             	pushl  -0x38(%ebp)
f0115775:	68 bc b3 12 f0       	push   $0xf012b3bc
f011577a:	68 cb 06 00 00       	push   $0x6cb
f011577f:	68 42 9b 12 f0       	push   $0xf0129b42
f0115784:	e8 2e ad fe ff       	call   f01004b7 <_warn>
f0115789:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011578c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115790:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115794:	74 04                	je     f011579a <test_calculate_required_frames+0x7c1>
f0115796:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011579a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f011579e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01157a1:	83 ec 04             	sub    $0x4,%esp
f01157a4:	50                   	push   %eax
f01157a5:	68 ff ff 3f 00       	push   $0x3fffff
f01157aa:	ff 75 d8             	pushl  -0x28(%ebp)
f01157ad:	e8 be 3c ff ff       	call   f0109470 <calculate_required_frames>
f01157b2:	83 c4 10             	add    $0x10,%esp
f01157b5:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f01157b8:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f01157bf:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01157c2:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01157c5:	74 24                	je     f01157eb <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01157c7:	83 ec 0c             	sub    $0xc,%esp
f01157ca:	ff 75 c4             	pushl  -0x3c(%ebp)
f01157cd:	ff 75 c8             	pushl  -0x38(%ebp)
f01157d0:	68 bc b3 12 f0       	push   $0xf012b3bc
f01157d5:	68 d6 06 00 00       	push   $0x6d6
f01157da:	68 42 9b 12 f0       	push   $0xf0129b42
f01157df:	e8 d3 ac fe ff       	call   f01004b7 <_warn>
f01157e4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01157e7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01157eb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01157ef:	74 04                	je     f01157f5 <test_calculate_required_frames+0x81c>
f01157f1:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01157f5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f01157f9:	83 ec 0c             	sub    $0xc,%esp
f01157fc:	68 cf a4 12 f0       	push   $0xf012a4cf
f0115801:	e8 66 b7 fe ff       	call   f0100f6c <cprintf>
f0115806:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f0115809:	83 ec 08             	sub    $0x8,%esp
f011580c:	ff 75 e4             	pushl  -0x1c(%ebp)
f011580f:	68 68 b4 12 f0       	push   $0xf012b468
f0115814:	e8 53 b7 fe ff       	call   f0100f6c <cprintf>
f0115819:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011581c:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0115820:	75 10                	jne    f0115832 <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f0115822:	83 ec 0c             	sub    $0xc,%esp
f0115825:	68 a8 b4 12 f0       	push   $0xf012b4a8
f011582a:	e8 3d b7 fe ff       	call   f0100f6c <cprintf>
f011582f:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115832:	a1 e4 51 55 f0       	mov    0xf05551e4,%eax
f0115837:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011583a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011583d:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115840:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115845:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0115848:	5b                   	pop    %ebx
f0115849:	5e                   	pop    %esi
f011584a:	5f                   	pop    %edi
f011584b:	5d                   	pop    %ebp
f011584c:	c3                   	ret    

f011584d <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f011584d:	55                   	push   %ebp
f011584e:	89 e5                	mov    %esp,%ebp
f0115850:	57                   	push   %edi
f0115851:	56                   	push   %esi
f0115852:	53                   	push   %ebx
f0115853:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0115859:	8d 45 8e             	lea    -0x72(%ebp),%eax
f011585c:	bb 44 a2 12 f0       	mov    $0xf012a244,%ebx
f0115861:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115866:	89 c7                	mov    %eax,%edi
f0115868:	89 de                	mov    %ebx,%esi
f011586a:	89 d1                	mov    %edx,%ecx
f011586c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011586e:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0115871:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115876:	b0 00                	mov    $0x0,%al
f0115878:	89 d7                	mov    %edx,%edi
f011587a:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011587c:	6a 00                	push   $0x0
f011587e:	6a 0a                	push   $0xa
f0115880:	6a 14                	push   $0x14
f0115882:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115885:	50                   	push   %eax
f0115886:	e8 03 3f ff ff       	call   f010978e <env_create>
f011588b:	83 c4 10             	add    $0x10,%esp
f011588e:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0115891:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115894:	8b 40 64             	mov    0x64(%eax),%eax
f0115897:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f011589a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011589d:	8b 40 68             	mov    0x68(%eax),%eax
f01158a0:	89 45 c0             	mov    %eax,-0x40(%ebp)
f01158a3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01158a6:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01158a9:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f01158b0:	75 70 20 
f01158b3:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f01158ba:	00 00 00 
f01158bd:	8d 55 82             	lea    -0x7e(%ebp),%edx
f01158c0:	b9 03 00 00 00       	mov    $0x3,%ecx
f01158c5:	b8 00 00 00 00       	mov    $0x0,%eax
f01158ca:	89 d7                	mov    %edx,%edi
f01158cc:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01158ce:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01158d1:	8b 40 10             	mov    0x10(%eax),%eax
f01158d4:	83 ec 08             	sub    $0x8,%esp
f01158d7:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f01158dd:	52                   	push   %edx
f01158de:	50                   	push   %eax
f01158df:	e8 13 b1 00 00       	call   f01209f7 <ltostr>
f01158e4:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01158e7:	83 ec 04             	sub    $0x4,%esp
f01158ea:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01158f0:	50                   	push   %eax
f01158f1:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f01158f7:	50                   	push   %eax
f01158f8:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f01158fe:	50                   	push   %eax
f01158ff:	e8 cc b1 00 00       	call   f0120ad0 <strcconcat>
f0115904:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115907:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f011590e:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0115915:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f011591c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f0115920:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115927:	00 00 00 
	uint32 num_tables = 0;
f011592a:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115931:	00 00 00 
	ClearUserSpace(proc_directory);
f0115934:	83 ec 0c             	sub    $0xc,%esp
f0115937:	ff 75 d8             	pushl  -0x28(%ebp)
f011593a:	e8 d8 11 00 00       	call   f0116b17 <ClearUserSpace>
f011593f:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0115942:	83 ec 0c             	sub    $0xc,%esp
f0115945:	68 88 b3 12 f0       	push   $0xf012b388
f011594a:	e8 1d b6 fe ff       	call   f0100f6c <cprintf>
f011594f:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0115952:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115955:	c1 e0 03             	shl    $0x3,%eax
f0115958:	89 c2                	mov    %eax,%edx
f011595a:	83 ec 0c             	sub    $0xc,%esp
f011595d:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115963:	50                   	push   %eax
f0115964:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011596a:	50                   	push   %eax
f011596b:	52                   	push   %edx
f011596c:	6a 00                	push   $0x0
f011596e:	ff 75 d8             	pushl  -0x28(%ebp)
f0115971:	e8 e0 3a ff ff       	call   f0109456 <calculate_allocated_space>
f0115976:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115979:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011597f:	85 c0                	test   %eax,%eax
f0115981:	74 27                	je     f01159aa <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115983:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115989:	83 ec 0c             	sub    $0xc,%esp
f011598c:	6a 00                	push   $0x0
f011598e:	50                   	push   %eax
f011598f:	68 f4 b4 12 f0       	push   $0xf012b4f4
f0115994:	68 0b 07 00 00       	push   $0x70b
f0115999:	68 42 9b 12 f0       	push   $0xf0129b42
f011599e:	e8 14 ab fe ff       	call   f01004b7 <_warn>
f01159a3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01159a6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01159aa:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01159b0:	85 c0                	test   %eax,%eax
f01159b2:	74 27                	je     f01159db <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01159b4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01159ba:	83 ec 0c             	sub    $0xc,%esp
f01159bd:	6a 00                	push   $0x0
f01159bf:	50                   	push   %eax
f01159c0:	68 54 b5 12 f0       	push   $0xf012b554
f01159c5:	68 10 07 00 00       	push   $0x710
f01159ca:	68 42 9b 12 f0       	push   $0xf0129b42
f01159cf:	e8 e3 aa fe ff       	call   f01004b7 <_warn>
f01159d4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01159d7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01159db:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01159df:	74 04                	je     f01159e5 <test_calculate_allocated_space+0x198>
f01159e1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01159e5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f01159e9:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01159f0:	00 00 00 
		num_pages = 0;
f01159f3:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01159fa:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f01159fd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115a00:	c1 e0 02             	shl    $0x2,%eax
f0115a03:	89 c2                	mov    %eax,%edx
f0115a05:	83 ec 0c             	sub    $0xc,%esp
f0115a08:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115a0e:	50                   	push   %eax
f0115a0f:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115a15:	50                   	push   %eax
f0115a16:	52                   	push   %edx
f0115a17:	6a 00                	push   $0x0
f0115a19:	ff 75 d8             	pushl  -0x28(%ebp)
f0115a1c:	e8 35 3a ff ff       	call   f0109456 <calculate_allocated_space>
f0115a21:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115a24:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115a2a:	85 c0                	test   %eax,%eax
f0115a2c:	74 27                	je     f0115a55 <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115a2e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115a34:	83 ec 0c             	sub    $0xc,%esp
f0115a37:	6a 00                	push   $0x0
f0115a39:	50                   	push   %eax
f0115a3a:	68 f4 b4 12 f0       	push   $0xf012b4f4
f0115a3f:	68 1c 07 00 00       	push   $0x71c
f0115a44:	68 42 9b 12 f0       	push   $0xf0129b42
f0115a49:	e8 69 aa fe ff       	call   f01004b7 <_warn>
f0115a4e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a51:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115a55:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115a5b:	85 c0                	test   %eax,%eax
f0115a5d:	74 27                	je     f0115a86 <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115a5f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115a65:	83 ec 0c             	sub    $0xc,%esp
f0115a68:	6a 00                	push   $0x0
f0115a6a:	50                   	push   %eax
f0115a6b:	68 54 b5 12 f0       	push   $0xf012b554
f0115a70:	68 21 07 00 00       	push   $0x721
f0115a75:	68 42 9b 12 f0       	push   $0xf0129b42
f0115a7a:	e8 38 aa fe ff       	call   f01004b7 <_warn>
f0115a7f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a82:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115a86:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115a8a:	74 04                	je     f0115a90 <test_calculate_allocated_space+0x243>
f0115a8c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115a90:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0115a94:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115a9b:	00 00 00 
		num_pages = 0;
f0115a9e:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115aa5:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0115aa8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115aab:	c1 e0 0a             	shl    $0xa,%eax
f0115aae:	89 c2                	mov    %eax,%edx
f0115ab0:	83 ec 0c             	sub    $0xc,%esp
f0115ab3:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115ab9:	50                   	push   %eax
f0115aba:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115ac0:	50                   	push   %eax
f0115ac1:	52                   	push   %edx
f0115ac2:	6a 00                	push   $0x0
f0115ac4:	ff 75 d8             	pushl  -0x28(%ebp)
f0115ac7:	e8 8a 39 ff ff       	call   f0109456 <calculate_allocated_space>
f0115acc:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115acf:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115ad5:	85 c0                	test   %eax,%eax
f0115ad7:	74 27                	je     f0115b00 <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115ad9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115adf:	83 ec 0c             	sub    $0xc,%esp
f0115ae2:	6a 00                	push   $0x0
f0115ae4:	50                   	push   %eax
f0115ae5:	68 f4 b4 12 f0       	push   $0xf012b4f4
f0115aea:	68 2d 07 00 00       	push   $0x72d
f0115aef:	68 42 9b 12 f0       	push   $0xf0129b42
f0115af4:	e8 be a9 fe ff       	call   f01004b7 <_warn>
f0115af9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115afc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115b00:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115b06:	85 c0                	test   %eax,%eax
f0115b08:	74 27                	je     f0115b31 <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115b0a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115b10:	83 ec 0c             	sub    $0xc,%esp
f0115b13:	6a 00                	push   $0x0
f0115b15:	50                   	push   %eax
f0115b16:	68 54 b5 12 f0       	push   $0xf012b554
f0115b1b:	68 32 07 00 00       	push   $0x732
f0115b20:	68 42 9b 12 f0       	push   $0xf0129b42
f0115b25:	e8 8d a9 fe ff       	call   f01004b7 <_warn>
f0115b2a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115b2d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115b31:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115b35:	74 04                	je     f0115b3b <test_calculate_allocated_space+0x2ee>
f0115b37:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115b3b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f0115b3f:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115b46:	00 00 00 
		num_pages = 0;
f0115b49:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115b50:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f0115b53:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115b56:	89 d0                	mov    %edx,%eax
f0115b58:	01 c0                	add    %eax,%eax
f0115b5a:	01 d0                	add    %edx,%eax
f0115b5c:	01 c0                	add    %eax,%eax
f0115b5e:	05 00 10 00 00       	add    $0x1000,%eax
f0115b63:	89 c2                	mov    %eax,%edx
f0115b65:	83 ec 0c             	sub    $0xc,%esp
f0115b68:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115b6e:	50                   	push   %eax
f0115b6f:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115b75:	50                   	push   %eax
f0115b76:	52                   	push   %edx
f0115b77:	68 00 10 00 00       	push   $0x1000
f0115b7c:	ff 75 d8             	pushl  -0x28(%ebp)
f0115b7f:	e8 d2 38 ff ff       	call   f0109456 <calculate_allocated_space>
f0115b84:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115b87:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115b8d:	85 c0                	test   %eax,%eax
f0115b8f:	74 27                	je     f0115bb8 <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115b91:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115b97:	83 ec 0c             	sub    $0xc,%esp
f0115b9a:	6a 00                	push   $0x0
f0115b9c:	50                   	push   %eax
f0115b9d:	68 f4 b4 12 f0       	push   $0xf012b4f4
f0115ba2:	68 3f 07 00 00       	push   $0x73f
f0115ba7:	68 42 9b 12 f0       	push   $0xf0129b42
f0115bac:	e8 06 a9 fe ff       	call   f01004b7 <_warn>
f0115bb1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115bb4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115bb8:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115bbe:	85 c0                	test   %eax,%eax
f0115bc0:	74 27                	je     f0115be9 <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115bc2:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115bc8:	83 ec 0c             	sub    $0xc,%esp
f0115bcb:	6a 00                	push   $0x0
f0115bcd:	50                   	push   %eax
f0115bce:	68 54 b5 12 f0       	push   $0xf012b554
f0115bd3:	68 44 07 00 00       	push   $0x744
f0115bd8:	68 42 9b 12 f0       	push   $0xf0129b42
f0115bdd:	e8 d5 a8 fe ff       	call   f01004b7 <_warn>
f0115be2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115be5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115be9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115bed:	74 04                	je     f0115bf3 <test_calculate_allocated_space+0x3a6>
f0115bef:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115bf3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f0115bf7:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115bfe:	00 00 00 
		num_pages = 0;
f0115c01:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115c08:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0115c0b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115c0e:	89 c2                	mov    %eax,%edx
f0115c10:	01 d2                	add    %edx,%edx
f0115c12:	01 d0                	add    %edx,%eax
f0115c14:	05 00 18 00 00       	add    $0x1800,%eax
f0115c19:	89 c2                	mov    %eax,%edx
f0115c1b:	83 ec 0c             	sub    $0xc,%esp
f0115c1e:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115c24:	50                   	push   %eax
f0115c25:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115c2b:	50                   	push   %eax
f0115c2c:	52                   	push   %edx
f0115c2d:	68 00 18 00 00       	push   $0x1800
f0115c32:	ff 75 d8             	pushl  -0x28(%ebp)
f0115c35:	e8 1c 38 ff ff       	call   f0109456 <calculate_allocated_space>
f0115c3a:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115c3d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115c43:	85 c0                	test   %eax,%eax
f0115c45:	74 27                	je     f0115c6e <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115c47:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115c4d:	83 ec 0c             	sub    $0xc,%esp
f0115c50:	6a 00                	push   $0x0
f0115c52:	50                   	push   %eax
f0115c53:	68 f4 b4 12 f0       	push   $0xf012b4f4
f0115c58:	68 50 07 00 00       	push   $0x750
f0115c5d:	68 42 9b 12 f0       	push   $0xf0129b42
f0115c62:	e8 50 a8 fe ff       	call   f01004b7 <_warn>
f0115c67:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115c6a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115c6e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115c74:	85 c0                	test   %eax,%eax
f0115c76:	74 27                	je     f0115c9f <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115c78:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115c7e:	83 ec 0c             	sub    $0xc,%esp
f0115c81:	6a 00                	push   $0x0
f0115c83:	50                   	push   %eax
f0115c84:	68 54 b5 12 f0       	push   $0xf012b554
f0115c89:	68 55 07 00 00       	push   $0x755
f0115c8e:	68 42 9b 12 f0       	push   $0xf0129b42
f0115c93:	e8 1f a8 fe ff       	call   f01004b7 <_warn>
f0115c98:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115c9b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115c9f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115ca3:	74 04                	je     f0115ca9 <test_calculate_allocated_space+0x45c>
f0115ca5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115ca9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f0115cad:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115cb4:	00 00 00 
		num_pages = 0;
f0115cb7:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115cbe:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0115cc1:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115cc4:	89 d0                	mov    %edx,%eax
f0115cc6:	c1 e0 02             	shl    $0x2,%eax
f0115cc9:	01 d0                	add    %edx,%eax
f0115ccb:	01 c0                	add    %eax,%eax
f0115ccd:	05 00 00 40 00       	add    $0x400000,%eax
f0115cd2:	89 c2                	mov    %eax,%edx
f0115cd4:	83 ec 0c             	sub    $0xc,%esp
f0115cd7:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115cdd:	50                   	push   %eax
f0115cde:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115ce4:	50                   	push   %eax
f0115ce5:	52                   	push   %edx
f0115ce6:	68 00 00 40 00       	push   $0x400000
f0115ceb:	ff 75 d8             	pushl  -0x28(%ebp)
f0115cee:	e8 63 37 ff ff       	call   f0109456 <calculate_allocated_space>
f0115cf3:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115cf6:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115cfc:	85 c0                	test   %eax,%eax
f0115cfe:	74 27                	je     f0115d27 <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115d00:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115d06:	83 ec 0c             	sub    $0xc,%esp
f0115d09:	6a 00                	push   $0x0
f0115d0b:	50                   	push   %eax
f0115d0c:	68 f4 b4 12 f0       	push   $0xf012b4f4
f0115d11:	68 61 07 00 00       	push   $0x761
f0115d16:	68 42 9b 12 f0       	push   $0xf0129b42
f0115d1b:	e8 97 a7 fe ff       	call   f01004b7 <_warn>
f0115d20:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d23:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115d27:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115d2d:	85 c0                	test   %eax,%eax
f0115d2f:	74 27                	je     f0115d58 <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115d31:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115d37:	83 ec 0c             	sub    $0xc,%esp
f0115d3a:	6a 00                	push   $0x0
f0115d3c:	50                   	push   %eax
f0115d3d:	68 54 b5 12 f0       	push   $0xf012b554
f0115d42:	68 66 07 00 00       	push   $0x766
f0115d47:	68 42 9b 12 f0       	push   $0xf0129b42
f0115d4c:	e8 66 a7 fe ff       	call   f01004b7 <_warn>
f0115d51:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d54:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115d58:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115d5c:	74 04                	je     f0115d62 <test_calculate_allocated_space+0x515>
f0115d5e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115d62:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f0115d66:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115d6d:	00 00 00 
		num_pages = 0;
f0115d70:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115d77:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0115d7a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115d7d:	05 00 00 38 00       	add    $0x380000,%eax
f0115d82:	01 c0                	add    %eax,%eax
f0115d84:	89 c2                	mov    %eax,%edx
f0115d86:	83 ec 0c             	sub    $0xc,%esp
f0115d89:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115d8f:	50                   	push   %eax
f0115d90:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115d96:	50                   	push   %eax
f0115d97:	52                   	push   %edx
f0115d98:	68 00 00 70 00       	push   $0x700000
f0115d9d:	ff 75 d8             	pushl  -0x28(%ebp)
f0115da0:	e8 b1 36 ff ff       	call   f0109456 <calculate_allocated_space>
f0115da5:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115da8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115dae:	85 c0                	test   %eax,%eax
f0115db0:	74 27                	je     f0115dd9 <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115db2:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115db8:	83 ec 0c             	sub    $0xc,%esp
f0115dbb:	6a 00                	push   $0x0
f0115dbd:	50                   	push   %eax
f0115dbe:	68 f4 b4 12 f0       	push   $0xf012b4f4
f0115dc3:	68 73 07 00 00       	push   $0x773
f0115dc8:	68 42 9b 12 f0       	push   $0xf0129b42
f0115dcd:	e8 e5 a6 fe ff       	call   f01004b7 <_warn>
f0115dd2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115dd5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115dd9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115ddf:	85 c0                	test   %eax,%eax
f0115de1:	74 27                	je     f0115e0a <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115de3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115de9:	83 ec 0c             	sub    $0xc,%esp
f0115dec:	6a 00                	push   $0x0
f0115dee:	50                   	push   %eax
f0115def:	68 54 b5 12 f0       	push   $0xf012b554
f0115df4:	68 78 07 00 00       	push   $0x778
f0115df9:	68 42 9b 12 f0       	push   $0xf0129b42
f0115dfe:	e8 b4 a6 fe ff       	call   f01004b7 <_warn>
f0115e03:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e06:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115e0a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115e0e:	74 04                	je     f0115e14 <test_calculate_allocated_space+0x5c7>
f0115e10:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115e14:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f0115e18:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115e1f:	00 00 00 
		num_pages = 0;
f0115e22:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115e29:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0115e2c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115e2f:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0115e34:	89 c2                	mov    %eax,%edx
f0115e36:	83 ec 0c             	sub    $0xc,%esp
f0115e39:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115e3f:	50                   	push   %eax
f0115e40:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115e46:	50                   	push   %eax
f0115e47:	52                   	push   %edx
f0115e48:	68 ff ff 3f 00       	push   $0x3fffff
f0115e4d:	ff 75 d8             	pushl  -0x28(%ebp)
f0115e50:	e8 01 36 ff ff       	call   f0109456 <calculate_allocated_space>
f0115e55:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115e58:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115e5e:	85 c0                	test   %eax,%eax
f0115e60:	74 27                	je     f0115e89 <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115e62:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115e68:	83 ec 0c             	sub    $0xc,%esp
f0115e6b:	6a 00                	push   $0x0
f0115e6d:	50                   	push   %eax
f0115e6e:	68 f4 b4 12 f0       	push   $0xf012b4f4
f0115e73:	68 84 07 00 00       	push   $0x784
f0115e78:	68 42 9b 12 f0       	push   $0xf0129b42
f0115e7d:	e8 35 a6 fe ff       	call   f01004b7 <_warn>
f0115e82:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e85:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115e89:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115e8f:	85 c0                	test   %eax,%eax
f0115e91:	74 27                	je     f0115eba <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115e93:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115e99:	83 ec 0c             	sub    $0xc,%esp
f0115e9c:	6a 00                	push   $0x0
f0115e9e:	50                   	push   %eax
f0115e9f:	68 54 b5 12 f0       	push   $0xf012b554
f0115ea4:	68 89 07 00 00       	push   $0x789
f0115ea9:	68 42 9b 12 f0       	push   $0xf0129b42
f0115eae:	e8 04 a6 fe ff       	call   f01004b7 <_warn>
f0115eb3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115eb6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115eba:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115ebe:	74 04                	je     f0115ec4 <test_calculate_allocated_space+0x677>
f0115ec0:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115ec4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0115ec8:	83 ec 0c             	sub    $0xc,%esp
f0115ecb:	68 f5 ae 12 f0       	push   $0xf012aef5
f0115ed0:	e8 97 b0 fe ff       	call   f0100f6c <cprintf>
f0115ed5:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0115ed8:	83 ec 0c             	sub    $0xc,%esp
f0115edb:	68 14 b4 12 f0       	push   $0xf012b414
f0115ee0:	e8 87 b0 fe ff       	call   f0100f6c <cprintf>
f0115ee5:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0115ee8:	83 ec 04             	sub    $0x4,%esp
f0115eeb:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0115ef1:	50                   	push   %eax
f0115ef2:	68 ae a2 12 f0       	push   $0xf012a2ae
f0115ef7:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115efd:	50                   	push   %eax
f0115efe:	e8 cd ab 00 00       	call   f0120ad0 <strcconcat>
f0115f03:	83 c4 10             	add    $0x10,%esp
f0115f06:	83 ec 0c             	sub    $0xc,%esp
f0115f09:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0115f0f:	50                   	push   %eax
f0115f10:	e8 c7 bf fe ff       	call   f0101edc <execute_command>
f0115f15:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f0115f18:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115f1f:	00 00 00 
		num_pages = 0;
f0115f22:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115f29:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0115f2c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115f2f:	c1 e0 03             	shl    $0x3,%eax
f0115f32:	89 c2                	mov    %eax,%edx
f0115f34:	83 ec 0c             	sub    $0xc,%esp
f0115f37:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115f3d:	50                   	push   %eax
f0115f3e:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115f44:	50                   	push   %eax
f0115f45:	52                   	push   %edx
f0115f46:	6a 00                	push   $0x0
f0115f48:	ff 75 d8             	pushl  -0x28(%ebp)
f0115f4b:	e8 06 35 ff ff       	call   f0109456 <calculate_allocated_space>
f0115f50:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0115f53:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f0115f5a:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115f61:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f67:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115f6a:	74 28                	je     f0115f94 <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115f6c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f72:	83 ec 0c             	sub    $0xc,%esp
f0115f75:	ff 75 c8             	pushl  -0x38(%ebp)
f0115f78:	50                   	push   %eax
f0115f79:	68 f4 b4 12 f0       	push   $0xf012b4f4
f0115f7e:	68 a0 07 00 00       	push   $0x7a0
f0115f83:	68 42 9b 12 f0       	push   $0xf0129b42
f0115f88:	e8 2a a5 fe ff       	call   f01004b7 <_warn>
f0115f8d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f90:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115f94:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f9a:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115f9d:	74 28                	je     f0115fc7 <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115f9f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115fa5:	83 ec 0c             	sub    $0xc,%esp
f0115fa8:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115fab:	50                   	push   %eax
f0115fac:	68 54 b5 12 f0       	push   $0xf012b554
f0115fb1:	68 a5 07 00 00       	push   $0x7a5
f0115fb6:	68 42 9b 12 f0       	push   $0xf0129b42
f0115fbb:	e8 f7 a4 fe ff       	call   f01004b7 <_warn>
f0115fc0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115fc3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115fc7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115fcb:	74 04                	je     f0115fd1 <test_calculate_allocated_space+0x784>
f0115fcd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115fd1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0115fd5:	83 ec 04             	sub    $0x4,%esp
f0115fd8:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115fde:	50                   	push   %eax
f0115fdf:	68 bb a2 12 f0       	push   $0xf012a2bb
f0115fe4:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115fea:	50                   	push   %eax
f0115feb:	e8 e0 aa 00 00       	call   f0120ad0 <strcconcat>
f0115ff0:	83 c4 10             	add    $0x10,%esp
f0115ff3:	83 ec 0c             	sub    $0xc,%esp
f0115ff6:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115ffc:	50                   	push   %eax
f0115ffd:	e8 da be fe ff       	call   f0101edc <execute_command>
f0116002:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0116005:	83 ec 04             	sub    $0x4,%esp
f0116008:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011600e:	50                   	push   %eax
f011600f:	68 48 b4 12 f0       	push   $0xf012b448
f0116014:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011601a:	50                   	push   %eax
f011601b:	e8 b0 aa 00 00       	call   f0120ad0 <strcconcat>
f0116020:	83 c4 10             	add    $0x10,%esp
f0116023:	83 ec 0c             	sub    $0xc,%esp
f0116026:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011602c:	50                   	push   %eax
f011602d:	e8 aa be fe ff       	call   f0101edc <execute_command>
f0116032:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f0116035:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011603c:	00 00 00 
		num_pages = 0;
f011603f:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116046:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f0116049:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011604c:	c1 e0 03             	shl    $0x3,%eax
f011604f:	89 c2                	mov    %eax,%edx
f0116051:	83 ec 0c             	sub    $0xc,%esp
f0116054:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011605a:	50                   	push   %eax
f011605b:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116061:	50                   	push   %eax
f0116062:	52                   	push   %edx
f0116063:	6a 00                	push   $0x0
f0116065:	ff 75 d8             	pushl  -0x28(%ebp)
f0116068:	e8 e9 33 ff ff       	call   f0109456 <calculate_allocated_space>
f011606d:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0116070:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f0116077:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011607e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116084:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116087:	74 28                	je     f01160b1 <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116089:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011608f:	83 ec 0c             	sub    $0xc,%esp
f0116092:	ff 75 c8             	pushl  -0x38(%ebp)
f0116095:	50                   	push   %eax
f0116096:	68 f4 b4 12 f0       	push   $0xf012b4f4
f011609b:	68 b6 07 00 00       	push   $0x7b6
f01160a0:	68 42 9b 12 f0       	push   $0xf0129b42
f01160a5:	e8 0d a4 fe ff       	call   f01004b7 <_warn>
f01160aa:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01160ad:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01160b1:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01160b7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01160ba:	74 28                	je     f01160e4 <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01160bc:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01160c2:	83 ec 0c             	sub    $0xc,%esp
f01160c5:	ff 75 c4             	pushl  -0x3c(%ebp)
f01160c8:	50                   	push   %eax
f01160c9:	68 54 b5 12 f0       	push   $0xf012b554
f01160ce:	68 bb 07 00 00       	push   $0x7bb
f01160d3:	68 42 9b 12 f0       	push   $0xf0129b42
f01160d8:	e8 da a3 fe ff       	call   f01004b7 <_warn>
f01160dd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01160e0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01160e4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01160e8:	74 04                	je     f01160ee <test_calculate_allocated_space+0x8a1>
f01160ea:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01160ee:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f01160f2:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01160f9:	00 00 00 
		num_pages = 0;
f01160fc:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116103:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0116106:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116109:	c1 e0 0a             	shl    $0xa,%eax
f011610c:	89 c2                	mov    %eax,%edx
f011610e:	83 ec 0c             	sub    $0xc,%esp
f0116111:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116117:	50                   	push   %eax
f0116118:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011611e:	50                   	push   %eax
f011611f:	52                   	push   %edx
f0116120:	6a 00                	push   $0x0
f0116122:	ff 75 d8             	pushl  -0x28(%ebp)
f0116125:	e8 2c 33 ff ff       	call   f0109456 <calculate_allocated_space>
f011612a:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f011612d:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f0116134:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011613b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116141:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116144:	74 28                	je     f011616e <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116146:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011614c:	83 ec 0c             	sub    $0xc,%esp
f011614f:	ff 75 c8             	pushl  -0x38(%ebp)
f0116152:	50                   	push   %eax
f0116153:	68 f4 b4 12 f0       	push   $0xf012b4f4
f0116158:	68 c9 07 00 00       	push   $0x7c9
f011615d:	68 42 9b 12 f0       	push   $0xf0129b42
f0116162:	e8 50 a3 fe ff       	call   f01004b7 <_warn>
f0116167:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011616a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011616e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116174:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116177:	74 28                	je     f01161a1 <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116179:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011617f:	83 ec 0c             	sub    $0xc,%esp
f0116182:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116185:	50                   	push   %eax
f0116186:	68 54 b5 12 f0       	push   $0xf012b554
f011618b:	68 ce 07 00 00       	push   $0x7ce
f0116190:	68 42 9b 12 f0       	push   $0xf0129b42
f0116195:	e8 1d a3 fe ff       	call   f01004b7 <_warn>
f011619a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011619d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01161a1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01161a5:	74 04                	je     f01161ab <test_calculate_allocated_space+0x95e>
f01161a7:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01161ab:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f01161af:	83 ec 04             	sub    $0x4,%esp
f01161b2:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01161b8:	50                   	push   %eax
f01161b9:	68 54 b4 12 f0       	push   $0xf012b454
f01161be:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01161c4:	50                   	push   %eax
f01161c5:	e8 06 a9 00 00       	call   f0120ad0 <strcconcat>
f01161ca:	83 c4 10             	add    $0x10,%esp
f01161cd:	83 ec 0c             	sub    $0xc,%esp
f01161d0:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01161d6:	50                   	push   %eax
f01161d7:	e8 00 bd fe ff       	call   f0101edc <execute_command>
f01161dc:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f01161df:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01161e6:	00 00 00 
		num_pages = 0;
f01161e9:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01161f0:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f01161f3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01161f6:	89 c2                	mov    %eax,%edx
f01161f8:	01 d2                	add    %edx,%edx
f01161fa:	01 d0                	add    %edx,%eax
f01161fc:	05 00 18 00 00       	add    $0x1800,%eax
f0116201:	89 c2                	mov    %eax,%edx
f0116203:	83 ec 0c             	sub    $0xc,%esp
f0116206:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011620c:	50                   	push   %eax
f011620d:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116213:	50                   	push   %eax
f0116214:	52                   	push   %edx
f0116215:	68 00 18 00 00       	push   $0x1800
f011621a:	ff 75 d8             	pushl  -0x28(%ebp)
f011621d:	e8 34 32 ff ff       	call   f0109456 <calculate_allocated_space>
f0116222:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116225:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f011622c:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116233:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116239:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011623c:	74 28                	je     f0116266 <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011623e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116244:	83 ec 0c             	sub    $0xc,%esp
f0116247:	ff 75 c8             	pushl  -0x38(%ebp)
f011624a:	50                   	push   %eax
f011624b:	68 f4 b4 12 f0       	push   $0xf012b4f4
f0116250:	68 df 07 00 00       	push   $0x7df
f0116255:	68 42 9b 12 f0       	push   $0xf0129b42
f011625a:	e8 58 a2 fe ff       	call   f01004b7 <_warn>
f011625f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116262:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116266:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011626c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011626f:	74 28                	je     f0116299 <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116271:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116277:	83 ec 0c             	sub    $0xc,%esp
f011627a:	ff 75 c4             	pushl  -0x3c(%ebp)
f011627d:	50                   	push   %eax
f011627e:	68 54 b5 12 f0       	push   $0xf012b554
f0116283:	68 e4 07 00 00       	push   $0x7e4
f0116288:	68 42 9b 12 f0       	push   $0xf0129b42
f011628d:	e8 25 a2 fe ff       	call   f01004b7 <_warn>
f0116292:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116295:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116299:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011629d:	74 04                	je     f01162a3 <test_calculate_allocated_space+0xa56>
f011629f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01162a3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f01162a7:	83 ec 04             	sub    $0x4,%esp
f01162aa:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01162b0:	50                   	push   %eax
f01162b1:	68 14 a5 12 f0       	push   $0xf012a514
f01162b6:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01162bc:	50                   	push   %eax
f01162bd:	e8 0e a8 00 00       	call   f0120ad0 <strcconcat>
f01162c2:	83 c4 10             	add    $0x10,%esp
f01162c5:	83 ec 0c             	sub    $0xc,%esp
f01162c8:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01162ce:	50                   	push   %eax
f01162cf:	e8 08 bc fe ff       	call   f0101edc <execute_command>
f01162d4:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f01162d7:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01162de:	00 00 00 
		num_pages = 0;
f01162e1:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01162e8:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f01162eb:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01162ee:	89 d0                	mov    %edx,%eax
f01162f0:	c1 e0 02             	shl    $0x2,%eax
f01162f3:	01 d0                	add    %edx,%eax
f01162f5:	01 c0                	add    %eax,%eax
f01162f7:	05 00 00 40 00       	add    $0x400000,%eax
f01162fc:	89 c2                	mov    %eax,%edx
f01162fe:	83 ec 0c             	sub    $0xc,%esp
f0116301:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116307:	50                   	push   %eax
f0116308:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011630e:	50                   	push   %eax
f011630f:	52                   	push   %edx
f0116310:	68 00 00 40 00       	push   $0x400000
f0116315:	ff 75 d8             	pushl  -0x28(%ebp)
f0116318:	e8 39 31 ff ff       	call   f0109456 <calculate_allocated_space>
f011631d:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116320:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0116327:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011632e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116334:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116337:	74 28                	je     f0116361 <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116339:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011633f:	83 ec 0c             	sub    $0xc,%esp
f0116342:	ff 75 c8             	pushl  -0x38(%ebp)
f0116345:	50                   	push   %eax
f0116346:	68 f4 b4 12 f0       	push   $0xf012b4f4
f011634b:	68 f4 07 00 00       	push   $0x7f4
f0116350:	68 42 9b 12 f0       	push   $0xf0129b42
f0116355:	e8 5d a1 fe ff       	call   f01004b7 <_warn>
f011635a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011635d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116361:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116367:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011636a:	74 28                	je     f0116394 <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011636c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116372:	83 ec 0c             	sub    $0xc,%esp
f0116375:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116378:	50                   	push   %eax
f0116379:	68 54 b5 12 f0       	push   $0xf012b554
f011637e:	68 f9 07 00 00       	push   $0x7f9
f0116383:	68 42 9b 12 f0       	push   $0xf0129b42
f0116388:	e8 2a a1 fe ff       	call   f01004b7 <_warn>
f011638d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116390:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116394:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116398:	74 04                	je     f011639e <test_calculate_allocated_space+0xb51>
f011639a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011639e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f01163a2:	83 ec 04             	sub    $0x4,%esp
f01163a5:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01163ab:	50                   	push   %eax
f01163ac:	68 1e a5 12 f0       	push   $0xf012a51e
f01163b1:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01163b7:	50                   	push   %eax
f01163b8:	e8 13 a7 00 00       	call   f0120ad0 <strcconcat>
f01163bd:	83 c4 10             	add    $0x10,%esp
f01163c0:	83 ec 0c             	sub    $0xc,%esp
f01163c3:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01163c9:	50                   	push   %eax
f01163ca:	e8 0d bb fe ff       	call   f0101edc <execute_command>
f01163cf:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f01163d2:	83 ec 04             	sub    $0x4,%esp
f01163d5:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01163db:	50                   	push   %eax
f01163dc:	68 5c b4 12 f0       	push   $0xf012b45c
f01163e1:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01163e7:	50                   	push   %eax
f01163e8:	e8 e3 a6 00 00       	call   f0120ad0 <strcconcat>
f01163ed:	83 c4 10             	add    $0x10,%esp
f01163f0:	83 ec 0c             	sub    $0xc,%esp
f01163f3:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01163f9:	50                   	push   %eax
f01163fa:	e8 dd ba fe ff       	call   f0101edc <execute_command>
f01163ff:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f0116402:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116409:	00 00 00 
		num_pages = 0;
f011640c:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116413:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0116416:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116419:	05 00 00 38 00       	add    $0x380000,%eax
f011641e:	01 c0                	add    %eax,%eax
f0116420:	89 c2                	mov    %eax,%edx
f0116422:	83 ec 0c             	sub    $0xc,%esp
f0116425:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011642b:	50                   	push   %eax
f011642c:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116432:	50                   	push   %eax
f0116433:	52                   	push   %edx
f0116434:	68 00 00 70 00       	push   $0x700000
f0116439:	ff 75 d8             	pushl  -0x28(%ebp)
f011643c:	e8 15 30 ff ff       	call   f0109456 <calculate_allocated_space>
f0116441:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116444:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f011644b:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116452:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116458:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011645b:	74 28                	je     f0116485 <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011645d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116463:	83 ec 0c             	sub    $0xc,%esp
f0116466:	ff 75 c8             	pushl  -0x38(%ebp)
f0116469:	50                   	push   %eax
f011646a:	68 f4 b4 12 f0       	push   $0xf012b4f4
f011646f:	68 0b 08 00 00       	push   $0x80b
f0116474:	68 42 9b 12 f0       	push   $0xf0129b42
f0116479:	e8 39 a0 fe ff       	call   f01004b7 <_warn>
f011647e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116481:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116485:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011648b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011648e:	74 28                	je     f01164b8 <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116490:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116496:	83 ec 0c             	sub    $0xc,%esp
f0116499:	ff 75 c4             	pushl  -0x3c(%ebp)
f011649c:	50                   	push   %eax
f011649d:	68 54 b5 12 f0       	push   $0xf012b554
f01164a2:	68 10 08 00 00       	push   $0x810
f01164a7:	68 42 9b 12 f0       	push   $0xf0129b42
f01164ac:	e8 06 a0 fe ff       	call   f01004b7 <_warn>
f01164b1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01164b4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01164b8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01164bc:	74 04                	je     f01164c2 <test_calculate_allocated_space+0xc75>
f01164be:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01164c2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f01164c6:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01164cd:	00 00 00 
		num_pages = 0;
f01164d0:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01164d7:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f01164da:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01164dd:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f01164e2:	89 c2                	mov    %eax,%edx
f01164e4:	83 ec 0c             	sub    $0xc,%esp
f01164e7:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01164ed:	50                   	push   %eax
f01164ee:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01164f4:	50                   	push   %eax
f01164f5:	52                   	push   %edx
f01164f6:	68 ff ff 3f 00       	push   $0x3fffff
f01164fb:	ff 75 d8             	pushl  -0x28(%ebp)
f01164fe:	e8 53 2f ff ff       	call   f0109456 <calculate_allocated_space>
f0116503:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116506:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f011650d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116514:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011651a:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011651d:	74 28                	je     f0116547 <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011651f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116525:	83 ec 0c             	sub    $0xc,%esp
f0116528:	ff 75 c8             	pushl  -0x38(%ebp)
f011652b:	50                   	push   %eax
f011652c:	68 f4 b4 12 f0       	push   $0xf012b4f4
f0116531:	68 1e 08 00 00       	push   $0x81e
f0116536:	68 42 9b 12 f0       	push   $0xf0129b42
f011653b:	e8 77 9f fe ff       	call   f01004b7 <_warn>
f0116540:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116543:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116547:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011654d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116550:	74 28                	je     f011657a <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116552:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116558:	83 ec 0c             	sub    $0xc,%esp
f011655b:	ff 75 c4             	pushl  -0x3c(%ebp)
f011655e:	50                   	push   %eax
f011655f:	68 54 b5 12 f0       	push   $0xf012b554
f0116564:	68 23 08 00 00       	push   $0x823
f0116569:	68 42 9b 12 f0       	push   $0xf0129b42
f011656e:	e8 44 9f fe ff       	call   f01004b7 <_warn>
f0116573:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116576:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011657a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011657e:	74 04                	je     f0116584 <test_calculate_allocated_space+0xd37>
f0116580:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116584:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0116588:	83 ec 0c             	sub    $0xc,%esp
f011658b:	68 cf a4 12 f0       	push   $0xf012a4cf
f0116590:	e8 d7 a9 fe ff       	call   f0100f6c <cprintf>
f0116595:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f0116598:	83 ec 08             	sub    $0x8,%esp
f011659b:	ff 75 e4             	pushl  -0x1c(%ebp)
f011659e:	68 b0 b5 12 f0       	push   $0xf012b5b0
f01165a3:	e8 c4 a9 fe ff       	call   f0100f6c <cprintf>
f01165a8:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01165ab:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01165af:	75 10                	jne    f01165c1 <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f01165b1:	83 ec 0c             	sub    $0xc,%esp
f01165b4:	68 f0 b5 12 f0       	push   $0xf012b5f0
f01165b9:	e8 ae a9 fe ff       	call   f0100f6c <cprintf>
f01165be:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01165c1:	a1 e4 51 55 f0       	mov    0xf05551e4,%eax
f01165c6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01165c9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01165cc:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01165cf:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01165d4:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01165d7:	5b                   	pop    %ebx
f01165d8:	5e                   	pop    %esi
f01165d9:	5f                   	pop    %edi
f01165da:	5d                   	pop    %ebp
f01165db:	c3                   	ret    

f01165dc <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f01165dc:	55                   	push   %ebp
f01165dd:	89 e5                	mov    %esp,%ebp
f01165df:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f01165e2:	8b 45 10             	mov    0x10(%ebp),%eax
f01165e5:	ba 01 00 00 00       	mov    $0x1,%edx
f01165ea:	88 c1                	mov    %al,%cl
f01165ec:	d3 e2                	shl    %cl,%edx
f01165ee:	89 d0                	mov    %edx,%eax
f01165f0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01165f3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01165f6:	c1 e8 16             	shr    $0x16,%eax
f01165f9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116600:	8b 45 08             	mov    0x8(%ebp),%eax
f0116603:	01 d0                	add    %edx,%eax
f0116605:	8b 00                	mov    (%eax),%eax
f0116607:	83 e0 01             	and    $0x1,%eax
f011660a:	85 c0                	test   %eax,%eax
f011660c:	75 07                	jne    f0116615 <CB+0x39>
f011660e:	b8 00 00 00 00       	mov    $0x0,%eax
f0116613:	eb 76                	jmp    f011668b <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0116615:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116618:	c1 e8 16             	shr    $0x16,%eax
f011661b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116622:	8b 45 08             	mov    0x8(%ebp),%eax
f0116625:	01 d0                	add    %edx,%eax
f0116627:	8b 00                	mov    (%eax),%eax
f0116629:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011662e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116631:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116634:	c1 e8 0c             	shr    $0xc,%eax
f0116637:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011663a:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f011663f:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0116642:	72 17                	jb     f011665b <CB+0x7f>
f0116644:	ff 75 f0             	pushl  -0x10(%ebp)
f0116647:	68 3c b6 12 f0       	push   $0xf012b63c
f011664c:	68 3e 08 00 00       	push   $0x83e
f0116651:	68 42 9b 12 f0       	push   $0xf0129b42
f0116656:	e8 bf 9c fe ff       	call   f010031a <_panic>
f011665b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011665e:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116663:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f0116666:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116669:	c1 e8 0c             	shr    $0xc,%eax
f011666c:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116671:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116678:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011667b:	01 d0                	add    %edx,%eax
f011667d:	8b 00                	mov    (%eax),%eax
f011667f:	23 45 f4             	and    -0xc(%ebp),%eax
f0116682:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0116685:	0f 94 c0             	sete   %al
f0116688:	0f b6 c0             	movzbl %al,%eax
}
f011668b:	c9                   	leave  
f011668c:	c3                   	ret    

f011668d <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f011668d:	55                   	push   %ebp
f011668e:	89 e5                	mov    %esp,%ebp
f0116690:	83 ec 18             	sub    $0x18,%esp
	assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f0116693:	8b 45 10             	mov    0x10(%ebp),%eax
f0116696:	ba 01 00 00 00       	mov    $0x1,%edx
f011669b:	88 c1                	mov    %al,%cl
f011669d:	d3 e2                	shl    %cl,%edx
f011669f:	89 d0                	mov    %edx,%eax
f01166a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01166a4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01166a7:	c1 e8 16             	shr    $0x16,%eax
f01166aa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01166b1:	8b 45 08             	mov    0x8(%ebp),%eax
f01166b4:	01 d0                	add    %edx,%eax
f01166b6:	8b 00                	mov    (%eax),%eax
f01166b8:	83 e0 01             	and    $0x1,%eax
f01166bb:	85 c0                	test   %eax,%eax
f01166bd:	75 0a                	jne    f01166c9 <SB+0x3c>
f01166bf:	b8 00 00 00 00       	mov    $0x0,%eax
f01166c4:	e9 cd 00 00 00       	jmp    f0116796 <SB+0x109>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01166c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01166cc:	c1 e8 16             	shr    $0x16,%eax
f01166cf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01166d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01166d9:	01 d0                	add    %edx,%eax
f01166db:	8b 00                	mov    (%eax),%eax
f01166dd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01166e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01166e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01166e8:	c1 e8 0c             	shr    $0xc,%eax
f01166eb:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01166ee:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f01166f3:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01166f6:	72 17                	jb     f011670f <SB+0x82>
f01166f8:	ff 75 f0             	pushl  -0x10(%ebp)
f01166fb:	68 3c b6 12 f0       	push   $0xf012b63c
f0116700:	68 46 08 00 00       	push   $0x846
f0116705:	68 42 9b 12 f0       	push   $0xf0129b42
f011670a:	e8 0b 9c fe ff       	call   f010031a <_panic>
f011670f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116712:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116717:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
f011671a:	83 7d 14 ff          	cmpl   $0xffffffff,0x14(%ebp)
f011671e:	74 3c                	je     f011675c <SB+0xcf>
f0116720:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116723:	c1 e8 0c             	shr    $0xc,%eax
f0116726:	25 ff 03 00 00       	and    $0x3ff,%eax
f011672b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116732:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116735:	01 d0                	add    %edx,%eax
f0116737:	8b 55 0c             	mov    0xc(%ebp),%edx
f011673a:	c1 ea 0c             	shr    $0xc,%edx
f011673d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0116743:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f011674a:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011674d:	01 ca                	add    %ecx,%edx
f011674f:	8b 12                	mov    (%edx),%edx
f0116751:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0116754:	f7 d1                	not    %ecx
f0116756:	21 ca                	and    %ecx,%edx
f0116758:	89 10                	mov    %edx,(%eax)
f011675a:	eb 35                	jmp    f0116791 <SB+0x104>
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
f011675c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011675f:	c1 e8 0c             	shr    $0xc,%eax
f0116762:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116767:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011676e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116771:	01 c2                	add    %eax,%edx
f0116773:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116776:	c1 e8 0c             	shr    $0xc,%eax
f0116779:	25 ff 03 00 00       	and    $0x3ff,%eax
f011677e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0116785:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116788:	01 c8                	add    %ecx,%eax
f011678a:	8b 00                	mov    (%eax),%eax
f011678c:	0b 45 f4             	or     -0xc(%ebp),%eax
f011678f:	89 02                	mov    %eax,(%edx)
	return 0;
f0116791:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0116796:	c9                   	leave  
f0116797:	c3                   	ret    

f0116798 <CPs>:
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f0116798:	55                   	push   %ebp
f0116799:	89 e5                	mov    %esp,%ebp
f011679b:	83 ec 28             	sub    $0x28,%esp
	assert(USE_KHEAP == 0) ;
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f011679e:	8b 45 0c             	mov    0xc(%ebp),%eax
f01167a1:	c1 e8 16             	shr    $0x16,%eax
f01167a4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01167ab:	8b 45 08             	mov    0x8(%ebp),%eax
f01167ae:	01 d0                	add    %edx,%eax
f01167b0:	8b 00                	mov    (%eax),%eax
f01167b2:	83 e0 01             	and    $0x1,%eax
f01167b5:	85 c0                	test   %eax,%eax
f01167b7:	75 0a                	jne    f01167c3 <CPs+0x2b>
f01167b9:	b8 00 00 00 00       	mov    $0x0,%eax
f01167be:	e9 b8 00 00 00       	jmp    f011687b <CPs+0xe3>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01167c3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01167c6:	c1 e8 16             	shr    $0x16,%eax
f01167c9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01167d0:	8b 45 08             	mov    0x8(%ebp),%eax
f01167d3:	01 d0                	add    %edx,%eax
f01167d5:	8b 00                	mov    (%eax),%eax
f01167d7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01167dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01167df:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01167e2:	c1 e8 0c             	shr    $0xc,%eax
f01167e5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01167e8:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f01167ed:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01167f0:	72 17                	jb     f0116809 <CPs+0x71>
f01167f2:	ff 75 f0             	pushl  -0x10(%ebp)
f01167f5:	68 3c b6 12 f0       	push   $0xf012b63c
f01167fa:	68 4f 08 00 00       	push   $0x84f
f01167ff:	68 42 9b 12 f0       	push   $0xf0129b42
f0116804:	e8 11 9b fe ff       	call   f010031a <_panic>
f0116809:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011680c:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116811:	89 45 e8             	mov    %eax,-0x18(%ebp)
	for (int i = 0 ; i < 12 ; i++)
f0116814:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011681b:	eb 53                	jmp    f0116870 <CPs+0xd8>
	{
		uint32 mask = 1<<i;
f011681d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116820:	ba 01 00 00 00       	mov    $0x1,%edx
f0116825:	88 c1                	mov    %al,%cl
f0116827:	d3 e2                	shl    %cl,%edx
f0116829:	89 d0                	mov    %edx,%eax
f011682b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (!(which & mask))	continue ;
f011682e:	8b 45 14             	mov    0x14(%ebp),%eax
f0116831:	23 45 e4             	and    -0x1c(%ebp),%eax
f0116834:	85 c0                	test   %eax,%eax
f0116836:	74 34                	je     f011686c <CPs+0xd4>
		uint8 c = (table[((((uint32) (va)) >> 12) & 0x3FF)] & mask) == (perms & mask) ? 1 :  0;
f0116838:	8b 45 0c             	mov    0xc(%ebp),%eax
f011683b:	c1 e8 0c             	shr    $0xc,%eax
f011683e:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116843:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011684a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011684d:	01 d0                	add    %edx,%eax
f011684f:	8b 00                	mov    (%eax),%eax
f0116851:	33 45 10             	xor    0x10(%ebp),%eax
f0116854:	23 45 e4             	and    -0x1c(%ebp),%eax
f0116857:	85 c0                	test   %eax,%eax
f0116859:	0f 94 c0             	sete   %al
f011685c:	88 45 e3             	mov    %al,-0x1d(%ebp)
		if (!c) return 0;
f011685f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116863:	75 08                	jne    f011686d <CPs+0xd5>
f0116865:	b8 00 00 00 00       	mov    $0x0,%eax
f011686a:	eb 0f                	jmp    f011687b <CPs+0xe3>
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	for (int i = 0 ; i < 12 ; i++)
	{
		uint32 mask = 1<<i;
		if (!(which & mask))	continue ;
f011686c:	90                   	nop
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
	assert(USE_KHEAP == 0) ;
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	for (int i = 0 ; i < 12 ; i++)
f011686d:	ff 45 f4             	incl   -0xc(%ebp)
f0116870:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
f0116874:	7e a7                	jle    f011681d <CPs+0x85>
		uint32 mask = 1<<i;
		if (!(which & mask))	continue ;
		uint8 c = (table[((((uint32) (va)) >> 12) & 0x3FF)] & mask) == (perms & mask) ? 1 :  0;
		if (!c) return 0;
	}
	return 1;
f0116876:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011687b:	c9                   	leave  
f011687c:	c3                   	ret    

f011687d <CA>:

int CA(uint32 *ptr_dir, uint32 va)
{
f011687d:	55                   	push   %ebp
f011687e:	89 e5                	mov    %esp,%ebp
f0116880:	83 ec 18             	sub    $0x18,%esp
	assert(USE_KHEAP == 0) ;
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0116883:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116886:	c1 e8 16             	shr    $0x16,%eax
f0116889:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116890:	8b 45 08             	mov    0x8(%ebp),%eax
f0116893:	01 d0                	add    %edx,%eax
f0116895:	8b 00                	mov    (%eax),%eax
f0116897:	83 e0 01             	and    $0x1,%eax
f011689a:	85 c0                	test   %eax,%eax
f011689c:	75 07                	jne    f01168a5 <CA+0x28>
f011689e:	b8 00 00 00 00       	mov    $0x0,%eax
f01168a3:	eb 6f                	jmp    f0116914 <CA+0x97>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01168a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01168a8:	c1 e8 16             	shr    $0x16,%eax
f01168ab:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01168b2:	8b 45 08             	mov    0x8(%ebp),%eax
f01168b5:	01 d0                	add    %edx,%eax
f01168b7:	8b 00                	mov    (%eax),%eax
f01168b9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01168be:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01168c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01168c4:	c1 e8 0c             	shr    $0xc,%eax
f01168c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01168ca:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f01168cf:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f01168d2:	72 17                	jb     f01168eb <CA+0x6e>
f01168d4:	ff 75 f4             	pushl  -0xc(%ebp)
f01168d7:	68 3c b6 12 f0       	push   $0xf012b63c
f01168dc:	68 5e 08 00 00       	push   $0x85e
f01168e1:	68 42 9b 12 f0       	push   $0xf0129b42
f01168e6:	e8 2f 9a fe ff       	call   f010031a <_panic>
f01168eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01168ee:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01168f3:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF;
f01168f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01168f9:	c1 e8 0c             	shr    $0xc,%eax
f01168fc:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116901:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116908:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011690b:	01 d0                	add    %edx,%eax
f011690d:	8b 00                	mov    (%eax),%eax
f011690f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f0116914:	c9                   	leave  
f0116915:	c3                   	ret    

f0116916 <CE>:

int CE(uint32 *_d, uint32 va)
{
f0116916:	55                   	push   %ebp
f0116917:	89 e5                	mov    %esp,%ebp
f0116919:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f011691c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011691f:	c1 e8 16             	shr    $0x16,%eax
f0116922:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116929:	8b 45 08             	mov    0x8(%ebp),%eax
f011692c:	01 d0                	add    %edx,%eax
f011692e:	8b 00                	mov    (%eax),%eax
f0116930:	83 e0 01             	and    $0x1,%eax
f0116933:	85 c0                	test   %eax,%eax
f0116935:	75 07                	jne    f011693e <CE+0x28>
f0116937:	b8 00 00 00 00       	mov    $0x0,%eax
f011693c:	eb 7a                	jmp    f01169b8 <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f011693e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116941:	c1 e8 16             	shr    $0x16,%eax
f0116944:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011694b:	8b 45 08             	mov    0x8(%ebp),%eax
f011694e:	01 d0                	add    %edx,%eax
f0116950:	8b 00                	mov    (%eax),%eax
f0116952:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116957:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011695a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011695d:	c1 e8 0c             	shr    $0xc,%eax
f0116960:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116963:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0116968:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f011696b:	72 17                	jb     f0116984 <CE+0x6e>
f011696d:	ff 75 f4             	pushl  -0xc(%ebp)
f0116970:	68 3c b6 12 f0       	push   $0xf012b63c
f0116975:	68 65 08 00 00       	push   $0x865
f011697a:	68 42 9b 12 f0       	push   $0xf0129b42
f011697f:	e8 96 99 fe ff       	call   f010031a <_panic>
f0116984:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116987:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011698c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f011698f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116992:	c1 e8 0c             	shr    $0xc,%eax
f0116995:	25 ff 03 00 00       	and    $0x3ff,%eax
f011699a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01169a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01169a4:	01 d0                	add    %edx,%eax
f01169a6:	8b 00                	mov    (%eax),%eax
f01169a8:	85 c0                	test   %eax,%eax
f01169aa:	74 07                	je     f01169b3 <CE+0x9d>
f01169ac:	b8 00 00 00 00       	mov    $0x0,%eax
f01169b1:	eb 05                	jmp    f01169b8 <CE+0xa2>
	return 1;
f01169b3:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01169b8:	c9                   	leave  
f01169b9:	c3                   	ret    

f01169ba <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f01169ba:	55                   	push   %ebp
f01169bb:	89 e5                	mov    %esp,%ebp
f01169bd:	83 ec 18             	sub    $0x18,%esp
	assert(USE_KHEAP == 0) ;
	uint32 pd_entry = pd[((((uint32) (va)) >> 22) & 0x3FF)];
f01169c0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01169c3:	c1 e8 16             	shr    $0x16,%eax
f01169c6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01169cd:	8b 45 08             	mov    0x8(%ebp),%eax
f01169d0:	01 d0                	add    %edx,%eax
f01169d2:	8b 00                	mov    (%eax),%eax
f01169d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if ( (pd_entry & 1) == 1)
f01169d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01169da:	83 e0 01             	and    $0x1,%eax
f01169dd:	85 c0                	test   %eax,%eax
f01169df:	0f 84 92 00 00 00    	je     f0116a77 <CP+0xbd>
	{
		uint32 *t = NULL;
f01169e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		t = (STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(pd_entry)));
f01169ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01169ef:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01169f4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01169f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01169fa:	c1 e8 0c             	shr    $0xc,%eax
f01169fd:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0116a00:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0116a05:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f0116a08:	72 17                	jb     f0116a21 <CP+0x67>
f0116a0a:	ff 75 ec             	pushl  -0x14(%ebp)
f0116a0d:	68 3c b6 12 f0       	push   $0xf012b63c
f0116a12:	68 71 08 00 00       	push   $0x871
f0116a17:	68 42 9b 12 f0       	push   $0xf0129b42
f0116a1c:	e8 f9 98 fe ff       	call   f010031a <_panic>
f0116a21:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116a24:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116a29:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf("va =%x, ENTRY after PERM = %x, perm to set = %x, perm to clear = %x\n", va, t[PTX(va)]&0x00000FFF, ps, pc);

		if (((t[((((uint32) (va)) >> 12) & 0x3FF)]&ps) == ps)&&((~(t[((((uint32) (va)) >> 12) & 0x3FF)])&pc) == pc))
f0116a2c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116a2f:	c1 e8 0c             	shr    $0xc,%eax
f0116a32:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116a37:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116a3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116a41:	01 d0                	add    %edx,%eax
f0116a43:	8b 00                	mov    (%eax),%eax
f0116a45:	23 45 10             	and    0x10(%ebp),%eax
f0116a48:	3b 45 10             	cmp    0x10(%ebp),%eax
f0116a4b:	75 2a                	jne    f0116a77 <CP+0xbd>
f0116a4d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116a50:	c1 e8 0c             	shr    $0xc,%eax
f0116a53:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116a58:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116a5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116a62:	01 d0                	add    %edx,%eax
f0116a64:	8b 00                	mov    (%eax),%eax
f0116a66:	f7 d0                	not    %eax
f0116a68:	23 45 14             	and    0x14(%ebp),%eax
f0116a6b:	3b 45 14             	cmp    0x14(%ebp),%eax
f0116a6e:	75 07                	jne    f0116a77 <CP+0xbd>
			return 1;
f0116a70:	b8 01 00 00 00       	mov    $0x1,%eax
f0116a75:	eb 05                	jmp    f0116a7c <CP+0xc2>
	}
	return 0;
f0116a77:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0116a7c:	c9                   	leave  
f0116a7d:	c3                   	ret    

f0116a7e <GP>:

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f0116a7e:	55                   	push   %ebp
f0116a7f:	89 e5                	mov    %esp,%ebp
f0116a81:	83 ec 18             	sub    $0x18,%esp
	assert(USE_KHEAP == 0) ;
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0116a84:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116a87:	c1 e8 16             	shr    $0x16,%eax
f0116a8a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116a91:	8b 45 08             	mov    0x8(%ebp),%eax
f0116a94:	01 d0                	add    %edx,%eax
f0116a96:	8b 00                	mov    (%eax),%eax
f0116a98:	83 e0 01             	and    $0x1,%eax
f0116a9b:	85 c0                	test   %eax,%eax
f0116a9d:	75 07                	jne    f0116aa6 <GP+0x28>
f0116a9f:	b8 00 00 00 00       	mov    $0x0,%eax
f0116aa4:	eb 6f                	jmp    f0116b15 <GP+0x97>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0116aa6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116aa9:	c1 e8 16             	shr    $0x16,%eax
f0116aac:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116ab3:	8b 45 08             	mov    0x8(%ebp),%eax
f0116ab6:	01 d0                	add    %edx,%eax
f0116ab8:	8b 00                	mov    (%eax),%eax
f0116aba:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116abf:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0116ac2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116ac5:	c1 e8 0c             	shr    $0xc,%eax
f0116ac8:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116acb:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0116ad0:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f0116ad3:	72 17                	jb     f0116aec <GP+0x6e>
f0116ad5:	ff 75 f4             	pushl  -0xc(%ebp)
f0116ad8:	68 3c b6 12 f0       	push   $0xf012b63c
f0116add:	68 7e 08 00 00       	push   $0x87e
f0116ae2:	68 42 9b 12 f0       	push   $0xf0129b42
f0116ae7:	e8 2e 98 fe ff       	call   f010031a <_panic>
f0116aec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116aef:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116af4:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
f0116af7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116afa:	c1 e8 0c             	shr    $0xc,%eax
f0116afd:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116b02:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116b09:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116b0c:	01 d0                	add    %edx,%eax
f0116b0e:	8b 00                	mov    (%eax),%eax
f0116b10:	25 ff 0f 00 00       	and    $0xfff,%eax
}
f0116b15:	c9                   	leave  
f0116b16:	c3                   	ret    

f0116b17 <ClearUserSpace>:

void ClearUserSpace(uint32 *ptr_dir)
{
f0116b17:	55                   	push   %ebp
f0116b18:	89 e5                	mov    %esp,%ebp
f0116b1a:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0116b1d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0116b24:	eb 18                	jmp    f0116b3e <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f0116b26:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0116b29:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116b30:	8b 45 08             	mov    0x8(%ebp),%eax
f0116b33:	01 d0                	add    %edx,%eax
f0116b35:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0116b3b:	ff 45 fc             	incl   -0x4(%ebp)
f0116b3e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0116b41:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f0116b46:	76 de                	jbe    f0116b26 <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f0116b48:	90                   	nop
f0116b49:	c9                   	leave  
f0116b4a:	c3                   	ret    

f0116b4b <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f0116b4b:	55                   	push   %ebp
f0116b4c:	89 e5                	mov    %esp,%ebp
f0116b4e:	83 ec 38             	sub    $0x38,%esp
f0116b51:	8b 45 2c             	mov    0x2c(%ebp),%eax
f0116b54:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f0116b57:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116b5a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116b5f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f0116b62:	8b 45 10             	mov    0x10(%ebp),%eax
f0116b65:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116b6a:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0116b6d:	e9 ea 01 00 00       	jmp    f0116d5c <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f0116b72:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116b76:	74 44                	je     f0116bbc <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f0116b78:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116b7b:	83 ec 04             	sub    $0x4,%esp
f0116b7e:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0116b81:	52                   	push   %edx
f0116b82:	50                   	push   %eax
f0116b83:	ff 75 08             	pushl  0x8(%ebp)
f0116b86:	e8 5d 18 ff ff       	call   f01083e8 <get_frame_info>
f0116b8b:	83 c4 10             	add    $0x10,%esp
f0116b8e:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f0116b91:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116b94:	85 c0                	test   %eax,%eax
f0116b96:	75 24                	jne    f0116bbc <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f0116b98:	83 ec 04             	sub    $0x4,%esp
f0116b9b:	68 6c b6 12 f0       	push   $0xf012b66c
f0116ba0:	68 99 08 00 00       	push   $0x899
f0116ba5:	68 42 9b 12 f0       	push   $0xf0129b42
f0116baa:	e8 08 99 fe ff       	call   f01004b7 <_warn>
f0116baf:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116bb2:	b8 00 00 00 00       	mov    $0x0,%eax
f0116bb7:	e9 b6 01 00 00       	jmp    f0116d72 <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f0116bbc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116bbf:	83 ec 04             	sub    $0x4,%esp
f0116bc2:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0116bc5:	52                   	push   %edx
f0116bc6:	50                   	push   %eax
f0116bc7:	ff 75 08             	pushl  0x8(%ebp)
f0116bca:	e8 19 18 ff ff       	call   f01083e8 <get_frame_info>
f0116bcf:	83 c4 10             	add    $0x10,%esp
f0116bd2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f0116bd5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116bd8:	85 c0                	test   %eax,%eax
f0116bda:	75 24                	jne    f0116c00 <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f0116bdc:	83 ec 04             	sub    $0x4,%esp
f0116bdf:	68 98 b6 12 f0       	push   $0xf012b698
f0116be4:	68 a0 08 00 00       	push   $0x8a0
f0116be9:	68 42 9b 12 f0       	push   $0xf0129b42
f0116bee:	e8 c4 98 fe ff       	call   f01004b7 <_warn>
f0116bf3:	83 c4 10             	add    $0x10,%esp
			return 0;
f0116bf6:	b8 00 00 00 00       	mov    $0x0,%eax
f0116bfb:	e9 72 01 00 00       	jmp    f0116d72 <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f0116c00:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f0116c04:	75 70                	jne    f0116c76 <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f0116c06:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116c09:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0116c0c:	c1 ea 0c             	shr    $0xc,%edx
f0116c0f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0116c15:	c1 e2 02             	shl    $0x2,%edx
f0116c18:	01 d0                	add    %edx,%eax
f0116c1a:	8b 00                	mov    (%eax),%eax
f0116c1c:	c1 e8 0c             	shr    $0xc,%eax
f0116c1f:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f0116c22:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116c25:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0116c28:	c1 ea 0c             	shr    $0xc,%edx
f0116c2b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0116c31:	c1 e2 02             	shl    $0x2,%edx
f0116c34:	01 d0                	add    %edx,%eax
f0116c36:	8b 00                	mov    (%eax),%eax
f0116c38:	c1 e8 0c             	shr    $0xc,%eax
f0116c3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f0116c3e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116c41:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0116c44:	74 30                	je     f0116c76 <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f0116c46:	83 ec 04             	sub    $0x4,%esp
f0116c49:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116c4c:	ff 75 e8             	pushl  -0x18(%ebp)
f0116c4f:	ff 75 f0             	pushl  -0x10(%ebp)
f0116c52:	ff 75 f4             	pushl  -0xc(%ebp)
f0116c55:	68 c4 b6 12 f0       	push   $0xf012b6c4
f0116c5a:	68 aa 08 00 00       	push   $0x8aa
f0116c5f:	68 42 9b 12 f0       	push   $0xf0129b42
f0116c64:	e8 4e 98 fe ff       	call   f01004b7 <_warn>
f0116c69:	83 c4 20             	add    $0x20,%esp
				return 0;
f0116c6c:	b8 00 00 00 00       	mov    $0x0,%eax
f0116c71:	e9 fc 00 00 00       	jmp    f0116d72 <CCP+0x227>
			}
		}
		if (ref != -1)
f0116c76:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f0116c7a:	74 52                	je     f0116cce <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f0116c7c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116c80:	74 0e                	je     f0116c90 <CCP+0x145>
f0116c82:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116c85:	8b 40 08             	mov    0x8(%eax),%eax
f0116c88:	0f b7 c0             	movzwl %ax,%eax
f0116c8b:	3b 45 18             	cmp    0x18(%ebp),%eax
f0116c8e:	74 3e                	je     f0116cce <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f0116c90:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116c94:	74 0b                	je     f0116ca1 <CCP+0x156>
f0116c96:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116c99:	8b 40 08             	mov    0x8(%eax),%eax
f0116c9c:	0f b7 c0             	movzwl %ax,%eax
f0116c9f:	eb 05                	jmp    f0116ca6 <CCP+0x15b>
f0116ca1:	b8 00 00 00 00       	mov    $0x0,%eax
f0116ca6:	83 ec 0c             	sub    $0xc,%esp
f0116ca9:	50                   	push   %eax
f0116caa:	ff 75 f0             	pushl  -0x10(%ebp)
f0116cad:	68 20 b7 12 f0       	push   $0xf012b720
f0116cb2:	68 b2 08 00 00       	push   $0x8b2
f0116cb7:	68 42 9b 12 f0       	push   $0xf0129b42
f0116cbc:	e8 f6 97 fe ff       	call   f01004b7 <_warn>
f0116cc1:	83 c4 20             	add    $0x20,%esp
				return 0;
f0116cc4:	b8 00 00 00 00       	mov    $0x0,%eax
f0116cc9:	e9 a4 00 00 00       	jmp    f0116d72 <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f0116cce:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116cd1:	ff 75 20             	pushl  0x20(%ebp)
f0116cd4:	ff 75 1c             	pushl  0x1c(%ebp)
f0116cd7:	50                   	push   %eax
f0116cd8:	ff 75 08             	pushl  0x8(%ebp)
f0116cdb:	e8 b8 fa ff ff       	call   f0116798 <CPs>
f0116ce0:	83 c4 10             	add    $0x10,%esp
f0116ce3:	85 c0                	test   %eax,%eax
f0116ce5:	7f 21                	jg     f0116d08 <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f0116ce7:	83 ec 04             	sub    $0x4,%esp
f0116cea:	68 90 b7 12 f0       	push   $0xf012b790
f0116cef:	68 b8 08 00 00       	push   $0x8b8
f0116cf4:	68 42 9b 12 f0       	push   $0xf0129b42
f0116cf9:	e8 b9 97 fe ff       	call   f01004b7 <_warn>
f0116cfe:	83 c4 10             	add    $0x10,%esp
			return 0;
f0116d01:	b8 00 00 00 00       	mov    $0x0,%eax
f0116d06:	eb 6a                	jmp    f0116d72 <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f0116d08:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116d0c:	74 3a                	je     f0116d48 <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f0116d0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116d11:	ff 75 28             	pushl  0x28(%ebp)
f0116d14:	ff 75 24             	pushl  0x24(%ebp)
f0116d17:	50                   	push   %eax
f0116d18:	ff 75 08             	pushl  0x8(%ebp)
f0116d1b:	e8 78 fa ff ff       	call   f0116798 <CPs>
f0116d20:	83 c4 10             	add    $0x10,%esp
f0116d23:	85 c0                	test   %eax,%eax
f0116d25:	7f 21                	jg     f0116d48 <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f0116d27:	83 ec 04             	sub    $0x4,%esp
f0116d2a:	68 d8 b7 12 f0       	push   $0xf012b7d8
f0116d2f:	68 bf 08 00 00       	push   $0x8bf
f0116d34:	68 42 9b 12 f0       	push   $0xf0129b42
f0116d39:	e8 79 97 fe ff       	call   f01004b7 <_warn>
f0116d3e:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116d41:	b8 00 00 00 00       	mov    $0x0,%eax
f0116d46:	eb 2a                	jmp    f0116d72 <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f0116d48:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116d4c:	74 07                	je     f0116d55 <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f0116d4e:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0116d55:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f0116d5c:	8b 55 10             	mov    0x10(%ebp),%edx
f0116d5f:	8b 45 14             	mov    0x14(%ebp),%eax
f0116d62:	01 d0                	add    %edx,%eax
f0116d64:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0116d67:	0f 87 05 fe ff ff    	ja     f0116b72 <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f0116d6d:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0116d72:	c9                   	leave  
f0116d73:	c3                   	ret    

f0116d74 <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f0116d74:	55                   	push   %ebp
f0116d75:	89 e5                	mov    %esp,%ebp
f0116d77:	57                   	push   %edi
f0116d78:	56                   	push   %esi
f0116d79:	53                   	push   %ebx
f0116d7a:	81 ec 4c 03 00 00    	sub    $0x34c,%esp
#if USE_KHEAP
	panic("not handled yet");
#else
	if(firstTime)
f0116d80:	a0 94 9d 17 f0       	mov    0xf0179d94,%al
f0116d85:	84 c0                	test   %al,%al
f0116d87:	0f 84 38 0a 00 00    	je     f01177c5 <test_priority_normal_and_higher+0xa51>
		uint32 fact_WS[15];
		uint32 fact_TimeStamp[15];
		uint32 hello_WS[10];
		uint32 hello_TimeStamp[10];

		firstTime = 0;
f0116d8d:	c6 05 94 9d 17 f0 00 	movb   $0x0,0xf0179d94
		char command[100] = "load fos_add 20";
f0116d94:	8d 85 14 fe ff ff    	lea    -0x1ec(%ebp),%eax
f0116d9a:	bb 94 ba 12 f0       	mov    $0xf012ba94,%ebx
f0116d9f:	ba 04 00 00 00       	mov    $0x4,%edx
f0116da4:	89 c7                	mov    %eax,%edi
f0116da6:	89 de                	mov    %ebx,%esi
f0116da8:	89 d1                	mov    %edx,%ecx
f0116daa:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0116dac:	8d 95 24 fe ff ff    	lea    -0x1dc(%ebp),%edx
f0116db2:	b9 15 00 00 00       	mov    $0x15,%ecx
f0116db7:	b8 00 00 00 00       	mov    $0x0,%eax
f0116dbc:	89 d7                	mov    %edx,%edi
f0116dbe:	f3 ab                	rep stos %eax,%es:(%edi)
		execute_command(command);
f0116dc0:	83 ec 0c             	sub    $0xc,%esp
f0116dc3:	8d 85 14 fe ff ff    	lea    -0x1ec(%ebp),%eax
f0116dc9:	50                   	push   %eax
f0116dca:	e8 0d b1 fe ff       	call   f0101edc <execute_command>
f0116dcf:	83 c4 10             	add    $0x10,%esp
		char command2[100] = "load fact 15";
f0116dd2:	8d 85 78 fe ff ff    	lea    -0x188(%ebp),%eax
f0116dd8:	bb f8 ba 12 f0       	mov    $0xf012baf8,%ebx
f0116ddd:	ba 0d 00 00 00       	mov    $0xd,%edx
f0116de2:	89 c7                	mov    %eax,%edi
f0116de4:	89 de                	mov    %ebx,%esi
f0116de6:	89 d1                	mov    %edx,%ecx
f0116de8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0116dea:	8d 95 85 fe ff ff    	lea    -0x17b(%ebp),%edx
f0116df0:	b9 57 00 00 00       	mov    $0x57,%ecx
f0116df5:	b0 00                	mov    $0x0,%al
f0116df7:	89 d7                	mov    %edx,%edi
f0116df9:	f3 aa                	rep stos %al,%es:(%edi)
		execute_command(command2);
f0116dfb:	83 ec 0c             	sub    $0xc,%esp
f0116dfe:	8d 85 78 fe ff ff    	lea    -0x188(%ebp),%eax
f0116e04:	50                   	push   %eax
f0116e05:	e8 d2 b0 fe ff       	call   f0101edc <execute_command>
f0116e0a:	83 c4 10             	add    $0x10,%esp
		char command3[100] = "load fos_helloWorld 10";
f0116e0d:	8d 85 dc fe ff ff    	lea    -0x124(%ebp),%eax
f0116e13:	bb 5c bb 12 f0       	mov    $0xf012bb5c,%ebx
f0116e18:	ba 17 00 00 00       	mov    $0x17,%edx
f0116e1d:	89 c7                	mov    %eax,%edi
f0116e1f:	89 de                	mov    %ebx,%esi
f0116e21:	89 d1                	mov    %edx,%ecx
f0116e23:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0116e25:	8d 95 f3 fe ff ff    	lea    -0x10d(%ebp),%edx
f0116e2b:	b9 4d 00 00 00       	mov    $0x4d,%ecx
f0116e30:	b0 00                	mov    $0x0,%al
f0116e32:	89 d7                	mov    %edx,%edi
f0116e34:	f3 aa                	rep stos %al,%es:(%edi)
		execute_command(command3);
f0116e36:	83 ec 0c             	sub    $0xc,%esp
f0116e39:	8d 85 dc fe ff ff    	lea    -0x124(%ebp),%eax
f0116e3f:	50                   	push   %eax
f0116e40:	e8 97 b0 fe ff       	call   f0101edc <execute_command>
f0116e45:	83 c4 10             	add    $0x10,%esp

		struct Env * addEnv;
		struct Env * factEnv;
		struct Env * helloEnv;
		envid2env(16, &addEnv, 0);
f0116e48:	83 ec 04             	sub    $0x4,%esp
f0116e4b:	6a 00                	push   $0x0
f0116e4d:	8d 45 ac             	lea    -0x54(%ebp),%eax
f0116e50:	50                   	push   %eax
f0116e51:	6a 10                	push   $0x10
f0116e53:	e8 86 36 ff ff       	call   f010a4de <envid2env>
f0116e58:	83 c4 10             	add    $0x10,%esp
		envid2env(17, &factEnv, 0);
f0116e5b:	83 ec 04             	sub    $0x4,%esp
f0116e5e:	6a 00                	push   $0x0
f0116e60:	8d 45 a8             	lea    -0x58(%ebp),%eax
f0116e63:	50                   	push   %eax
f0116e64:	6a 11                	push   $0x11
f0116e66:	e8 73 36 ff ff       	call   f010a4de <envid2env>
f0116e6b:	83 c4 10             	add    $0x10,%esp
		envid2env(18, &helloEnv, 0);
f0116e6e:	83 ec 04             	sub    $0x4,%esp
f0116e71:	6a 00                	push   $0x0
f0116e73:	8d 45 a4             	lea    -0x5c(%ebp),%eax
f0116e76:	50                   	push   %eax
f0116e77:	6a 12                	push   $0x12
f0116e79:	e8 60 36 ff ff       	call   f010a4de <envid2env>
f0116e7e:	83 c4 10             	add    $0x10,%esp

		if(addEnv == NULL || factEnv == NULL || helloEnv == NULL)
f0116e81:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0116e84:	85 c0                	test   %eax,%eax
f0116e86:	74 0e                	je     f0116e96 <test_priority_normal_and_higher+0x122>
f0116e88:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116e8b:	85 c0                	test   %eax,%eax
f0116e8d:	74 07                	je     f0116e96 <test_priority_normal_and_higher+0x122>
f0116e8f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116e92:	85 c0                	test   %eax,%eax
f0116e94:	75 14                	jne    f0116eaa <test_priority_normal_and_higher+0x136>
			panic("Loading programs failed\n");
f0116e96:	83 ec 04             	sub    $0x4,%esp
f0116e99:	68 18 b8 12 f0       	push   $0xf012b818
f0116e9e:	6a 29                	push   $0x29
f0116ea0:	68 31 b8 12 f0       	push   $0xf012b831
f0116ea5:	e8 70 94 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 10)
f0116eaa:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0116ead:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0116eb3:	83 f8 14             	cmp    $0x14,%eax
f0116eb6:	75 1c                	jne    f0116ed4 <test_priority_normal_and_higher+0x160>
f0116eb8:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116ebb:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0116ec1:	83 f8 0f             	cmp    $0xf,%eax
f0116ec4:	75 0e                	jne    f0116ed4 <test_priority_normal_and_higher+0x160>
f0116ec6:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116ec9:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0116ecf:	83 f8 0a             	cmp    $0xa,%eax
f0116ed2:	74 32                	je     f0116f06 <test_priority_normal_and_higher+0x192>
			panic("The programs should be initially loaded with the given working set size. add: %d, fact: %d, hello: %d\n", addEnv->page_WS_max_size , factEnv->page_WS_max_size , helloEnv->page_WS_max_size );
f0116ed4:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116ed7:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
f0116edd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116ee0:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f0116ee6:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0116ee9:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0116eef:	83 ec 08             	sub    $0x8,%esp
f0116ef2:	51                   	push   %ecx
f0116ef3:	52                   	push   %edx
f0116ef4:	50                   	push   %eax
f0116ef5:	68 4c b8 12 f0       	push   $0xf012b84c
f0116efa:	6a 2c                	push   $0x2c
f0116efc:	68 31 b8 12 f0       	push   $0xf012b831
f0116f01:	e8 14 94 fe ff       	call   f010031a <_panic>

		for(int i = 0; i < 20; i++)
f0116f06:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0116f0d:	eb 47                	jmp    f0116f56 <test_priority_normal_and_higher+0x1e2>
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
f0116f0f:	8b 4d ac             	mov    -0x54(%ebp),%ecx
f0116f12:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0116f15:	89 d0                	mov    %edx,%eax
f0116f17:	01 c0                	add    %eax,%eax
f0116f19:	01 d0                	add    %edx,%eax
f0116f1b:	c1 e0 03             	shl    $0x3,%eax
f0116f1e:	01 c8                	add    %ecx,%eax
f0116f20:	05 88 00 00 00       	add    $0x88,%eax
f0116f25:	8b 10                	mov    (%eax),%edx
f0116f27:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0116f2a:	89 94 85 74 fd ff ff 	mov    %edx,-0x28c(%ebp,%eax,4)
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
f0116f31:	8b 4d ac             	mov    -0x54(%ebp),%ecx
f0116f34:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0116f37:	89 d0                	mov    %edx,%eax
f0116f39:	01 c0                	add    %eax,%eax
f0116f3b:	01 d0                	add    %edx,%eax
f0116f3d:	c1 e0 03             	shl    $0x3,%eax
f0116f40:	01 c8                	add    %ecx,%eax
f0116f42:	05 90 00 00 00       	add    $0x90,%eax
f0116f47:	8b 10                	mov    (%eax),%edx
f0116f49:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0116f4c:	89 94 85 c4 fd ff ff 	mov    %edx,-0x23c(%ebp,%eax,4)
			panic("Loading programs failed\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 10)
			panic("The programs should be initially loaded with the given working set size. add: %d, fact: %d, hello: %d\n", addEnv->page_WS_max_size , factEnv->page_WS_max_size , helloEnv->page_WS_max_size );

		for(int i = 0; i < 20; i++)
f0116f53:	ff 45 e4             	incl   -0x1c(%ebp)
f0116f56:	83 7d e4 13          	cmpl   $0x13,-0x1c(%ebp)
f0116f5a:	7e b3                	jle    f0116f0f <test_priority_normal_and_higher+0x19b>
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 15; i++)
f0116f5c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0116f63:	eb 47                	jmp    f0116fac <test_priority_normal_and_higher+0x238>
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
f0116f65:	8b 4d a8             	mov    -0x58(%ebp),%ecx
f0116f68:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0116f6b:	89 d0                	mov    %edx,%eax
f0116f6d:	01 c0                	add    %eax,%eax
f0116f6f:	01 d0                	add    %edx,%eax
f0116f71:	c1 e0 03             	shl    $0x3,%eax
f0116f74:	01 c8                	add    %ecx,%eax
f0116f76:	05 88 00 00 00       	add    $0x88,%eax
f0116f7b:	8b 10                	mov    (%eax),%edx
f0116f7d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0116f80:	89 94 85 fc fc ff ff 	mov    %edx,-0x304(%ebp,%eax,4)
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
f0116f87:	8b 4d a8             	mov    -0x58(%ebp),%ecx
f0116f8a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0116f8d:	89 d0                	mov    %edx,%eax
f0116f8f:	01 c0                	add    %eax,%eax
f0116f91:	01 d0                	add    %edx,%eax
f0116f93:	c1 e0 03             	shl    $0x3,%eax
f0116f96:	01 c8                	add    %ecx,%eax
f0116f98:	05 90 00 00 00       	add    $0x90,%eax
f0116f9d:	8b 10                	mov    (%eax),%edx
f0116f9f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0116fa2:	89 94 85 38 fd ff ff 	mov    %edx,-0x2c8(%ebp,%eax,4)
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 15; i++)
f0116fa9:	ff 45 e0             	incl   -0x20(%ebp)
f0116fac:	83 7d e0 0e          	cmpl   $0xe,-0x20(%ebp)
f0116fb0:	7e b3                	jle    f0116f65 <test_priority_normal_and_higher+0x1f1>
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 10; i++)
f0116fb2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0116fb9:	eb 47                	jmp    f0117002 <test_priority_normal_and_higher+0x28e>
		{
			hello_WS[i] = helloEnv->ptr_pageWorkingSet[i].virtual_address;
f0116fbb:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
f0116fbe:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0116fc1:	89 d0                	mov    %edx,%eax
f0116fc3:	01 c0                	add    %eax,%eax
f0116fc5:	01 d0                	add    %edx,%eax
f0116fc7:	c1 e0 03             	shl    $0x3,%eax
f0116fca:	01 c8                	add    %ecx,%eax
f0116fcc:	05 88 00 00 00       	add    $0x88,%eax
f0116fd1:	8b 10                	mov    (%eax),%edx
f0116fd3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116fd6:	89 94 85 ac fc ff ff 	mov    %edx,-0x354(%ebp,%eax,4)
			hello_TimeStamp[i] = helloEnv->ptr_pageWorkingSet[i].time_stamp;
f0116fdd:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
f0116fe0:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0116fe3:	89 d0                	mov    %edx,%eax
f0116fe5:	01 c0                	add    %eax,%eax
f0116fe7:	01 d0                	add    %edx,%eax
f0116fe9:	c1 e0 03             	shl    $0x3,%eax
f0116fec:	01 c8                	add    %ecx,%eax
f0116fee:	05 90 00 00 00       	add    $0x90,%eax
f0116ff3:	8b 10                	mov    (%eax),%edx
f0116ff5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116ff8:	89 94 85 d4 fc ff ff 	mov    %edx,-0x32c(%ebp,%eax,4)
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 10; i++)
f0116fff:	ff 45 dc             	incl   -0x24(%ebp)
f0117002:	83 7d dc 09          	cmpl   $0x9,-0x24(%ebp)
f0117006:	7e b3                	jle    f0116fbb <test_priority_normal_and_higher+0x247>
		{
			hello_WS[i] = helloEnv->ptr_pageWorkingSet[i].virtual_address;
			hello_TimeStamp[i] = helloEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		int freeFrames = sys_calculate_free_frames();
f0117008:	e8 1a 67 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011700d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		int freeDiskFrames = pf_calculate_free_frames();
f0117010:	e8 49 d5 fe ff       	call   f010455e <pf_calculate_free_frames>
f0117015:	89 45 b0             	mov    %eax,-0x50(%ebp)

		// Set Priority To Normal // Should change nothing
		set_program_priority(addEnv, 3);
f0117018:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011701b:	83 ec 08             	sub    $0x8,%esp
f011701e:	6a 03                	push   $0x3
f0117020:	50                   	push   %eax
f0117021:	e8 a7 4b ff ff       	call   f010bbcd <set_program_priority>
f0117026:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 3);
f0117029:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011702c:	83 ec 08             	sub    $0x8,%esp
f011702f:	6a 03                	push   $0x3
f0117031:	50                   	push   %eax
f0117032:	e8 96 4b ff ff       	call   f010bbcd <set_program_priority>
f0117037:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 3);
f011703a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011703d:	83 ec 08             	sub    $0x8,%esp
f0117040:	6a 03                	push   $0x3
f0117042:	50                   	push   %eax
f0117043:	e8 85 4b ff ff       	call   f010bbcd <set_program_priority>
f0117048:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f011704b:	e8 0e d5 fe ff       	call   f010455e <pf_calculate_free_frames>
f0117050:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0117053:	74 14                	je     f0117069 <test_priority_normal_and_higher+0x2f5>
f0117055:	83 ec 04             	sub    $0x4,%esp
f0117058:	68 b4 b8 12 f0       	push   $0xf012b8b4
f011705d:	6a 48                	push   $0x48
f011705f:	68 31 b8 12 f0       	push   $0xf012b831
f0117064:	e8 b1 92 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f0117069:	e8 b9 66 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011706e:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0117071:	74 14                	je     f0117087 <test_priority_normal_and_higher+0x313>
f0117073:	83 ec 04             	sub    $0x4,%esp
f0117076:	68 b4 b8 12 f0       	push   $0xf012b8b4
f011707b:	6a 49                	push   $0x49
f011707d:	68 31 b8 12 f0       	push   $0xf012b831
f0117082:	e8 93 92 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 10)
f0117087:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011708a:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117090:	83 f8 14             	cmp    $0x14,%eax
f0117093:	75 1c                	jne    f01170b1 <test_priority_normal_and_higher+0x33d>
f0117095:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117098:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011709e:	83 f8 0f             	cmp    $0xf,%eax
f01170a1:	75 0e                	jne    f01170b1 <test_priority_normal_and_higher+0x33d>
f01170a3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01170a6:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01170ac:	83 f8 0a             	cmp    $0xa,%eax
f01170af:	74 14                	je     f01170c5 <test_priority_normal_and_higher+0x351>
			panic("The programs' working set size should not change after setting priority to normal\n");
f01170b1:	83 ec 04             	sub    $0x4,%esp
f01170b4:	68 e0 b8 12 f0       	push   $0xf012b8e0
f01170b9:	6a 4c                	push   $0x4c
f01170bb:	68 31 b8 12 f0       	push   $0xf012b831
f01170c0:	e8 55 92 fe ff       	call   f010031a <_panic>

		freeFrames = sys_calculate_free_frames();
f01170c5:	e8 5d 66 ff ff       	call   f010d727 <sys_calculate_free_frames>
f01170ca:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01170cd:	e8 8c d4 fe ff       	call   f010455e <pf_calculate_free_frames>
f01170d2:	89 45 b0             	mov    %eax,-0x50(%ebp)

		// Set Priority To Above Normal // Should change only helloWorld as none of the rest is full
		set_program_priority(addEnv, 4);
f01170d5:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01170d8:	83 ec 08             	sub    $0x8,%esp
f01170db:	6a 04                	push   $0x4
f01170dd:	50                   	push   %eax
f01170de:	e8 ea 4a ff ff       	call   f010bbcd <set_program_priority>
f01170e3:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 4);
f01170e6:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01170e9:	83 ec 08             	sub    $0x8,%esp
f01170ec:	6a 04                	push   $0x4
f01170ee:	50                   	push   %eax
f01170ef:	e8 d9 4a ff ff       	call   f010bbcd <set_program_priority>
f01170f4:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 4);
f01170f7:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01170fa:	83 ec 08             	sub    $0x8,%esp
f01170fd:	6a 04                	push   $0x4
f01170ff:	50                   	push   %eax
f0117100:	e8 c8 4a ff ff       	call   f010bbcd <set_program_priority>
f0117105:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0117108:	e8 51 d4 fe ff       	call   f010455e <pf_calculate_free_frames>
f011710d:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0117110:	74 14                	je     f0117126 <test_priority_normal_and_higher+0x3b2>
f0117112:	83 ec 04             	sub    $0x4,%esp
f0117115:	68 b4 b8 12 f0       	push   $0xf012b8b4
f011711a:	6a 56                	push   $0x56
f011711c:	68 31 b8 12 f0       	push   $0xf012b831
f0117121:	e8 f4 91 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly%x\n");
f0117126:	e8 fc 65 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011712b:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011712e:	74 14                	je     f0117144 <test_priority_normal_and_higher+0x3d0>
f0117130:	83 ec 04             	sub    $0x4,%esp
f0117133:	68 34 b9 12 f0       	push   $0xf012b934
f0117138:	6a 57                	push   $0x57
f011713a:	68 31 b8 12 f0       	push   $0xf012b831
f011713f:	e8 d6 91 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
f0117144:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117147:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011714d:	83 f8 14             	cmp    $0x14,%eax
f0117150:	75 1c                	jne    f011716e <test_priority_normal_and_higher+0x3fa>
f0117152:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117155:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011715b:	83 f8 0f             	cmp    $0xf,%eax
f011715e:	75 0e                	jne    f011716e <test_priority_normal_and_higher+0x3fa>
f0117160:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117163:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117169:	83 f8 14             	cmp    $0x14,%eax
f011716c:	74 14                	je     f0117182 <test_priority_normal_and_higher+0x40e>
			panic("The programs' working set size should be doubled only if it is full\n");
f011716e:	83 ec 04             	sub    $0x4,%esp
f0117171:	68 64 b9 12 f0       	push   $0xf012b964
f0117176:	6a 5a                	push   $0x5a
f0117178:	68 31 b8 12 f0       	push   $0xf012b831
f011717d:	e8 98 91 fe ff       	call   f010031a <_panic>

		freeFrames = sys_calculate_free_frames();
f0117182:	e8 a0 65 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0117187:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011718a:	e8 cf d3 fe ff       	call   f010455e <pf_calculate_free_frames>
f011718f:	89 45 b0             	mov    %eax,-0x50(%ebp)

		// Set priority to above normal --> nothing should change (1 time only)
		set_program_priority(helloEnv, 4);
f0117192:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117195:	83 ec 08             	sub    $0x8,%esp
f0117198:	6a 04                	push   $0x4
f011719a:	50                   	push   %eax
f011719b:	e8 2d 4a ff ff       	call   f010bbcd <set_program_priority>
f01171a0:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f01171a3:	e8 b6 d3 fe ff       	call   f010455e <pf_calculate_free_frames>
f01171a8:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f01171ab:	74 14                	je     f01171c1 <test_priority_normal_and_higher+0x44d>
f01171ad:	83 ec 04             	sub    $0x4,%esp
f01171b0:	68 b4 b8 12 f0       	push   $0xf012b8b4
f01171b5:	6a 62                	push   $0x62
f01171b7:	68 31 b8 12 f0       	push   $0xf012b831
f01171bc:	e8 59 91 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f01171c1:	e8 61 65 ff ff       	call   f010d727 <sys_calculate_free_frames>
f01171c6:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f01171c9:	74 14                	je     f01171df <test_priority_normal_and_higher+0x46b>
f01171cb:	83 ec 04             	sub    $0x4,%esp
f01171ce:	68 b4 b8 12 f0       	push   $0xf012b8b4
f01171d3:	6a 63                	push   $0x63
f01171d5:	68 31 b8 12 f0       	push   $0xf012b831
f01171da:	e8 3b 91 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
f01171df:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01171e2:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01171e8:	83 f8 14             	cmp    $0x14,%eax
f01171eb:	75 1c                	jne    f0117209 <test_priority_normal_and_higher+0x495>
f01171ed:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01171f0:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01171f6:	83 f8 0f             	cmp    $0xf,%eax
f01171f9:	75 0e                	jne    f0117209 <test_priority_normal_and_higher+0x495>
f01171fb:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01171fe:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117204:	83 f8 14             	cmp    $0x14,%eax
f0117207:	74 14                	je     f011721d <test_priority_normal_and_higher+0x4a9>
			panic("The programs' working set size should be doubled only once\n");
f0117209:	83 ec 04             	sub    $0x4,%esp
f011720c:	68 ac b9 12 f0       	push   $0xf012b9ac
f0117211:	6a 66                	push   $0x66
f0117213:	68 31 b8 12 f0       	push   $0xf012b831
f0117218:	e8 fd 90 fe ff       	call   f010031a <_panic>


		// Manipulate WS to seem as full
		for(int i = 10; i < 20; i++)
f011721d:	c7 45 d8 0a 00 00 00 	movl   $0xa,-0x28(%ebp)
f0117224:	eb 1c                	jmp    f0117242 <test_priority_normal_and_higher+0x4ce>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 0;
f0117226:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
f0117229:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011722c:	89 d0                	mov    %edx,%eax
f011722e:	01 c0                	add    %eax,%eax
f0117230:	01 d0                	add    %edx,%eax
f0117232:	c1 e0 03             	shl    $0x3,%eax
f0117235:	01 c8                	add    %ecx,%eax
f0117237:	05 8c 00 00 00       	add    $0x8c,%eax
f011723c:	c6 00 00             	movb   $0x0,(%eax)
		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
			panic("The programs' working set size should be doubled only once\n");


		// Manipulate WS to seem as full
		for(int i = 10; i < 20; i++)
f011723f:	ff 45 d8             	incl   -0x28(%ebp)
f0117242:	83 7d d8 13          	cmpl   $0x13,-0x28(%ebp)
f0117246:	7e de                	jle    f0117226 <test_priority_normal_and_higher+0x4b2>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 0;
		}

		freeFrames = sys_calculate_free_frames();
f0117248:	e8 da 64 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011724d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0117250:	e8 09 d3 fe ff       	call   f010455e <pf_calculate_free_frames>
f0117255:	89 45 b0             	mov    %eax,-0x50(%ebp)

		set_program_priority(helloEnv, 4);
f0117258:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011725b:	83 ec 08             	sub    $0x8,%esp
f011725e:	6a 04                	push   $0x4
f0117260:	50                   	push   %eax
f0117261:	e8 67 49 ff ff       	call   f010bbcd <set_program_priority>
f0117266:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0117269:	e8 f0 d2 fe ff       	call   f010455e <pf_calculate_free_frames>
f011726e:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0117271:	74 14                	je     f0117287 <test_priority_normal_and_higher+0x513>
f0117273:	83 ec 04             	sub    $0x4,%esp
f0117276:	68 b4 b8 12 f0       	push   $0xf012b8b4
f011727b:	6a 73                	push   $0x73
f011727d:	68 31 b8 12 f0       	push   $0xf012b831
f0117282:	e8 93 90 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f0117287:	e8 9b 64 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011728c:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011728f:	74 14                	je     f01172a5 <test_priority_normal_and_higher+0x531>
f0117291:	83 ec 04             	sub    $0x4,%esp
f0117294:	68 b4 b8 12 f0       	push   $0xf012b8b4
f0117299:	6a 74                	push   $0x74
f011729b:	68 31 b8 12 f0       	push   $0xf012b831
f01172a0:	e8 75 90 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
f01172a5:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01172a8:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01172ae:	83 f8 14             	cmp    $0x14,%eax
f01172b1:	75 1c                	jne    f01172cf <test_priority_normal_and_higher+0x55b>
f01172b3:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01172b6:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01172bc:	83 f8 0f             	cmp    $0xf,%eax
f01172bf:	75 0e                	jne    f01172cf <test_priority_normal_and_higher+0x55b>
f01172c1:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01172c4:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01172ca:	83 f8 14             	cmp    $0x14,%eax
f01172cd:	74 14                	je     f01172e3 <test_priority_normal_and_higher+0x56f>
			panic("The programs' working set size should be doubled only once\n");
f01172cf:	83 ec 04             	sub    $0x4,%esp
f01172d2:	68 ac b9 12 f0       	push   $0xf012b9ac
f01172d7:	6a 77                	push   $0x77
f01172d9:	68 31 b8 12 f0       	push   $0xf012b831
f01172de:	e8 37 90 fe ff       	call   f010031a <_panic>

		for(int i = 10; i < 15; i++)
f01172e3:	c7 45 d4 0a 00 00 00 	movl   $0xa,-0x2c(%ebp)
f01172ea:	eb 1c                	jmp    f0117308 <test_priority_normal_and_higher+0x594>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 0;
f01172ec:	8b 4d a8             	mov    -0x58(%ebp),%ecx
f01172ef:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01172f2:	89 d0                	mov    %edx,%eax
f01172f4:	01 c0                	add    %eax,%eax
f01172f6:	01 d0                	add    %edx,%eax
f01172f8:	c1 e0 03             	shl    $0x3,%eax
f01172fb:	01 c8                	add    %ecx,%eax
f01172fd:	05 8c 00 00 00       	add    $0x8c,%eax
f0117302:	c6 00 00             	movb   $0x0,(%eax)
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
			panic("The programs' working set size should be doubled only once\n");

		for(int i = 10; i < 15; i++)
f0117305:	ff 45 d4             	incl   -0x2c(%ebp)
f0117308:	83 7d d4 0e          	cmpl   $0xe,-0x2c(%ebp)
f011730c:	7e de                	jle    f01172ec <test_priority_normal_and_higher+0x578>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 0;
		}

		freeFrames = sys_calculate_free_frames();
f011730e:	e8 14 64 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0117313:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0117316:	e8 43 d2 fe ff       	call   f010455e <pf_calculate_free_frames>
f011731b:	89 45 b0             	mov    %eax,-0x50(%ebp)
		set_program_priority(factEnv, 5);
f011731e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117321:	83 ec 08             	sub    $0x8,%esp
f0117324:	6a 05                	push   $0x5
f0117326:	50                   	push   %eax
f0117327:	e8 a1 48 ff ff       	call   f010bbcd <set_program_priority>
f011732c:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 5);
f011732f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117332:	83 ec 08             	sub    $0x8,%esp
f0117335:	6a 05                	push   $0x5
f0117337:	50                   	push   %eax
f0117338:	e8 90 48 ff ff       	call   f010bbcd <set_program_priority>
f011733d:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0117340:	e8 19 d2 fe ff       	call   f010455e <pf_calculate_free_frames>
f0117345:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0117348:	74 17                	je     f0117361 <test_priority_normal_and_higher+0x5ed>
f011734a:	83 ec 04             	sub    $0x4,%esp
f011734d:	68 b4 b8 12 f0       	push   $0xf012b8b4
f0117352:	68 82 00 00 00       	push   $0x82
f0117357:	68 31 b8 12 f0       	push   $0xf012b831
f011735c:	e8 b9 8f fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f0117361:	e8 c1 63 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0117366:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0117369:	74 17                	je     f0117382 <test_priority_normal_and_higher+0x60e>
f011736b:	83 ec 04             	sub    $0x4,%esp
f011736e:	68 b4 b8 12 f0       	push   $0xf012b8b4
f0117373:	68 83 00 00 00       	push   $0x83
f0117378:	68 31 b8 12 f0       	push   $0xf012b831
f011737d:	e8 98 8f fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
f0117382:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117385:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011738b:	83 f8 14             	cmp    $0x14,%eax
f011738e:	75 1c                	jne    f01173ac <test_priority_normal_and_higher+0x638>
f0117390:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117393:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117399:	83 f8 1e             	cmp    $0x1e,%eax
f011739c:	75 0e                	jne    f01173ac <test_priority_normal_and_higher+0x638>
f011739e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01173a1:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01173a7:	83 f8 28             	cmp    $0x28,%eax
f01173aa:	74 17                	je     f01173c3 <test_priority_normal_and_higher+0x64f>
			panic("The programs' working set size should be doubled if full\n");
f01173ac:	83 ec 04             	sub    $0x4,%esp
f01173af:	68 e8 b9 12 f0       	push   $0xf012b9e8
f01173b4:	68 86 00 00 00       	push   $0x86
f01173b9:	68 31 b8 12 f0       	push   $0xf012b831
f01173be:	e8 57 8f fe ff       	call   f010031a <_panic>

		for(int i = 20; i < 40; i++)
f01173c3:	c7 45 d0 14 00 00 00 	movl   $0x14,-0x30(%ebp)
f01173ca:	eb 1c                	jmp    f01173e8 <test_priority_normal_and_higher+0x674>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 0;
f01173cc:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
f01173cf:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01173d2:	89 d0                	mov    %edx,%eax
f01173d4:	01 c0                	add    %eax,%eax
f01173d6:	01 d0                	add    %edx,%eax
f01173d8:	c1 e0 03             	shl    $0x3,%eax
f01173db:	01 c8                	add    %ecx,%eax
f01173dd:	05 8c 00 00 00       	add    $0x8c,%eax
f01173e2:	c6 00 00             	movb   $0x0,(%eax)
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
			panic("The programs' working set size should be doubled if full\n");

		for(int i = 20; i < 40; i++)
f01173e5:	ff 45 d0             	incl   -0x30(%ebp)
f01173e8:	83 7d d0 27          	cmpl   $0x27,-0x30(%ebp)
f01173ec:	7e de                	jle    f01173cc <test_priority_normal_and_higher+0x658>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 0;
		}

		freeFrames = sys_calculate_free_frames();
f01173ee:	e8 34 63 ff ff       	call   f010d727 <sys_calculate_free_frames>
f01173f3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01173f6:	e8 63 d1 fe ff       	call   f010455e <pf_calculate_free_frames>
f01173fb:	89 45 b0             	mov    %eax,-0x50(%ebp)
		set_program_priority(factEnv, 5);
f01173fe:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117401:	83 ec 08             	sub    $0x8,%esp
f0117404:	6a 05                	push   $0x5
f0117406:	50                   	push   %eax
f0117407:	e8 c1 47 ff ff       	call   f010bbcd <set_program_priority>
f011740c:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 4);
f011740f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117412:	83 ec 08             	sub    $0x8,%esp
f0117415:	6a 04                	push   $0x4
f0117417:	50                   	push   %eax
f0117418:	e8 b0 47 ff ff       	call   f010bbcd <set_program_priority>
f011741d:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0117420:	e8 39 d1 fe ff       	call   f010455e <pf_calculate_free_frames>
f0117425:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0117428:	74 17                	je     f0117441 <test_priority_normal_and_higher+0x6cd>
f011742a:	83 ec 04             	sub    $0x4,%esp
f011742d:	68 b4 b8 12 f0       	push   $0xf012b8b4
f0117432:	68 91 00 00 00       	push   $0x91
f0117437:	68 31 b8 12 f0       	push   $0xf012b831
f011743c:	e8 d9 8e fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f0117441:	e8 e1 62 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0117446:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0117449:	74 17                	je     f0117462 <test_priority_normal_and_higher+0x6ee>
f011744b:	83 ec 04             	sub    $0x4,%esp
f011744e:	68 b4 b8 12 f0       	push   $0xf012b8b4
f0117453:	68 92 00 00 00       	push   $0x92
f0117458:	68 31 b8 12 f0       	push   $0xf012b831
f011745d:	e8 b8 8e fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
f0117462:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117465:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011746b:	83 f8 14             	cmp    $0x14,%eax
f011746e:	75 1c                	jne    f011748c <test_priority_normal_and_higher+0x718>
f0117470:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117473:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117479:	83 f8 1e             	cmp    $0x1e,%eax
f011747c:	75 0e                	jne    f011748c <test_priority_normal_and_higher+0x718>
f011747e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117481:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117487:	83 f8 28             	cmp    $0x28,%eax
f011748a:	74 17                	je     f01174a3 <test_priority_normal_and_higher+0x72f>
			panic("The programs' working set size should be doubled if full\n");
f011748c:	83 ec 04             	sub    $0x4,%esp
f011748f:	68 e8 b9 12 f0       	push   $0xf012b9e8
f0117494:	68 95 00 00 00       	push   $0x95
f0117499:	68 31 b8 12 f0       	push   $0xf012b831
f011749e:	e8 77 8e fe ff       	call   f010031a <_panic>

		for(int i = 15; i < 30; i++)
f01174a3:	c7 45 cc 0f 00 00 00 	movl   $0xf,-0x34(%ebp)
f01174aa:	eb 1c                	jmp    f01174c8 <test_priority_normal_and_higher+0x754>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 0;
f01174ac:	8b 4d a8             	mov    -0x58(%ebp),%ecx
f01174af:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01174b2:	89 d0                	mov    %edx,%eax
f01174b4:	01 c0                	add    %eax,%eax
f01174b6:	01 d0                	add    %edx,%eax
f01174b8:	c1 e0 03             	shl    $0x3,%eax
f01174bb:	01 c8                	add    %ecx,%eax
f01174bd:	05 8c 00 00 00       	add    $0x8c,%eax
f01174c2:	c6 00 00             	movb   $0x0,(%eax)
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
			panic("The programs' working set size should be doubled if full\n");

		for(int i = 15; i < 30; i++)
f01174c5:	ff 45 cc             	incl   -0x34(%ebp)
f01174c8:	83 7d cc 1d          	cmpl   $0x1d,-0x34(%ebp)
f01174cc:	7e de                	jle    f01174ac <test_priority_normal_and_higher+0x738>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 0;
		}

		freeFrames = sys_calculate_free_frames();
f01174ce:	e8 54 62 ff ff       	call   f010d727 <sys_calculate_free_frames>
f01174d3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01174d6:	e8 83 d0 fe ff       	call   f010455e <pf_calculate_free_frames>
f01174db:	89 45 b0             	mov    %eax,-0x50(%ebp)
		set_program_priority(factEnv, 5);
f01174de:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01174e1:	83 ec 08             	sub    $0x8,%esp
f01174e4:	6a 05                	push   $0x5
f01174e6:	50                   	push   %eax
f01174e7:	e8 e1 46 ff ff       	call   f010bbcd <set_program_priority>
f01174ec:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 4);
f01174ef:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01174f2:	83 ec 08             	sub    $0x8,%esp
f01174f5:	6a 04                	push   $0x4
f01174f7:	50                   	push   %eax
f01174f8:	e8 d0 46 ff ff       	call   f010bbcd <set_program_priority>
f01174fd:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0117500:	e8 59 d0 fe ff       	call   f010455e <pf_calculate_free_frames>
f0117505:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0117508:	74 17                	je     f0117521 <test_priority_normal_and_higher+0x7ad>
f011750a:	83 ec 04             	sub    $0x4,%esp
f011750d:	68 b4 b8 12 f0       	push   $0xf012b8b4
f0117512:	68 a0 00 00 00       	push   $0xa0
f0117517:	68 31 b8 12 f0       	push   $0xf012b831
f011751c:	e8 f9 8d fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f0117521:	e8 01 62 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0117526:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0117529:	74 17                	je     f0117542 <test_priority_normal_and_higher+0x7ce>
f011752b:	83 ec 04             	sub    $0x4,%esp
f011752e:	68 b4 b8 12 f0       	push   $0xf012b8b4
f0117533:	68 a1 00 00 00       	push   $0xa1
f0117538:	68 31 b8 12 f0       	push   $0xf012b831
f011753d:	e8 d8 8d fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 60 || helloEnv->page_WS_max_size != 40)
f0117542:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117545:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011754b:	83 f8 14             	cmp    $0x14,%eax
f011754e:	75 1c                	jne    f011756c <test_priority_normal_and_higher+0x7f8>
f0117550:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117553:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117559:	83 f8 3c             	cmp    $0x3c,%eax
f011755c:	75 0e                	jne    f011756c <test_priority_normal_and_higher+0x7f8>
f011755e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117561:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117567:	83 f8 28             	cmp    $0x28,%eax
f011756a:	74 17                	je     f0117583 <test_priority_normal_and_higher+0x80f>
			panic("The programs' working set size should be doubled if full\n");
f011756c:	83 ec 04             	sub    $0x4,%esp
f011756f:	68 e8 b9 12 f0       	push   $0xf012b9e8
f0117574:	68 a4 00 00 00       	push   $0xa4
f0117579:	68 31 b8 12 f0       	push   $0xf012b831
f011757e:	e8 97 8d fe ff       	call   f010031a <_panic>

		for(int i = 15; i < 60; i++)
f0117583:	c7 45 c8 0f 00 00 00 	movl   $0xf,-0x38(%ebp)
f011758a:	eb 1c                	jmp    f01175a8 <test_priority_normal_and_higher+0x834>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 1;
f011758c:	8b 4d a8             	mov    -0x58(%ebp),%ecx
f011758f:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0117592:	89 d0                	mov    %edx,%eax
f0117594:	01 c0                	add    %eax,%eax
f0117596:	01 d0                	add    %edx,%eax
f0117598:	c1 e0 03             	shl    $0x3,%eax
f011759b:	01 c8                	add    %ecx,%eax
f011759d:	05 8c 00 00 00       	add    $0x8c,%eax
f01175a2:	c6 00 01             	movb   $0x1,(%eax)
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 60 || helloEnv->page_WS_max_size != 40)
			panic("The programs' working set size should be doubled if full\n");

		for(int i = 15; i < 60; i++)
f01175a5:	ff 45 c8             	incl   -0x38(%ebp)
f01175a8:	83 7d c8 3b          	cmpl   $0x3b,-0x38(%ebp)
f01175ac:	7e de                	jle    f011758c <test_priority_normal_and_higher+0x818>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 1;
		}
		for(int i = 10; i < 40; i++)
f01175ae:	c7 45 c4 0a 00 00 00 	movl   $0xa,-0x3c(%ebp)
f01175b5:	eb 1c                	jmp    f01175d3 <test_priority_normal_and_higher+0x85f>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 1;
f01175b7:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
f01175ba:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01175bd:	89 d0                	mov    %edx,%eax
f01175bf:	01 c0                	add    %eax,%eax
f01175c1:	01 d0                	add    %edx,%eax
f01175c3:	c1 e0 03             	shl    $0x3,%eax
f01175c6:	01 c8                	add    %ecx,%eax
f01175c8:	05 8c 00 00 00       	add    $0x8c,%eax
f01175cd:	c6 00 01             	movb   $0x1,(%eax)

		for(int i = 15; i < 60; i++)
		{
			factEnv->ptr_pageWorkingSet[i].empty = 1;
		}
		for(int i = 10; i < 40; i++)
f01175d0:	ff 45 c4             	incl   -0x3c(%ebp)
f01175d3:	83 7d c4 27          	cmpl   $0x27,-0x3c(%ebp)
f01175d7:	7e de                	jle    f01175b7 <test_priority_normal_and_higher+0x843>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 1;
		}

		for(int i = 0; i < 20; i++)
f01175d9:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f01175e0:	eb 7d                	jmp    f011765f <test_priority_normal_and_higher+0x8eb>
		{
			if(add_WS[i] != addEnv->ptr_pageWorkingSet[i].virtual_address)
f01175e2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01175e5:	8b 8c 85 74 fd ff ff 	mov    -0x28c(%ebp,%eax,4),%ecx
f01175ec:	8b 5d ac             	mov    -0x54(%ebp),%ebx
f01175ef:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01175f2:	89 d0                	mov    %edx,%eax
f01175f4:	01 c0                	add    %eax,%eax
f01175f6:	01 d0                	add    %edx,%eax
f01175f8:	c1 e0 03             	shl    $0x3,%eax
f01175fb:	01 d8                	add    %ebx,%eax
f01175fd:	05 88 00 00 00       	add    $0x88,%eax
f0117602:	8b 00                	mov    (%eax),%eax
f0117604:	39 c1                	cmp    %eax,%ecx
f0117606:	74 17                	je     f011761f <test_priority_normal_and_higher+0x8ab>
				panic("Working set should be moved properly to the new one");
f0117608:	83 ec 04             	sub    $0x4,%esp
f011760b:	68 24 ba 12 f0       	push   $0xf012ba24
f0117610:	68 b2 00 00 00       	push   $0xb2
f0117615:	68 31 b8 12 f0       	push   $0xf012b831
f011761a:	e8 fb 8c fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
f011761f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0117622:	8b 8c 85 c4 fd ff ff 	mov    -0x23c(%ebp,%eax,4),%ecx
f0117629:	8b 5d ac             	mov    -0x54(%ebp),%ebx
f011762c:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011762f:	89 d0                	mov    %edx,%eax
f0117631:	01 c0                	add    %eax,%eax
f0117633:	01 d0                	add    %edx,%eax
f0117635:	c1 e0 03             	shl    $0x3,%eax
f0117638:	01 d8                	add    %ebx,%eax
f011763a:	05 90 00 00 00       	add    $0x90,%eax
f011763f:	8b 00                	mov    (%eax),%eax
f0117641:	39 c1                	cmp    %eax,%ecx
f0117643:	74 17                	je     f011765c <test_priority_normal_and_higher+0x8e8>
				panic("Working set should be moved properly to the new one");
f0117645:	83 ec 04             	sub    $0x4,%esp
f0117648:	68 24 ba 12 f0       	push   $0xf012ba24
f011764d:	68 b5 00 00 00       	push   $0xb5
f0117652:	68 31 b8 12 f0       	push   $0xf012b831
f0117657:	e8 be 8c fe ff       	call   f010031a <_panic>
		for(int i = 10; i < 40; i++)
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 1;
		}

		for(int i = 0; i < 20; i++)
f011765c:	ff 45 c0             	incl   -0x40(%ebp)
f011765f:	83 7d c0 13          	cmpl   $0x13,-0x40(%ebp)
f0117663:	0f 8e 79 ff ff ff    	jle    f01175e2 <test_priority_normal_and_higher+0x86e>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 15; i++)
f0117669:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0117670:	eb 7d                	jmp    f01176ef <test_priority_normal_and_higher+0x97b>
		{
			if(fact_WS[i] != factEnv->ptr_pageWorkingSet[i].virtual_address)
f0117672:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117675:	8b 8c 85 fc fc ff ff 	mov    -0x304(%ebp,%eax,4),%ecx
f011767c:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011767f:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0117682:	89 d0                	mov    %edx,%eax
f0117684:	01 c0                	add    %eax,%eax
f0117686:	01 d0                	add    %edx,%eax
f0117688:	c1 e0 03             	shl    $0x3,%eax
f011768b:	01 d8                	add    %ebx,%eax
f011768d:	05 88 00 00 00       	add    $0x88,%eax
f0117692:	8b 00                	mov    (%eax),%eax
f0117694:	39 c1                	cmp    %eax,%ecx
f0117696:	74 17                	je     f01176af <test_priority_normal_and_higher+0x93b>
				panic("Working set should be moved properly to the new one");
f0117698:	83 ec 04             	sub    $0x4,%esp
f011769b:	68 24 ba 12 f0       	push   $0xf012ba24
f01176a0:	68 bb 00 00 00       	push   $0xbb
f01176a5:	68 31 b8 12 f0       	push   $0xf012b831
f01176aa:	e8 6b 8c fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
f01176af:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01176b2:	8b 8c 85 38 fd ff ff 	mov    -0x2c8(%ebp,%eax,4),%ecx
f01176b9:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f01176bc:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01176bf:	89 d0                	mov    %edx,%eax
f01176c1:	01 c0                	add    %eax,%eax
f01176c3:	01 d0                	add    %edx,%eax
f01176c5:	c1 e0 03             	shl    $0x3,%eax
f01176c8:	01 d8                	add    %ebx,%eax
f01176ca:	05 90 00 00 00       	add    $0x90,%eax
f01176cf:	8b 00                	mov    (%eax),%eax
f01176d1:	39 c1                	cmp    %eax,%ecx
f01176d3:	74 17                	je     f01176ec <test_priority_normal_and_higher+0x978>
				panic("Working set should be moved properly to the new one");
f01176d5:	83 ec 04             	sub    $0x4,%esp
f01176d8:	68 24 ba 12 f0       	push   $0xf012ba24
f01176dd:	68 be 00 00 00       	push   $0xbe
f01176e2:	68 31 b8 12 f0       	push   $0xf012b831
f01176e7:	e8 2e 8c fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 15; i++)
f01176ec:	ff 45 bc             	incl   -0x44(%ebp)
f01176ef:	83 7d bc 0e          	cmpl   $0xe,-0x44(%ebp)
f01176f3:	0f 8e 79 ff ff ff    	jle    f0117672 <test_priority_normal_and_higher+0x8fe>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 10; i++)
f01176f9:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f0117700:	eb 7d                	jmp    f011777f <test_priority_normal_and_higher+0xa0b>
		{
			if(hello_WS[i] != helloEnv->ptr_pageWorkingSet[i].virtual_address)
f0117702:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117705:	8b 8c 85 ac fc ff ff 	mov    -0x354(%ebp,%eax,4),%ecx
f011770c:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f011770f:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0117712:	89 d0                	mov    %edx,%eax
f0117714:	01 c0                	add    %eax,%eax
f0117716:	01 d0                	add    %edx,%eax
f0117718:	c1 e0 03             	shl    $0x3,%eax
f011771b:	01 d8                	add    %ebx,%eax
f011771d:	05 88 00 00 00       	add    $0x88,%eax
f0117722:	8b 00                	mov    (%eax),%eax
f0117724:	39 c1                	cmp    %eax,%ecx
f0117726:	74 17                	je     f011773f <test_priority_normal_and_higher+0x9cb>
				panic("Working set should be moved properly to the new one");
f0117728:	83 ec 04             	sub    $0x4,%esp
f011772b:	68 24 ba 12 f0       	push   $0xf012ba24
f0117730:	68 c4 00 00 00       	push   $0xc4
f0117735:	68 31 b8 12 f0       	push   $0xf012b831
f011773a:	e8 db 8b fe ff       	call   f010031a <_panic>

			if(hello_TimeStamp[i] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
f011773f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117742:	8b 8c 85 d4 fc ff ff 	mov    -0x32c(%ebp,%eax,4),%ecx
f0117749:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f011774c:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011774f:	89 d0                	mov    %edx,%eax
f0117751:	01 c0                	add    %eax,%eax
f0117753:	01 d0                	add    %edx,%eax
f0117755:	c1 e0 03             	shl    $0x3,%eax
f0117758:	01 d8                	add    %ebx,%eax
f011775a:	05 90 00 00 00       	add    $0x90,%eax
f011775f:	8b 00                	mov    (%eax),%eax
f0117761:	39 c1                	cmp    %eax,%ecx
f0117763:	74 17                	je     f011777c <test_priority_normal_and_higher+0xa08>
				panic("Working set should be moved properly to the new one");
f0117765:	83 ec 04             	sub    $0x4,%esp
f0117768:	68 24 ba 12 f0       	push   $0xf012ba24
f011776d:	68 c7 00 00 00       	push   $0xc7
f0117772:	68 31 b8 12 f0       	push   $0xf012b831
f0117777:	e8 9e 8b fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 10; i++)
f011777c:	ff 45 b8             	incl   -0x48(%ebp)
f011777f:	83 7d b8 09          	cmpl   $0x9,-0x48(%ebp)
f0117783:	0f 8e 79 ff ff ff    	jle    f0117702 <test_priority_normal_and_higher+0x98e>

			if(hello_TimeStamp[i] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		char command4[100] = "runall";
f0117789:	c7 85 40 ff ff ff 72 	movl   $0x616e7572,-0xc0(%ebp)
f0117790:	75 6e 61 
f0117793:	c7 85 44 ff ff ff 6c 	movl   $0x6c6c,-0xbc(%ebp)
f011779a:	6c 00 00 
f011779d:	8d 95 48 ff ff ff    	lea    -0xb8(%ebp),%edx
f01177a3:	b9 17 00 00 00       	mov    $0x17,%ecx
f01177a8:	b8 00 00 00 00       	mov    $0x0,%eax
f01177ad:	89 d7                	mov    %edx,%edi
f01177af:	f3 ab                	rep stos %eax,%es:(%edi)
		execute_command(command4);
f01177b1:	83 ec 0c             	sub    $0xc,%esp
f01177b4:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
f01177ba:	50                   	push   %eax
f01177bb:	e8 1c a7 fe ff       	call   f0101edc <execute_command>
f01177c0:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nCongratulations!! test priority 1 completed successfully.\n");
	}
#endif
}
f01177c3:	eb 10                	jmp    f01177d5 <test_priority_normal_and_higher+0xa61>
		char command4[100] = "runall";
		execute_command(command4);
	}
	else
	{
		cprintf("\nCongratulations!! test priority 1 completed successfully.\n");
f01177c5:	83 ec 0c             	sub    $0xc,%esp
f01177c8:	68 58 ba 12 f0       	push   $0xf012ba58
f01177cd:	e8 9a 97 fe ff       	call   f0100f6c <cprintf>
f01177d2:	83 c4 10             	add    $0x10,%esp
	}
#endif
}
f01177d5:	90                   	nop
f01177d6:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01177d9:	5b                   	pop    %ebx
f01177da:	5e                   	pop    %esi
f01177db:	5f                   	pop    %edi
f01177dc:	5d                   	pop    %ebp
f01177dd:	c3                   	ret    

f01177de <test_priority_normal_and_lower>:

void test_priority_normal_and_lower()
{
f01177de:	55                   	push   %ebp
f01177df:	89 e5                	mov    %esp,%ebp
f01177e1:	57                   	push   %edi
f01177e2:	56                   	push   %esi
f01177e3:	53                   	push   %ebx
f01177e4:	81 ec ac 04 00 00    	sub    $0x4ac,%esp
#if USE_KHEAP
	panic("not handled yet");
#else
	if(firstTime)
f01177ea:	a0 94 9d 17 f0       	mov    0xf0179d94,%al
f01177ef:	84 c0                	test   %al,%al
f01177f1:	0f 84 1b 0a 00 00    	je     f0118212 <test_priority_normal_and_lower+0xa34>
		uint32 fact_WS[30];
		uint32 fact_TimeStamp[30];
		uint32 hello_WS[40];
		uint32 hello_TimeStamp[40];

		firstTime = 0;
f01177f7:	c6 05 94 9d 17 f0 00 	movb   $0x0,0xf0179d94
		char command[100] = "load fos_add 20";
f01177fe:	8d 85 f0 fb ff ff    	lea    -0x410(%ebp),%eax
f0117804:	bb 94 ba 12 f0       	mov    $0xf012ba94,%ebx
f0117809:	ba 04 00 00 00       	mov    $0x4,%edx
f011780e:	89 c7                	mov    %eax,%edi
f0117810:	89 de                	mov    %ebx,%esi
f0117812:	89 d1                	mov    %edx,%ecx
f0117814:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0117816:	8d 95 00 fc ff ff    	lea    -0x400(%ebp),%edx
f011781c:	b9 15 00 00 00       	mov    $0x15,%ecx
f0117821:	b8 00 00 00 00       	mov    $0x0,%eax
f0117826:	89 d7                	mov    %edx,%edi
f0117828:	f3 ab                	rep stos %eax,%es:(%edi)
		execute_command(command);
f011782a:	83 ec 0c             	sub    $0xc,%esp
f011782d:	8d 85 f0 fb ff ff    	lea    -0x410(%ebp),%eax
f0117833:	50                   	push   %eax
f0117834:	e8 a3 a6 fe ff       	call   f0101edc <execute_command>
f0117839:	83 c4 10             	add    $0x10,%esp
		char command2[100] = "load fact 30";
f011783c:	8d 85 54 fc ff ff    	lea    -0x3ac(%ebp),%eax
f0117842:	bb 9c bd 12 f0       	mov    $0xf012bd9c,%ebx
f0117847:	ba 0d 00 00 00       	mov    $0xd,%edx
f011784c:	89 c7                	mov    %eax,%edi
f011784e:	89 de                	mov    %ebx,%esi
f0117850:	89 d1                	mov    %edx,%ecx
f0117852:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0117854:	8d 95 61 fc ff ff    	lea    -0x39f(%ebp),%edx
f011785a:	b9 57 00 00 00       	mov    $0x57,%ecx
f011785f:	b0 00                	mov    $0x0,%al
f0117861:	89 d7                	mov    %edx,%edi
f0117863:	f3 aa                	rep stos %al,%es:(%edi)
		execute_command(command2);
f0117865:	83 ec 0c             	sub    $0xc,%esp
f0117868:	8d 85 54 fc ff ff    	lea    -0x3ac(%ebp),%eax
f011786e:	50                   	push   %eax
f011786f:	e8 68 a6 fe ff       	call   f0101edc <execute_command>
f0117874:	83 c4 10             	add    $0x10,%esp
		char command3[100] = "load fos_helloWorld 40";
f0117877:	8d 85 b8 fc ff ff    	lea    -0x348(%ebp),%eax
f011787d:	bb 00 be 12 f0       	mov    $0xf012be00,%ebx
f0117882:	ba 17 00 00 00       	mov    $0x17,%edx
f0117887:	89 c7                	mov    %eax,%edi
f0117889:	89 de                	mov    %ebx,%esi
f011788b:	89 d1                	mov    %edx,%ecx
f011788d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011788f:	8d 95 cf fc ff ff    	lea    -0x331(%ebp),%edx
f0117895:	b9 4d 00 00 00       	mov    $0x4d,%ecx
f011789a:	b0 00                	mov    $0x0,%al
f011789c:	89 d7                	mov    %edx,%edi
f011789e:	f3 aa                	rep stos %al,%es:(%edi)
		execute_command(command3);
f01178a0:	83 ec 0c             	sub    $0xc,%esp
f01178a3:	8d 85 b8 fc ff ff    	lea    -0x348(%ebp),%eax
f01178a9:	50                   	push   %eax
f01178aa:	e8 2d a6 fe ff       	call   f0101edc <execute_command>
f01178af:	83 c4 10             	add    $0x10,%esp

		struct Env * addEnv;
		struct Env * factEnv;
		struct Env * helloEnv;
		envid2env(4096, &addEnv, 0);
f01178b2:	83 ec 04             	sub    $0x4,%esp
f01178b5:	6a 00                	push   $0x0
f01178b7:	8d 45 b8             	lea    -0x48(%ebp),%eax
f01178ba:	50                   	push   %eax
f01178bb:	68 00 10 00 00       	push   $0x1000
f01178c0:	e8 19 2c ff ff       	call   f010a4de <envid2env>
f01178c5:	83 c4 10             	add    $0x10,%esp
		envid2env(4097, &factEnv, 0);
f01178c8:	83 ec 04             	sub    $0x4,%esp
f01178cb:	6a 00                	push   $0x0
f01178cd:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f01178d0:	50                   	push   %eax
f01178d1:	68 01 10 00 00       	push   $0x1001
f01178d6:	e8 03 2c ff ff       	call   f010a4de <envid2env>
f01178db:	83 c4 10             	add    $0x10,%esp
		envid2env(4098, &helloEnv, 0);
f01178de:	83 ec 04             	sub    $0x4,%esp
f01178e1:	6a 00                	push   $0x0
f01178e3:	8d 45 b0             	lea    -0x50(%ebp),%eax
f01178e6:	50                   	push   %eax
f01178e7:	68 02 10 00 00       	push   $0x1002
f01178ec:	e8 ed 2b ff ff       	call   f010a4de <envid2env>
f01178f1:	83 c4 10             	add    $0x10,%esp

		if(addEnv == NULL || factEnv == NULL || helloEnv == NULL)
f01178f4:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01178f7:	85 c0                	test   %eax,%eax
f01178f9:	74 0e                	je     f0117909 <test_priority_normal_and_lower+0x12b>
f01178fb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01178fe:	85 c0                	test   %eax,%eax
f0117900:	74 07                	je     f0117909 <test_priority_normal_and_lower+0x12b>
f0117902:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117905:	85 c0                	test   %eax,%eax
f0117907:	75 17                	jne    f0117920 <test_priority_normal_and_lower+0x142>
			panic("Loading programs failed\n");
f0117909:	83 ec 04             	sub    $0x4,%esp
f011790c:	68 18 b8 12 f0       	push   $0xf012b818
f0117911:	68 f2 00 00 00       	push   $0xf2
f0117916:	68 31 b8 12 f0       	push   $0xf012b831
f011791b:	e8 fa 89 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
f0117920:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117923:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117929:	83 f8 14             	cmp    $0x14,%eax
f011792c:	75 1c                	jne    f011794a <test_priority_normal_and_lower+0x16c>
f011792e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117931:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117937:	83 f8 1e             	cmp    $0x1e,%eax
f011793a:	75 0e                	jne    f011794a <test_priority_normal_and_lower+0x16c>
f011793c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011793f:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117945:	83 f8 28             	cmp    $0x28,%eax
f0117948:	74 17                	je     f0117961 <test_priority_normal_and_lower+0x183>
			panic("The programs should be initially loaded with the given working set size\n");
f011794a:	83 ec 04             	sub    $0x4,%esp
f011794d:	68 c0 bb 12 f0       	push   $0xf012bbc0
f0117952:	68 f5 00 00 00       	push   $0xf5
f0117957:	68 31 b8 12 f0       	push   $0xf012b831
f011795c:	e8 b9 89 fe ff       	call   f010031a <_panic>

		for(int i = 0; i < 20; i++)
f0117961:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0117968:	eb 47                	jmp    f01179b1 <test_priority_normal_and_lower+0x1d3>
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
f011796a:	8b 4d b8             	mov    -0x48(%ebp),%ecx
f011796d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0117970:	89 d0                	mov    %edx,%eax
f0117972:	01 c0                	add    %eax,%eax
f0117974:	01 d0                	add    %edx,%eax
f0117976:	c1 e0 03             	shl    $0x3,%eax
f0117979:	01 c8                	add    %ecx,%eax
f011797b:	05 88 00 00 00       	add    $0x88,%eax
f0117980:	8b 10                	mov    (%eax),%edx
f0117982:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0117985:	89 94 85 50 fb ff ff 	mov    %edx,-0x4b0(%ebp,%eax,4)
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
f011798c:	8b 4d b8             	mov    -0x48(%ebp),%ecx
f011798f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0117992:	89 d0                	mov    %edx,%eax
f0117994:	01 c0                	add    %eax,%eax
f0117996:	01 d0                	add    %edx,%eax
f0117998:	c1 e0 03             	shl    $0x3,%eax
f011799b:	01 c8                	add    %ecx,%eax
f011799d:	05 90 00 00 00       	add    $0x90,%eax
f01179a2:	8b 10                	mov    (%eax),%edx
f01179a4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01179a7:	89 94 85 a0 fb ff ff 	mov    %edx,-0x460(%ebp,%eax,4)
			panic("Loading programs failed\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
			panic("The programs should be initially loaded with the given working set size\n");

		for(int i = 0; i < 20; i++)
f01179ae:	ff 45 e4             	incl   -0x1c(%ebp)
f01179b1:	83 7d e4 13          	cmpl   $0x13,-0x1c(%ebp)
f01179b5:	7e b3                	jle    f011796a <test_priority_normal_and_lower+0x18c>
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 30; i++)
f01179b7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f01179be:	eb 47                	jmp    f0117a07 <test_priority_normal_and_lower+0x229>
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
f01179c0:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
f01179c3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01179c6:	89 d0                	mov    %edx,%eax
f01179c8:	01 c0                	add    %eax,%eax
f01179ca:	01 d0                	add    %edx,%eax
f01179cc:	c1 e0 03             	shl    $0x3,%eax
f01179cf:	01 c8                	add    %ecx,%eax
f01179d1:	05 88 00 00 00       	add    $0x88,%eax
f01179d6:	8b 10                	mov    (%eax),%edx
f01179d8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01179db:	89 94 85 80 fd ff ff 	mov    %edx,-0x280(%ebp,%eax,4)
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
f01179e2:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
f01179e5:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01179e8:	89 d0                	mov    %edx,%eax
f01179ea:	01 c0                	add    %eax,%eax
f01179ec:	01 d0                	add    %edx,%eax
f01179ee:	c1 e0 03             	shl    $0x3,%eax
f01179f1:	01 c8                	add    %ecx,%eax
f01179f3:	05 90 00 00 00       	add    $0x90,%eax
f01179f8:	8b 10                	mov    (%eax),%edx
f01179fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01179fd:	89 94 85 f8 fd ff ff 	mov    %edx,-0x208(%ebp,%eax,4)
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 30; i++)
f0117a04:	ff 45 e0             	incl   -0x20(%ebp)
f0117a07:	83 7d e0 1d          	cmpl   $0x1d,-0x20(%ebp)
f0117a0b:	7e b3                	jle    f01179c0 <test_priority_normal_and_lower+0x1e2>
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 40; i++)
f0117a0d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0117a14:	eb 47                	jmp    f0117a5d <test_priority_normal_and_lower+0x27f>
		{
			hello_WS[i] = helloEnv->ptr_pageWorkingSet[i].virtual_address;
f0117a16:	8b 4d b0             	mov    -0x50(%ebp),%ecx
f0117a19:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0117a1c:	89 d0                	mov    %edx,%eax
f0117a1e:	01 c0                	add    %eax,%eax
f0117a20:	01 d0                	add    %edx,%eax
f0117a22:	c1 e0 03             	shl    $0x3,%eax
f0117a25:	01 c8                	add    %ecx,%eax
f0117a27:	05 88 00 00 00       	add    $0x88,%eax
f0117a2c:	8b 10                	mov    (%eax),%edx
f0117a2e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117a31:	89 94 85 70 fe ff ff 	mov    %edx,-0x190(%ebp,%eax,4)
			hello_TimeStamp[i] = helloEnv->ptr_pageWorkingSet[i].time_stamp;
f0117a38:	8b 4d b0             	mov    -0x50(%ebp),%ecx
f0117a3b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0117a3e:	89 d0                	mov    %edx,%eax
f0117a40:	01 c0                	add    %eax,%eax
f0117a42:	01 d0                	add    %edx,%eax
f0117a44:	c1 e0 03             	shl    $0x3,%eax
f0117a47:	01 c8                	add    %ecx,%eax
f0117a49:	05 90 00 00 00       	add    $0x90,%eax
f0117a4e:	8b 10                	mov    (%eax),%edx
f0117a50:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117a53:	89 94 85 10 ff ff ff 	mov    %edx,-0xf0(%ebp,%eax,4)
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 40; i++)
f0117a5a:	ff 45 dc             	incl   -0x24(%ebp)
f0117a5d:	83 7d dc 27          	cmpl   $0x27,-0x24(%ebp)
f0117a61:	7e b3                	jle    f0117a16 <test_priority_normal_and_lower+0x238>
		{
			hello_WS[i] = helloEnv->ptr_pageWorkingSet[i].virtual_address;
			hello_TimeStamp[i] = helloEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		int freeFrames = sys_calculate_free_frames();
f0117a63:	e8 bf 5c ff ff       	call   f010d727 <sys_calculate_free_frames>
f0117a68:	89 45 c0             	mov    %eax,-0x40(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f0117a6b:	e8 ee ca fe ff       	call   f010455e <pf_calculate_free_frames>
f0117a70:	89 45 bc             	mov    %eax,-0x44(%ebp)

		// Set Priority To Normal // Should change nothing
		set_program_priority(addEnv, 3);
f0117a73:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117a76:	83 ec 08             	sub    $0x8,%esp
f0117a79:	6a 03                	push   $0x3
f0117a7b:	50                   	push   %eax
f0117a7c:	e8 4c 41 ff ff       	call   f010bbcd <set_program_priority>
f0117a81:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 3);
f0117a84:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117a87:	83 ec 08             	sub    $0x8,%esp
f0117a8a:	6a 03                	push   $0x3
f0117a8c:	50                   	push   %eax
f0117a8d:	e8 3b 41 ff ff       	call   f010bbcd <set_program_priority>
f0117a92:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 3);
f0117a95:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117a98:	83 ec 08             	sub    $0x8,%esp
f0117a9b:	6a 03                	push   $0x3
f0117a9d:	50                   	push   %eax
f0117a9e:	e8 2a 41 ff ff       	call   f010bbcd <set_program_priority>
f0117aa3:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0117aa6:	e8 b3 ca fe ff       	call   f010455e <pf_calculate_free_frames>
f0117aab:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f0117aae:	74 17                	je     f0117ac7 <test_priority_normal_and_lower+0x2e9>
f0117ab0:	83 ec 04             	sub    $0x4,%esp
f0117ab3:	68 b4 b8 12 f0       	push   $0xf012b8b4
f0117ab8:	68 11 01 00 00       	push   $0x111
f0117abd:	68 31 b8 12 f0       	push   $0xf012b831
f0117ac2:	e8 53 88 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f0117ac7:	e8 5b 5c ff ff       	call   f010d727 <sys_calculate_free_frames>
f0117acc:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0117acf:	74 17                	je     f0117ae8 <test_priority_normal_and_lower+0x30a>
f0117ad1:	83 ec 04             	sub    $0x4,%esp
f0117ad4:	68 b4 b8 12 f0       	push   $0xf012b8b4
f0117ad9:	68 12 01 00 00       	push   $0x112
f0117ade:	68 31 b8 12 f0       	push   $0xf012b831
f0117ae3:	e8 32 88 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
f0117ae8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117aeb:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117af1:	83 f8 14             	cmp    $0x14,%eax
f0117af4:	75 1c                	jne    f0117b12 <test_priority_normal_and_lower+0x334>
f0117af6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117af9:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117aff:	83 f8 1e             	cmp    $0x1e,%eax
f0117b02:	75 0e                	jne    f0117b12 <test_priority_normal_and_lower+0x334>
f0117b04:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117b07:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117b0d:	83 f8 28             	cmp    $0x28,%eax
f0117b10:	74 17                	je     f0117b29 <test_priority_normal_and_lower+0x34b>
			panic("The programs' working set size should not change after setting priority to normal\n");
f0117b12:	83 ec 04             	sub    $0x4,%esp
f0117b15:	68 e0 b8 12 f0       	push   $0xf012b8e0
f0117b1a:	68 15 01 00 00       	push   $0x115
f0117b1f:	68 31 b8 12 f0       	push   $0xf012b831
f0117b24:	e8 f1 87 fe ff       	call   f010031a <_panic>

		freeFrames = sys_calculate_free_frames();
f0117b29:	e8 f9 5b ff ff       	call   f010d727 <sys_calculate_free_frames>
f0117b2e:	89 45 c0             	mov    %eax,-0x40(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0117b31:	e8 28 ca fe ff       	call   f010455e <pf_calculate_free_frames>
f0117b36:	89 45 bc             	mov    %eax,-0x44(%ebp)

		// Set Priority To Below Normal // Should change only if half is free
		set_program_priority(addEnv, 2);
f0117b39:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117b3c:	83 ec 08             	sub    $0x8,%esp
f0117b3f:	6a 02                	push   $0x2
f0117b41:	50                   	push   %eax
f0117b42:	e8 86 40 ff ff       	call   f010bbcd <set_program_priority>
f0117b47:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 2);
f0117b4a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117b4d:	83 ec 08             	sub    $0x8,%esp
f0117b50:	6a 02                	push   $0x2
f0117b52:	50                   	push   %eax
f0117b53:	e8 75 40 ff ff       	call   f010bbcd <set_program_priority>
f0117b58:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 2);
f0117b5b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117b5e:	83 ec 08             	sub    $0x8,%esp
f0117b61:	6a 02                	push   $0x2
f0117b63:	50                   	push   %eax
f0117b64:	e8 64 40 ff ff       	call   f010bbcd <set_program_priority>
f0117b69:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0117b6c:	e8 ed c9 fe ff       	call   f010455e <pf_calculate_free_frames>
f0117b71:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f0117b74:	74 17                	je     f0117b8d <test_priority_normal_and_lower+0x3af>
f0117b76:	83 ec 04             	sub    $0x4,%esp
f0117b79:	68 b4 b8 12 f0       	push   $0xf012b8b4
f0117b7e:	68 1f 01 00 00       	push   $0x11f
f0117b83:	68 31 b8 12 f0       	push   $0xf012b831
f0117b88:	e8 8d 87 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 0) panic("Old working set should be removed properly%x\n", (freeFrames - sys_calculate_free_frames()));
f0117b8d:	e8 95 5b ff ff       	call   f010d727 <sys_calculate_free_frames>
f0117b92:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0117b95:	74 21                	je     f0117bb8 <test_priority_normal_and_lower+0x3da>
f0117b97:	e8 8b 5b ff ff       	call   f010d727 <sys_calculate_free_frames>
f0117b9c:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0117b9f:	29 c2                	sub    %eax,%edx
f0117ba1:	89 d0                	mov    %edx,%eax
f0117ba3:	50                   	push   %eax
f0117ba4:	68 34 b9 12 f0       	push   $0xf012b934
f0117ba9:	68 20 01 00 00       	push   $0x120
f0117bae:	68 31 b8 12 f0       	push   $0xf012b831
f0117bb3:	e8 62 87 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 10 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
f0117bb8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117bbb:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117bc1:	83 f8 0a             	cmp    $0xa,%eax
f0117bc4:	75 1c                	jne    f0117be2 <test_priority_normal_and_lower+0x404>
f0117bc6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117bc9:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117bcf:	83 f8 0f             	cmp    $0xf,%eax
f0117bd2:	75 0e                	jne    f0117be2 <test_priority_normal_and_lower+0x404>
f0117bd4:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117bd7:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117bdd:	83 f8 14             	cmp    $0x14,%eax
f0117be0:	74 17                	je     f0117bf9 <test_priority_normal_and_lower+0x41b>
			panic("The programs' working set size should be doubled only if it is full\n");
f0117be2:	83 ec 04             	sub    $0x4,%esp
f0117be5:	68 64 b9 12 f0       	push   $0xf012b964
f0117bea:	68 23 01 00 00       	push   $0x123
f0117bef:	68 31 b8 12 f0       	push   $0xf012b831
f0117bf4:	e8 21 87 fe ff       	call   f010031a <_panic>

		freeFrames = sys_calculate_free_frames();
f0117bf9:	e8 29 5b ff ff       	call   f010d727 <sys_calculate_free_frames>
f0117bfe:	89 45 c0             	mov    %eax,-0x40(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0117c01:	e8 58 c9 fe ff       	call   f010455e <pf_calculate_free_frames>
f0117c06:	89 45 bc             	mov    %eax,-0x44(%ebp)

		// Set Priority To Below Normal // Should change only if half is free
		set_program_priority(addEnv, 2);
f0117c09:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117c0c:	83 ec 08             	sub    $0x8,%esp
f0117c0f:	6a 02                	push   $0x2
f0117c11:	50                   	push   %eax
f0117c12:	e8 b6 3f ff ff       	call   f010bbcd <set_program_priority>
f0117c17:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 2);
f0117c1a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117c1d:	83 ec 08             	sub    $0x8,%esp
f0117c20:	6a 02                	push   $0x2
f0117c22:	50                   	push   %eax
f0117c23:	e8 a5 3f ff ff       	call   f010bbcd <set_program_priority>
f0117c28:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 2);
f0117c2b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117c2e:	83 ec 08             	sub    $0x8,%esp
f0117c31:	6a 02                	push   $0x2
f0117c33:	50                   	push   %eax
f0117c34:	e8 94 3f ff ff       	call   f010bbcd <set_program_priority>
f0117c39:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0117c3c:	e8 1d c9 fe ff       	call   f010455e <pf_calculate_free_frames>
f0117c41:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f0117c44:	74 17                	je     f0117c5d <test_priority_normal_and_lower+0x47f>
f0117c46:	83 ec 04             	sub    $0x4,%esp
f0117c49:	68 b4 b8 12 f0       	push   $0xf012b8b4
f0117c4e:	68 2d 01 00 00       	push   $0x12d
f0117c53:	68 31 b8 12 f0       	push   $0xf012b831
f0117c58:	e8 bd 86 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 0) panic("Old working set should be removed properly%x\n", (freeFrames - sys_calculate_free_frames()));
f0117c5d:	e8 c5 5a ff ff       	call   f010d727 <sys_calculate_free_frames>
f0117c62:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0117c65:	74 21                	je     f0117c88 <test_priority_normal_and_lower+0x4aa>
f0117c67:	e8 bb 5a ff ff       	call   f010d727 <sys_calculate_free_frames>
f0117c6c:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0117c6f:	29 c2                	sub    %eax,%edx
f0117c71:	89 d0                	mov    %edx,%eax
f0117c73:	50                   	push   %eax
f0117c74:	68 34 b9 12 f0       	push   $0xf012b934
f0117c79:	68 2e 01 00 00       	push   $0x12e
f0117c7e:	68 31 b8 12 f0       	push   $0xf012b831
f0117c83:	e8 92 86 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 10 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 10)
f0117c88:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117c8b:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117c91:	83 f8 0a             	cmp    $0xa,%eax
f0117c94:	75 1c                	jne    f0117cb2 <test_priority_normal_and_lower+0x4d4>
f0117c96:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117c99:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117c9f:	83 f8 0f             	cmp    $0xf,%eax
f0117ca2:	75 0e                	jne    f0117cb2 <test_priority_normal_and_lower+0x4d4>
f0117ca4:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117ca7:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117cad:	83 f8 0a             	cmp    $0xa,%eax
f0117cb0:	74 17                	je     f0117cc9 <test_priority_normal_and_lower+0x4eb>
			panic("The programs' working set size should be doubled only if it is full\n");
f0117cb2:	83 ec 04             	sub    $0x4,%esp
f0117cb5:	68 64 b9 12 f0       	push   $0xf012b964
f0117cba:	68 31 01 00 00       	push   $0x131
f0117cbf:	68 31 b8 12 f0       	push   $0xf012b831
f0117cc4:	e8 51 86 fe ff       	call   f010031a <_panic>

		for(int i = 0; i < 10; i++)
f0117cc9:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0117cd0:	eb 7d                	jmp    f0117d4f <test_priority_normal_and_lower+0x571>
		{
			if(add_WS[i] != addEnv->ptr_pageWorkingSet[i].virtual_address)
f0117cd2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0117cd5:	8b 8c 85 50 fb ff ff 	mov    -0x4b0(%ebp,%eax,4),%ecx
f0117cdc:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f0117cdf:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0117ce2:	89 d0                	mov    %edx,%eax
f0117ce4:	01 c0                	add    %eax,%eax
f0117ce6:	01 d0                	add    %edx,%eax
f0117ce8:	c1 e0 03             	shl    $0x3,%eax
f0117ceb:	01 d8                	add    %ebx,%eax
f0117ced:	05 88 00 00 00       	add    $0x88,%eax
f0117cf2:	8b 00                	mov    (%eax),%eax
f0117cf4:	39 c1                	cmp    %eax,%ecx
f0117cf6:	74 17                	je     f0117d0f <test_priority_normal_and_lower+0x531>
				panic("Working set should be moved properly to the new one");
f0117cf8:	83 ec 04             	sub    $0x4,%esp
f0117cfb:	68 24 ba 12 f0       	push   $0xf012ba24
f0117d00:	68 36 01 00 00       	push   $0x136
f0117d05:	68 31 b8 12 f0       	push   $0xf012b831
f0117d0a:	e8 0b 86 fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
f0117d0f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0117d12:	8b 8c 85 a0 fb ff ff 	mov    -0x460(%ebp,%eax,4),%ecx
f0117d19:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f0117d1c:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0117d1f:	89 d0                	mov    %edx,%eax
f0117d21:	01 c0                	add    %eax,%eax
f0117d23:	01 d0                	add    %edx,%eax
f0117d25:	c1 e0 03             	shl    $0x3,%eax
f0117d28:	01 d8                	add    %ebx,%eax
f0117d2a:	05 90 00 00 00       	add    $0x90,%eax
f0117d2f:	8b 00                	mov    (%eax),%eax
f0117d31:	39 c1                	cmp    %eax,%ecx
f0117d33:	74 17                	je     f0117d4c <test_priority_normal_and_lower+0x56e>
				panic("Working set should be moved properly to the new one");
f0117d35:	83 ec 04             	sub    $0x4,%esp
f0117d38:	68 24 ba 12 f0       	push   $0xf012ba24
f0117d3d:	68 39 01 00 00       	push   $0x139
f0117d42:	68 31 b8 12 f0       	push   $0xf012b831
f0117d47:	e8 ce 85 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 0) panic("Old working set should be removed properly%x\n", (freeFrames - sys_calculate_free_frames()));

		if(addEnv->page_WS_max_size != 10 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 10)
			panic("The programs' working set size should be doubled only if it is full\n");

		for(int i = 0; i < 10; i++)
f0117d4c:	ff 45 d8             	incl   -0x28(%ebp)
f0117d4f:	83 7d d8 09          	cmpl   $0x9,-0x28(%ebp)
f0117d53:	0f 8e 79 ff ff ff    	jle    f0117cd2 <test_priority_normal_and_lower+0x4f4>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 15; i++)
f0117d59:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f0117d60:	eb 7d                	jmp    f0117ddf <test_priority_normal_and_lower+0x601>
		{
			if(fact_WS[i] != factEnv->ptr_pageWorkingSet[i].virtual_address)
f0117d62:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117d65:	8b 8c 85 80 fd ff ff 	mov    -0x280(%ebp,%eax,4),%ecx
f0117d6c:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
f0117d6f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0117d72:	89 d0                	mov    %edx,%eax
f0117d74:	01 c0                	add    %eax,%eax
f0117d76:	01 d0                	add    %edx,%eax
f0117d78:	c1 e0 03             	shl    $0x3,%eax
f0117d7b:	01 d8                	add    %ebx,%eax
f0117d7d:	05 88 00 00 00       	add    $0x88,%eax
f0117d82:	8b 00                	mov    (%eax),%eax
f0117d84:	39 c1                	cmp    %eax,%ecx
f0117d86:	74 17                	je     f0117d9f <test_priority_normal_and_lower+0x5c1>
				panic("Working set should be moved properly to the new one");
f0117d88:	83 ec 04             	sub    $0x4,%esp
f0117d8b:	68 24 ba 12 f0       	push   $0xf012ba24
f0117d90:	68 3f 01 00 00       	push   $0x13f
f0117d95:	68 31 b8 12 f0       	push   $0xf012b831
f0117d9a:	e8 7b 85 fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
f0117d9f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117da2:	8b 8c 85 f8 fd ff ff 	mov    -0x208(%ebp,%eax,4),%ecx
f0117da9:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
f0117dac:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0117daf:	89 d0                	mov    %edx,%eax
f0117db1:	01 c0                	add    %eax,%eax
f0117db3:	01 d0                	add    %edx,%eax
f0117db5:	c1 e0 03             	shl    $0x3,%eax
f0117db8:	01 d8                	add    %ebx,%eax
f0117dba:	05 90 00 00 00       	add    $0x90,%eax
f0117dbf:	8b 00                	mov    (%eax),%eax
f0117dc1:	39 c1                	cmp    %eax,%ecx
f0117dc3:	74 17                	je     f0117ddc <test_priority_normal_and_lower+0x5fe>
				panic("Working set should be moved properly to the new one");
f0117dc5:	83 ec 04             	sub    $0x4,%esp
f0117dc8:	68 24 ba 12 f0       	push   $0xf012ba24
f0117dcd:	68 42 01 00 00       	push   $0x142
f0117dd2:	68 31 b8 12 f0       	push   $0xf012b831
f0117dd7:	e8 3e 85 fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 15; i++)
f0117ddc:	ff 45 d4             	incl   -0x2c(%ebp)
f0117ddf:	83 7d d4 0e          	cmpl   $0xe,-0x2c(%ebp)
f0117de3:	0f 8e 79 ff ff ff    	jle    f0117d62 <test_priority_normal_and_lower+0x584>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 10; i++)
f0117de9:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f0117df0:	eb 7d                	jmp    f0117e6f <test_priority_normal_and_lower+0x691>
		{
			if(hello_WS[i] != helloEnv->ptr_pageWorkingSet[i].virtual_address)
f0117df2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117df5:	8b 8c 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%ecx
f0117dfc:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f0117dff:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0117e02:	89 d0                	mov    %edx,%eax
f0117e04:	01 c0                	add    %eax,%eax
f0117e06:	01 d0                	add    %edx,%eax
f0117e08:	c1 e0 03             	shl    $0x3,%eax
f0117e0b:	01 d8                	add    %ebx,%eax
f0117e0d:	05 88 00 00 00       	add    $0x88,%eax
f0117e12:	8b 00                	mov    (%eax),%eax
f0117e14:	39 c1                	cmp    %eax,%ecx
f0117e16:	74 17                	je     f0117e2f <test_priority_normal_and_lower+0x651>
				panic("Working set should be moved properly to the new one");
f0117e18:	83 ec 04             	sub    $0x4,%esp
f0117e1b:	68 24 ba 12 f0       	push   $0xf012ba24
f0117e20:	68 48 01 00 00       	push   $0x148
f0117e25:	68 31 b8 12 f0       	push   $0xf012b831
f0117e2a:	e8 eb 84 fe ff       	call   f010031a <_panic>

			if(hello_TimeStamp[i] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
f0117e2f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117e32:	8b 8c 85 10 ff ff ff 	mov    -0xf0(%ebp,%eax,4),%ecx
f0117e39:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f0117e3c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0117e3f:	89 d0                	mov    %edx,%eax
f0117e41:	01 c0                	add    %eax,%eax
f0117e43:	01 d0                	add    %edx,%eax
f0117e45:	c1 e0 03             	shl    $0x3,%eax
f0117e48:	01 d8                	add    %ebx,%eax
f0117e4a:	05 90 00 00 00       	add    $0x90,%eax
f0117e4f:	8b 00                	mov    (%eax),%eax
f0117e51:	39 c1                	cmp    %eax,%ecx
f0117e53:	74 17                	je     f0117e6c <test_priority_normal_and_lower+0x68e>
				panic("Working set should be moved properly to the new one");
f0117e55:	83 ec 04             	sub    $0x4,%esp
f0117e58:	68 24 ba 12 f0       	push   $0xf012ba24
f0117e5d:	68 4b 01 00 00       	push   $0x14b
f0117e62:	68 31 b8 12 f0       	push   $0xf012b831
f0117e67:	e8 ae 84 fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 10; i++)
f0117e6c:	ff 45 d0             	incl   -0x30(%ebp)
f0117e6f:	83 7d d0 09          	cmpl   $0x9,-0x30(%ebp)
f0117e73:	0f 8e 79 ff ff ff    	jle    f0117df2 <test_priority_normal_and_lower+0x614>
			if(hello_TimeStamp[i] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		// Set priority to low
		freeFrames = sys_calculate_free_frames();
f0117e79:	e8 a9 58 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0117e7e:	89 45 c0             	mov    %eax,-0x40(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0117e81:	e8 d8 c6 fe ff       	call   f010455e <pf_calculate_free_frames>
f0117e86:	89 45 bc             	mov    %eax,-0x44(%ebp)
		set_program_priority(addEnv, 1);
f0117e89:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117e8c:	83 ec 08             	sub    $0x8,%esp
f0117e8f:	6a 01                	push   $0x1
f0117e91:	50                   	push   %eax
f0117e92:	e8 36 3d ff ff       	call   f010bbcd <set_program_priority>
f0117e97:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 1);
f0117e9a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117e9d:	83 ec 08             	sub    $0x8,%esp
f0117ea0:	6a 01                	push   $0x1
f0117ea2:	50                   	push   %eax
f0117ea3:	e8 25 3d ff ff       	call   f010bbcd <set_program_priority>
f0117ea8:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 1);
f0117eab:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117eae:	83 ec 08             	sub    $0x8,%esp
f0117eb1:	6a 01                	push   $0x1
f0117eb3:	50                   	push   %eax
f0117eb4:	e8 14 3d ff ff       	call   f010bbcd <set_program_priority>
f0117eb9:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0117ebc:	e8 9d c6 fe ff       	call   f010455e <pf_calculate_free_frames>
f0117ec1:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f0117ec4:	74 17                	je     f0117edd <test_priority_normal_and_lower+0x6ff>
f0117ec6:	83 ec 04             	sub    $0x4,%esp
f0117ec9:	68 b4 b8 12 f0       	push   $0xf012b8b4
f0117ece:	68 54 01 00 00       	push   $0x154
f0117ed3:	68 31 b8 12 f0       	push   $0xf012b831
f0117ed8:	e8 3d 84 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != (5+3+5)) panic("Old working set and extra pages in WS should be removed properly %d\n");
f0117edd:	e8 45 58 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0117ee2:	2b 45 c0             	sub    -0x40(%ebp),%eax
f0117ee5:	83 f8 0d             	cmp    $0xd,%eax
f0117ee8:	74 17                	je     f0117f01 <test_priority_normal_and_lower+0x723>
f0117eea:	83 ec 04             	sub    $0x4,%esp
f0117eed:	68 0c bc 12 f0       	push   $0xf012bc0c
f0117ef2:	68 55 01 00 00       	push   $0x155
f0117ef7:	68 31 b8 12 f0       	push   $0xf012b831
f0117efc:	e8 19 84 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 5 || factEnv->page_WS_max_size != 7 || helloEnv->page_WS_max_size != 5)
f0117f01:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117f04:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117f0a:	83 f8 05             	cmp    $0x5,%eax
f0117f0d:	75 1c                	jne    f0117f2b <test_priority_normal_and_lower+0x74d>
f0117f0f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117f12:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117f18:	83 f8 07             	cmp    $0x7,%eax
f0117f1b:	75 0e                	jne    f0117f2b <test_priority_normal_and_lower+0x74d>
f0117f1d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117f20:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117f26:	83 f8 05             	cmp    $0x5,%eax
f0117f29:	74 17                	je     f0117f42 <test_priority_normal_and_lower+0x764>
			panic("The programs' working set size should be half\n");
f0117f2b:	83 ec 04             	sub    $0x4,%esp
f0117f2e:	68 54 bc 12 f0       	push   $0xf012bc54
f0117f33:	68 58 01 00 00       	push   $0x158
f0117f38:	68 31 b8 12 f0       	push   $0xf012b831
f0117f3d:	e8 d8 83 fe ff       	call   f010031a <_panic>


		freeFrames = sys_calculate_free_frames();
f0117f42:	e8 e0 57 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0117f47:	89 45 c0             	mov    %eax,-0x40(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0117f4a:	e8 0f c6 fe ff       	call   f010455e <pf_calculate_free_frames>
f0117f4f:	89 45 bc             	mov    %eax,-0x44(%ebp)
		set_program_priority(addEnv, 1);
f0117f52:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117f55:	83 ec 08             	sub    $0x8,%esp
f0117f58:	6a 01                	push   $0x1
f0117f5a:	50                   	push   %eax
f0117f5b:	e8 6d 3c ff ff       	call   f010bbcd <set_program_priority>
f0117f60:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0117f63:	e8 f6 c5 fe ff       	call   f010455e <pf_calculate_free_frames>
f0117f68:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f0117f6b:	74 17                	je     f0117f84 <test_priority_normal_and_lower+0x7a6>
f0117f6d:	83 ec 04             	sub    $0x4,%esp
f0117f70:	68 b4 b8 12 f0       	push   $0xf012b8b4
f0117f75:	68 5e 01 00 00       	push   $0x15e
f0117f7a:	68 31 b8 12 f0       	push   $0xf012b831
f0117f7f:	e8 96 83 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 3) panic("Old working set should be removed properly\n");
f0117f84:	e8 9e 57 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0117f89:	2b 45 c0             	sub    -0x40(%ebp),%eax
f0117f8c:	83 f8 03             	cmp    $0x3,%eax
f0117f8f:	74 17                	je     f0117fa8 <test_priority_normal_and_lower+0x7ca>
f0117f91:	83 ec 04             	sub    $0x4,%esp
f0117f94:	68 b4 b8 12 f0       	push   $0xf012b8b4
f0117f99:	68 5f 01 00 00       	push   $0x15f
f0117f9e:	68 31 b8 12 f0       	push   $0xf012b831
f0117fa3:	e8 72 83 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 2 || factEnv->page_WS_max_size != 7 || helloEnv->page_WS_max_size != 5)
f0117fa8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117fab:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117fb1:	83 f8 02             	cmp    $0x2,%eax
f0117fb4:	75 1c                	jne    f0117fd2 <test_priority_normal_and_lower+0x7f4>
f0117fb6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117fb9:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117fbf:	83 f8 07             	cmp    $0x7,%eax
f0117fc2:	75 0e                	jne    f0117fd2 <test_priority_normal_and_lower+0x7f4>
f0117fc4:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117fc7:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117fcd:	83 f8 05             	cmp    $0x5,%eax
f0117fd0:	74 17                	je     f0117fe9 <test_priority_normal_and_lower+0x80b>
			panic("The programs' working set size should be doubled if full\n");
f0117fd2:	83 ec 04             	sub    $0x4,%esp
f0117fd5:	68 e8 b9 12 f0       	push   $0xf012b9e8
f0117fda:	68 62 01 00 00       	push   $0x162
f0117fdf:	68 31 b8 12 f0       	push   $0xf012b831
f0117fe4:	e8 31 83 fe ff       	call   f010031a <_panic>

		for(int i = 0; i < 2; i++)
f0117fe9:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f0117ff0:	e9 83 00 00 00       	jmp    f0118078 <test_priority_normal_and_lower+0x89a>
		{
			if(add_WS[i+8] != addEnv->ptr_pageWorkingSet[i].virtual_address)
f0117ff5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0117ff8:	83 c0 08             	add    $0x8,%eax
f0117ffb:	8b 8c 85 50 fb ff ff 	mov    -0x4b0(%ebp,%eax,4),%ecx
f0118002:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f0118005:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0118008:	89 d0                	mov    %edx,%eax
f011800a:	01 c0                	add    %eax,%eax
f011800c:	01 d0                	add    %edx,%eax
f011800e:	c1 e0 03             	shl    $0x3,%eax
f0118011:	01 d8                	add    %ebx,%eax
f0118013:	05 88 00 00 00       	add    $0x88,%eax
f0118018:	8b 00                	mov    (%eax),%eax
f011801a:	39 c1                	cmp    %eax,%ecx
f011801c:	74 17                	je     f0118035 <test_priority_normal_and_lower+0x857>
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
f011801e:	83 ec 04             	sub    $0x4,%esp
f0118021:	68 84 bc 12 f0       	push   $0xf012bc84
f0118026:	68 67 01 00 00       	push   $0x167
f011802b:	68 31 b8 12 f0       	push   $0xf012b831
f0118030:	e8 e5 82 fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i+8] != addEnv->ptr_pageWorkingSet[i].time_stamp)
f0118035:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0118038:	83 c0 08             	add    $0x8,%eax
f011803b:	8b 8c 85 a0 fb ff ff 	mov    -0x460(%ebp,%eax,4),%ecx
f0118042:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f0118045:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0118048:	89 d0                	mov    %edx,%eax
f011804a:	01 c0                	add    %eax,%eax
f011804c:	01 d0                	add    %edx,%eax
f011804e:	c1 e0 03             	shl    $0x3,%eax
f0118051:	01 d8                	add    %ebx,%eax
f0118053:	05 90 00 00 00       	add    $0x90,%eax
f0118058:	8b 00                	mov    (%eax),%eax
f011805a:	39 c1                	cmp    %eax,%ecx
f011805c:	74 17                	je     f0118075 <test_priority_normal_and_lower+0x897>
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
f011805e:	83 ec 04             	sub    $0x4,%esp
f0118061:	68 84 bc 12 f0       	push   $0xf012bc84
f0118066:	68 6a 01 00 00       	push   $0x16a
f011806b:	68 31 b8 12 f0       	push   $0xf012b831
f0118070:	e8 a5 82 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 3) panic("Old working set should be removed properly\n");

		if(addEnv->page_WS_max_size != 2 || factEnv->page_WS_max_size != 7 || helloEnv->page_WS_max_size != 5)
			panic("The programs' working set size should be doubled if full\n");

		for(int i = 0; i < 2; i++)
f0118075:	ff 45 cc             	incl   -0x34(%ebp)
f0118078:	83 7d cc 01          	cmpl   $0x1,-0x34(%ebp)
f011807c:	0f 8e 73 ff ff ff    	jle    f0117ff5 <test_priority_normal_and_lower+0x817>

			if(add_TimeStamp[i+8] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
		}

		for(int i = 0; i < 7; i++)
f0118082:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f0118089:	e9 83 00 00 00       	jmp    f0118111 <test_priority_normal_and_lower+0x933>
		{
			if(fact_WS[i+3] != factEnv->ptr_pageWorkingSet[i].virtual_address)
f011808e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0118091:	83 c0 03             	add    $0x3,%eax
f0118094:	8b 8c 85 80 fd ff ff 	mov    -0x280(%ebp,%eax,4),%ecx
f011809b:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
f011809e:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01180a1:	89 d0                	mov    %edx,%eax
f01180a3:	01 c0                	add    %eax,%eax
f01180a5:	01 d0                	add    %edx,%eax
f01180a7:	c1 e0 03             	shl    $0x3,%eax
f01180aa:	01 d8                	add    %ebx,%eax
f01180ac:	05 88 00 00 00       	add    $0x88,%eax
f01180b1:	8b 00                	mov    (%eax),%eax
f01180b3:	39 c1                	cmp    %eax,%ecx
f01180b5:	74 17                	je     f01180ce <test_priority_normal_and_lower+0x8f0>
				panic("%d Working set should be moved properly to the new one, removed pages are chosen based on replacement policy", i);
f01180b7:	ff 75 c8             	pushl  -0x38(%ebp)
f01180ba:	68 f0 bc 12 f0       	push   $0xf012bcf0
f01180bf:	68 70 01 00 00       	push   $0x170
f01180c4:	68 31 b8 12 f0       	push   $0xf012b831
f01180c9:	e8 4c 82 fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i+3] != factEnv->ptr_pageWorkingSet[i].time_stamp)
f01180ce:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01180d1:	83 c0 03             	add    $0x3,%eax
f01180d4:	8b 8c 85 f8 fd ff ff 	mov    -0x208(%ebp,%eax,4),%ecx
f01180db:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
f01180de:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01180e1:	89 d0                	mov    %edx,%eax
f01180e3:	01 c0                	add    %eax,%eax
f01180e5:	01 d0                	add    %edx,%eax
f01180e7:	c1 e0 03             	shl    $0x3,%eax
f01180ea:	01 d8                	add    %ebx,%eax
f01180ec:	05 90 00 00 00       	add    $0x90,%eax
f01180f1:	8b 00                	mov    (%eax),%eax
f01180f3:	39 c1                	cmp    %eax,%ecx
f01180f5:	74 17                	je     f011810e <test_priority_normal_and_lower+0x930>
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
f01180f7:	83 ec 04             	sub    $0x4,%esp
f01180fa:	68 84 bc 12 f0       	push   $0xf012bc84
f01180ff:	68 73 01 00 00       	push   $0x173
f0118104:	68 31 b8 12 f0       	push   $0xf012b831
f0118109:	e8 0c 82 fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i+8] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
		}

		for(int i = 0; i < 7; i++)
f011810e:	ff 45 c8             	incl   -0x38(%ebp)
f0118111:	83 7d c8 06          	cmpl   $0x6,-0x38(%ebp)
f0118115:	0f 8e 73 ff ff ff    	jle    f011808e <test_priority_normal_and_lower+0x8b0>

			if(fact_TimeStamp[i+3] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
		}

		for(int i = 0; i < 5; i++)
f011811b:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0118122:	e9 83 00 00 00       	jmp    f01181aa <test_priority_normal_and_lower+0x9cc>
		{
			if(hello_WS[i+5] != helloEnv->ptr_pageWorkingSet[i].virtual_address)
f0118127:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011812a:	83 c0 05             	add    $0x5,%eax
f011812d:	8b 8c 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%ecx
f0118134:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f0118137:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011813a:	89 d0                	mov    %edx,%eax
f011813c:	01 c0                	add    %eax,%eax
f011813e:	01 d0                	add    %edx,%eax
f0118140:	c1 e0 03             	shl    $0x3,%eax
f0118143:	01 d8                	add    %ebx,%eax
f0118145:	05 88 00 00 00       	add    $0x88,%eax
f011814a:	8b 00                	mov    (%eax),%eax
f011814c:	39 c1                	cmp    %eax,%ecx
f011814e:	74 17                	je     f0118167 <test_priority_normal_and_lower+0x989>
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
f0118150:	83 ec 04             	sub    $0x4,%esp
f0118153:	68 84 bc 12 f0       	push   $0xf012bc84
f0118158:	68 79 01 00 00       	push   $0x179
f011815d:	68 31 b8 12 f0       	push   $0xf012b831
f0118162:	e8 b3 81 fe ff       	call   f010031a <_panic>

			if(hello_TimeStamp[i+5] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
f0118167:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011816a:	83 c0 05             	add    $0x5,%eax
f011816d:	8b 8c 85 10 ff ff ff 	mov    -0xf0(%ebp,%eax,4),%ecx
f0118174:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f0118177:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011817a:	89 d0                	mov    %edx,%eax
f011817c:	01 c0                	add    %eax,%eax
f011817e:	01 d0                	add    %edx,%eax
f0118180:	c1 e0 03             	shl    $0x3,%eax
f0118183:	01 d8                	add    %ebx,%eax
f0118185:	05 90 00 00 00       	add    $0x90,%eax
f011818a:	8b 00                	mov    (%eax),%eax
f011818c:	39 c1                	cmp    %eax,%ecx
f011818e:	74 17                	je     f01181a7 <test_priority_normal_and_lower+0x9c9>
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
f0118190:	83 ec 04             	sub    $0x4,%esp
f0118193:	68 84 bc 12 f0       	push   $0xf012bc84
f0118198:	68 7c 01 00 00       	push   $0x17c
f011819d:	68 31 b8 12 f0       	push   $0xf012b831
f01181a2:	e8 73 81 fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i+3] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
		}

		for(int i = 0; i < 5; i++)
f01181a7:	ff 45 c4             	incl   -0x3c(%ebp)
f01181aa:	83 7d c4 04          	cmpl   $0x4,-0x3c(%ebp)
f01181ae:	0f 8e 73 ff ff ff    	jle    f0118127 <test_priority_normal_and_lower+0x949>

			if(hello_TimeStamp[i+5] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
		}

		set_program_priority(addEnv, 5);
f01181b4:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01181b7:	83 ec 08             	sub    $0x8,%esp
f01181ba:	6a 05                	push   $0x5
f01181bc:	50                   	push   %eax
f01181bd:	e8 0b 3a ff ff       	call   f010bbcd <set_program_priority>
f01181c2:	83 c4 10             	add    $0x10,%esp
		set_program_priority(addEnv, 5);
f01181c5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01181c8:	83 ec 08             	sub    $0x8,%esp
f01181cb:	6a 05                	push   $0x5
f01181cd:	50                   	push   %eax
f01181ce:	e8 fa 39 ff ff       	call   f010bbcd <set_program_priority>
f01181d3:	83 c4 10             	add    $0x10,%esp

		char command4[100] = "runall";
f01181d6:	c7 85 1c fd ff ff 72 	movl   $0x616e7572,-0x2e4(%ebp)
f01181dd:	75 6e 61 
f01181e0:	c7 85 20 fd ff ff 6c 	movl   $0x6c6c,-0x2e0(%ebp)
f01181e7:	6c 00 00 
f01181ea:	8d 95 24 fd ff ff    	lea    -0x2dc(%ebp),%edx
f01181f0:	b9 17 00 00 00       	mov    $0x17,%ecx
f01181f5:	b8 00 00 00 00       	mov    $0x0,%eax
f01181fa:	89 d7                	mov    %edx,%edi
f01181fc:	f3 ab                	rep stos %eax,%es:(%edi)
		execute_command(command4);
f01181fe:	83 ec 0c             	sub    $0xc,%esp
f0118201:	8d 85 1c fd ff ff    	lea    -0x2e4(%ebp),%eax
f0118207:	50                   	push   %eax
f0118208:	e8 cf 9c fe ff       	call   f0101edc <execute_command>
f011820d:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nCongratulations!! test priority 2 completed successfully.\n");
	}
#endif
}
f0118210:	eb 10                	jmp    f0118222 <test_priority_normal_and_lower+0xa44>
		char command4[100] = "runall";
		execute_command(command4);
	}
	else
	{
		cprintf("\nCongratulations!! test priority 2 completed successfully.\n");
f0118212:	83 ec 0c             	sub    $0xc,%esp
f0118215:	68 60 bd 12 f0       	push   $0xf012bd60
f011821a:	e8 4d 8d fe ff       	call   f0100f6c <cprintf>
f011821f:	83 c4 10             	add    $0x10,%esp
	}
#endif
}
f0118222:	90                   	nop
f0118223:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0118226:	5b                   	pop    %ebx
f0118227:	5e                   	pop    %esi
f0118228:	5f                   	pop    %edi
f0118229:	5d                   	pop    %ebp
f011822a:	c3                   	ret    

f011822b <test_kmalloc>:
	int c;
};

uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;
int test_kmalloc()
{
f011822b:	55                   	push   %ebp
f011822c:	89 e5                	mov    %esp,%ebp
f011822e:	57                   	push   %edi
f011822f:	53                   	push   %ebx
f0118230:	81 ec d0 00 00 00    	sub    $0xd0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0118236:	83 ec 0c             	sub    $0xc,%esp
f0118239:	68 80 be 12 f0       	push   $0xf012be80
f011823e:	e8 29 8d fe ff       	call   f0100f6c <cprintf>
f0118243:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0118246:	83 ec 0c             	sub    $0xc,%esp
f0118249:	68 b0 be 12 f0       	push   $0xf012beb0
f011824e:	e8 19 8d fe ff       	call   f0100f6c <cprintf>
f0118253:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0118256:	83 ec 0c             	sub    $0xc,%esp
f0118259:	68 80 be 12 f0       	push   $0xf012be80
f011825e:	e8 09 8d fe ff       	call   f0100f6c <cprintf>
f0118263:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f0118266:	c6 45 eb 80          	movb   $0x80,-0x15(%ebp)
	char maxByte = 0x7F;
f011826a:	c6 45 ea 7f          	movb   $0x7f,-0x16(%ebp)
	short minShort = 1<<15 ;
f011826e:	66 c7 45 e8 00 80    	movw   $0x8000,-0x18(%ebp)
	short maxShort = 0x7FFF;
f0118274:	66 c7 45 e6 ff 7f    	movw   $0x7fff,-0x1a(%ebp)
	int minInt = 1<<31 ;
f011827a:	c7 45 e0 00 00 00 80 	movl   $0x80000000,-0x20(%ebp)
	int maxInt = 0x7FFFFFFF;
f0118281:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,-0x24(%ebp)
	char *byteArr, *byteArr2, *byteArr3 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfByte3, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = (int)sys_calculate_free_frames() ;
f0118288:	e8 9a 54 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011828d:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int eval = 0;
f0118290:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0118297:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int freeFrames, freeDiskFrames;
	uint32 sizeOfKHeap;
	void* ptr_allocations[20] = {0};
f011829e:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f01182a4:	b9 14 00 00 00       	mov    $0x14,%ecx
f01182a9:	b8 00 00 00 00       	mov    $0x0,%eax
f01182ae:	89 d7                	mov    %edx,%edi
f01182b0:	f3 ab                	rep stos %eax,%es:(%edi)
	correct = 1 ;
f01182b2:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//Insufficient space
		freeFrames = (int)sys_calculate_free_frames() ;
f01182b9:	e8 69 54 ff ff       	call   f010d727 <sys_calculate_free_frames>
f01182be:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01182c1:	e8 98 c2 fe ff       	call   f010455e <pf_calculate_free_frames>
f01182c6:	89 45 d0             	mov    %eax,-0x30(%ebp)
		sizeOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 1) ;
f01182c9:	c7 45 cc 01 e0 ff 07 	movl   $0x7ffe001,-0x34(%ebp)
		ptr_allocations[0] = kmalloc(sizeOfKHeap);
f01182d0:	83 ec 0c             	sub    $0xc,%esp
f01182d3:	ff 75 cc             	pushl  -0x34(%ebp)
f01182d6:	e8 f9 04 ff ff       	call   f01087d4 <kmalloc>
f01182db:	83 c4 10             	add    $0x10,%esp
f01182de:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f01182e4:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f01182ea:	85 c0                	test   %eax,%eax
f01182ec:	74 17                	je     f0118305 <test_kmalloc+0xda>
f01182ee:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01182f5:	83 ec 0c             	sub    $0xc,%esp
f01182f8:	68 0c bf 12 f0       	push   $0xf012bf0c
f01182fd:	e8 6a 8c fe ff       	call   f0100f6c <cprintf>
f0118302:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118305:	e8 54 c2 fe ff       	call   f010455e <pf_calculate_free_frames>
f011830a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011830d:	74 17                	je     f0118326 <test_kmalloc+0xfb>
f011830f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118316:	83 ec 0c             	sub    $0xc,%esp
f0118319:	68 40 bf 12 f0       	push   $0xf012bf40
f011831e:	e8 49 8c fe ff       	call   f0100f6c <cprintf>
f0118323:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118326:	e8 fc 53 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011832b:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011832e:	74 17                	je     f0118347 <test_kmalloc+0x11c>
f0118330:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118337:	83 ec 0c             	sub    $0xc,%esp
f011833a:	68 ac bf 12 f0       	push   $0xf012bfac
f011833f:	e8 28 8c fe ff       	call   f0100f6c <cprintf>
f0118344:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118347:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011834b:	74 04                	je     f0118351 <test_kmalloc+0x126>
f011834d:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0118351:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118358:	e8 ca 53 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011835d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118360:	e8 f9 c1 fe ff       	call   f010455e <pf_calculate_free_frames>
f0118365:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0118368:	83 ec 0c             	sub    $0xc,%esp
f011836b:	68 00 fc 1f 00       	push   $0x1ffc00
f0118370:	e8 5f 04 ff ff       	call   f01087d4 <kmalloc>
f0118375:	83 c4 10             	add    $0x10,%esp
f0118378:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011837e:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0118384:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118389:	74 17                	je     f01183a2 <test_kmalloc+0x177>
f011838b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118392:	83 ec 0c             	sub    $0xc,%esp
f0118395:	68 f0 bf 12 f0       	push   $0xf012bff0
f011839a:	e8 cd 8b fe ff       	call   f0100f6c <cprintf>
f011839f:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01183a2:	e8 b7 c1 fe ff       	call   f010455e <pf_calculate_free_frames>
f01183a7:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01183aa:	74 17                	je     f01183c3 <test_kmalloc+0x198>
f01183ac:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01183b3:	83 ec 0c             	sub    $0xc,%esp
f01183b6:	68 40 bf 12 f0       	push   $0xf012bf40
f01183bb:	e8 ac 8b fe ff       	call   f0100f6c <cprintf>
f01183c0:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f01183c3:	e8 5f 53 ff ff       	call   f010d727 <sys_calculate_free_frames>
f01183c8:	89 c2                	mov    %eax,%edx
f01183ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01183cd:	29 d0                	sub    %edx,%eax
f01183cf:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01183d4:	7f 17                	jg     f01183ed <test_kmalloc+0x1c2>
f01183d6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01183dd:	83 ec 0c             	sub    $0xc,%esp
f01183e0:	68 ac bf 12 f0       	push   $0xf012bfac
f01183e5:	e8 82 8b fe ff       	call   f0100f6c <cprintf>
f01183ea:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01183ed:	e8 35 53 ff ff       	call   f010d727 <sys_calculate_free_frames>
f01183f2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01183f5:	e8 64 c1 fe ff       	call   f010455e <pf_calculate_free_frames>
f01183fa:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f01183fd:	83 ec 0c             	sub    $0xc,%esp
f0118400:	68 00 fc 1f 00       	push   $0x1ffc00
f0118405:	e8 ca 03 ff ff       	call   f01087d4 <kmalloc>
f011840a:	83 c4 10             	add    $0x10,%esp
f011840d:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0118413:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0118419:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011841e:	74 17                	je     f0118437 <test_kmalloc+0x20c>
f0118420:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118427:	83 ec 0c             	sub    $0xc,%esp
f011842a:	68 f0 bf 12 f0       	push   $0xf012bff0
f011842f:	e8 38 8b fe ff       	call   f0100f6c <cprintf>
f0118434:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118437:	e8 22 c1 fe ff       	call   f010455e <pf_calculate_free_frames>
f011843c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011843f:	74 17                	je     f0118458 <test_kmalloc+0x22d>
f0118441:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118448:	83 ec 0c             	sub    $0xc,%esp
f011844b:	68 40 bf 12 f0       	push   $0xf012bf40
f0118450:	e8 17 8b fe ff       	call   f0100f6c <cprintf>
f0118455:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118458:	e8 ca 52 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011845d:	89 c2                	mov    %eax,%edx
f011845f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0118462:	29 d0                	sub    %edx,%eax
f0118464:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118469:	7f 17                	jg     f0118482 <test_kmalloc+0x257>
f011846b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118472:	83 ec 0c             	sub    $0xc,%esp
f0118475:	68 ac bf 12 f0       	push   $0xf012bfac
f011847a:	e8 ed 8a fe ff       	call   f0100f6c <cprintf>
f011847f:	83 c4 10             	add    $0x10,%esp

		//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
		freeFrames = (int)sys_calculate_free_frames() ;
f0118482:	e8 a0 52 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0118487:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011848a:	e8 cf c0 fe ff       	call   f010455e <pf_calculate_free_frames>
f011848f:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[2] = kmalloc(2*kilo-1);
f0118492:	83 ec 0c             	sub    $0xc,%esp
f0118495:	68 ff 07 00 00       	push   $0x7ff
f011849a:	e8 35 03 ff ff       	call   f01087d4 <kmalloc>
f011849f:	83 c4 10             	add    $0x10,%esp
f01184a2:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
		if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f01184a8:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f01184ae:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01184b3:	76 28                	jbe    f01184dd <test_kmalloc+0x2b2>
f01184b5:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f01184bb:	83 ec 0c             	sub    $0xc,%esp
f01184be:	6a 00                	push   $0x0
f01184c0:	e8 05 03 ff ff       	call   f01087ca <sbrk>
f01184c5:	83 c4 10             	add    $0x10,%esp
f01184c8:	39 c3                	cmp    %eax,%ebx
f01184ca:	73 11                	jae    f01184dd <test_kmalloc+0x2b2>
f01184cc:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f01184d2:	89 c2                	mov    %eax,%edx
f01184d4:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f01184d9:	39 c2                	cmp    %eax,%edx
f01184db:	72 17                	jb     f01184f4 <test_kmalloc+0x2c9>
		{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01184dd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184e4:	83 ec 0c             	sub    $0xc,%esp
f01184e7:	68 40 c0 12 f0       	push   $0xf012c040
f01184ec:	e8 7b 8a fe ff       	call   f0100f6c <cprintf>
f01184f1:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01184f4:	e8 65 c0 fe ff       	call   f010455e <pf_calculate_free_frames>
f01184f9:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01184fc:	74 17                	je     f0118515 <test_kmalloc+0x2ea>
f01184fe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118505:	83 ec 0c             	sub    $0xc,%esp
f0118508:	68 40 bf 12 f0       	push   $0xf012bf40
f011850d:	e8 5a 8a fe ff       	call   f0100f6c <cprintf>
f0118512:	83 c4 10             	add    $0x10,%esp
		//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

		//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
		freeFrames = (int)sys_calculate_free_frames() ;
f0118515:	e8 0d 52 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011851a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011851d:	e8 3c c0 fe ff       	call   f010455e <pf_calculate_free_frames>
f0118522:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[3] = kmalloc(2*kilo-1);
f0118525:	83 ec 0c             	sub    $0xc,%esp
f0118528:	68 ff 07 00 00       	push   $0x7ff
f011852d:	e8 a2 02 ff ff       	call   f01087d4 <kmalloc>
f0118532:	83 c4 10             	add    $0x10,%esp
f0118535:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
		if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011853b:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0118541:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118546:	76 28                	jbe    f0118570 <test_kmalloc+0x345>
f0118548:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f011854e:	83 ec 0c             	sub    $0xc,%esp
f0118551:	6a 00                	push   $0x0
f0118553:	e8 72 02 ff ff       	call   f01087ca <sbrk>
f0118558:	83 c4 10             	add    $0x10,%esp
f011855b:	39 c3                	cmp    %eax,%ebx
f011855d:	73 11                	jae    f0118570 <test_kmalloc+0x345>
f011855f:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0118565:	89 c2                	mov    %eax,%edx
f0118567:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011856c:	39 c2                	cmp    %eax,%edx
f011856e:	72 17                	jb     f0118587 <test_kmalloc+0x35c>
		{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118570:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118577:	83 ec 0c             	sub    $0xc,%esp
f011857a:	68 40 c0 12 f0       	push   $0xf012c040
f011857f:	e8 e8 89 fe ff       	call   f0100f6c <cprintf>
f0118584:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118587:	e8 d2 bf fe ff       	call   f010455e <pf_calculate_free_frames>
f011858c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011858f:	74 17                	je     f01185a8 <test_kmalloc+0x37d>
f0118591:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118598:	83 ec 0c             	sub    $0xc,%esp
f011859b:	68 40 bf 12 f0       	push   $0xf012bf40
f01185a0:	e8 c7 89 fe ff       	call   f0100f6c <cprintf>
f01185a5:	83 c4 10             	add    $0x10,%esp
		//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) panic("Wrong allocation: pages are not loaded successfully into memory\n"); }

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01185a8:	e8 7a 51 ff ff       	call   f010d727 <sys_calculate_free_frames>
f01185ad:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01185b0:	e8 a9 bf fe ff       	call   f010455e <pf_calculate_free_frames>
f01185b5:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f01185b8:	83 ec 0c             	sub    $0xc,%esp
f01185bb:	68 00 1c 00 00       	push   $0x1c00
f01185c0:	e8 0f 02 ff ff       	call   f01087d4 <kmalloc>
f01185c5:	83 c4 10             	add    $0x10,%esp
f01185c8:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01185ce:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f01185d4:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f01185d9:	74 17                	je     f01185f2 <test_kmalloc+0x3c7>
f01185db:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185e2:	83 ec 0c             	sub    $0xc,%esp
f01185e5:	68 f0 bf 12 f0       	push   $0xf012bff0
f01185ea:	e8 7d 89 fe ff       	call   f0100f6c <cprintf>
f01185ef:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01185f2:	e8 67 bf fe ff       	call   f010455e <pf_calculate_free_frames>
f01185f7:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01185fa:	74 17                	je     f0118613 <test_kmalloc+0x3e8>
f01185fc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118603:	83 ec 0c             	sub    $0xc,%esp
f0118606:	68 40 bf 12 f0       	push   $0xf012bf40
f011860b:	e8 5c 89 fe ff       	call   f0100f6c <cprintf>
f0118610:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118613:	e8 0f 51 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0118618:	89 c2                	mov    %eax,%edx
f011861a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011861d:	29 d0                	sub    %edx,%eax
f011861f:	83 f8 01             	cmp    $0x1,%eax
f0118622:	7f 17                	jg     f011863b <test_kmalloc+0x410>
f0118624:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011862b:	83 ec 0c             	sub    $0xc,%esp
f011862e:	68 ac bf 12 f0       	push   $0xf012bfac
f0118633:	e8 34 89 fe ff       	call   f0100f6c <cprintf>
f0118638:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011863b:	e8 e7 50 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0118640:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118643:	e8 16 bf fe ff       	call   f010455e <pf_calculate_free_frames>
f0118648:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f011864b:	83 ec 0c             	sub    $0xc,%esp
f011864e:	68 00 fc 2f 00       	push   $0x2ffc00
f0118653:	e8 7c 01 ff ff       	call   f01087d4 <kmalloc>
f0118658:	83 c4 10             	add    $0x10,%esp
f011865b:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0118661:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f0118667:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011866c:	74 17                	je     f0118685 <test_kmalloc+0x45a>
f011866e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118675:	83 ec 0c             	sub    $0xc,%esp
f0118678:	68 f0 bf 12 f0       	push   $0xf012bff0
f011867d:	e8 ea 88 fe ff       	call   f0100f6c <cprintf>
f0118682:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118685:	e8 d4 be fe ff       	call   f010455e <pf_calculate_free_frames>
f011868a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011868d:	74 17                	je     f01186a6 <test_kmalloc+0x47b>
f011868f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118696:	83 ec 0c             	sub    $0xc,%esp
f0118699:	68 40 bf 12 f0       	push   $0xf012bf40
f011869e:	e8 c9 88 fe ff       	call   f0100f6c <cprintf>
f01186a3:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f01186a6:	e8 7c 50 ff ff       	call   f010d727 <sys_calculate_free_frames>
f01186ab:	89 c2                	mov    %eax,%edx
f01186ad:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01186b0:	29 d0                	sub    %edx,%eax
f01186b2:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01186b7:	7f 17                	jg     f01186d0 <test_kmalloc+0x4a5>
f01186b9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01186c0:	83 ec 0c             	sub    $0xc,%esp
f01186c3:	68 ac bf 12 f0       	push   $0xf012bfac
f01186c8:	e8 9f 88 fe ff       	call   f0100f6c <cprintf>
f01186cd:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01186d0:	e8 52 50 ff ff       	call   f010d727 <sys_calculate_free_frames>
f01186d5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01186d8:	e8 81 be fe ff       	call   f010455e <pf_calculate_free_frames>
f01186dd:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f01186e0:	83 ec 0c             	sub    $0xc,%esp
f01186e3:	68 00 fc 5f 00       	push   $0x5ffc00
f01186e8:	e8 e7 00 ff ff       	call   f01087d4 <kmalloc>
f01186ed:	83 c4 10             	add    $0x10,%esp
f01186f0:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01186f6:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f01186fc:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0118701:	74 17                	je     f011871a <test_kmalloc+0x4ef>
f0118703:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011870a:	83 ec 0c             	sub    $0xc,%esp
f011870d:	68 f0 bf 12 f0       	push   $0xf012bff0
f0118712:	e8 55 88 fe ff       	call   f0100f6c <cprintf>
f0118717:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011871a:	e8 3f be fe ff       	call   f010455e <pf_calculate_free_frames>
f011871f:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0118722:	74 17                	je     f011873b <test_kmalloc+0x510>
f0118724:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011872b:	83 ec 0c             	sub    $0xc,%esp
f011872e:	68 40 bf 12 f0       	push   $0xf012bf40
f0118733:	e8 34 88 fe ff       	call   f0100f6c <cprintf>
f0118738:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011873b:	e8 e7 4f ff ff       	call   f010d727 <sys_calculate_free_frames>
f0118740:	89 c2                	mov    %eax,%edx
f0118742:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0118745:	29 d0                	sub    %edx,%eax
f0118747:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011874c:	7f 17                	jg     f0118765 <test_kmalloc+0x53a>
f011874e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118755:	83 ec 0c             	sub    $0xc,%esp
f0118758:	68 ac bf 12 f0       	push   $0xf012bfac
f011875d:	e8 0a 88 fe ff       	call   f0100f6c <cprintf>
f0118762:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118765:	e8 bd 4f ff ff       	call   f010d727 <sys_calculate_free_frames>
f011876a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011876d:	e8 ec bd fe ff       	call   f010455e <pf_calculate_free_frames>
f0118772:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f0118775:	83 ec 0c             	sub    $0xc,%esp
f0118778:	68 00 38 00 00       	push   $0x3800
f011877d:	e8 52 00 ff ff       	call   f01087d4 <kmalloc>
f0118782:	83 c4 10             	add    $0x10,%esp
f0118785:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011878b:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0118791:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0118796:	74 17                	je     f01187af <test_kmalloc+0x584>
f0118798:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011879f:	83 ec 0c             	sub    $0xc,%esp
f01187a2:	68 f0 bf 12 f0       	push   $0xf012bff0
f01187a7:	e8 c0 87 fe ff       	call   f0100f6c <cprintf>
f01187ac:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01187af:	e8 aa bd fe ff       	call   f010455e <pf_calculate_free_frames>
f01187b4:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01187b7:	74 17                	je     f01187d0 <test_kmalloc+0x5a5>
f01187b9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01187c0:	83 ec 0c             	sub    $0xc,%esp
f01187c3:	68 40 bf 12 f0       	push   $0xf012bf40
f01187c8:	e8 9f 87 fe ff       	call   f0100f6c <cprintf>
f01187cd:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 4) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f01187d0:	e8 52 4f ff ff       	call   f010d727 <sys_calculate_free_frames>
f01187d5:	89 c2                	mov    %eax,%edx
f01187d7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01187da:	29 d0                	sub    %edx,%eax
f01187dc:	83 f8 03             	cmp    $0x3,%eax
f01187df:	7f 17                	jg     f01187f8 <test_kmalloc+0x5cd>
f01187e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01187e8:	83 ec 0c             	sub    $0xc,%esp
f01187eb:	68 ac bf 12 f0       	push   $0xf012bfac
f01187f0:	e8 77 87 fe ff       	call   f0100f6c <cprintf>
f01187f5:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f01187f8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01187fc:	74 04                	je     f0118802 <test_kmalloc+0x5d7>
f01187fe:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f0118802:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Checking read/write on the allocated spaces
	{

		freeFrames = (int)sys_calculate_free_frames() ;
f0118809:	e8 19 4f ff ff       	call   f010d727 <sys_calculate_free_frames>
f011880e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118811:	e8 48 bd fe ff       	call   f010455e <pf_calculate_free_frames>
f0118816:	89 45 d0             	mov    %eax,-0x30(%ebp)

		//Write values
		//In 1st 2 MB
		lastIndexOfByte = (2*Mega-kilo)/sizeof(char) - 1;
f0118819:	c7 45 c8 ff fb 1f 00 	movl   $0x1ffbff,-0x38(%ebp)
		byteArr = (char *) ptr_allocations[0];
f0118820:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0118826:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		byteArr[0] = minByte ;
f0118829:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011882c:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011882f:	88 10                	mov    %dl,(%eax)
		byteArr[lastIndexOfByte] = maxByte ;
f0118831:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0118834:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118837:	01 c2                	add    %eax,%edx
f0118839:	8a 45 ea             	mov    -0x16(%ebp),%al
f011883c:	88 02                	mov    %al,(%edx)

		//In 2nd 2 MB
		shortArr = (short *) ptr_allocations[1];
f011883e:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0118844:	89 45 c0             	mov    %eax,-0x40(%ebp)
		lastIndexOfShort = (2*Mega-kilo)/sizeof(short) - 1;
f0118847:	c7 45 bc ff fd 0f 00 	movl   $0xffdff,-0x44(%ebp)
		shortArr[0] = minShort;
f011884e:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0118851:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0118854:	66 89 02             	mov    %ax,(%edx)
		shortArr[lastIndexOfShort] = maxShort;
f0118857:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011885a:	01 c0                	add    %eax,%eax
f011885c:	89 c2                	mov    %eax,%edx
f011885e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118861:	01 c2                	add    %eax,%edx
f0118863:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0118867:	66 89 02             	mov    %ax,(%edx)

		//In Dynamic Allocator Area
		{
			//In 2 KB - 1
			intArr = (int *) ptr_allocations[2];
f011886a:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0118870:	89 45 b8             	mov    %eax,-0x48(%ebp)
			lastIndexOfInt = (2*kilo-1)/sizeof(int) - 1;
f0118873:	c7 45 b4 fe 01 00 00 	movl   $0x1fe,-0x4c(%ebp)
			intArr[0] = minInt;
f011887a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011887d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0118880:	89 10                	mov    %edx,(%eax)
			intArr[lastIndexOfInt] = maxInt;
f0118882:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0118885:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011888c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011888f:	01 c2                	add    %eax,%edx
f0118891:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118894:	89 02                	mov    %eax,(%edx)

			//In 2 KB - 1
			byteArr2 = (char *) ptr_allocations[3];
f0118896:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011889c:	89 45 b0             	mov    %eax,-0x50(%ebp)
			lastIndexOfByte2 = (2*kilo-1)/sizeof(char) - 1;
f011889f:	c7 45 ac fe 07 00 00 	movl   $0x7fe,-0x54(%ebp)
			byteArr2[0] = minByte;
f01188a6:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01188a9:	8a 55 eb             	mov    -0x15(%ebp),%dl
f01188ac:	88 10                	mov    %dl,(%eax)
			byteArr2[lastIndexOfByte2] = maxByte;
f01188ae:	8b 55 ac             	mov    -0x54(%ebp),%edx
f01188b1:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01188b4:	01 c2                	add    %eax,%edx
f01188b6:	8a 45 ea             	mov    -0x16(%ebp),%al
f01188b9:	88 02                	mov    %al,(%edx)
		}

		//In 7 KB
		structArr = (struct MyStruct *) ptr_allocations[4];
f01188bb:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f01188c1:	89 45 a8             	mov    %eax,-0x58(%ebp)
		lastIndexOfStruct = (7*kilo)/sizeof(struct MyStruct) - 1;
f01188c4:	c7 45 a4 7f 03 00 00 	movl   $0x37f,-0x5c(%ebp)
		structArr[0].a = minByte; structArr[0].b = minShort; structArr[0].c = minInt;
f01188cb:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01188ce:	8a 55 eb             	mov    -0x15(%ebp),%dl
f01188d1:	88 10                	mov    %dl,(%eax)
f01188d3:	8b 55 a8             	mov    -0x58(%ebp),%edx
f01188d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01188d9:	66 89 42 02          	mov    %ax,0x2(%edx)
f01188dd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01188e0:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01188e3:	89 50 04             	mov    %edx,0x4(%eax)
		structArr[lastIndexOfStruct].a = maxByte; structArr[lastIndexOfStruct].b = maxShort; structArr[lastIndexOfStruct].c = maxInt;
f01188e6:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01188e9:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01188f0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01188f3:	01 c2                	add    %eax,%edx
f01188f5:	8a 45 ea             	mov    -0x16(%ebp),%al
f01188f8:	88 02                	mov    %al,(%edx)
f01188fa:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01188fd:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0118904:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118907:	01 c2                	add    %eax,%edx
f0118909:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f011890d:	66 89 42 02          	mov    %ax,0x2(%edx)
f0118911:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118914:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011891b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011891e:	01 c2                	add    %eax,%edx
f0118920:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118923:	89 42 04             	mov    %eax,0x4(%edx)

		//In 6 MB
		lastIndexOfByte3 = (6*Mega-kilo)/sizeof(char) - 1;
f0118926:	c7 45 a0 ff fb 5f 00 	movl   $0x5ffbff,-0x60(%ebp)
		byteArr3 = (char *) ptr_allocations[6];
f011892d:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0118933:	89 45 9c             	mov    %eax,-0x64(%ebp)
		byteArr3[0] = minByte ;
f0118936:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118939:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011893c:	88 10                	mov    %dl,(%eax)
		byteArr3[lastIndexOfByte3 / 2] = maxByte / 2;
f011893e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118941:	89 c2                	mov    %eax,%edx
f0118943:	c1 ea 1f             	shr    $0x1f,%edx
f0118946:	01 d0                	add    %edx,%eax
f0118948:	d1 f8                	sar    %eax
f011894a:	89 c2                	mov    %eax,%edx
f011894c:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011894f:	01 c2                	add    %eax,%edx
f0118951:	8a 45 ea             	mov    -0x16(%ebp),%al
f0118954:	88 c1                	mov    %al,%cl
f0118956:	c0 e9 07             	shr    $0x7,%cl
f0118959:	01 c8                	add    %ecx,%eax
f011895b:	d0 f8                	sar    %al
f011895d:	88 02                	mov    %al,(%edx)
		byteArr3[lastIndexOfByte3] = maxByte ;
f011895f:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0118962:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118965:	01 c2                	add    %eax,%edx
f0118967:	8a 45 ea             	mov    -0x16(%ebp),%al
f011896a:	88 02                	mov    %al,(%edx)

		//In 14 KB
		shortArr2 = (short *) ptr_allocations[7];
f011896c:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0118972:	89 45 98             	mov    %eax,-0x68(%ebp)
		lastIndexOfShort2 = (14*kilo)/sizeof(short) - 1;
f0118975:	c7 45 94 ff 1b 00 00 	movl   $0x1bff,-0x6c(%ebp)
		shortArr2[0] = minShort;
f011897c:	8b 55 98             	mov    -0x68(%ebp),%edx
f011897f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0118982:	66 89 02             	mov    %ax,(%edx)
		shortArr2[lastIndexOfShort2] = maxShort;
f0118985:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0118988:	01 c0                	add    %eax,%eax
f011898a:	89 c2                	mov    %eax,%edx
f011898c:	8b 45 98             	mov    -0x68(%ebp),%eax
f011898f:	01 c2                	add    %eax,%edx
f0118991:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0118995:	66 89 02             	mov    %ax,(%edx)

		//Read values: check that the values are successfully written
		if (byteArr[0] 	!= minByte 	|| byteArr[lastIndexOfByte] 	!= maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0118998:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011899b:	8a 00                	mov    (%eax),%al
f011899d:	3a 45 eb             	cmp    -0x15(%ebp),%al
f01189a0:	75 0f                	jne    f01189b1 <test_kmalloc+0x786>
f01189a2:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01189a5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01189a8:	01 d0                	add    %edx,%eax
f01189aa:	8a 00                	mov    (%eax),%al
f01189ac:	3a 45 ea             	cmp    -0x16(%ebp),%al
f01189af:	74 17                	je     f01189c8 <test_kmalloc+0x79d>
f01189b1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01189b8:	83 ec 0c             	sub    $0xc,%esp
f01189bb:	68 c8 c0 12 f0       	push   $0xf012c0c8
f01189c0:	e8 a7 85 fe ff       	call   f0100f6c <cprintf>
f01189c5:	83 c4 10             	add    $0x10,%esp
		if (shortArr[0] != minShort || shortArr[lastIndexOfShort] 	!= maxShort) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f01189c8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01189cb:	66 8b 00             	mov    (%eax),%ax
f01189ce:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f01189d2:	75 15                	jne    f01189e9 <test_kmalloc+0x7be>
f01189d4:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01189d7:	01 c0                	add    %eax,%eax
f01189d9:	89 c2                	mov    %eax,%edx
f01189db:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01189de:	01 d0                	add    %edx,%eax
f01189e0:	66 8b 00             	mov    (%eax),%ax
f01189e3:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f01189e7:	74 17                	je     f0118a00 <test_kmalloc+0x7d5>
f01189e9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01189f0:	83 ec 0c             	sub    $0xc,%esp
f01189f3:	68 c8 c0 12 f0       	push   $0xf012c0c8
f01189f8:	e8 6f 85 fe ff       	call   f0100f6c <cprintf>
f01189fd:	83 c4 10             	add    $0x10,%esp
		if (intArr[0] 	!= minInt 	|| intArr[lastIndexOfInt] 		!= maxInt) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0118a00:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118a03:	8b 00                	mov    (%eax),%eax
f0118a05:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0118a08:	75 16                	jne    f0118a20 <test_kmalloc+0x7f5>
f0118a0a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0118a0d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0118a14:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118a17:	01 d0                	add    %edx,%eax
f0118a19:	8b 00                	mov    (%eax),%eax
f0118a1b:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0118a1e:	74 17                	je     f0118a37 <test_kmalloc+0x80c>
f0118a20:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a27:	83 ec 0c             	sub    $0xc,%esp
f0118a2a:	68 c8 c0 12 f0       	push   $0xf012c0c8
f0118a2f:	e8 38 85 fe ff       	call   f0100f6c <cprintf>
f0118a34:	83 c4 10             	add    $0x10,%esp
		if (byteArr2[0] != minByte || byteArr2[lastIndexOfByte2] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0118a37:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0118a3a:	8a 00                	mov    (%eax),%al
f0118a3c:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0118a3f:	75 0f                	jne    f0118a50 <test_kmalloc+0x825>
f0118a41:	8b 55 ac             	mov    -0x54(%ebp),%edx
f0118a44:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0118a47:	01 d0                	add    %edx,%eax
f0118a49:	8a 00                	mov    (%eax),%al
f0118a4b:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0118a4e:	74 17                	je     f0118a67 <test_kmalloc+0x83c>
f0118a50:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a57:	83 ec 0c             	sub    $0xc,%esp
f0118a5a:	68 c8 c0 12 f0       	push   $0xf012c0c8
f0118a5f:	e8 08 85 fe ff       	call   f0100f6c <cprintf>
f0118a64:	83 c4 10             	add    $0x10,%esp

		if (structArr[0].a != minByte 	|| structArr[lastIndexOfStruct].a != maxByte) 	{ correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0118a67:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118a6a:	8a 00                	mov    (%eax),%al
f0118a6c:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0118a6f:	75 16                	jne    f0118a87 <test_kmalloc+0x85c>
f0118a71:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118a74:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0118a7b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118a7e:	01 d0                	add    %edx,%eax
f0118a80:	8a 00                	mov    (%eax),%al
f0118a82:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0118a85:	74 17                	je     f0118a9e <test_kmalloc+0x873>
f0118a87:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a8e:	83 ec 0c             	sub    $0xc,%esp
f0118a91:	68 c8 c0 12 f0       	push   $0xf012c0c8
f0118a96:	e8 d1 84 fe ff       	call   f0100f6c <cprintf>
f0118a9b:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].b != minShort 	|| structArr[lastIndexOfStruct].b != maxShort) 	{ correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0118a9e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118aa1:	66 8b 40 02          	mov    0x2(%eax),%ax
f0118aa5:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0118aa9:	75 19                	jne    f0118ac4 <test_kmalloc+0x899>
f0118aab:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118aae:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0118ab5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118ab8:	01 d0                	add    %edx,%eax
f0118aba:	66 8b 40 02          	mov    0x2(%eax),%ax
f0118abe:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0118ac2:	74 17                	je     f0118adb <test_kmalloc+0x8b0>
f0118ac4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118acb:	83 ec 0c             	sub    $0xc,%esp
f0118ace:	68 c8 c0 12 f0       	push   $0xf012c0c8
f0118ad3:	e8 94 84 fe ff       	call   f0100f6c <cprintf>
f0118ad8:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].c != minInt 	|| structArr[lastIndexOfStruct].c != maxInt) 	{ correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0118adb:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118ade:	8b 40 04             	mov    0x4(%eax),%eax
f0118ae1:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0118ae4:	75 17                	jne    f0118afd <test_kmalloc+0x8d2>
f0118ae6:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118ae9:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0118af0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118af3:	01 d0                	add    %edx,%eax
f0118af5:	8b 40 04             	mov    0x4(%eax),%eax
f0118af8:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0118afb:	74 17                	je     f0118b14 <test_kmalloc+0x8e9>
f0118afd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b04:	83 ec 0c             	sub    $0xc,%esp
f0118b07:	68 c8 c0 12 f0       	push   $0xf012c0c8
f0118b0c:	e8 5b 84 fe ff       	call   f0100f6c <cprintf>
f0118b11:	83 c4 10             	add    $0x10,%esp

		if (byteArr3[0] != minByte || byteArr3[lastIndexOfByte3/2] != maxByte/2 || byteArr3[lastIndexOfByte3] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0118b14:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118b17:	8a 00                	mov    (%eax),%al
f0118b19:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0118b1c:	75 34                	jne    f0118b52 <test_kmalloc+0x927>
f0118b1e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118b21:	89 c2                	mov    %eax,%edx
f0118b23:	c1 ea 1f             	shr    $0x1f,%edx
f0118b26:	01 d0                	add    %edx,%eax
f0118b28:	d1 f8                	sar    %eax
f0118b2a:	89 c2                	mov    %eax,%edx
f0118b2c:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118b2f:	01 d0                	add    %edx,%eax
f0118b31:	8a 10                	mov    (%eax),%dl
f0118b33:	8a 45 ea             	mov    -0x16(%ebp),%al
f0118b36:	88 c1                	mov    %al,%cl
f0118b38:	c0 e9 07             	shr    $0x7,%cl
f0118b3b:	01 c8                	add    %ecx,%eax
f0118b3d:	d0 f8                	sar    %al
f0118b3f:	38 c2                	cmp    %al,%dl
f0118b41:	75 0f                	jne    f0118b52 <test_kmalloc+0x927>
f0118b43:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0118b46:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118b49:	01 d0                	add    %edx,%eax
f0118b4b:	8a 00                	mov    (%eax),%al
f0118b4d:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0118b50:	74 17                	je     f0118b69 <test_kmalloc+0x93e>
f0118b52:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b59:	83 ec 0c             	sub    $0xc,%esp
f0118b5c:	68 c8 c0 12 f0       	push   $0xf012c0c8
f0118b61:	e8 06 84 fe ff       	call   f0100f6c <cprintf>
f0118b66:	83 c4 10             	add    $0x10,%esp
		if (shortArr2[0] != minShort || shortArr2[lastIndexOfShort2] != maxShort) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0118b69:	8b 45 98             	mov    -0x68(%ebp),%eax
f0118b6c:	66 8b 00             	mov    (%eax),%ax
f0118b6f:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0118b73:	75 15                	jne    f0118b8a <test_kmalloc+0x95f>
f0118b75:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0118b78:	01 c0                	add    %eax,%eax
f0118b7a:	89 c2                	mov    %eax,%edx
f0118b7c:	8b 45 98             	mov    -0x68(%ebp),%eax
f0118b7f:	01 d0                	add    %edx,%eax
f0118b81:	66 8b 00             	mov    (%eax),%ax
f0118b84:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0118b88:	74 17                	je     f0118ba1 <test_kmalloc+0x976>
f0118b8a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b91:	83 ec 0c             	sub    $0xc,%esp
f0118b94:	68 c8 c0 12 f0       	push   $0xf012c0c8
f0118b99:	e8 ce 83 fe ff       	call   f0100f6c <cprintf>
f0118b9e:	83 c4 10             	add    $0x10,%esp

		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118ba1:	e8 81 4b ff ff       	call   f010d727 <sys_calculate_free_frames>
f0118ba6:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0118ba9:	74 17                	je     f0118bc2 <test_kmalloc+0x997>
f0118bab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118bb2:	83 ec 0c             	sub    $0xc,%esp
f0118bb5:	68 ac bf 12 f0       	push   $0xf012bfac
f0118bba:	e8 ad 83 fe ff       	call   f0100f6c <cprintf>
f0118bbf:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118bc2:	e8 97 b9 fe ff       	call   f010455e <pf_calculate_free_frames>
f0118bc7:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0118bca:	74 17                	je     f0118be3 <test_kmalloc+0x9b8>
f0118bcc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118bd3:	83 ec 0c             	sub    $0xc,%esp
f0118bd6:	68 40 bf 12 f0       	push   $0xf012bf40
f0118bdb:	e8 8c 83 fe ff       	call   f0100f6c <cprintf>
f0118be0:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=30 ;
f0118be3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118be7:	74 04                	je     f0118bed <test_kmalloc+0x9c2>
f0118be9:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	correct = 1 ;
f0118bed:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Insufficient space again
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f0118bf4:	e8 2e 4b ff ff       	call   f010d727 <sys_calculate_free_frames>
f0118bf9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118bfc:	e8 5d b9 fe ff       	call   f010455e <pf_calculate_free_frames>
f0118c01:	89 45 d0             	mov    %eax,-0x30(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 2*PAGE_SIZE) - (2*Mega+2*Mega+/*4*kilo+4*kilo+*/8*kilo+3*Mega+6*Mega+16*kilo) ;
f0118c04:	c7 45 90 00 a0 2f 07 	movl   $0x72fa000,-0x70(%ebp)
		ptr_allocations[8] = kmalloc(restOfKHeap);
f0118c0b:	83 ec 0c             	sub    $0xc,%esp
f0118c0e:	ff 75 90             	pushl  -0x70(%ebp)
f0118c11:	e8 be fb fe ff       	call   f01087d4 <kmalloc>
f0118c16:	83 c4 10             	add    $0x10,%esp
f0118c19:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		if (ptr_allocations[8] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f0118c1f:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0118c25:	85 c0                	test   %eax,%eax
f0118c27:	74 17                	je     f0118c40 <test_kmalloc+0xa15>
f0118c29:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c30:	83 ec 0c             	sub    $0xc,%esp
f0118c33:	68 0c bf 12 f0       	push   $0xf012bf0c
f0118c38:	e8 2f 83 fe ff       	call   f0100f6c <cprintf>
f0118c3d:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118c40:	e8 19 b9 fe ff       	call   f010455e <pf_calculate_free_frames>
f0118c45:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0118c48:	74 17                	je     f0118c61 <test_kmalloc+0xa36>
f0118c4a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c51:	83 ec 0c             	sub    $0xc,%esp
f0118c54:	68 40 bf 12 f0       	push   $0xf012bf40
f0118c59:	e8 0e 83 fe ff       	call   f0100f6c <cprintf>
f0118c5e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118c61:	e8 c1 4a ff ff       	call   f010d727 <sys_calculate_free_frames>
f0118c66:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0118c69:	74 17                	je     f0118c82 <test_kmalloc+0xa57>
f0118c6b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c72:	83 ec 0c             	sub    $0xc,%esp
f0118c75:	68 ac bf 12 f0       	push   $0xf012bfac
f0118c7a:	e8 ed 82 fe ff       	call   f0100f6c <cprintf>
f0118c7f:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118c82:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118c86:	74 04                	je     f0118c8c <test_kmalloc+0xa61>
f0118c88:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0118c8c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//permissions
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
f0118c93:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0118c99:	05 00 40 00 00       	add    $0x4000,%eax
f0118c9e:	89 45 8c             	mov    %eax,-0x74(%ebp)
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f0118ca1:	c7 45 ec 00 10 00 f8 	movl   $0xf8001000,-0x14(%ebp)
f0118ca8:	eb 6a                	jmp    f0118d14 <test_kmalloc+0xae9>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, va, &table);
f0118caa:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0118caf:	83 ec 04             	sub    $0x4,%esp
f0118cb2:	8d 95 34 ff ff ff    	lea    -0xcc(%ebp),%edx
f0118cb8:	52                   	push   %edx
f0118cb9:	ff 75 ec             	pushl  -0x14(%ebp)
f0118cbc:	50                   	push   %eax
f0118cbd:	e8 69 f4 fe ff       	call   f010812b <get_page_table>
f0118cc2:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f0118cc5:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f0118ccb:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0118cce:	c1 ea 0c             	shr    $0xc,%edx
f0118cd1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0118cd7:	c1 e2 02             	shl    $0x2,%edx
f0118cda:	01 d0                	add    %edx,%eax
f0118cdc:	8b 00                	mov    (%eax),%eax
f0118cde:	25 ff 0f 00 00       	and    $0xfff,%eax
f0118ce3:	89 45 88             	mov    %eax,-0x78(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f0118ce6:	8b 45 88             	mov    -0x78(%ebp),%eax
f0118ce9:	83 e0 04             	and    $0x4,%eax
f0118cec:	85 c0                	test   %eax,%eax
f0118cee:	74 1d                	je     f0118d0d <test_kmalloc+0xae2>
			{
				if (correct)
f0118cf0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118cf4:	74 17                	je     f0118d0d <test_kmalloc+0xae2>
				{
					correct = 0; cprintf("Wrong permissions: pages should be mapped with Supervisor permission only\n");
f0118cf6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118cfd:	83 ec 0c             	sub    $0xc,%esp
f0118d00:	68 00 c1 12 f0       	push   $0xf012c100
f0118d05:	e8 62 82 fe ff       	call   f0100f6c <cprintf>
f0118d0a:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//permissions
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f0118d0d:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f0118d14:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118d17:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0118d1a:	72 8e                	jb     f0118caa <test_kmalloc+0xa7f>
					correct = 0; cprintf("Wrong permissions: pages should be mapped with Supervisor permission only\n");
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f0118d1c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118d20:	74 04                	je     f0118d26 <test_kmalloc+0xafb>
f0118d22:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\ntest kmalloc completed. Evaluation = %d%\n", eval);
f0118d26:	83 ec 08             	sub    $0x8,%esp
f0118d29:	ff 75 f4             	pushl  -0xc(%ebp)
f0118d2c:	68 4c c1 12 f0       	push   $0xf012c14c
f0118d31:	e8 36 82 fe ff       	call   f0100f6c <cprintf>
f0118d36:	83 c4 10             	add    $0x10,%esp

	return 1;
f0118d39:	b8 01 00 00 00       	mov    $0x1,%eax

}
f0118d3e:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0118d41:	5b                   	pop    %ebx
f0118d42:	5f                   	pop    %edi
f0118d43:	5d                   	pop    %ebp
f0118d44:	c3                   	ret    

f0118d45 <test_kmalloc_firstfit1>:


int test_kmalloc_firstfit1()
{
f0118d45:	55                   	push   %ebp
f0118d46:	89 e5                	mov    %esp,%ebp
f0118d48:	57                   	push   %edi
f0118d49:	83 ec 64             	sub    $0x64,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0118d4c:	83 ec 0c             	sub    $0xc,%esp
f0118d4f:	68 80 be 12 f0       	push   $0xf012be80
f0118d54:	e8 13 82 fe ff       	call   f0100f6c <cprintf>
f0118d59:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0118d5c:	83 ec 0c             	sub    $0xc,%esp
f0118d5f:	68 b0 be 12 f0       	push   $0xf012beb0
f0118d64:	e8 03 82 fe ff       	call   f0100f6c <cprintf>
f0118d69:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0118d6c:	83 ec 0c             	sub    $0xc,%esp
f0118d6f:	68 80 be 12 f0       	push   $0xf012be80
f0118d74:	e8 f3 81 fe ff       	call   f0100f6c <cprintf>
f0118d79:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f0118d7c:	8d 55 98             	lea    -0x68(%ebp),%edx
f0118d7f:	b9 14 00 00 00       	mov    $0x14,%ecx
f0118d84:	b8 00 00 00 00       	mov    $0x0,%eax
f0118d89:	89 d7                	mov    %edx,%edi
f0118d8b:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 freeFrames;
	uint32 freeDiskFrames;
	int eval = 0;
f0118d8d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0118d94:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0118d9b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Allocate all
	{
		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118da2:	e8 80 49 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0118da7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118daa:	e8 af b7 fe ff       	call   f010455e <pf_calculate_free_frames>
f0118daf:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(1*Mega-kilo);
f0118db2:	83 ec 0c             	sub    $0xc,%esp
f0118db5:	68 00 fc 0f 00       	push   $0xffc00
f0118dba:	e8 15 fa fe ff       	call   f01087d4 <kmalloc>
f0118dbf:	83 c4 10             	add    $0x10,%esp
f0118dc2:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0118dc5:	8b 45 98             	mov    -0x68(%ebp),%eax
f0118dc8:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118dcd:	74 17                	je     f0118de6 <test_kmalloc_firstfit1+0xa1>
f0118dcf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118dd6:	83 ec 0c             	sub    $0xc,%esp
f0118dd9:	68 78 c1 12 f0       	push   $0xf012c178
f0118dde:	e8 89 81 fe ff       	call   f0100f6c <cprintf>
f0118de3:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118de6:	e8 73 b7 fe ff       	call   f010455e <pf_calculate_free_frames>
f0118deb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118dee:	74 17                	je     f0118e07 <test_kmalloc_firstfit1+0xc2>
f0118df0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118df7:	83 ec 0c             	sub    $0xc,%esp
f0118dfa:	68 40 bf 12 f0       	push   $0xf012bf40
f0118dff:	e8 68 81 fe ff       	call   f0100f6c <cprintf>
f0118e04:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f0118e07:	e8 1b 49 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0118e0c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0118e0f:	29 c2                	sub    %eax,%edx
f0118e11:	89 d0                	mov    %edx,%eax
f0118e13:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118e18:	77 17                	ja     f0118e31 <test_kmalloc_firstfit1+0xec>
f0118e1a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e21:	83 ec 0c             	sub    $0xc,%esp
f0118e24:	68 a9 c1 12 f0       	push   $0xf012c1a9
f0118e29:	e8 3e 81 fe ff       	call   f0100f6c <cprintf>
f0118e2e:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118e31:	e8 f1 48 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0118e36:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118e39:	e8 20 b7 fe ff       	call   f010455e <pf_calculate_free_frames>
f0118e3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(1*Mega-kilo);
f0118e41:	83 ec 0c             	sub    $0xc,%esp
f0118e44:	68 00 fc 0f 00       	push   $0xffc00
f0118e49:	e8 86 f9 fe ff       	call   f01087d4 <kmalloc>
f0118e4e:	83 c4 10             	add    $0x10,%esp
f0118e51:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0118e54:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118e57:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f0118e5c:	74 17                	je     f0118e75 <test_kmalloc_firstfit1+0x130>
f0118e5e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e65:	83 ec 0c             	sub    $0xc,%esp
f0118e68:	68 78 c1 12 f0       	push   $0xf012c178
f0118e6d:	e8 fa 80 fe ff       	call   f0100f6c <cprintf>
f0118e72:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118e75:	e8 e4 b6 fe ff       	call   f010455e <pf_calculate_free_frames>
f0118e7a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118e7d:	74 17                	je     f0118e96 <test_kmalloc_firstfit1+0x151>
f0118e7f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e86:	83 ec 0c             	sub    $0xc,%esp
f0118e89:	68 40 bf 12 f0       	push   $0xf012bf40
f0118e8e:	e8 d9 80 fe ff       	call   f0100f6c <cprintf>
f0118e93:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f0118e96:	e8 8c 48 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0118e9b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0118e9e:	29 c2                	sub    %eax,%edx
f0118ea0:	89 d0                	mov    %edx,%eax
f0118ea2:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118ea7:	77 17                	ja     f0118ec0 <test_kmalloc_firstfit1+0x17b>
f0118ea9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118eb0:	83 ec 0c             	sub    $0xc,%esp
f0118eb3:	68 a9 c1 12 f0       	push   $0xf012c1a9
f0118eb8:	e8 af 80 fe ff       	call   f0100f6c <cprintf>
f0118ebd:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118ec0:	e8 62 48 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0118ec5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118ec8:	e8 91 b6 fe ff       	call   f010455e <pf_calculate_free_frames>
f0118ecd:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*Mega-kilo);
f0118ed0:	83 ec 0c             	sub    $0xc,%esp
f0118ed3:	68 00 fc 0f 00       	push   $0xffc00
f0118ed8:	e8 f7 f8 fe ff       	call   f01087d4 <kmalloc>
f0118edd:	83 c4 10             	add    $0x10,%esp
f0118ee0:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0118ee3:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118ee6:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0118eeb:	74 17                	je     f0118f04 <test_kmalloc_firstfit1+0x1bf>
f0118eed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ef4:	83 ec 0c             	sub    $0xc,%esp
f0118ef7:	68 78 c1 12 f0       	push   $0xf012c178
f0118efc:	e8 6b 80 fe ff       	call   f0100f6c <cprintf>
f0118f01:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118f04:	e8 55 b6 fe ff       	call   f010455e <pf_calculate_free_frames>
f0118f09:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118f0c:	74 17                	je     f0118f25 <test_kmalloc_firstfit1+0x1e0>
f0118f0e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118f15:	83 ec 0c             	sub    $0xc,%esp
f0118f18:	68 40 bf 12 f0       	push   $0xf012bf40
f0118f1d:	e8 4a 80 fe ff       	call   f0100f6c <cprintf>
f0118f22:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f0118f25:	e8 fd 47 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0118f2a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0118f2d:	29 c2                	sub    %eax,%edx
f0118f2f:	89 d0                	mov    %edx,%eax
f0118f31:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118f36:	77 17                	ja     f0118f4f <test_kmalloc_firstfit1+0x20a>
f0118f38:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118f3f:	83 ec 0c             	sub    $0xc,%esp
f0118f42:	68 a9 c1 12 f0       	push   $0xf012c1a9
f0118f47:	e8 20 80 fe ff       	call   f0100f6c <cprintf>
f0118f4c:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118f4f:	e8 d3 47 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0118f54:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118f57:	e8 02 b6 fe ff       	call   f010455e <pf_calculate_free_frames>
f0118f5c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(1*Mega-kilo);
f0118f5f:	83 ec 0c             	sub    $0xc,%esp
f0118f62:	68 00 fc 0f 00       	push   $0xffc00
f0118f67:	e8 68 f8 fe ff       	call   f01087d4 <kmalloc>
f0118f6c:	83 c4 10             	add    $0x10,%esp
f0118f6f:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] != (ACTUAL_START + 3*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0118f72:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118f75:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f0118f7a:	74 17                	je     f0118f93 <test_kmalloc_firstfit1+0x24e>
f0118f7c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118f83:	83 ec 0c             	sub    $0xc,%esp
f0118f86:	68 78 c1 12 f0       	push   $0xf012c178
f0118f8b:	e8 dc 7f fe ff       	call   f0100f6c <cprintf>
f0118f90:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118f93:	e8 c6 b5 fe ff       	call   f010455e <pf_calculate_free_frames>
f0118f98:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118f9b:	74 17                	je     f0118fb4 <test_kmalloc_firstfit1+0x26f>
f0118f9d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118fa4:	83 ec 0c             	sub    $0xc,%esp
f0118fa7:	68 40 bf 12 f0       	push   $0xf012bf40
f0118fac:	e8 bb 7f fe ff       	call   f0100f6c <cprintf>
f0118fb1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f0118fb4:	e8 6e 47 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0118fb9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0118fbc:	29 c2                	sub    %eax,%edx
f0118fbe:	89 d0                	mov    %edx,%eax
f0118fc0:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118fc5:	77 17                	ja     f0118fde <test_kmalloc_firstfit1+0x299>
f0118fc7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118fce:	83 ec 0c             	sub    $0xc,%esp
f0118fd1:	68 a9 c1 12 f0       	push   $0xf012c1a9
f0118fd6:	e8 91 7f fe ff       	call   f0100f6c <cprintf>
f0118fdb:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118fde:	e8 44 47 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0118fe3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118fe6:	e8 73 b5 fe ff       	call   f010455e <pf_calculate_free_frames>
f0118feb:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(2*Mega-kilo);
f0118fee:	83 ec 0c             	sub    $0xc,%esp
f0118ff1:	68 00 fc 1f 00       	push   $0x1ffc00
f0118ff6:	e8 d9 f7 fe ff       	call   f01087d4 <kmalloc>
f0118ffb:	83 c4 10             	add    $0x10,%esp
f0118ffe:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0119001:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0119004:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0119009:	74 17                	je     f0119022 <test_kmalloc_firstfit1+0x2dd>
f011900b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119012:	83 ec 0c             	sub    $0xc,%esp
f0119015:	68 78 c1 12 f0       	push   $0xf012c178
f011901a:	e8 4d 7f fe ff       	call   f0100f6c <cprintf>
f011901f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119022:	e8 37 b5 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119027:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011902a:	74 17                	je     f0119043 <test_kmalloc_firstfit1+0x2fe>
f011902c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119033:	83 ec 0c             	sub    $0xc,%esp
f0119036:	68 40 bf 12 f0       	push   $0xf012bf40
f011903b:	e8 2c 7f fe ff       	call   f0100f6c <cprintf>
f0119040:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: \n"); }
f0119043:	e8 df 46 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119048:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011904b:	29 c2                	sub    %eax,%edx
f011904d:	89 d0                	mov    %edx,%eax
f011904f:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119054:	77 17                	ja     f011906d <test_kmalloc_firstfit1+0x328>
f0119056:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011905d:	83 ec 0c             	sub    $0xc,%esp
f0119060:	68 a9 c1 12 f0       	push   $0xf012c1a9
f0119065:	e8 02 7f fe ff       	call   f0100f6c <cprintf>
f011906a:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011906d:	e8 b5 46 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119072:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119075:	e8 e4 b4 fe ff       	call   f010455e <pf_calculate_free_frames>
f011907a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(2*Mega-kilo);
f011907d:	83 ec 0c             	sub    $0xc,%esp
f0119080:	68 00 fc 1f 00       	push   $0x1ffc00
f0119085:	e8 4a f7 fe ff       	call   f01087d4 <kmalloc>
f011908a:	83 c4 10             	add    $0x10,%esp
f011908d:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 6*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0119090:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0119093:	3d 00 10 60 f8       	cmp    $0xf8601000,%eax
f0119098:	74 17                	je     f01190b1 <test_kmalloc_firstfit1+0x36c>
f011909a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01190a1:	83 ec 0c             	sub    $0xc,%esp
f01190a4:	68 78 c1 12 f0       	push   $0xf012c178
f01190a9:	e8 be 7e fe ff       	call   f0100f6c <cprintf>
f01190ae:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01190b1:	e8 a8 b4 fe ff       	call   f010455e <pf_calculate_free_frames>
f01190b6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01190b9:	74 17                	je     f01190d2 <test_kmalloc_firstfit1+0x38d>
f01190bb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01190c2:	83 ec 0c             	sub    $0xc,%esp
f01190c5:	68 40 bf 12 f0       	push   $0xf012bf40
f01190ca:	e8 9d 7e fe ff       	call   f0100f6c <cprintf>
f01190cf:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: \n"); }
f01190d2:	e8 50 46 ff ff       	call   f010d727 <sys_calculate_free_frames>
f01190d7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01190da:	29 c2                	sub    %eax,%edx
f01190dc:	89 d0                	mov    %edx,%eax
f01190de:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01190e3:	77 17                	ja     f01190fc <test_kmalloc_firstfit1+0x3b7>
f01190e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01190ec:	83 ec 0c             	sub    $0xc,%esp
f01190ef:	68 a9 c1 12 f0       	push   $0xf012c1a9
f01190f4:	e8 73 7e fe ff       	call   f0100f6c <cprintf>
f01190f9:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01190fc:	e8 26 46 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119101:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119104:	e8 55 b4 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119109:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011910c:	83 ec 0c             	sub    $0xc,%esp
f011910f:	68 00 fc 2f 00       	push   $0x2ffc00
f0119114:	e8 bb f6 fe ff       	call   f01087d4 <kmalloc>
f0119119:	83 c4 10             	add    $0x10,%esp
f011911c:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] !=  (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011911f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119122:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0119127:	74 17                	je     f0119140 <test_kmalloc_firstfit1+0x3fb>
f0119129:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119130:	83 ec 0c             	sub    $0xc,%esp
f0119133:	68 78 c1 12 f0       	push   $0xf012c178
f0119138:	e8 2f 7e fe ff       	call   f0100f6c <cprintf>
f011913d:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119140:	e8 19 b4 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119145:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119148:	74 17                	je     f0119161 <test_kmalloc_firstfit1+0x41c>
f011914a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119151:	83 ec 0c             	sub    $0xc,%esp
f0119154:	68 40 bf 12 f0       	push   $0xf012bf40
f0119159:	e8 0e 7e fe ff       	call   f0100f6c <cprintf>
f011915e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: \n"); }
f0119161:	e8 c1 45 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119166:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0119169:	29 c2                	sub    %eax,%edx
f011916b:	89 d0                	mov    %edx,%eax
f011916d:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119172:	77 17                	ja     f011918b <test_kmalloc_firstfit1+0x446>
f0119174:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011917b:	83 ec 0c             	sub    $0xc,%esp
f011917e:	68 a9 c1 12 f0       	push   $0xf012c1a9
f0119183:	e8 e4 7d fe ff       	call   f0100f6c <cprintf>
f0119188:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011918b:	e8 97 45 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119190:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119193:	e8 c6 b3 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119198:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(3*Mega-kilo);
f011919b:	83 ec 0c             	sub    $0xc,%esp
f011919e:	68 00 fc 2f 00       	push   $0x2ffc00
f01191a3:	e8 2c f6 fe ff       	call   f01087d4 <kmalloc>
f01191a8:	83 c4 10             	add    $0x10,%esp
f01191ab:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 11*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f01191ae:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01191b1:	3d 00 10 b0 f8       	cmp    $0xf8b01000,%eax
f01191b6:	74 17                	je     f01191cf <test_kmalloc_firstfit1+0x48a>
f01191b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01191bf:	83 ec 0c             	sub    $0xc,%esp
f01191c2:	68 78 c1 12 f0       	push   $0xf012c178
f01191c7:	e8 a0 7d fe ff       	call   f0100f6c <cprintf>
f01191cc:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01191cf:	e8 8a b3 fe ff       	call   f010455e <pf_calculate_free_frames>
f01191d4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01191d7:	74 17                	je     f01191f0 <test_kmalloc_firstfit1+0x4ab>
f01191d9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01191e0:	83 ec 0c             	sub    $0xc,%esp
f01191e3:	68 40 bf 12 f0       	push   $0xf012bf40
f01191e8:	e8 7f 7d fe ff       	call   f0100f6c <cprintf>
f01191ed:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: \n"); }
f01191f0:	e8 32 45 ff ff       	call   f010d727 <sys_calculate_free_frames>
f01191f5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01191f8:	29 c2                	sub    %eax,%edx
f01191fa:	89 d0                	mov    %edx,%eax
f01191fc:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119201:	77 17                	ja     f011921a <test_kmalloc_firstfit1+0x4d5>
f0119203:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011920a:	83 ec 0c             	sub    $0xc,%esp
f011920d:	68 a9 c1 12 f0       	push   $0xf012c1a9
f0119212:	e8 55 7d fe ff       	call   f0100f6c <cprintf>
f0119217:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011921a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011921e:	74 04                	je     f0119224 <test_kmalloc_firstfit1+0x4df>
f0119220:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0119224:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Free some to create holes
	{
		//1 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011922b:	e8 f7 44 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119230:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119233:	e8 26 b3 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119238:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f011923b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011923e:	83 ec 0c             	sub    $0xc,%esp
f0119241:	50                   	push   %eax
f0119242:	e8 a7 f5 fe ff       	call   f01087ee <kfree>
f0119247:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011924a:	e8 0f b3 fe ff       	call   f010455e <pf_calculate_free_frames>
f011924f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119252:	74 17                	je     f011926b <test_kmalloc_firstfit1+0x526>
f0119254:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011925b:	83 ec 0c             	sub    $0xc,%esp
f011925e:	68 40 bf 12 f0       	push   $0xf012bf40
f0119263:	e8 04 7d fe ff       	call   f0100f6c <cprintf>
f0119268:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("Wrong free: \n"); }
f011926b:	e8 b7 44 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119270:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0119273:	3d ff 00 00 00       	cmp    $0xff,%eax
f0119278:	77 17                	ja     f0119291 <test_kmalloc_firstfit1+0x54c>
f011927a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119281:	83 ec 0c             	sub    $0xc,%esp
f0119284:	68 bd c1 12 f0       	push   $0xf012c1bd
f0119289:	e8 de 7c fe ff       	call   f0100f6c <cprintf>
f011928e:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0119291:	e8 91 44 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119296:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119299:	e8 c0 b2 fe ff       	call   f010455e <pf_calculate_free_frames>
f011929e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[4]);
f01192a1:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01192a4:	83 ec 0c             	sub    $0xc,%esp
f01192a7:	50                   	push   %eax
f01192a8:	e8 41 f5 fe ff       	call   f01087ee <kfree>
f01192ad:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01192b0:	e8 a9 b2 fe ff       	call   f010455e <pf_calculate_free_frames>
f01192b5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01192b8:	74 17                	je     f01192d1 <test_kmalloc_firstfit1+0x58c>
f01192ba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01192c1:	83 ec 0c             	sub    $0xc,%esp
f01192c4:	68 40 bf 12 f0       	push   $0xf012bf40
f01192c9:	e8 9e 7c fe ff       	call   f0100f6c <cprintf>
f01192ce:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong free: \n"); }
f01192d1:	e8 51 44 ff ff       	call   f010d727 <sys_calculate_free_frames>
f01192d6:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01192d9:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01192de:	77 17                	ja     f01192f7 <test_kmalloc_firstfit1+0x5b2>
f01192e0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01192e7:	83 ec 0c             	sub    $0xc,%esp
f01192ea:	68 bd c1 12 f0       	push   $0xf012c1bd
f01192ef:	e8 78 7c fe ff       	call   f0100f6c <cprintf>
f01192f4:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01192f7:	e8 2b 44 ff ff       	call   f010d727 <sys_calculate_free_frames>
f01192fc:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01192ff:	e8 5a b2 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119304:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f0119307:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011930a:	83 ec 0c             	sub    $0xc,%esp
f011930d:	50                   	push   %eax
f011930e:	e8 db f4 fe ff       	call   f01087ee <kfree>
f0119313:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119316:	e8 43 b2 fe ff       	call   f010455e <pf_calculate_free_frames>
f011931b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011931e:	74 17                	je     f0119337 <test_kmalloc_firstfit1+0x5f2>
f0119320:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119327:	83 ec 0c             	sub    $0xc,%esp
f011932a:	68 40 bf 12 f0       	push   $0xf012bf40
f011932f:	e8 38 7c fe ff       	call   f0100f6c <cprintf>
f0119334:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("Wrong free: \n"); }
f0119337:	e8 eb 43 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011933c:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011933f:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119344:	77 17                	ja     f011935d <test_kmalloc_firstfit1+0x618>
f0119346:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011934d:	83 ec 0c             	sub    $0xc,%esp
f0119350:	68 bd c1 12 f0       	push   $0xf012c1bd
f0119355:	e8 12 7c fe ff       	call   f0100f6c <cprintf>
f011935a:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011935d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0119361:	74 04                	je     f0119367 <test_kmalloc_firstfit1+0x622>
f0119363:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0119367:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[3] Allocate again [test first fit]
	{
		//Allocate 512 KB - should be placed in 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011936e:	e8 b4 43 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119373:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119376:	e8 e3 b1 fe ff       	call   f010455e <pf_calculate_free_frames>
f011937b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(512*kilo - kilo);
f011937e:	83 ec 0c             	sub    $0xc,%esp
f0119381:	68 00 fc 07 00       	push   $0x7fc00
f0119386:	e8 49 f4 fe ff       	call   f01087d4 <kmalloc>
f011938b:	83 c4 10             	add    $0x10,%esp
f011938e:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0119391:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119394:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f0119399:	74 17                	je     f01193b2 <test_kmalloc_firstfit1+0x66d>
f011939b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01193a2:	83 ec 0c             	sub    $0xc,%esp
f01193a5:	68 78 c1 12 f0       	push   $0xf012c178
f01193aa:	e8 bd 7b fe ff       	call   f0100f6c <cprintf>
f01193af:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01193b2:	e8 a7 b1 fe ff       	call   f010455e <pf_calculate_free_frames>
f01193b7:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01193ba:	74 17                	je     f01193d3 <test_kmalloc_firstfit1+0x68e>
f01193bc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01193c3:	83 ec 0c             	sub    $0xc,%esp
f01193c6:	68 40 bf 12 f0       	push   $0xf012bf40
f01193cb:	e8 9c 7b fe ff       	call   f0100f6c <cprintf>
f01193d0:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 128) { correct = 0; cprintf("Wrong allocation: \n"); }
f01193d3:	e8 4f 43 ff ff       	call   f010d727 <sys_calculate_free_frames>
f01193d8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01193db:	29 c2                	sub    %eax,%edx
f01193dd:	89 d0                	mov    %edx,%eax
f01193df:	83 f8 7f             	cmp    $0x7f,%eax
f01193e2:	77 17                	ja     f01193fb <test_kmalloc_firstfit1+0x6b6>
f01193e4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01193eb:	83 ec 0c             	sub    $0xc,%esp
f01193ee:	68 a9 c1 12 f0       	push   $0xf012c1a9
f01193f3:	e8 74 7b fe ff       	call   f0100f6c <cprintf>
f01193f8:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB - should be placed in 2nd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01193fb:	e8 27 43 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119400:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119403:	e8 56 b1 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119408:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(1*Mega - kilo);
f011940b:	83 ec 0c             	sub    $0xc,%esp
f011940e:	68 00 fc 0f 00       	push   $0xffc00
f0119413:	e8 bc f3 fe ff       	call   f01087d4 <kmalloc>
f0119418:	83 c4 10             	add    $0x10,%esp
f011941b:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011941e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119421:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0119426:	74 17                	je     f011943f <test_kmalloc_firstfit1+0x6fa>
f0119428:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011942f:	83 ec 0c             	sub    $0xc,%esp
f0119432:	68 78 c1 12 f0       	push   $0xf012c178
f0119437:	e8 30 7b fe ff       	call   f0100f6c <cprintf>
f011943c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011943f:	e8 1a b1 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119444:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119447:	74 17                	je     f0119460 <test_kmalloc_firstfit1+0x71b>
f0119449:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119450:	83 ec 0c             	sub    $0xc,%esp
f0119453:	68 40 bf 12 f0       	push   $0xf012bf40
f0119458:	e8 0f 7b fe ff       	call   f0100f6c <cprintf>
f011945d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f0119460:	e8 c2 42 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119465:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0119468:	29 c2                	sub    %eax,%edx
f011946a:	89 d0                	mov    %edx,%eax
f011946c:	3d ff 00 00 00       	cmp    $0xff,%eax
f0119471:	77 17                	ja     f011948a <test_kmalloc_firstfit1+0x745>
f0119473:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011947a:	83 ec 0c             	sub    $0xc,%esp
f011947d:	68 a9 c1 12 f0       	push   $0xf012c1a9
f0119482:	e8 e5 7a fe ff       	call   f0100f6c <cprintf>
f0119487:	83 c4 10             	add    $0x10,%esp


		//Allocate 256 KB - should be placed in remaining of 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011948a:	e8 98 42 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011948f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119492:	e8 c7 b0 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119497:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(256*kilo - kilo);
f011949a:	83 ec 0c             	sub    $0xc,%esp
f011949d:	68 00 fc 03 00       	push   $0x3fc00
f01194a2:	e8 2d f3 fe ff       	call   f01087d4 <kmalloc>
f01194a7:	83 c4 10             	add    $0x10,%esp
f01194aa:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 1*Mega + 512*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f01194ad:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01194b0:	3d 00 10 18 f8       	cmp    $0xf8181000,%eax
f01194b5:	74 17                	je     f01194ce <test_kmalloc_firstfit1+0x789>
f01194b7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01194be:	83 ec 0c             	sub    $0xc,%esp
f01194c1:	68 78 c1 12 f0       	push   $0xf012c178
f01194c6:	e8 a1 7a fe ff       	call   f0100f6c <cprintf>
f01194cb:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01194ce:	e8 8b b0 fe ff       	call   f010455e <pf_calculate_free_frames>
f01194d3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01194d6:	74 17                	je     f01194ef <test_kmalloc_firstfit1+0x7aa>
f01194d8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01194df:	83 ec 0c             	sub    $0xc,%esp
f01194e2:	68 40 bf 12 f0       	push   $0xf012bf40
f01194e7:	e8 80 7a fe ff       	call   f0100f6c <cprintf>
f01194ec:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 64) { correct = 0; cprintf("Wrong allocation: \n"); }
f01194ef:	e8 33 42 ff ff       	call   f010d727 <sys_calculate_free_frames>
f01194f4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01194f7:	29 c2                	sub    %eax,%edx
f01194f9:	89 d0                	mov    %edx,%eax
f01194fb:	83 f8 3f             	cmp    $0x3f,%eax
f01194fe:	77 17                	ja     f0119517 <test_kmalloc_firstfit1+0x7d2>
f0119500:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119507:	83 ec 0c             	sub    $0xc,%esp
f011950a:	68 a9 c1 12 f0       	push   $0xf012c1a9
f011950f:	e8 58 7a fe ff       	call   f0100f6c <cprintf>
f0119514:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB - should be placed in 3rd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0119517:	e8 0b 42 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011951c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011951f:	e8 3a b0 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119524:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*Mega);
f0119527:	83 ec 0c             	sub    $0xc,%esp
f011952a:	68 00 00 20 00       	push   $0x200000
f011952f:	e8 a0 f2 fe ff       	call   f01087d4 <kmalloc>
f0119534:	83 c4 10             	add    $0x10,%esp
f0119537:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((uint32) ptr_allocations[11] != (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011953a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011953d:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0119542:	74 17                	je     f011955b <test_kmalloc_firstfit1+0x816>
f0119544:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011954b:	83 ec 0c             	sub    $0xc,%esp
f011954e:	68 78 c1 12 f0       	push   $0xf012c178
f0119553:	e8 14 7a fe ff       	call   f0100f6c <cprintf>
f0119558:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: \n"); }
f011955b:	e8 c7 41 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119560:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0119563:	29 c2                	sub    %eax,%edx
f0119565:	89 d0                	mov    %edx,%eax
f0119567:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011956c:	77 17                	ja     f0119585 <test_kmalloc_firstfit1+0x840>
f011956e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119575:	83 ec 0c             	sub    $0xc,%esp
f0119578:	68 a9 c1 12 f0       	push   $0xf012c1a9
f011957d:	e8 ea 79 fe ff       	call   f0100f6c <cprintf>
f0119582:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119585:	e8 d4 af fe ff       	call   f010455e <pf_calculate_free_frames>
f011958a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011958d:	74 17                	je     f01195a6 <test_kmalloc_firstfit1+0x861>
f011958f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119596:	83 ec 0c             	sub    $0xc,%esp
f0119599:	68 40 bf 12 f0       	push   $0xf012bf40
f011959e:	e8 c9 79 fe ff       	call   f0100f6c <cprintf>
f01195a3:	83 c4 10             	add    $0x10,%esp


		//Allocate 4 MB - should be placed in end of all allocations
		freeFrames = (int)sys_calculate_free_frames() ;
f01195a6:	e8 7c 41 ff ff       	call   f010d727 <sys_calculate_free_frames>
f01195ab:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01195ae:	e8 ab af fe ff       	call   f010455e <pf_calculate_free_frames>
f01195b3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(4*Mega - kilo);
f01195b6:	83 ec 0c             	sub    $0xc,%esp
f01195b9:	68 00 fc 3f 00       	push   $0x3ffc00
f01195be:	e8 11 f2 fe ff       	call   f01087d4 <kmalloc>
f01195c3:	83 c4 10             	add    $0x10,%esp
f01195c6:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((uint32) ptr_allocations[12] != (ACTUAL_START + 14*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f01195c9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01195cc:	3d 00 10 e0 f8       	cmp    $0xf8e01000,%eax
f01195d1:	74 17                	je     f01195ea <test_kmalloc_firstfit1+0x8a5>
f01195d3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01195da:	83 ec 0c             	sub    $0xc,%esp
f01195dd:	68 78 c1 12 f0       	push   $0xf012c178
f01195e2:	e8 85 79 fe ff       	call   f0100f6c <cprintf>
f01195e7:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01195ea:	e8 6f af fe ff       	call   f010455e <pf_calculate_free_frames>
f01195ef:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01195f2:	74 17                	je     f011960b <test_kmalloc_firstfit1+0x8c6>
f01195f4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01195fb:	83 ec 0c             	sub    $0xc,%esp
f01195fe:	68 40 bf 12 f0       	push   $0xf012bf40
f0119603:	e8 64 79 fe ff       	call   f0100f6c <cprintf>
f0119608:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1024) { correct = 0; cprintf("Wrong allocation: \n"); }
f011960b:	e8 17 41 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119610:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0119613:	29 c2                	sub    %eax,%edx
f0119615:	89 d0                	mov    %edx,%eax
f0119617:	3d ff 03 00 00       	cmp    $0x3ff,%eax
f011961c:	77 17                	ja     f0119635 <test_kmalloc_firstfit1+0x8f0>
f011961e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119625:	83 ec 0c             	sub    $0xc,%esp
f0119628:	68 a9 c1 12 f0       	push   $0xf012c1a9
f011962d:	e8 3a 79 fe ff       	call   f0100f6c <cprintf>
f0119632:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f0119635:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0119639:	74 04                	je     f011963f <test_kmalloc_firstfit1+0x8fa>
f011963b:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f011963f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[4] Free contiguous allocations
	{
		//1 MB Hole appended to previous 256 KB hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0119646:	e8 dc 40 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011964b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011964e:	e8 0b af fe ff       	call   f010455e <pf_calculate_free_frames>
f0119653:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f0119656:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0119659:	83 ec 0c             	sub    $0xc,%esp
f011965c:	50                   	push   %eax
f011965d:	e8 8c f1 fe ff       	call   f01087ee <kfree>
f0119662:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119665:	e8 f4 ae fe ff       	call   f010455e <pf_calculate_free_frames>
f011966a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011966d:	74 17                	je     f0119686 <test_kmalloc_firstfit1+0x941>
f011966f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119676:	83 ec 0c             	sub    $0xc,%esp
f0119679:	68 40 bf 12 f0       	push   $0xf012bf40
f011967e:	e8 e9 78 fe ff       	call   f0100f6c <cprintf>
f0119683:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("Wrong free: \n"); }
f0119686:	e8 9c 40 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011968b:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011968e:	3d ff 00 00 00       	cmp    $0xff,%eax
f0119693:	77 17                	ja     f01196ac <test_kmalloc_firstfit1+0x967>
f0119695:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011969c:	83 ec 0c             	sub    $0xc,%esp
f011969f:	68 bd c1 12 f0       	push   $0xf012c1bd
f01196a4:	e8 c3 78 fe ff       	call   f0100f6c <cprintf>
f01196a9:	83 c4 10             	add    $0x10,%esp

		//Next 1 MB Hole appended also
		freeFrames = (int)sys_calculate_free_frames() ;
f01196ac:	e8 76 40 ff ff       	call   f010d727 <sys_calculate_free_frames>
f01196b1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01196b4:	e8 a5 ae fe ff       	call   f010455e <pf_calculate_free_frames>
f01196b9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f01196bc:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01196bf:	83 ec 0c             	sub    $0xc,%esp
f01196c2:	50                   	push   %eax
f01196c3:	e8 26 f1 fe ff       	call   f01087ee <kfree>
f01196c8:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01196cb:	e8 8e ae fe ff       	call   f010455e <pf_calculate_free_frames>
f01196d0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01196d3:	74 17                	je     f01196ec <test_kmalloc_firstfit1+0x9a7>
f01196d5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01196dc:	83 ec 0c             	sub    $0xc,%esp
f01196df:	68 40 bf 12 f0       	push   $0xf012bf40
f01196e4:	e8 83 78 fe ff       	call   f0100f6c <cprintf>
f01196e9:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("Wrong free: \n"); }
f01196ec:	e8 36 40 ff ff       	call   f010d727 <sys_calculate_free_frames>
f01196f1:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01196f4:	3d ff 00 00 00       	cmp    $0xff,%eax
f01196f9:	77 17                	ja     f0119712 <test_kmalloc_firstfit1+0x9cd>
f01196fb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119702:	83 ec 0c             	sub    $0xc,%esp
f0119705:	68 bd c1 12 f0       	push   $0xf012c1bd
f011970a:	e8 5d 78 fe ff       	call   f0100f6c <cprintf>
f011970f:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0119712:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0119716:	74 04                	je     f011971c <test_kmalloc_firstfit1+0x9d7>
f0119718:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f011971c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[5] Allocate again [test first fit]
	{
		//[FIRST FIT Case]
		//Allocate 1 MB - should be placed in the contiguous hole (256 KB + 2 MB)
		freeFrames = (int)sys_calculate_free_frames() ;
f0119723:	e8 ff 3f ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119728:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011972b:	e8 2e ae fe ff       	call   f010455e <pf_calculate_free_frames>
f0119730:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[13] = kmalloc(1*Mega);
f0119733:	83 ec 0c             	sub    $0xc,%esp
f0119736:	68 00 00 10 00       	push   $0x100000
f011973b:	e8 94 f0 fe ff       	call   f01087d4 <kmalloc>
f0119740:	83 c4 10             	add    $0x10,%esp
f0119743:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((uint32) ptr_allocations[13] != (ACTUAL_START + 1*Mega + 768*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0119746:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119749:	3d 00 10 1c f8       	cmp    $0xf81c1000,%eax
f011974e:	74 17                	je     f0119767 <test_kmalloc_firstfit1+0xa22>
f0119750:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119757:	83 ec 0c             	sub    $0xc,%esp
f011975a:	68 78 c1 12 f0       	push   $0xf012c178
f011975f:	e8 08 78 fe ff       	call   f0100f6c <cprintf>
f0119764:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119767:	e8 f2 ad fe ff       	call   f010455e <pf_calculate_free_frames>
f011976c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011976f:	74 17                	je     f0119788 <test_kmalloc_firstfit1+0xa43>
f0119771:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119778:	83 ec 0c             	sub    $0xc,%esp
f011977b:	68 40 bf 12 f0       	push   $0xf012bf40
f0119780:	e8 e7 77 fe ff       	call   f0100f6c <cprintf>
f0119785:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f0119788:	e8 9a 3f ff ff       	call   f010d727 <sys_calculate_free_frames>
f011978d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0119790:	29 c2                	sub    %eax,%edx
f0119792:	89 d0                	mov    %edx,%eax
f0119794:	3d ff 00 00 00       	cmp    $0xff,%eax
f0119799:	77 17                	ja     f01197b2 <test_kmalloc_firstfit1+0xa6d>
f011979b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01197a2:	83 ec 0c             	sub    $0xc,%esp
f01197a5:	68 a9 c1 12 f0       	push   $0xf012c1a9
f01197aa:	e8 bd 77 fe ff       	call   f0100f6c <cprintf>
f01197af:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f01197b2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01197b6:	74 04                	je     f01197bc <test_kmalloc_firstfit1+0xa77>
f01197b8:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (1) completed. Eval = %d%\n", eval);
f01197bc:	83 ec 08             	sub    $0x8,%esp
f01197bf:	ff 75 f4             	pushl  -0xc(%ebp)
f01197c2:	68 cc c1 12 f0       	push   $0xf012c1cc
f01197c7:	e8 a0 77 fe ff       	call   f0100f6c <cprintf>
f01197cc:	83 c4 10             	add    $0x10,%esp

	return 1;
f01197cf:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01197d4:	8b 7d fc             	mov    -0x4(%ebp),%edi
f01197d7:	c9                   	leave  
f01197d8:	c3                   	ret    

f01197d9 <test_kmalloc_firstfit2>:

int test_kmalloc_firstfit2()
{
f01197d9:	55                   	push   %ebp
f01197da:	89 e5                	mov    %esp,%ebp
f01197dc:	57                   	push   %edi
f01197dd:	53                   	push   %ebx
f01197de:	83 ec 60             	sub    $0x60,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f01197e1:	83 ec 0c             	sub    $0xc,%esp
f01197e4:	68 80 be 12 f0       	push   $0xf012be80
f01197e9:	e8 7e 77 fe ff       	call   f0100f6c <cprintf>
f01197ee:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f01197f1:	83 ec 0c             	sub    $0xc,%esp
f01197f4:	68 b0 be 12 f0       	push   $0xf012beb0
f01197f9:	e8 6e 77 fe ff       	call   f0100f6c <cprintf>
f01197fe:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0119801:	83 ec 0c             	sub    $0xc,%esp
f0119804:	68 80 be 12 f0       	push   $0xf012be80
f0119809:	e8 5e 77 fe ff       	call   f0100f6c <cprintf>
f011980e:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f0119811:	8d 55 98             	lea    -0x68(%ebp),%edx
f0119814:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119819:	b8 00 00 00 00       	mov    $0x0,%eax
f011981e:	89 d7                	mov    %edx,%edi
f0119820:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 freeFrames;
	uint32 freeDiskFrames;
	int eval = 0;
f0119822:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0119829:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0119830:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Attempt to allocate more than heap size
	{
		ptr_allocations[0] = kmalloc(KERNEL_HEAP_MAX - ACTUAL_START + 1);
f0119837:	83 ec 0c             	sub    $0xc,%esp
f011983a:	68 01 e0 ff 07       	push   $0x7ffe001
f011983f:	e8 90 ef fe ff       	call   f01087d4 <kmalloc>
f0119844:	83 c4 10             	add    $0x10,%esp
f0119847:	89 45 98             	mov    %eax,-0x68(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("kmalloc: Attempt to allocate more than heap size, should return NULL\n"); }
f011984a:	8b 45 98             	mov    -0x68(%ebp),%eax
f011984d:	85 c0                	test   %eax,%eax
f011984f:	74 17                	je     f0119868 <test_kmalloc_firstfit2+0x8f>
f0119851:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119858:	83 ec 0c             	sub    $0xc,%esp
f011985b:	68 04 c2 12 f0       	push   $0xf012c204
f0119860:	e8 07 77 fe ff       	call   f0100f6c <cprintf>
f0119865:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0119868:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011986c:	74 04                	je     f0119872 <test_kmalloc_firstfit2+0x99>
f011986e:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0119872:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Attempt to allocate space more than any available fragment
	//	a) Create Fragments
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0119879:	e8 a9 3e ff ff       	call   f010d727 <sys_calculate_free_frames>
f011987e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119881:	e8 d8 ac fe ff       	call   f010455e <pf_calculate_free_frames>
f0119886:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0119889:	83 ec 0c             	sub    $0xc,%esp
f011988c:	68 00 fc 1f 00       	push   $0x1ffc00
f0119891:	e8 3e ef fe ff       	call   f01087d4 <kmalloc>
f0119896:	83 c4 10             	add    $0x10,%esp
f0119899:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011989c:	8b 45 98             	mov    -0x68(%ebp),%eax
f011989f:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f01198a4:	74 17                	je     f01198bd <test_kmalloc_firstfit2+0xe4>
f01198a6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01198ad:	83 ec 0c             	sub    $0xc,%esp
f01198b0:	68 78 c1 12 f0       	push   $0xf012c178
f01198b5:	e8 b2 76 fe ff       	call   f0100f6c <cprintf>
f01198ba:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01198bd:	e8 9c ac fe ff       	call   f010455e <pf_calculate_free_frames>
f01198c2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01198c5:	74 17                	je     f01198de <test_kmalloc_firstfit2+0x105>
f01198c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01198ce:	83 ec 0c             	sub    $0xc,%esp
f01198d1:	68 40 bf 12 f0       	push   $0xf012bf40
f01198d6:	e8 91 76 fe ff       	call   f0100f6c <cprintf>
f01198db:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: \n"); }
f01198de:	e8 44 3e ff ff       	call   f010d727 <sys_calculate_free_frames>
f01198e3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01198e6:	29 c2                	sub    %eax,%edx
f01198e8:	89 d0                	mov    %edx,%eax
f01198ea:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01198ef:	77 17                	ja     f0119908 <test_kmalloc_firstfit2+0x12f>
f01198f1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01198f8:	83 ec 0c             	sub    $0xc,%esp
f01198fb:	68 a9 c1 12 f0       	push   $0xf012c1a9
f0119900:	e8 67 76 fe ff       	call   f0100f6c <cprintf>
f0119905:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0119908:	e8 1a 3e ff ff       	call   f010d727 <sys_calculate_free_frames>
f011990d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119910:	e8 49 ac fe ff       	call   f010455e <pf_calculate_free_frames>
f0119915:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0119918:	83 ec 0c             	sub    $0xc,%esp
f011991b:	68 00 fc 1f 00       	push   $0x1ffc00
f0119920:	e8 af ee fe ff       	call   f01087d4 <kmalloc>
f0119925:	83 c4 10             	add    $0x10,%esp
f0119928:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011992b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011992e:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0119933:	74 17                	je     f011994c <test_kmalloc_firstfit2+0x173>
f0119935:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011993c:	83 ec 0c             	sub    $0xc,%esp
f011993f:	68 78 c1 12 f0       	push   $0xf012c178
f0119944:	e8 23 76 fe ff       	call   f0100f6c <cprintf>
f0119949:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011994c:	e8 0d ac fe ff       	call   f010455e <pf_calculate_free_frames>
f0119951:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119954:	74 17                	je     f011996d <test_kmalloc_firstfit2+0x194>
f0119956:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011995d:	83 ec 0c             	sub    $0xc,%esp
f0119960:	68 40 bf 12 f0       	push   $0xf012bf40
f0119965:	e8 02 76 fe ff       	call   f0100f6c <cprintf>
f011996a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: \n"); }
f011996d:	e8 b5 3d ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119972:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0119975:	29 c2                	sub    %eax,%edx
f0119977:	89 d0                	mov    %edx,%eax
f0119979:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011997e:	77 17                	ja     f0119997 <test_kmalloc_firstfit2+0x1be>
f0119980:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119987:	83 ec 0c             	sub    $0xc,%esp
f011998a:	68 a9 c1 12 f0       	push   $0xf012c1a9
f011998f:	e8 d8 75 fe ff       	call   f0100f6c <cprintf>
f0119994:	83 c4 10             	add    $0x10,%esp

		//1 KB (should be allocated by dynamic allocator not page allocator)
		freeFrames = (int)sys_calculate_free_frames() ;
f0119997:	e8 8b 3d ff ff       	call   f010d727 <sys_calculate_free_frames>
f011999c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011999f:	e8 ba ab fe ff       	call   f010455e <pf_calculate_free_frames>
f01199a4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*kilo);
f01199a7:	83 ec 0c             	sub    $0xc,%esp
f01199aa:	68 00 04 00 00       	push   $0x400
f01199af:	e8 20 ee fe ff       	call   f01087d4 <kmalloc>
f01199b4:	83 c4 10             	add    $0x10,%esp
f01199b7:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f01199ba:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01199bd:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01199c2:	76 22                	jbe    f01199e6 <test_kmalloc_firstfit2+0x20d>
f01199c4:	8b 5d a0             	mov    -0x60(%ebp),%ebx
f01199c7:	83 ec 0c             	sub    $0xc,%esp
f01199ca:	6a 00                	push   $0x0
f01199cc:	e8 f9 ed fe ff       	call   f01087ca <sbrk>
f01199d1:	83 c4 10             	add    $0x10,%esp
f01199d4:	39 c3                	cmp    %eax,%ebx
f01199d6:	73 0e                	jae    f01199e6 <test_kmalloc_firstfit2+0x20d>
f01199d8:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01199db:	89 c2                	mov    %eax,%edx
f01199dd:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f01199e2:	39 c2                	cmp    %eax,%edx
f01199e4:	72 17                	jb     f01199fd <test_kmalloc_firstfit2+0x224>
		{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01199e6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01199ed:	83 ec 0c             	sub    $0xc,%esp
f01199f0:	68 40 c0 12 f0       	push   $0xf012c040
f01199f5:	e8 72 75 fe ff       	call   f0100f6c <cprintf>
f01199fa:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01199fd:	e8 5c ab fe ff       	call   f010455e <pf_calculate_free_frames>
f0119a02:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119a05:	74 17                	je     f0119a1e <test_kmalloc_firstfit2+0x245>
f0119a07:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119a0e:	83 ec 0c             	sub    $0xc,%esp
f0119a11:	68 40 bf 12 f0       	push   $0xf012bf40
f0119a16:	e8 51 75 fe ff       	call   f0100f6c <cprintf>
f0119a1b:	83 c4 10             	add    $0x10,%esp
		//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

		//2 KB (should be allocated by dynamic allocator not page allocator)
		freeFrames = (int)sys_calculate_free_frames() ;
f0119a1e:	e8 04 3d ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119a23:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119a26:	e8 33 ab fe ff       	call   f010455e <pf_calculate_free_frames>
f0119a2b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(2*kilo);
f0119a2e:	83 ec 0c             	sub    $0xc,%esp
f0119a31:	68 00 08 00 00       	push   $0x800
f0119a36:	e8 99 ed fe ff       	call   f01087d4 <kmalloc>
f0119a3b:	83 c4 10             	add    $0x10,%esp
f0119a3e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0119a41:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0119a44:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119a49:	76 22                	jbe    f0119a6d <test_kmalloc_firstfit2+0x294>
f0119a4b:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f0119a4e:	83 ec 0c             	sub    $0xc,%esp
f0119a51:	6a 00                	push   $0x0
f0119a53:	e8 72 ed fe ff       	call   f01087ca <sbrk>
f0119a58:	83 c4 10             	add    $0x10,%esp
f0119a5b:	39 c3                	cmp    %eax,%ebx
f0119a5d:	73 0e                	jae    f0119a6d <test_kmalloc_firstfit2+0x294>
f0119a5f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0119a62:	89 c2                	mov    %eax,%edx
f0119a64:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f0119a69:	39 c2                	cmp    %eax,%edx
f0119a6b:	72 17                	jb     f0119a84 <test_kmalloc_firstfit2+0x2ab>
		{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119a6d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119a74:	83 ec 0c             	sub    $0xc,%esp
f0119a77:	68 40 c0 12 f0       	push   $0xf012c040
f0119a7c:	e8 eb 74 fe ff       	call   f0100f6c <cprintf>
f0119a81:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119a84:	e8 d5 aa fe ff       	call   f010455e <pf_calculate_free_frames>
f0119a89:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119a8c:	74 17                	je     f0119aa5 <test_kmalloc_firstfit2+0x2cc>
f0119a8e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119a95:	83 ec 0c             	sub    $0xc,%esp
f0119a98:	68 40 bf 12 f0       	push   $0xf012bf40
f0119a9d:	e8 ca 74 fe ff       	call   f0100f6c <cprintf>
f0119aa2:	83 c4 10             	add    $0x10,%esp
		//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

		//1 KB (should be allocated by dynamic allocator not page allocator)
		freeFrames = (int)sys_calculate_free_frames() ;
f0119aa5:	e8 7d 3c ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119aaa:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119aad:	e8 ac aa fe ff       	call   f010455e <pf_calculate_free_frames>
f0119ab2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(1*kilo);
f0119ab5:	83 ec 0c             	sub    $0xc,%esp
f0119ab8:	68 00 04 00 00       	push   $0x400
f0119abd:	e8 12 ed fe ff       	call   f01087d4 <kmalloc>
f0119ac2:	83 c4 10             	add    $0x10,%esp
f0119ac5:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f0119ac8:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0119acb:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119ad0:	76 22                	jbe    f0119af4 <test_kmalloc_firstfit2+0x31b>
f0119ad2:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0119ad5:	83 ec 0c             	sub    $0xc,%esp
f0119ad8:	6a 00                	push   $0x0
f0119ada:	e8 eb ec fe ff       	call   f01087ca <sbrk>
f0119adf:	83 c4 10             	add    $0x10,%esp
f0119ae2:	39 c3                	cmp    %eax,%ebx
f0119ae4:	73 0e                	jae    f0119af4 <test_kmalloc_firstfit2+0x31b>
f0119ae6:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0119ae9:	89 c2                	mov    %eax,%edx
f0119aeb:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f0119af0:	39 c2                	cmp    %eax,%edx
f0119af2:	72 17                	jb     f0119b0b <test_kmalloc_firstfit2+0x332>
		{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119af4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119afb:	83 ec 0c             	sub    $0xc,%esp
f0119afe:	68 40 c0 12 f0       	push   $0xf012c040
f0119b03:	e8 64 74 fe ff       	call   f0100f6c <cprintf>
f0119b08:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119b0b:	e8 4e aa fe ff       	call   f010455e <pf_calculate_free_frames>
f0119b10:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119b13:	74 17                	je     f0119b2c <test_kmalloc_firstfit2+0x353>
f0119b15:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119b1c:	83 ec 0c             	sub    $0xc,%esp
f0119b1f:	68 40 bf 12 f0       	push   $0xf012bf40
f0119b24:	e8 43 74 fe ff       	call   f0100f6c <cprintf>
f0119b29:	83 c4 10             	add    $0x10,%esp
		//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

		//1 KB Hole in Dynamic Allocator Area
		freeFrames = (int)sys_calculate_free_frames() ;
f0119b2c:	e8 f6 3b ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119b31:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119b34:	e8 25 aa fe ff       	call   f010455e <pf_calculate_free_frames>
f0119b39:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f0119b3c:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0119b3f:	83 ec 0c             	sub    $0xc,%esp
f0119b42:	50                   	push   %eax
f0119b43:	e8 a6 ec fe ff       	call   f01087ee <kfree>
f0119b48:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119b4b:	e8 0e aa fe ff       	call   f010455e <pf_calculate_free_frames>
f0119b50:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119b53:	74 17                	je     f0119b6c <test_kmalloc_firstfit2+0x393>
f0119b55:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119b5c:	83 ec 0c             	sub    $0xc,%esp
f0119b5f:	68 40 bf 12 f0       	push   $0xf012bf40
f0119b64:	e8 03 74 fe ff       	call   f0100f6c <cprintf>
f0119b69:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0119b6c:	e8 b6 3b ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119b71:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119b74:	74 17                	je     f0119b8d <test_kmalloc_firstfit2+0x3b4>
f0119b76:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119b7d:	83 ec 0c             	sub    $0xc,%esp
f0119b80:	68 4c c2 12 f0       	push   $0xf012c24c
f0119b85:	e8 e2 73 fe ff       	call   f0100f6c <cprintf>
f0119b8a:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0119b8d:	e8 95 3b ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119b92:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119b95:	e8 c4 a9 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119b9a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f0119b9d:	83 ec 0c             	sub    $0xc,%esp
f0119ba0:	68 00 1c 00 00       	push   $0x1c00
f0119ba5:	e8 2a ec fe ff       	call   f01087d4 <kmalloc>
f0119baa:	83 c4 10             	add    $0x10,%esp
f0119bad:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0119bb0:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0119bb3:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0119bb8:	74 17                	je     f0119bd1 <test_kmalloc_firstfit2+0x3f8>
f0119bba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119bc1:	83 ec 0c             	sub    $0xc,%esp
f0119bc4:	68 78 c1 12 f0       	push   $0xf012c178
f0119bc9:	e8 9e 73 fe ff       	call   f0100f6c <cprintf>
f0119bce:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119bd1:	e8 88 a9 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119bd6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119bd9:	74 17                	je     f0119bf2 <test_kmalloc_firstfit2+0x419>
f0119bdb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119be2:	83 ec 0c             	sub    $0xc,%esp
f0119be5:	68 40 bf 12 f0       	push   $0xf012bf40
f0119bea:	e8 7d 73 fe ff       	call   f0100f6c <cprintf>
f0119bef:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: \n"); }
f0119bf2:	e8 30 3b ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119bf7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0119bfa:	29 c2                	sub    %eax,%edx
f0119bfc:	89 d0                	mov    %edx,%eax
f0119bfe:	83 f8 01             	cmp    $0x1,%eax
f0119c01:	77 17                	ja     f0119c1a <test_kmalloc_firstfit2+0x441>
f0119c03:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119c0a:	83 ec 0c             	sub    $0xc,%esp
f0119c0d:	68 a9 c1 12 f0       	push   $0xf012c1a9
f0119c12:	e8 55 73 fe ff       	call   f0100f6c <cprintf>
f0119c17:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0119c1a:	e8 08 3b ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119c1f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119c22:	e8 37 a9 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119c27:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[0]);
f0119c2a:	8b 45 98             	mov    -0x68(%ebp),%eax
f0119c2d:	83 ec 0c             	sub    $0xc,%esp
f0119c30:	50                   	push   %eax
f0119c31:	e8 b8 eb fe ff       	call   f01087ee <kfree>
f0119c36:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119c39:	e8 20 a9 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119c3e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119c41:	74 17                	je     f0119c5a <test_kmalloc_firstfit2+0x481>
f0119c43:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119c4a:	83 ec 0c             	sub    $0xc,%esp
f0119c4d:	68 40 bf 12 f0       	push   $0xf012bf40
f0119c52:	e8 15 73 fe ff       	call   f0100f6c <cprintf>
f0119c57:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong free: \n"); }
f0119c5a:	e8 c8 3a ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119c5f:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0119c62:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119c67:	77 17                	ja     f0119c80 <test_kmalloc_firstfit2+0x4a7>
f0119c69:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119c70:	83 ec 0c             	sub    $0xc,%esp
f0119c73:	68 bd c1 12 f0       	push   $0xf012c1bd
f0119c78:	e8 ef 72 fe ff       	call   f0100f6c <cprintf>
f0119c7d:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0119c80:	e8 a2 3a ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119c85:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119c88:	e8 d1 a8 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119c8d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0119c90:	83 ec 0c             	sub    $0xc,%esp
f0119c93:	68 00 fc 2f 00       	push   $0x2ffc00
f0119c98:	e8 37 eb fe ff       	call   f01087d4 <kmalloc>
f0119c9d:	83 c4 10             	add    $0x10,%esp
f0119ca0:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0119ca3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119ca6:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0119cab:	74 17                	je     f0119cc4 <test_kmalloc_firstfit2+0x4eb>
f0119cad:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119cb4:	83 ec 0c             	sub    $0xc,%esp
f0119cb7:	68 78 c1 12 f0       	push   $0xf012c178
f0119cbc:	e8 ab 72 fe ff       	call   f0100f6c <cprintf>
f0119cc1:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119cc4:	e8 95 a8 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119cc9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119ccc:	74 17                	je     f0119ce5 <test_kmalloc_firstfit2+0x50c>
f0119cce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119cd5:	83 ec 0c             	sub    $0xc,%esp
f0119cd8:	68 40 bf 12 f0       	push   $0xf012bf40
f0119cdd:	e8 8a 72 fe ff       	call   f0100f6c <cprintf>
f0119ce2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  3*Mega/PAGE_SIZE) { correct = 0; cprintf("Wrong allocation: \n"); }
f0119ce5:	e8 3d 3a ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119cea:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0119ced:	29 c2                	sub    %eax,%edx
f0119cef:	89 d0                	mov    %edx,%eax
f0119cf1:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119cf6:	77 17                	ja     f0119d0f <test_kmalloc_firstfit2+0x536>
f0119cf8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119cff:	83 ec 0c             	sub    $0xc,%esp
f0119d02:	68 a9 c1 12 f0       	push   $0xf012c1a9
f0119d07:	e8 60 72 fe ff       	call   f0100f6c <cprintf>
f0119d0c:	83 c4 10             	add    $0x10,%esp

		//2 MB + 6 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0119d0f:	e8 13 3a ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119d14:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119d17:	e8 42 a8 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119d1c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(2*Mega + 6*kilo);
f0119d1f:	83 ec 0c             	sub    $0xc,%esp
f0119d22:	68 00 18 20 00       	push   $0x201800
f0119d27:	e8 a8 ea fe ff       	call   f01087d4 <kmalloc>
f0119d2c:	83 c4 10             	add    $0x10,%esp
f0119d2f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0119d32:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119d35:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0119d3a:	74 17                	je     f0119d53 <test_kmalloc_firstfit2+0x57a>
f0119d3c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119d43:	83 ec 0c             	sub    $0xc,%esp
f0119d46:	68 78 c1 12 f0       	push   $0xf012c178
f0119d4b:	e8 1c 72 fe ff       	call   f0100f6c <cprintf>
f0119d50:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119d53:	e8 06 a8 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119d58:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119d5b:	74 17                	je     f0119d74 <test_kmalloc_firstfit2+0x59b>
f0119d5d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119d64:	83 ec 0c             	sub    $0xc,%esp
f0119d67:	68 40 bf 12 f0       	push   $0xf012bf40
f0119d6c:	e8 fb 71 fe ff       	call   f0100f6c <cprintf>
f0119d71:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  514) { correct = 0; cprintf("Wrong allocation: \n"); }
f0119d74:	e8 ae 39 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119d79:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0119d7c:	29 c2                	sub    %eax,%edx
f0119d7e:	89 d0                	mov    %edx,%eax
f0119d80:	3d 01 02 00 00       	cmp    $0x201,%eax
f0119d85:	77 17                	ja     f0119d9e <test_kmalloc_firstfit2+0x5c5>
f0119d87:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119d8e:	83 ec 0c             	sub    $0xc,%esp
f0119d91:	68 a9 c1 12 f0       	push   $0xf012c1a9
f0119d96:	e8 d1 71 fe ff       	call   f0100f6c <cprintf>
f0119d9b:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0119d9e:	e8 84 39 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119da3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119da6:	e8 b3 a7 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119dab:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f0119dae:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119db1:	83 ec 0c             	sub    $0xc,%esp
f0119db4:	50                   	push   %eax
f0119db5:	e8 34 ea fe ff       	call   f01087ee <kfree>
f0119dba:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119dbd:	e8 9c a7 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119dc2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119dc5:	74 17                	je     f0119dde <test_kmalloc_firstfit2+0x605>
f0119dc7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119dce:	83 ec 0c             	sub    $0xc,%esp
f0119dd1:	68 40 bf 12 f0       	push   $0xf012bf40
f0119dd6:	e8 91 71 fe ff       	call   f0100f6c <cprintf>
f0119ddb:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("Wrong free: \n"); }
f0119dde:	e8 44 39 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119de3:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0119de6:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119deb:	77 17                	ja     f0119e04 <test_kmalloc_firstfit2+0x62b>
f0119ded:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119df4:	83 ec 0c             	sub    $0xc,%esp
f0119df7:	68 bd c1 12 f0       	push   $0xf012c1bd
f0119dfc:	e8 6b 71 fe ff       	call   f0100f6c <cprintf>
f0119e01:	83 c4 10             	add    $0x10,%esp

		//2 KB Hole in Dynamic Allocator Area [Resulting Hole = 1 KB + 2 KB = 3 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f0119e04:	e8 1e 39 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119e09:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119e0c:	e8 4d a7 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119e11:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f0119e14:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0119e17:	83 ec 0c             	sub    $0xc,%esp
f0119e1a:	50                   	push   %eax
f0119e1b:	e8 ce e9 fe ff       	call   f01087ee <kfree>
f0119e20:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119e23:	e8 36 a7 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119e28:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119e2b:	74 17                	je     f0119e44 <test_kmalloc_firstfit2+0x66b>
f0119e2d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119e34:	83 ec 0c             	sub    $0xc,%esp
f0119e37:	68 40 bf 12 f0       	push   $0xf012bf40
f0119e3c:	e8 2b 71 fe ff       	call   f0100f6c <cprintf>
f0119e41:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0119e44:	e8 de 38 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119e49:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119e4c:	74 17                	je     f0119e65 <test_kmalloc_firstfit2+0x68c>
f0119e4e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119e55:	83 ec 0c             	sub    $0xc,%esp
f0119e58:	68 4c c2 12 f0       	push   $0xf012c24c
f0119e5d:	e8 0a 71 fe ff       	call   f0100f6c <cprintf>
f0119e62:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole [Resulting Hole = 2 MB + 2 MB = 4 MB]
		freeFrames = (int)sys_calculate_free_frames() ;
f0119e65:	e8 bd 38 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119e6a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119e6d:	e8 ec a6 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119e72:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f0119e75:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0119e78:	83 ec 0c             	sub    $0xc,%esp
f0119e7b:	50                   	push   %eax
f0119e7c:	e8 6d e9 fe ff       	call   f01087ee <kfree>
f0119e81:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong free: \n"); }
f0119e84:	e8 9e 38 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119e89:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0119e8c:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119e91:	77 17                	ja     f0119eaa <test_kmalloc_firstfit2+0x6d1>
f0119e93:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119e9a:	83 ec 0c             	sub    $0xc,%esp
f0119e9d:	68 bd c1 12 f0       	push   $0xf012c1bd
f0119ea2:	e8 c5 70 fe ff       	call   f0100f6c <cprintf>
f0119ea7:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119eaa:	e8 af a6 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119eaf:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119eb2:	74 17                	je     f0119ecb <test_kmalloc_firstfit2+0x6f2>
f0119eb4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119ebb:	83 ec 0c             	sub    $0xc,%esp
f0119ebe:	68 40 bf 12 f0       	push   $0xf012bf40
f0119ec3:	e8 a4 70 fe ff       	call   f0100f6c <cprintf>
f0119ec8:	83 c4 10             	add    $0x10,%esp

		//5 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0119ecb:	e8 57 38 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119ed0:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119ed3:	e8 86 a6 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119ed8:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(5*Mega-kilo);
f0119edb:	83 ec 0c             	sub    $0xc,%esp
f0119ede:	68 00 fc 4f 00       	push   $0x4ffc00
f0119ee3:	e8 ec e8 fe ff       	call   f01087d4 <kmalloc>
f0119ee8:	83 c4 10             	add    $0x10,%esp
f0119eeb:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 9*Mega + 16*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0119eee:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119ef1:	3d 00 50 90 f8       	cmp    $0xf8905000,%eax
f0119ef6:	74 17                	je     f0119f0f <test_kmalloc_firstfit2+0x736>
f0119ef8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119eff:	83 ec 0c             	sub    $0xc,%esp
f0119f02:	68 78 c1 12 f0       	push   $0xf012c178
f0119f07:	e8 60 70 fe ff       	call   f0100f6c <cprintf>
f0119f0c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119f0f:	e8 4a a6 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119f14:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119f17:	74 17                	je     f0119f30 <test_kmalloc_firstfit2+0x757>
f0119f19:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119f20:	83 ec 0c             	sub    $0xc,%esp
f0119f23:	68 40 bf 12 f0       	push   $0xf012bf40
f0119f28:	e8 3f 70 fe ff       	call   f0100f6c <cprintf>
f0119f2d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <   5*Mega/PAGE_SIZE) { correct = 0; cprintf("Wrong allocation: \n"); }
f0119f30:	e8 f2 37 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119f35:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0119f38:	29 c2                	sub    %eax,%edx
f0119f3a:	89 d0                	mov    %edx,%eax
f0119f3c:	3d ff 04 00 00       	cmp    $0x4ff,%eax
f0119f41:	77 17                	ja     f0119f5a <test_kmalloc_firstfit2+0x781>
f0119f43:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119f4a:	83 ec 0c             	sub    $0xc,%esp
f0119f4d:	68 a9 c1 12 f0       	push   $0xf012c1a9
f0119f52:	e8 15 70 fe ff       	call   f0100f6c <cprintf>
f0119f57:	83 c4 10             	add    $0x10,%esp

		//8 KB Hole [Resulting Hole = 2 MB + 2 MB + 8 KB + 3 MB = 7 MB + 8 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f0119f5a:	e8 c8 37 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119f5f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119f62:	e8 f7 a5 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119f67:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[5]);
f0119f6a:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0119f6d:	83 ec 0c             	sub    $0xc,%esp
f0119f70:	50                   	push   %eax
f0119f71:	e8 78 e8 fe ff       	call   f01087ee <kfree>
f0119f76:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119f79:	e8 e0 a5 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119f7e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119f81:	74 17                	je     f0119f9a <test_kmalloc_firstfit2+0x7c1>
f0119f83:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119f8a:	83 ec 0c             	sub    $0xc,%esp
f0119f8d:	68 40 bf 12 f0       	push   $0xf012bf40
f0119f92:	e8 d5 6f fe ff       	call   f0100f6c <cprintf>
f0119f97:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("Wrong free: \n"); }
f0119f9a:	e8 88 37 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119f9f:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0119fa2:	83 f8 01             	cmp    $0x1,%eax
f0119fa5:	77 17                	ja     f0119fbe <test_kmalloc_firstfit2+0x7e5>
f0119fa7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119fae:	83 ec 0c             	sub    $0xc,%esp
f0119fb1:	68 bd c1 12 f0       	push   $0xf012c1bd
f0119fb6:	e8 b1 6f fe ff       	call   f0100f6c <cprintf>
f0119fbb:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0119fbe:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0119fc2:	74 04                	je     f0119fc8 <test_kmalloc_firstfit2+0x7ef>
f0119fc4:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0119fc8:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#1] Should be allocated in the resulting hole inside Page Allocator Area
		//7 MB + 1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0119fcf:	e8 53 37 ff ff       	call   f010d727 <sys_calculate_free_frames>
f0119fd4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119fd7:	e8 82 a5 fe ff       	call   f010455e <pf_calculate_free_frames>
f0119fdc:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(7*Mega+kilo);
f0119fdf:	83 ec 0c             	sub    $0xc,%esp
f0119fe2:	68 00 04 70 00       	push   $0x700400
f0119fe7:	e8 e8 e7 fe ff       	call   f01087d4 <kmalloc>
f0119fec:	83 c4 10             	add    $0x10,%esp
f0119fef:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0119ff2:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119ff5:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119ffa:	74 17                	je     f011a013 <test_kmalloc_firstfit2+0x83a>
f0119ffc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a003:	83 ec 0c             	sub    $0xc,%esp
f011a006:	68 78 c1 12 f0       	push   $0xf012c178
f011a00b:	e8 5c 6f fe ff       	call   f0100f6c <cprintf>
f011a010:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a013:	e8 46 a5 fe ff       	call   f010455e <pf_calculate_free_frames>
f011a018:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011a01b:	74 17                	je     f011a034 <test_kmalloc_firstfit2+0x85b>
f011a01d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a024:	83 ec 0c             	sub    $0xc,%esp
f011a027:	68 40 bf 12 f0       	push   $0xf012bf40
f011a02c:	e8 3b 6f fe ff       	call   f0100f6c <cprintf>
f011a031:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  (7*Mega+4*kilo)/PAGE_SIZE) { correct = 0; cprintf("Wrong allocation: \n"); }
f011a034:	e8 ee 36 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a039:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011a03c:	29 c2                	sub    %eax,%edx
f011a03e:	89 d0                	mov    %edx,%eax
f011a040:	3d 00 07 00 00       	cmp    $0x700,%eax
f011a045:	77 17                	ja     f011a05e <test_kmalloc_firstfit2+0x885>
f011a047:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a04e:	83 ec 0c             	sub    $0xc,%esp
f011a051:	68 a9 c1 12 f0       	push   $0xf012c1a9
f011a056:	e8 11 6f fe ff       	call   f0100f6c <cprintf>
f011a05b:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#2] Should be allocated in the remaining area of resulting hole inside Page Allocator Area
		//3 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011a05e:	e8 c4 36 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a063:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a066:	e8 f3 a4 fe ff       	call   f010455e <pf_calculate_free_frames>
f011a06b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(3*kilo);
f011a06e:	83 ec 0c             	sub    $0xc,%esp
f011a071:	68 00 0c 00 00       	push   $0xc00
f011a076:	e8 59 e7 fe ff       	call   f01087d4 <kmalloc>
f011a07b:	83 c4 10             	add    $0x10,%esp
f011a07e:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32)ptr_allocations[10] != (ACTUAL_START + 7*Mega + 4*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011a081:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a084:	3d 00 20 70 f8       	cmp    $0xf8702000,%eax
f011a089:	74 17                	je     f011a0a2 <test_kmalloc_firstfit2+0x8c9>
f011a08b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a092:	83 ec 0c             	sub    $0xc,%esp
f011a095:	68 78 c1 12 f0       	push   $0xf012c178
f011a09a:	e8 cd 6e fe ff       	call   f0100f6c <cprintf>
f011a09f:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a0a2:	e8 b7 a4 fe ff       	call   f010455e <pf_calculate_free_frames>
f011a0a7:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011a0aa:	74 17                	je     f011a0c3 <test_kmalloc_firstfit2+0x8ea>
f011a0ac:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a0b3:	83 ec 0c             	sub    $0xc,%esp
f011a0b6:	68 40 bf 12 f0       	push   $0xf012bf40
f011a0bb:	e8 ac 6e fe ff       	call   f0100f6c <cprintf>
f011a0c0:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1) { correct = 0; cprintf("Wrong allocation: \n"); }
f011a0c3:	e8 5f 36 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a0c8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011a0cb:	75 17                	jne    f011a0e4 <test_kmalloc_firstfit2+0x90b>
f011a0cd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a0d4:	83 ec 0c             	sub    $0xc,%esp
f011a0d7:	68 a9 c1 12 f0       	push   $0xf012c1a9
f011a0dc:	e8 8b 6e fe ff       	call   f0100f6c <cprintf>
f011a0e1:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=35 ;
f011a0e4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011a0e8:	74 04                	je     f011a0ee <test_kmalloc_firstfit2+0x915>
f011a0ea:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	correct = 1 ;
f011a0ee:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#3] Should be allocated in the resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011a0f5:	e8 2d 36 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a0fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a0fd:	e8 5c a4 fe ff       	call   f010455e <pf_calculate_free_frames>
f011a102:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(1*kilo);
f011a105:	83 ec 0c             	sub    $0xc,%esp
f011a108:	68 00 04 00 00       	push   $0x400
f011a10d:	e8 c2 e6 fe ff       	call   f01087d4 <kmalloc>
f011a112:	83 c4 10             	add    $0x10,%esp
f011a115:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((ptr_allocations[11] < ptr_allocations[2]) || (ptr_allocations[11] > (ptr_allocations[2] + 1*kilo)))
f011a118:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011a11b:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011a11e:	39 c2                	cmp    %eax,%edx
f011a120:	72 10                	jb     f011a132 <test_kmalloc_firstfit2+0x959>
f011a122:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011a125:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011a128:	81 c2 00 04 00 00    	add    $0x400,%edx
f011a12e:	39 d0                	cmp    %edx,%eax
f011a130:	76 17                	jbe    f011a149 <test_kmalloc_firstfit2+0x970>
		{ correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011a132:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a139:	83 ec 0c             	sub    $0xc,%esp
f011a13c:	68 78 c1 12 f0       	push   $0xf012c178
f011a141:	e8 26 6e fe ff       	call   f0100f6c <cprintf>
f011a146:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a149:	e8 10 a4 fe ff       	call   f010455e <pf_calculate_free_frames>
f011a14e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011a151:	74 17                	je     f011a16a <test_kmalloc_firstfit2+0x991>
f011a153:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a15a:	83 ec 0c             	sub    $0xc,%esp
f011a15d:	68 40 bf 12 f0       	push   $0xf012bf40
f011a162:	e8 05 6e fe ff       	call   f0100f6c <cprintf>
f011a167:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: \n"); }
f011a16a:	e8 b8 35 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a16f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011a172:	74 17                	je     f011a18b <test_kmalloc_firstfit2+0x9b2>
f011a174:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a17b:	83 ec 0c             	sub    $0xc,%esp
f011a17e:	68 a9 c1 12 f0       	push   $0xf012c1a9
f011a183:	e8 e4 6d fe ff       	call   f0100f6c <cprintf>
f011a188:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#4] Should be allocated in the remaining of resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011a18b:	e8 97 35 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a190:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a193:	e8 c6 a3 fe ff       	call   f010455e <pf_calculate_free_frames>
f011a198:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(1*kilo);
f011a19b:	83 ec 0c             	sub    $0xc,%esp
f011a19e:	68 00 04 00 00       	push   $0x400
f011a1a3:	e8 2c e6 fe ff       	call   f01087d4 <kmalloc>
f011a1a8:	83 c4 10             	add    $0x10,%esp
f011a1ab:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((ptr_allocations[12] < ptr_allocations[2] + 1*kilo) || (ptr_allocations[12] > (ptr_allocations[2] + 2*kilo)))
f011a1ae:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a1b1:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011a1b4:	81 c2 00 04 00 00    	add    $0x400,%edx
f011a1ba:	39 d0                	cmp    %edx,%eax
f011a1bc:	72 10                	jb     f011a1ce <test_kmalloc_firstfit2+0x9f5>
f011a1be:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a1c1:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011a1c4:	81 c2 00 08 00 00    	add    $0x800,%edx
f011a1ca:	39 d0                	cmp    %edx,%eax
f011a1cc:	76 17                	jbe    f011a1e5 <test_kmalloc_firstfit2+0xa0c>
		{ correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011a1ce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a1d5:	83 ec 0c             	sub    $0xc,%esp
f011a1d8:	68 78 c1 12 f0       	push   $0xf012c178
f011a1dd:	e8 8a 6d fe ff       	call   f0100f6c <cprintf>
f011a1e2:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a1e5:	e8 74 a3 fe ff       	call   f010455e <pf_calculate_free_frames>
f011a1ea:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011a1ed:	74 17                	je     f011a206 <test_kmalloc_firstfit2+0xa2d>
f011a1ef:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a1f6:	83 ec 0c             	sub    $0xc,%esp
f011a1f9:	68 40 bf 12 f0       	push   $0xf012bf40
f011a1fe:	e8 69 6d fe ff       	call   f0100f6c <cprintf>
f011a203:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: \n"); }
f011a206:	e8 1c 35 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a20b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011a20e:	74 17                	je     f011a227 <test_kmalloc_firstfit2+0xa4e>
f011a210:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a217:	83 ec 0c             	sub    $0xc,%esp
f011a21a:	68 a9 c1 12 f0       	push   $0xf012c1a9
f011a21f:	e8 48 6d fe ff       	call   f0100f6c <cprintf>
f011a224:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=35 ;
f011a227:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011a22b:	74 04                	je     f011a231 <test_kmalloc_firstfit2+0xa58>
f011a22d:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	correct = 1 ;
f011a231:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//	b) Attempt to allocate large segment with no suitable fragment to fit on
	{
		//Large Allocation
		ptr_allocations[13] = kmalloc((KERNEL_HEAP_MAX - ACTUAL_START - 14*Mega));
f011a238:	83 ec 0c             	sub    $0xc,%esp
f011a23b:	68 00 e0 1f 07       	push   $0x71fe000
f011a240:	e8 8f e5 fe ff       	call   f01087d4 <kmalloc>
f011a245:	83 c4 10             	add    $0x10,%esp
f011a248:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (ptr_allocations[13] != NULL) { correct = 0; cprintf("Kmalloc: Attempt to allocate large segment with no suitable fragment to fit on, should return NULL\n"); }
f011a24b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011a24e:	85 c0                	test   %eax,%eax
f011a250:	74 17                	je     f011a269 <test_kmalloc_firstfit2+0xa90>
f011a252:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a259:	83 ec 0c             	sub    $0xc,%esp
f011a25c:	68 a8 c2 12 f0       	push   $0xf012c2a8
f011a261:	e8 06 6d fe ff       	call   f0100f6c <cprintf>
f011a266:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=10 ;
f011a269:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011a26d:	74 04                	je     f011a273 <test_kmalloc_firstfit2+0xa9a>
f011a26f:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (2) completed. Eval = %d%\n", eval);
f011a273:	83 ec 08             	sub    $0x8,%esp
f011a276:	ff 75 f4             	pushl  -0xc(%ebp)
f011a279:	68 0c c3 12 f0       	push   $0xf012c30c
f011a27e:	e8 e9 6c fe ff       	call   f0100f6c <cprintf>
f011a283:	83 c4 10             	add    $0x10,%esp

	return 1;
f011a286:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011a28b:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011a28e:	5b                   	pop    %ebx
f011a28f:	5f                   	pop    %edi
f011a290:	5d                   	pop    %ebp
f011a291:	c3                   	ret    

f011a292 <test_kfree_bestfirstfit>:


int test_kfree_bestfirstfit()
{
f011a292:	55                   	push   %ebp
f011a293:	89 e5                	mov    %esp,%ebp
f011a295:	57                   	push   %edi
f011a296:	53                   	push   %ebx
f011a297:	81 ec 40 01 00 00    	sub    $0x140,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011a29d:	83 ec 0c             	sub    $0xc,%esp
f011a2a0:	68 80 be 12 f0       	push   $0xf012be80
f011a2a5:	e8 c2 6c fe ff       	call   f0100f6c <cprintf>
f011a2aa:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011a2ad:	83 ec 0c             	sub    $0xc,%esp
f011a2b0:	68 b0 be 12 f0       	push   $0xf012beb0
f011a2b5:	e8 b2 6c fe ff       	call   f0100f6c <cprintf>
f011a2ba:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011a2bd:	83 ec 0c             	sub    $0xc,%esp
f011a2c0:	68 80 be 12 f0       	push   $0xf012be80
f011a2c5:	e8 a2 6c fe ff       	call   f0100f6c <cprintf>
f011a2ca:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011a2cd:	c6 45 df 80          	movb   $0x80,-0x21(%ebp)
	char maxByte = 0x7F;
f011a2d1:	c6 45 de 7f          	movb   $0x7f,-0x22(%ebp)
	short minShort = 1<<15 ;
f011a2d5:	66 c7 45 dc 00 80    	movw   $0x8000,-0x24(%ebp)
	short maxShort = 0x7FFF;
f011a2db:	66 c7 45 da ff 7f    	movw   $0x7fff,-0x26(%ebp)
	int minInt = 1<<31 ;
f011a2e1:	c7 45 d4 00 00 00 80 	movl   $0x80000000,-0x2c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011a2e8:	c7 45 d0 ff ff ff 7f 	movl   $0x7fffffff,-0x30(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011a2ef:	e8 33 34 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a2f4:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011a2f7:	8d 95 68 ff ff ff    	lea    -0x98(%ebp),%edx
f011a2fd:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a302:	b8 00 00 00 00       	mov    $0x0,%eax
f011a307:	89 d7                	mov    %edx,%edi
f011a309:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011a30b:	8d 95 18 ff ff ff    	lea    -0xe8(%ebp),%edx
f011a311:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a316:	b8 00 00 00 00       	mov    $0x0,%eax
f011a31b:	89 d7                	mov    %edx,%edi
f011a31d:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011a31f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011a326:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	correct = 1;
f011a32d:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011a334:	8d 95 c8 fe ff ff    	lea    -0x138(%ebp),%edx
f011a33a:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a33f:	b8 00 00 00 00       	mov    $0x0,%eax
f011a344:	89 d7                	mov    %edx,%edi
f011a346:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//[BLOCK ALLOCATOR]
		{
			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011a348:	e8 da 33 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a34d:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a350:	e8 09 a2 fe ff       	call   f010455e <pf_calculate_free_frames>
f011a355:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo);
f011a358:	83 ec 0c             	sub    $0xc,%esp
f011a35b:	68 00 08 00 00       	push   $0x800
f011a360:	e8 6f e4 fe ff       	call   f01087d4 <kmalloc>
f011a365:	83 c4 10             	add    $0x10,%esp
f011a368:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011a36e:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a374:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a379:	76 28                	jbe    f011a3a3 <test_kfree_bestfirstfit+0x111>
f011a37b:	8b 9d d0 fe ff ff    	mov    -0x130(%ebp),%ebx
f011a381:	83 ec 0c             	sub    $0xc,%esp
f011a384:	6a 00                	push   $0x0
f011a386:	e8 3f e4 fe ff       	call   f01087ca <sbrk>
f011a38b:	83 c4 10             	add    $0x10,%esp
f011a38e:	39 c3                	cmp    %eax,%ebx
f011a390:	73 11                	jae    f011a3a3 <test_kfree_bestfirstfit+0x111>
f011a392:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a398:	89 c2                	mov    %eax,%edx
f011a39a:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011a39f:	39 c2                	cmp    %eax,%edx
f011a3a1:	72 17                	jb     f011a3ba <test_kfree_bestfirstfit+0x128>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a3a3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a3aa:	83 ec 0c             	sub    $0xc,%esp
f011a3ad:	68 40 c0 12 f0       	push   $0xf012c040
f011a3b2:	e8 b5 6b fe ff       	call   f0100f6c <cprintf>
f011a3b7:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a3ba:	e8 9f a1 fe ff       	call   f010455e <pf_calculate_free_frames>
f011a3bf:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a3c2:	74 17                	je     f011a3db <test_kfree_bestfirstfit+0x149>
f011a3c4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a3cb:	83 ec 0c             	sub    $0xc,%esp
f011a3ce:	68 40 bf 12 f0       	push   $0xf012bf40
f011a3d3:	e8 94 6b fe ff       	call   f0100f6c <cprintf>
f011a3d8:	83 c4 10             	add    $0x10,%esp
			//		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
f011a3db:	c7 85 70 ff ff ff ff 	movl   $0x7ff,-0x90(%ebp)
f011a3e2:	07 00 00 
			ptr = (char*)ptr_allocations[2];
f011a3e5:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a3eb:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[2]; ++i)
f011a3ee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a3f5:	eb 0e                	jmp    f011a405 <test_kfree_bestfirstfit+0x173>
			{
				ptr[i] = 2 ;
f011a3f7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a3fa:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a3fd:	01 d0                	add    %edx,%eax
f011a3ff:	c6 00 02             	movb   $0x2,(%eax)
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			//		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[2];
			for (i = 0; i < lastIndices[2]; ++i)
f011a402:	ff 45 f4             	incl   -0xc(%ebp)
f011a405:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011a40b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a40e:	7f e7                	jg     f011a3f7 <test_kfree_bestfirstfit+0x165>
			{
				ptr[i] = 2 ;
			}

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011a410:	e8 12 33 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a415:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a418:	e8 41 a1 fe ff       	call   f010455e <pf_calculate_free_frames>
f011a41d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011a420:	83 ec 0c             	sub    $0xc,%esp
f011a423:	68 00 08 00 00       	push   $0x800
f011a428:	e8 a7 e3 fe ff       	call   f01087d4 <kmalloc>
f011a42d:	83 c4 10             	add    $0x10,%esp
f011a430:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011a436:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011a43c:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a441:	76 28                	jbe    f011a46b <test_kfree_bestfirstfit+0x1d9>
f011a443:	8b 9d d4 fe ff ff    	mov    -0x12c(%ebp),%ebx
f011a449:	83 ec 0c             	sub    $0xc,%esp
f011a44c:	6a 00                	push   $0x0
f011a44e:	e8 77 e3 fe ff       	call   f01087ca <sbrk>
f011a453:	83 c4 10             	add    $0x10,%esp
f011a456:	39 c3                	cmp    %eax,%ebx
f011a458:	73 11                	jae    f011a46b <test_kfree_bestfirstfit+0x1d9>
f011a45a:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011a460:	89 c2                	mov    %eax,%edx
f011a462:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011a467:	39 c2                	cmp    %eax,%edx
f011a469:	72 17                	jb     f011a482 <test_kfree_bestfirstfit+0x1f0>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a46b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a472:	83 ec 0c             	sub    $0xc,%esp
f011a475:	68 40 c0 12 f0       	push   $0xf012c040
f011a47a:	e8 ed 6a fe ff       	call   f0100f6c <cprintf>
f011a47f:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a482:	e8 d7 a0 fe ff       	call   f010455e <pf_calculate_free_frames>
f011a487:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a48a:	74 17                	je     f011a4a3 <test_kfree_bestfirstfit+0x211>
f011a48c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a493:	83 ec 0c             	sub    $0xc,%esp
f011a496:	68 40 bf 12 f0       	push   $0xf012bf40
f011a49b:	e8 cc 6a fe ff       	call   f0100f6c <cprintf>
f011a4a0:	83 c4 10             	add    $0x10,%esp
			//		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
f011a4a3:	c7 85 74 ff ff ff ff 	movl   $0x7ff,-0x8c(%ebp)
f011a4aa:	07 00 00 
			ptr = (char*)ptr_allocations[3];
f011a4ad:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011a4b3:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[3]; ++i)
f011a4b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a4bd:	eb 0e                	jmp    f011a4cd <test_kfree_bestfirstfit+0x23b>
			{
				ptr[i] = 3 ;
f011a4bf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a4c2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a4c5:	01 d0                	add    %edx,%eax
f011a4c7:	c6 00 03             	movb   $0x3,(%eax)
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			//		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[3];
			for (i = 0; i < lastIndices[3]; ++i)
f011a4ca:	ff 45 f4             	incl   -0xc(%ebp)
f011a4cd:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011a4d3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a4d6:	7f e7                	jg     f011a4bf <test_kfree_bestfirstfit+0x22d>
		}

		//[PAGE ALLOCATOR]
		{
			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f011a4d8:	e8 4a 32 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a4dd:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a4e0:	e8 79 a0 fe ff       	call   f010455e <pf_calculate_free_frames>
f011a4e5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011a4e8:	83 ec 0c             	sub    $0xc,%esp
f011a4eb:	68 00 fc 1f 00       	push   $0x1ffc00
f011a4f0:	e8 df e2 fe ff       	call   f01087d4 <kmalloc>
f011a4f5:	83 c4 10             	add    $0x10,%esp
f011a4f8:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
			if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a4fe:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f011a504:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011a509:	74 17                	je     f011a522 <test_kfree_bestfirstfit+0x290>
f011a50b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a512:	83 ec 0c             	sub    $0xc,%esp
f011a515:	68 f0 bf 12 f0       	push   $0xf012bff0
f011a51a:	e8 4d 6a fe ff       	call   f0100f6c <cprintf>
f011a51f:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a522:	e8 37 a0 fe ff       	call   f010455e <pf_calculate_free_frames>
f011a527:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a52a:	74 17                	je     f011a543 <test_kfree_bestfirstfit+0x2b1>
f011a52c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a533:	83 ec 0c             	sub    $0xc,%esp
f011a536:	68 40 bf 12 f0       	push   $0xf012bf40
f011a53b:	e8 2c 6a fe ff       	call   f0100f6c <cprintf>
f011a540:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a543:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a546:	e8 dc 31 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a54b:	29 c3                	sub    %eax,%ebx
f011a54d:	89 d8                	mov    %ebx,%eax
f011a54f:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a554:	77 17                	ja     f011a56d <test_kfree_bestfirstfit+0x2db>
f011a556:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a55d:	83 ec 0c             	sub    $0xc,%esp
f011a560:	68 ac bf 12 f0       	push   $0xf012bfac
f011a565:	e8 02 6a fe ff       	call   f0100f6c <cprintf>
f011a56a:	83 c4 10             	add    $0x10,%esp
			lastIndices[0] = (2*Mega-kilo)/sizeof(char) - 1;
f011a56d:	c7 85 68 ff ff ff ff 	movl   $0x1ffbff,-0x98(%ebp)
f011a574:	fb 1f 00 

			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f011a577:	e8 ab 31 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a57c:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a57f:	e8 da 9f fe ff       	call   f010455e <pf_calculate_free_frames>
f011a584:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011a587:	83 ec 0c             	sub    $0xc,%esp
f011a58a:	68 00 fc 1f 00       	push   $0x1ffc00
f011a58f:	e8 40 e2 fe ff       	call   f01087d4 <kmalloc>
f011a594:	83 c4 10             	add    $0x10,%esp
f011a597:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
			if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a59d:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a5a3:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011a5a8:	74 17                	je     f011a5c1 <test_kfree_bestfirstfit+0x32f>
f011a5aa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a5b1:	83 ec 0c             	sub    $0xc,%esp
f011a5b4:	68 f0 bf 12 f0       	push   $0xf012bff0
f011a5b9:	e8 ae 69 fe ff       	call   f0100f6c <cprintf>
f011a5be:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a5c1:	e8 98 9f fe ff       	call   f010455e <pf_calculate_free_frames>
f011a5c6:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a5c9:	74 17                	je     f011a5e2 <test_kfree_bestfirstfit+0x350>
f011a5cb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a5d2:	83 ec 0c             	sub    $0xc,%esp
f011a5d5:	68 40 bf 12 f0       	push   $0xf012bf40
f011a5da:	e8 8d 69 fe ff       	call   f0100f6c <cprintf>
f011a5df:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a5e2:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a5e5:	e8 3d 31 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a5ea:	29 c3                	sub    %eax,%ebx
f011a5ec:	89 d8                	mov    %ebx,%eax
f011a5ee:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a5f3:	77 17                	ja     f011a60c <test_kfree_bestfirstfit+0x37a>
f011a5f5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a5fc:	83 ec 0c             	sub    $0xc,%esp
f011a5ff:	68 ac bf 12 f0       	push   $0xf012bfac
f011a604:	e8 63 69 fe ff       	call   f0100f6c <cprintf>
f011a609:	83 c4 10             	add    $0x10,%esp
			lastIndices[1] = (2*Mega-kilo)/sizeof(char) - 1;
f011a60c:	c7 85 6c ff ff ff ff 	movl   $0x1ffbff,-0x94(%ebp)
f011a613:	fb 1f 00 


			//7 KB
			freeFrames = sys_calculate_free_frames() ;
f011a616:	e8 0c 31 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a61b:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a61e:	e8 3b 9f fe ff       	call   f010455e <pf_calculate_free_frames>
f011a623:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[4] = kmalloc(7*kilo);
f011a626:	83 ec 0c             	sub    $0xc,%esp
f011a629:	68 00 1c 00 00       	push   $0x1c00
f011a62e:	e8 a1 e1 fe ff       	call   f01087d4 <kmalloc>
f011a633:	83 c4 10             	add    $0x10,%esp
f011a636:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a63c:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011a642:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011a647:	74 17                	je     f011a660 <test_kfree_bestfirstfit+0x3ce>
f011a649:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a650:	83 ec 0c             	sub    $0xc,%esp
f011a653:	68 f0 bf 12 f0       	push   $0xf012bff0
f011a658:	e8 0f 69 fe ff       	call   f0100f6c <cprintf>
f011a65d:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a660:	e8 f9 9e fe ff       	call   f010455e <pf_calculate_free_frames>
f011a665:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a668:	74 17                	je     f011a681 <test_kfree_bestfirstfit+0x3ef>
f011a66a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a671:	83 ec 0c             	sub    $0xc,%esp
f011a674:	68 40 bf 12 f0       	push   $0xf012bf40
f011a679:	e8 ee 68 fe ff       	call   f0100f6c <cprintf>
f011a67e:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a681:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a684:	e8 9e 30 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a689:	29 c3                	sub    %eax,%ebx
f011a68b:	89 d8                	mov    %ebx,%eax
f011a68d:	83 f8 01             	cmp    $0x1,%eax
f011a690:	77 17                	ja     f011a6a9 <test_kfree_bestfirstfit+0x417>
f011a692:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a699:	83 ec 0c             	sub    $0xc,%esp
f011a69c:	68 ac bf 12 f0       	push   $0xf012bfac
f011a6a1:	e8 c6 68 fe ff       	call   f0100f6c <cprintf>
f011a6a6:	83 c4 10             	add    $0x10,%esp
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
f011a6a9:	c7 85 78 ff ff ff ff 	movl   $0x1bff,-0x88(%ebp)
f011a6b0:	1b 00 00 
			ptr = (char*)ptr_allocations[4];
f011a6b3:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011a6b9:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[4]; ++i)
f011a6bc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a6c3:	eb 0e                	jmp    f011a6d3 <test_kfree_bestfirstfit+0x441>
			{
				ptr[i] = 4 ;
f011a6c5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a6c8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a6cb:	01 d0                	add    %edx,%eax
f011a6cd:	c6 00 04             	movb   $0x4,(%eax)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[4];
			for (i = 0; i < lastIndices[4]; ++i)
f011a6d0:	ff 45 f4             	incl   -0xc(%ebp)
f011a6d3:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011a6d9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a6dc:	7f e7                	jg     f011a6c5 <test_kfree_bestfirstfit+0x433>
			{
				ptr[i] = 4 ;
			}

			//3 MB
			freeFrames = sys_calculate_free_frames() ;
f011a6de:	e8 44 30 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a6e3:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a6e6:	e8 73 9e fe ff       	call   f010455e <pf_calculate_free_frames>
f011a6eb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[5] = kmalloc(3*Mega-kilo);
f011a6ee:	83 ec 0c             	sub    $0xc,%esp
f011a6f1:	68 00 fc 2f 00       	push   $0x2ffc00
f011a6f6:	e8 d9 e0 fe ff       	call   f01087d4 <kmalloc>
f011a6fb:	83 c4 10             	add    $0x10,%esp
f011a6fe:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a704:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011a70a:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011a70f:	74 17                	je     f011a728 <test_kfree_bestfirstfit+0x496>
f011a711:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a718:	83 ec 0c             	sub    $0xc,%esp
f011a71b:	68 f0 bf 12 f0       	push   $0xf012bff0
f011a720:	e8 47 68 fe ff       	call   f0100f6c <cprintf>
f011a725:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a728:	e8 31 9e fe ff       	call   f010455e <pf_calculate_free_frames>
f011a72d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a730:	74 17                	je     f011a749 <test_kfree_bestfirstfit+0x4b7>
f011a732:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a739:	83 ec 0c             	sub    $0xc,%esp
f011a73c:	68 40 bf 12 f0       	push   $0xf012bf40
f011a741:	e8 26 68 fe ff       	call   f0100f6c <cprintf>
f011a746:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a749:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a74c:	e8 d6 2f ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a751:	29 c3                	sub    %eax,%ebx
f011a753:	89 d8                	mov    %ebx,%eax
f011a755:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a75a:	77 17                	ja     f011a773 <test_kfree_bestfirstfit+0x4e1>
f011a75c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a763:	83 ec 0c             	sub    $0xc,%esp
f011a766:	68 ac bf 12 f0       	push   $0xf012bfac
f011a76b:	e8 fc 67 fe ff       	call   f0100f6c <cprintf>
f011a770:	83 c4 10             	add    $0x10,%esp
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
f011a773:	c7 85 7c ff ff ff ff 	movl   $0x2ffbff,-0x84(%ebp)
f011a77a:	fb 2f 00 
			ptr = (char*)ptr_allocations[5];
f011a77d:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011a783:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[5]; ++i)
f011a786:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a78d:	eb 0e                	jmp    f011a79d <test_kfree_bestfirstfit+0x50b>
			{
				ptr[i] = 5 ;
f011a78f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a792:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a795:	01 d0                	add    %edx,%eax
f011a797:	c6 00 05             	movb   $0x5,(%eax)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[5];
			for (i = 0; i < lastIndices[5]; ++i)
f011a79a:	ff 45 f4             	incl   -0xc(%ebp)
f011a79d:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011a7a3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a7a6:	7f e7                	jg     f011a78f <test_kfree_bestfirstfit+0x4fd>
			{
				ptr[i] = 5 ;
			}

			//6 MB
			freeFrames = sys_calculate_free_frames() ;
f011a7a8:	e8 7a 2f ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a7ad:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a7b0:	e8 a9 9d fe ff       	call   f010455e <pf_calculate_free_frames>
f011a7b5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[6] = kmalloc(6*Mega-kilo);
f011a7b8:	83 ec 0c             	sub    $0xc,%esp
f011a7bb:	68 00 fc 5f 00       	push   $0x5ffc00
f011a7c0:	e8 0f e0 fe ff       	call   f01087d4 <kmalloc>
f011a7c5:	83 c4 10             	add    $0x10,%esp
f011a7c8:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
			if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a7ce:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011a7d4:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011a7d9:	74 17                	je     f011a7f2 <test_kfree_bestfirstfit+0x560>
f011a7db:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a7e2:	83 ec 0c             	sub    $0xc,%esp
f011a7e5:	68 f0 bf 12 f0       	push   $0xf012bff0
f011a7ea:	e8 7d 67 fe ff       	call   f0100f6c <cprintf>
f011a7ef:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a7f2:	e8 67 9d fe ff       	call   f010455e <pf_calculate_free_frames>
f011a7f7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a7fa:	74 17                	je     f011a813 <test_kfree_bestfirstfit+0x581>
f011a7fc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a803:	83 ec 0c             	sub    $0xc,%esp
f011a806:	68 40 bf 12 f0       	push   $0xf012bf40
f011a80b:	e8 5c 67 fe ff       	call   f0100f6c <cprintf>
f011a810:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a813:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a816:	e8 0c 2f ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a81b:	29 c3                	sub    %eax,%ebx
f011a81d:	89 d8                	mov    %ebx,%eax
f011a81f:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011a824:	77 17                	ja     f011a83d <test_kfree_bestfirstfit+0x5ab>
f011a826:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a82d:	83 ec 0c             	sub    $0xc,%esp
f011a830:	68 ac bf 12 f0       	push   $0xf012bfac
f011a835:	e8 32 67 fe ff       	call   f0100f6c <cprintf>
f011a83a:	83 c4 10             	add    $0x10,%esp
			lastIndices[6] = (6*Mega-kilo)/sizeof(char) - 1;
f011a83d:	c7 45 80 ff fb 5f 00 	movl   $0x5ffbff,-0x80(%ebp)

			//14 KB
			freeFrames = sys_calculate_free_frames() ;
f011a844:	e8 de 2e ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a849:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a84c:	e8 0d 9d fe ff       	call   f010455e <pf_calculate_free_frames>
f011a851:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[7] = kmalloc(14*kilo);
f011a854:	83 ec 0c             	sub    $0xc,%esp
f011a857:	68 00 38 00 00       	push   $0x3800
f011a85c:	e8 73 df fe ff       	call   f01087d4 <kmalloc>
f011a861:	83 c4 10             	add    $0x10,%esp
f011a864:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a86a:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a870:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011a875:	74 17                	je     f011a88e <test_kfree_bestfirstfit+0x5fc>
f011a877:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a87e:	83 ec 0c             	sub    $0xc,%esp
f011a881:	68 f0 bf 12 f0       	push   $0xf012bff0
f011a886:	e8 e1 66 fe ff       	call   f0100f6c <cprintf>
f011a88b:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a88e:	e8 cb 9c fe ff       	call   f010455e <pf_calculate_free_frames>
f011a893:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a896:	74 17                	je     f011a8af <test_kfree_bestfirstfit+0x61d>
f011a898:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a89f:	83 ec 0c             	sub    $0xc,%esp
f011a8a2:	68 40 bf 12 f0       	push   $0xf012bf40
f011a8a7:	e8 c0 66 fe ff       	call   f0100f6c <cprintf>
f011a8ac:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a8af:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a8b2:	e8 70 2e ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a8b7:	29 c3                	sub    %eax,%ebx
f011a8b9:	89 d8                	mov    %ebx,%eax
f011a8bb:	83 f8 03             	cmp    $0x3,%eax
f011a8be:	77 17                	ja     f011a8d7 <test_kfree_bestfirstfit+0x645>
f011a8c0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a8c7:	83 ec 0c             	sub    $0xc,%esp
f011a8ca:	68 ac bf 12 f0       	push   $0xf012bfac
f011a8cf:	e8 98 66 fe ff       	call   f0100f6c <cprintf>
f011a8d4:	83 c4 10             	add    $0x10,%esp
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
f011a8d7:	c7 45 84 ff 37 00 00 	movl   $0x37ff,-0x7c(%ebp)
			ptr = (char*)ptr_allocations[7];
f011a8de:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a8e4:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[7]; ++i)
f011a8e7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a8ee:	eb 0e                	jmp    f011a8fe <test_kfree_bestfirstfit+0x66c>
			{
				ptr[i] = 7 ;
f011a8f0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a8f3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a8f6:	01 d0                	add    %edx,%eax
f011a8f8:	c6 00 07             	movb   $0x7,(%eax)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[7];
			for (i = 0; i < lastIndices[7]; ++i)
f011a8fb:	ff 45 f4             	incl   -0xc(%ebp)
f011a8fe:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011a901:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a904:	7f ea                	jg     f011a8f0 <test_kfree_bestfirstfit+0x65e>
	}

	//kfree some of the allocated spaces [10%]
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011a906:	e8 1c 2e ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a90b:	89 45 bc             	mov    %eax,-0x44(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011a90e:	e8 4b 9c fe ff       	call   f010455e <pf_calculate_free_frames>
f011a913:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[0]);
f011a916:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f011a91c:	83 ec 0c             	sub    $0xc,%esp
f011a91f:	50                   	push   %eax
f011a920:	e8 c9 de fe ff       	call   f01087ee <kfree>
f011a925:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a928:	e8 31 9c fe ff       	call   f010455e <pf_calculate_free_frames>
f011a92d:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011a930:	74 17                	je     f011a949 <test_kfree_bestfirstfit+0x6b7>
f011a932:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a939:	83 ec 0c             	sub    $0xc,%esp
f011a93c:	68 40 bf 12 f0       	push   $0xf012bf40
f011a941:	e8 26 66 fe ff       	call   f0100f6c <cprintf>
f011a946:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011a949:	e8 d9 2d ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a94e:	89 c2                	mov    %eax,%edx
f011a950:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a953:	29 c2                	sub    %eax,%edx
f011a955:	89 d0                	mov    %edx,%eax
f011a957:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a95c:	77 17                	ja     f011a975 <test_kfree_bestfirstfit+0x6e3>
f011a95e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a965:	83 ec 0c             	sub    $0xc,%esp
f011a968:	68 44 c3 12 f0       	push   $0xf012c344
f011a96d:	e8 fa 65 fe ff       	call   f0100f6c <cprintf>
f011a972:	83 c4 10             	add    $0x10,%esp

		//kfree 1st 2 KB
		freeFrames = sys_calculate_free_frames() ;
f011a975:	e8 ad 2d ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a97a:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a97d:	e8 dc 9b fe ff       	call   f010455e <pf_calculate_free_frames>
f011a982:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[2]);
f011a985:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a98b:	83 ec 0c             	sub    $0xc,%esp
f011a98e:	50                   	push   %eax
f011a98f:	e8 5a de fe ff       	call   f01087ee <kfree>
f011a994:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a997:	e8 c2 9b fe ff       	call   f010455e <pf_calculate_free_frames>
f011a99c:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011a99f:	74 17                	je     f011a9b8 <test_kfree_bestfirstfit+0x726>
f011a9a1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9a8:	83 ec 0c             	sub    $0xc,%esp
f011a9ab:	68 40 bf 12 f0       	push   $0xf012bf40
f011a9b0:	e8 b7 65 fe ff       	call   f0100f6c <cprintf>
f011a9b5:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0 ) { correct = 0; cprintf("Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011a9b8:	e8 6a 2d ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a9bd:	89 c2                	mov    %eax,%edx
f011a9bf:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a9c2:	39 c2                	cmp    %eax,%edx
f011a9c4:	74 17                	je     f011a9dd <test_kfree_bestfirstfit+0x74b>
f011a9c6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9cd:	83 ec 0c             	sub    $0xc,%esp
f011a9d0:	68 4c c2 12 f0       	push   $0xf012c24c
f011a9d5:	e8 92 65 fe ff       	call   f0100f6c <cprintf>
f011a9da:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011a9dd:	e8 45 2d ff ff       	call   f010d727 <sys_calculate_free_frames>
f011a9e2:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a9e5:	e8 74 9b fe ff       	call   f010455e <pf_calculate_free_frames>
f011a9ea:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[1]);
f011a9ed:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a9f3:	83 ec 0c             	sub    $0xc,%esp
f011a9f6:	50                   	push   %eax
f011a9f7:	e8 f2 dd fe ff       	call   f01087ee <kfree>
f011a9fc:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a9ff:	e8 5a 9b fe ff       	call   f010455e <pf_calculate_free_frames>
f011aa04:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011aa07:	74 17                	je     f011aa20 <test_kfree_bestfirstfit+0x78e>
f011aa09:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa10:	83 ec 0c             	sub    $0xc,%esp
f011aa13:	68 40 bf 12 f0       	push   $0xf012bf40
f011aa18:	e8 4f 65 fe ff       	call   f0100f6c <cprintf>
f011aa1d:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011aa20:	e8 02 2d ff ff       	call   f010d727 <sys_calculate_free_frames>
f011aa25:	89 c2                	mov    %eax,%edx
f011aa27:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011aa2a:	29 c2                	sub    %eax,%edx
f011aa2c:	89 d0                	mov    %edx,%eax
f011aa2e:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011aa33:	77 17                	ja     f011aa4c <test_kfree_bestfirstfit+0x7ba>
f011aa35:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa3c:	83 ec 0c             	sub    $0xc,%esp
f011aa3f:	68 44 c3 12 f0       	push   $0xf012c344
f011aa44:	e8 23 65 fe ff       	call   f0100f6c <cprintf>
f011aa49:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011aa4c:	e8 d6 2c ff ff       	call   f010d727 <sys_calculate_free_frames>
f011aa51:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011aa54:	e8 05 9b fe ff       	call   f010455e <pf_calculate_free_frames>
f011aa59:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[6]);
f011aa5c:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011aa62:	83 ec 0c             	sub    $0xc,%esp
f011aa65:	50                   	push   %eax
f011aa66:	e8 83 dd fe ff       	call   f01087ee <kfree>
f011aa6b:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aa6e:	e8 eb 9a fe ff       	call   f010455e <pf_calculate_free_frames>
f011aa73:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011aa76:	74 17                	je     f011aa8f <test_kfree_bestfirstfit+0x7fd>
f011aa78:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa7f:	83 ec 0c             	sub    $0xc,%esp
f011aa82:	68 40 bf 12 f0       	push   $0xf012bf40
f011aa87:	e8 e0 64 fe ff       	call   f0100f6c <cprintf>
f011aa8c:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011aa8f:	e8 93 2c ff ff       	call   f010d727 <sys_calculate_free_frames>
f011aa94:	89 c2                	mov    %eax,%edx
f011aa96:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011aa99:	29 c2                	sub    %eax,%edx
f011aa9b:	89 d0                	mov    %edx,%eax
f011aa9d:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011aaa2:	77 17                	ja     f011aabb <test_kfree_bestfirstfit+0x829>
f011aaa4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aaab:	83 ec 0c             	sub    $0xc,%esp
f011aaae:	68 44 c3 12 f0       	push   $0xf012c344
f011aab3:	e8 b4 64 fe ff       	call   f0100f6c <cprintf>
f011aab8:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011aabb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011aabf:	74 04                	je     f011aac5 <test_kfree_bestfirstfit+0x833>
f011aac1:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011aac5:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access after kfree [10%]
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
f011aacc:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011aad2:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[3]; ++i)
f011aad5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aadc:	eb 1e                	jmp    f011aafc <test_kfree_bestfirstfit+0x86a>
		{
			sums[3] += ptr[i] ;
f011aade:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f011aae4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011aae7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aaea:	01 c8                	add    %ecx,%eax
f011aaec:	8a 00                	mov    (%eax),%al
f011aaee:	0f be c0             	movsbl %al,%eax
f011aaf1:	01 d0                	add    %edx,%eax
f011aaf3:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
	correct = 1 ;
	//Check memory access after kfree [10%]
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
		for (i = 0; i < lastIndices[3]; ++i)
f011aaf9:	ff 45 f4             	incl   -0xc(%ebp)
f011aafc:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011ab02:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ab05:	7f d7                	jg     f011aade <test_kfree_bestfirstfit+0x84c>
		{
			sums[3] += ptr[i] ;
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }
f011ab07:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f011ab0d:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011ab13:	89 c1                	mov    %eax,%ecx
f011ab15:	01 c9                	add    %ecx,%ecx
f011ab17:	01 c8                	add    %ecx,%eax
f011ab19:	39 c2                	cmp    %eax,%edx
f011ab1b:	74 17                	je     f011ab34 <test_kfree_bestfirstfit+0x8a2>
f011ab1d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab24:	83 ec 0c             	sub    $0xc,%esp
f011ab27:	68 7c c3 12 f0       	push   $0xf012c37c
f011ab2c:	e8 3b 64 fe ff       	call   f0100f6c <cprintf>
f011ab31:	83 c4 10             	add    $0x10,%esp

		//7 KB
		ptr = (char*)ptr_allocations[4];
f011ab34:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011ab3a:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[4]; ++i)
f011ab3d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ab44:	eb 1e                	jmp    f011ab64 <test_kfree_bestfirstfit+0x8d2>
		{
			sums[4] += ptr[i] ;
f011ab46:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f011ab4c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ab4f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ab52:	01 c8                	add    %ecx,%eax
f011ab54:	8a 00                	mov    (%eax),%al
f011ab56:	0f be c0             	movsbl %al,%eax
f011ab59:	01 d0                	add    %edx,%eax
f011ab5b:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }

		//7 KB
		ptr = (char*)ptr_allocations[4];
		for (i = 0; i < lastIndices[4]; ++i)
f011ab61:	ff 45 f4             	incl   -0xc(%ebp)
f011ab64:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011ab6a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ab6d:	7f d7                	jg     f011ab46 <test_kfree_bestfirstfit+0x8b4>
		{
			sums[4] += ptr[i] ;
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }
f011ab6f:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
f011ab75:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f011ab7b:	c1 e2 02             	shl    $0x2,%edx
f011ab7e:	39 d0                	cmp    %edx,%eax
f011ab80:	74 17                	je     f011ab99 <test_kfree_bestfirstfit+0x907>
f011ab82:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab89:	83 ec 0c             	sub    $0xc,%esp
f011ab8c:	68 7c c3 12 f0       	push   $0xf012c37c
f011ab91:	e8 d6 63 fe ff       	call   f0100f6c <cprintf>
f011ab96:	83 c4 10             	add    $0x10,%esp

		//3 MB
		ptr = (char*)ptr_allocations[5];
f011ab99:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011ab9f:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[5]; ++i)
f011aba2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aba9:	eb 1e                	jmp    f011abc9 <test_kfree_bestfirstfit+0x937>
		{
			sums[5] += ptr[i] ;
f011abab:	8b 95 2c ff ff ff    	mov    -0xd4(%ebp),%edx
f011abb1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011abb4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011abb7:	01 c8                	add    %ecx,%eax
f011abb9:	8a 00                	mov    (%eax),%al
f011abbb:	0f be c0             	movsbl %al,%eax
f011abbe:	01 d0                	add    %edx,%eax
f011abc0:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }

		//3 MB
		ptr = (char*)ptr_allocations[5];
		for (i = 0; i < lastIndices[5]; ++i)
f011abc6:	ff 45 f4             	incl   -0xc(%ebp)
f011abc9:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011abcf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011abd2:	7f d7                	jg     f011abab <test_kfree_bestfirstfit+0x919>
		{
			sums[5] += ptr[i] ;
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }
f011abd4:	8b 8d 2c ff ff ff    	mov    -0xd4(%ebp),%ecx
f011abda:	8b 95 7c ff ff ff    	mov    -0x84(%ebp),%edx
f011abe0:	89 d0                	mov    %edx,%eax
f011abe2:	c1 e0 02             	shl    $0x2,%eax
f011abe5:	01 d0                	add    %edx,%eax
f011abe7:	39 c1                	cmp    %eax,%ecx
f011abe9:	74 17                	je     f011ac02 <test_kfree_bestfirstfit+0x970>
f011abeb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011abf2:	83 ec 0c             	sub    $0xc,%esp
f011abf5:	68 7c c3 12 f0       	push   $0xf012c37c
f011abfa:	e8 6d 63 fe ff       	call   f0100f6c <cprintf>
f011abff:	83 c4 10             	add    $0x10,%esp

		//14 KB
		ptr = (char*)ptr_allocations[7];
f011ac02:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011ac08:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[7]; ++i)
f011ac0b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ac12:	eb 1e                	jmp    f011ac32 <test_kfree_bestfirstfit+0x9a0>
		{
			sums[7] += ptr[i] ;
f011ac14:	8b 95 34 ff ff ff    	mov    -0xcc(%ebp),%edx
f011ac1a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ac1d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ac20:	01 c8                	add    %ecx,%eax
f011ac22:	8a 00                	mov    (%eax),%al
f011ac24:	0f be c0             	movsbl %al,%eax
f011ac27:	01 d0                	add    %edx,%eax
f011ac29:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }

		//14 KB
		ptr = (char*)ptr_allocations[7];
		for (i = 0; i < lastIndices[7]; ++i)
f011ac2f:	ff 45 f4             	incl   -0xc(%ebp)
f011ac32:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011ac35:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ac38:	7f da                	jg     f011ac14 <test_kfree_bestfirstfit+0x982>
		{
			sums[7] += ptr[i] ;
		}
		if (sums[7] != 7*lastIndices[7])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }
f011ac3a:	8b 8d 34 ff ff ff    	mov    -0xcc(%ebp),%ecx
f011ac40:	8b 55 84             	mov    -0x7c(%ebp),%edx
f011ac43:	89 d0                	mov    %edx,%eax
f011ac45:	01 c0                	add    %eax,%eax
f011ac47:	01 d0                	add    %edx,%eax
f011ac49:	01 c0                	add    %eax,%eax
f011ac4b:	01 d0                	add    %edx,%eax
f011ac4d:	39 c1                	cmp    %eax,%ecx
f011ac4f:	74 17                	je     f011ac68 <test_kfree_bestfirstfit+0x9d6>
f011ac51:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac58:	83 ec 0c             	sub    $0xc,%esp
f011ac5b:	68 7c c3 12 f0       	push   $0xf012c37c
f011ac60:	e8 07 63 fe ff       	call   f0100f6c <cprintf>
f011ac65:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011ac68:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ac6c:	74 04                	je     f011ac72 <test_kfree_bestfirstfit+0x9e0>
f011ac6e:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011ac72:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Allocate after kfree [15%]
	{
		//Allocate in merged freed space
		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011ac79:	e8 a9 2a ff ff       	call   f010d727 <sys_calculate_free_frames>
f011ac7e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ac81:	e8 d8 98 fe ff       	call   f010455e <pf_calculate_free_frames>
f011ac86:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[8] = kmalloc(3*Mega);
f011ac89:	83 ec 0c             	sub    $0xc,%esp
f011ac8c:	68 00 00 30 00       	push   $0x300000
f011ac91:	e8 3e db fe ff       	call   f01087d4 <kmalloc>
f011ac96:	83 c4 10             	add    $0x10,%esp
f011ac99:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ac9f:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011aca5:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011acaa:	74 17                	je     f011acc3 <test_kfree_bestfirstfit+0xa31>
f011acac:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011acb3:	83 ec 0c             	sub    $0xc,%esp
f011acb6:	68 f0 bf 12 f0       	push   $0xf012bff0
f011acbb:	e8 ac 62 fe ff       	call   f0100f6c <cprintf>
f011acc0:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011acc3:	e8 96 98 fe ff       	call   f010455e <pf_calculate_free_frames>
f011acc8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011accb:	74 17                	je     f011ace4 <test_kfree_bestfirstfit+0xa52>
f011accd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011acd4:	83 ec 0c             	sub    $0xc,%esp
f011acd7:	68 40 bf 12 f0       	push   $0xf012bf40
f011acdc:	e8 8b 62 fe ff       	call   f0100f6c <cprintf>
f011ace1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ace4:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011ace7:	e8 3b 2a ff ff       	call   f010d727 <sys_calculate_free_frames>
f011acec:	29 c3                	sub    %eax,%ebx
f011acee:	89 d8                	mov    %ebx,%eax
f011acf0:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011acf5:	77 17                	ja     f011ad0e <test_kfree_bestfirstfit+0xa7c>
f011acf7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011acfe:	83 ec 0c             	sub    $0xc,%esp
f011ad01:	68 ac bf 12 f0       	push   $0xf012bfac
f011ad06:	e8 61 62 fe ff       	call   f0100f6c <cprintf>
f011ad0b:	83 c4 10             	add    $0x10,%esp
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
f011ad0e:	c7 45 88 ff ff 2f 00 	movl   $0x2fffff,-0x78(%ebp)
		ptr = (char*)ptr_allocations[8];
f011ad15:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011ad1b:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[8]; ++i)
f011ad1e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ad25:	eb 0e                	jmp    f011ad35 <test_kfree_bestfirstfit+0xaa3>
		{
			ptr[i] = 8 ;
f011ad27:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ad2a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ad2d:	01 d0                	add    %edx,%eax
f011ad2f:	c6 00 08             	movb   $0x8,(%eax)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[8];
		for (i = 0; i < lastIndices[8]; ++i)
f011ad32:	ff 45 f4             	incl   -0xc(%ebp)
f011ad35:	8b 45 88             	mov    -0x78(%ebp),%eax
f011ad38:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ad3b:	7f ea                	jg     f011ad27 <test_kfree_bestfirstfit+0xa95>
		{
			ptr[i] = 8 ;
		}

		//1 MB
		freeFrames = sys_calculate_free_frames() ;
f011ad3d:	e8 e5 29 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011ad42:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ad45:	e8 14 98 fe ff       	call   f010455e <pf_calculate_free_frames>
f011ad4a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(1*Mega);
f011ad4d:	83 ec 0c             	sub    $0xc,%esp
f011ad50:	68 00 00 10 00       	push   $0x100000
f011ad55:	e8 7a da fe ff       	call   f01087d4 <kmalloc>
f011ad5a:	83 c4 10             	add    $0x10,%esp
f011ad5d:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ad63:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011ad69:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f011ad6e:	74 17                	je     f011ad87 <test_kfree_bestfirstfit+0xaf5>
f011ad70:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ad77:	83 ec 0c             	sub    $0xc,%esp
f011ad7a:	68 f0 bf 12 f0       	push   $0xf012bff0
f011ad7f:	e8 e8 61 fe ff       	call   f0100f6c <cprintf>
f011ad84:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ad87:	e8 d2 97 fe ff       	call   f010455e <pf_calculate_free_frames>
f011ad8c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011ad8f:	74 17                	je     f011ada8 <test_kfree_bestfirstfit+0xb16>
f011ad91:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ad98:	83 ec 0c             	sub    $0xc,%esp
f011ad9b:	68 40 bf 12 f0       	push   $0xf012bf40
f011ada0:	e8 c7 61 fe ff       	call   f0100f6c <cprintf>
f011ada5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ada8:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011adab:	e8 77 29 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011adb0:	29 c3                	sub    %eax,%ebx
f011adb2:	89 d8                	mov    %ebx,%eax
f011adb4:	3d ff 00 00 00       	cmp    $0xff,%eax
f011adb9:	77 17                	ja     f011add2 <test_kfree_bestfirstfit+0xb40>
f011adbb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011adc2:	83 ec 0c             	sub    $0xc,%esp
f011adc5:	68 ac bf 12 f0       	push   $0xf012bfac
f011adca:	e8 9d 61 fe ff       	call   f0100f6c <cprintf>
f011adcf:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
f011add2:	c7 45 90 ff ff 0f 00 	movl   $0xfffff,-0x70(%ebp)
		ptr = (char*)ptr_allocations[10];
f011add9:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011addf:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f011ade2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ade9:	eb 0e                	jmp    f011adf9 <test_kfree_bestfirstfit+0xb67>
		{
			ptr[i] = 10 ;
f011adeb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011adee:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011adf1:	01 d0                	add    %edx,%eax
f011adf3:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011adf6:	ff 45 f4             	incl   -0xc(%ebp)
f011adf9:	8b 45 90             	mov    -0x70(%ebp),%eax
f011adfc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011adff:	7f ea                	jg     f011adeb <test_kfree_bestfirstfit+0xb59>
		{
			ptr[i] = 10 ;
		}

		//1 KB [Should be allocated in 1st hole in the Dynamic Allocator]
		freeFrames = sys_calculate_free_frames() ;
f011ae01:	e8 21 29 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011ae06:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ae09:	e8 50 97 fe ff       	call   f010455e <pf_calculate_free_frames>
f011ae0e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[9] = kmalloc(1*kilo);
f011ae11:	83 ec 0c             	sub    $0xc,%esp
f011ae14:	68 00 04 00 00       	push   $0x400
f011ae19:	e8 b6 d9 fe ff       	call   f01087d4 <kmalloc>
f011ae1e:	83 c4 10             	add    $0x10,%esp
f011ae21:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
		if ((ptr_allocations[9] < ptr_allocations[2]) || (ptr_allocations[9] > (ptr_allocations[2] + 1*kilo)))
f011ae27:	8b 95 ec fe ff ff    	mov    -0x114(%ebp),%edx
f011ae2d:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011ae33:	39 c2                	cmp    %eax,%edx
f011ae35:	72 16                	jb     f011ae4d <test_kfree_bestfirstfit+0xbbb>
f011ae37:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011ae3d:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011ae43:	81 c2 00 04 00 00    	add    $0x400,%edx
f011ae49:	39 d0                	cmp    %edx,%eax
f011ae4b:	76 17                	jbe    f011ae64 <test_kfree_bestfirstfit+0xbd2>
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ae4d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae54:	83 ec 0c             	sub    $0xc,%esp
f011ae57:	68 f0 bf 12 f0       	push   $0xf012bff0
f011ae5c:	e8 0b 61 fe ff       	call   f0100f6c <cprintf>
f011ae61:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ae64:	e8 f5 96 fe ff       	call   f010455e <pf_calculate_free_frames>
f011ae69:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011ae6c:	74 17                	je     f011ae85 <test_kfree_bestfirstfit+0xbf3>
f011ae6e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae75:	83 ec 0c             	sub    $0xc,%esp
f011ae78:	68 40 bf 12 f0       	push   $0xf012bf40
f011ae7d:	e8 ea 60 fe ff       	call   f0100f6c <cprintf>
f011ae82:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011ae85:	e8 9d 28 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011ae8a:	89 c2                	mov    %eax,%edx
f011ae8c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011ae8f:	39 c2                	cmp    %eax,%edx
f011ae91:	74 17                	je     f011aeaa <test_kfree_bestfirstfit+0xc18>
f011ae93:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae9a:	83 ec 0c             	sub    $0xc,%esp
f011ae9d:	68 b0 c3 12 f0       	push   $0xf012c3b0
f011aea2:	e8 c5 60 fe ff       	call   f0100f6c <cprintf>
f011aea7:	83 c4 10             	add    $0x10,%esp
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
f011aeaa:	c7 45 8c ff 03 00 00 	movl   $0x3ff,-0x74(%ebp)
		ptr = (char*)ptr_allocations[9];
f011aeb1:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011aeb7:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[9]; ++i)
f011aeba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aec1:	eb 0e                	jmp    f011aed1 <test_kfree_bestfirstfit+0xc3f>
		{
			ptr[i] = 9 ;
f011aec3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011aec6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aec9:	01 d0                	add    %edx,%eax
f011aecb:	c6 00 09             	movb   $0x9,(%eax)
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[9];
		for (i = 0; i < lastIndices[9]; ++i)
f011aece:	ff 45 f4             	incl   -0xc(%ebp)
f011aed1:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011aed4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011aed7:	7f ea                	jg     f011aec3 <test_kfree_bestfirstfit+0xc31>
		{
			ptr[i] = 9 ;
		}

	}
	if (correct)	eval+=15 ;
f011aed9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011aedd:	74 04                	je     f011aee3 <test_kfree_bestfirstfit+0xc51>
f011aedf:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011aee3:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree remaining allocated spaces [15%]
	{
		//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with NEXT 6 MB hole - total = 9MB]
		freeFrames = sys_calculate_free_frames() ;
f011aeea:	e8 38 28 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011aeef:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011aef2:	e8 67 96 fe ff       	call   f010455e <pf_calculate_free_frames>
f011aef7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[5]);
f011aefa:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011af00:	83 ec 0c             	sub    $0xc,%esp
f011af03:	50                   	push   %eax
f011af04:	e8 e5 d8 fe ff       	call   f01087ee <kfree>
f011af09:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011af0c:	e8 4d 96 fe ff       	call   f010455e <pf_calculate_free_frames>
f011af11:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011af14:	74 17                	je     f011af2d <test_kfree_bestfirstfit+0xc9b>
f011af16:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af1d:	83 ec 0c             	sub    $0xc,%esp
f011af20:	68 40 bf 12 f0       	push   $0xf012bf40
f011af25:	e8 42 60 fe ff       	call   f0100f6c <cprintf>
f011af2a:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011af2d:	e8 f5 27 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011af32:	89 c2                	mov    %eax,%edx
f011af34:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011af37:	29 c2                	sub    %eax,%edx
f011af39:	89 d0                	mov    %edx,%eax
f011af3b:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011af40:	77 17                	ja     f011af59 <test_kfree_bestfirstfit+0xcc7>
f011af42:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af49:	83 ec 0c             	sub    $0xc,%esp
f011af4c:	68 44 c3 12 f0       	push   $0xf012c344
f011af51:	e8 16 60 fe ff       	call   f0100f6c <cprintf>
f011af56:	83 c4 10             	add    $0x10,%esp

		//kfree 7 KB [PAGE ALLOCATOR: Should be Merged with NEXT 9 MB hole - total = 9MB + 8KB]
		freeFrames = sys_calculate_free_frames() ;
f011af59:	e8 c9 27 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011af5e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011af61:	e8 f8 95 fe ff       	call   f010455e <pf_calculate_free_frames>
f011af66:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[4]);
f011af69:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011af6f:	83 ec 0c             	sub    $0xc,%esp
f011af72:	50                   	push   %eax
f011af73:	e8 76 d8 fe ff       	call   f01087ee <kfree>
f011af78:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011af7b:	e8 de 95 fe ff       	call   f010455e <pf_calculate_free_frames>
f011af80:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011af83:	74 17                	je     f011af9c <test_kfree_bestfirstfit+0xd0a>
f011af85:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af8c:	83 ec 0c             	sub    $0xc,%esp
f011af8f:	68 40 bf 12 f0       	push   $0xf012bf40
f011af94:	e8 d3 5f fe ff       	call   f0100f6c <cprintf>
f011af99:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011af9c:	e8 86 27 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011afa1:	89 c2                	mov    %eax,%edx
f011afa3:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011afa6:	29 c2                	sub    %eax,%edx
f011afa8:	89 d0                	mov    %edx,%eax
f011afaa:	83 f8 01             	cmp    $0x1,%eax
f011afad:	77 17                	ja     f011afc6 <test_kfree_bestfirstfit+0xd34>
f011afaf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011afb6:	83 ec 0c             	sub    $0xc,%esp
f011afb9:	68 44 c3 12 f0       	push   $0xf012c344
f011afbe:	e8 a9 5f fe ff       	call   f0100f6c <cprintf>
f011afc3:	83 c4 10             	add    $0x10,%esp

		//kfree 1 KB [DYNAMIC ALLOCATOR]
		freeFrames = sys_calculate_free_frames() ;
f011afc6:	e8 5c 27 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011afcb:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011afce:	e8 8b 95 fe ff       	call   f010455e <pf_calculate_free_frames>
f011afd3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[9]);
f011afd6:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011afdc:	83 ec 0c             	sub    $0xc,%esp
f011afdf:	50                   	push   %eax
f011afe0:	e8 09 d8 fe ff       	call   f01087ee <kfree>
f011afe5:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011afe8:	e8 71 95 fe ff       	call   f010455e <pf_calculate_free_frames>
f011afed:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011aff0:	74 17                	je     f011b009 <test_kfree_bestfirstfit+0xd77>
f011aff2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aff9:	83 ec 0c             	sub    $0xc,%esp
f011affc:	68 40 bf 12 f0       	push   $0xf012bf40
f011b001:	e8 66 5f fe ff       	call   f0100f6c <cprintf>
f011b006:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011b009:	e8 19 27 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b00e:	89 c2                	mov    %eax,%edx
f011b010:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b013:	39 c2                	cmp    %eax,%edx
f011b015:	74 17                	je     f011b02e <test_kfree_bestfirstfit+0xd9c>
f011b017:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b01e:	83 ec 0c             	sub    $0xc,%esp
f011b021:	68 44 c3 12 f0       	push   $0xf012c344
f011b026:	e8 41 5f fe ff       	call   f0100f6c <cprintf>
f011b02b:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 KB [DYNAMIC ALLOCATOR: Should be Merged with PREV remaining area of 2KB & NEXT free space]
		freeFrames = sys_calculate_free_frames() ;
f011b02e:	e8 f4 26 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b033:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b036:	e8 23 95 fe ff       	call   f010455e <pf_calculate_free_frames>
f011b03b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[3]);
f011b03e:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011b044:	83 ec 0c             	sub    $0xc,%esp
f011b047:	50                   	push   %eax
f011b048:	e8 a1 d7 fe ff       	call   f01087ee <kfree>
f011b04d:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b050:	e8 09 95 fe ff       	call   f010455e <pf_calculate_free_frames>
f011b055:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b058:	74 17                	je     f011b071 <test_kfree_bestfirstfit+0xddf>
f011b05a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b061:	83 ec 0c             	sub    $0xc,%esp
f011b064:	68 40 bf 12 f0       	push   $0xf012bf40
f011b069:	e8 fe 5e fe ff       	call   f0100f6c <cprintf>
f011b06e:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011b071:	e8 b1 26 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b076:	89 c2                	mov    %eax,%edx
f011b078:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b07b:	39 c2                	cmp    %eax,%edx
f011b07d:	74 17                	je     f011b096 <test_kfree_bestfirstfit+0xe04>
f011b07f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b086:	83 ec 0c             	sub    $0xc,%esp
f011b089:	68 4c c2 12 f0       	push   $0xf012c24c
f011b08e:	e8 d9 5e fe ff       	call   f0100f6c <cprintf>
f011b093:	83 c4 10             	add    $0x10,%esp

		//kfree 14 KB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 8KB hole - total = 9MB + 24KB]
		freeFrames = sys_calculate_free_frames() ;
f011b096:	e8 8c 26 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b09b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b09e:	e8 bb 94 fe ff       	call   f010455e <pf_calculate_free_frames>
f011b0a3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[7]);
f011b0a6:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011b0ac:	83 ec 0c             	sub    $0xc,%esp
f011b0af:	50                   	push   %eax
f011b0b0:	e8 39 d7 fe ff       	call   f01087ee <kfree>
f011b0b5:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b0b8:	e8 a1 94 fe ff       	call   f010455e <pf_calculate_free_frames>
f011b0bd:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b0c0:	74 17                	je     f011b0d9 <test_kfree_bestfirstfit+0xe47>
f011b0c2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b0c9:	83 ec 0c             	sub    $0xc,%esp
f011b0cc:	68 40 bf 12 f0       	push   $0xf012bf40
f011b0d1:	e8 96 5e fe ff       	call   f0100f6c <cprintf>
f011b0d6:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 4) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011b0d9:	e8 49 26 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b0de:	89 c2                	mov    %eax,%edx
f011b0e0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b0e3:	29 c2                	sub    %eax,%edx
f011b0e5:	89 d0                	mov    %edx,%eax
f011b0e7:	83 f8 03             	cmp    $0x3,%eax
f011b0ea:	77 17                	ja     f011b103 <test_kfree_bestfirstfit+0xe71>
f011b0ec:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b0f3:	83 ec 0c             	sub    $0xc,%esp
f011b0f6:	68 44 c3 12 f0       	push   $0xf012c344
f011b0fb:	e8 6c 5e fe ff       	call   f0100f6c <cprintf>
f011b100:	83 c4 10             	add    $0x10,%esp

		//kfree 1 MB [PAGE ALLOCATOR: Should be Merged with NEXT remaining hole ]
		freeFrames = sys_calculate_free_frames() ;
f011b103:	e8 1f 26 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b108:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b10b:	e8 4e 94 fe ff       	call   f010455e <pf_calculate_free_frames>
f011b110:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[10]);
f011b113:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011b119:	83 ec 0c             	sub    $0xc,%esp
f011b11c:	50                   	push   %eax
f011b11d:	e8 cc d6 fe ff       	call   f01087ee <kfree>
f011b122:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b125:	e8 34 94 fe ff       	call   f010455e <pf_calculate_free_frames>
f011b12a:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b12d:	74 17                	je     f011b146 <test_kfree_bestfirstfit+0xeb4>
f011b12f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b136:	83 ec 0c             	sub    $0xc,%esp
f011b139:	68 40 bf 12 f0       	push   $0xf012bf40
f011b13e:	e8 29 5e fe ff       	call   f0100f6c <cprintf>
f011b143:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 1*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011b146:	e8 dc 25 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b14b:	89 c2                	mov    %eax,%edx
f011b14d:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b150:	29 c2                	sub    %eax,%edx
f011b152:	89 d0                	mov    %edx,%eax
f011b154:	3d ff 00 00 00       	cmp    $0xff,%eax
f011b159:	77 17                	ja     f011b172 <test_kfree_bestfirstfit+0xee0>
f011b15b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b162:	83 ec 0c             	sub    $0xc,%esp
f011b165:	68 44 c3 12 f0       	push   $0xf012c344
f011b16a:	e8 fd 5d fe ff       	call   f0100f6c <cprintf>
f011b16f:	83 c4 10             	add    $0x10,%esp

		//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 24KB hole & NEXT remaining hole - total = ALL PAGE ALLOCATOR Space]
		freeFrames = sys_calculate_free_frames() ;
f011b172:	e8 b0 25 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b177:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b17a:	e8 df 93 fe ff       	call   f010455e <pf_calculate_free_frames>
f011b17f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[8]);
f011b182:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011b188:	83 ec 0c             	sub    $0xc,%esp
f011b18b:	50                   	push   %eax
f011b18c:	e8 5d d6 fe ff       	call   f01087ee <kfree>
f011b191:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b194:	e8 c5 93 fe ff       	call   f010455e <pf_calculate_free_frames>
f011b199:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b19c:	74 17                	je     f011b1b5 <test_kfree_bestfirstfit+0xf23>
f011b19e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b1a5:	83 ec 0c             	sub    $0xc,%esp
f011b1a8:	68 40 bf 12 f0       	push   $0xf012bf40
f011b1ad:	e8 ba 5d fe ff       	call   f0100f6c <cprintf>
f011b1b2:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011b1b5:	e8 6d 25 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b1ba:	89 c2                	mov    %eax,%edx
f011b1bc:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b1bf:	29 c2                	sub    %eax,%edx
f011b1c1:	89 d0                	mov    %edx,%eax
f011b1c3:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011b1c8:	77 17                	ja     f011b1e1 <test_kfree_bestfirstfit+0xf4f>
f011b1ca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b1d1:	83 ec 0c             	sub    $0xc,%esp
f011b1d4:	68 44 c3 12 f0       	push   $0xf012c344
f011b1d9:	e8 8e 5d fe ff       	call   f0100f6c <cprintf>
f011b1de:	83 c4 10             	add    $0x10,%esp

		//				if(start_freeFrames != (sys_calculate_free_frames())) {{ correct = 0; cprintf("Wrong kfree: not all pages removed correctly at end\n"); }}
	}
	if (correct)	eval+=15 ;
f011b1e1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b1e5:	74 04                	je     f011b1eb <test_kfree_bestfirstfit+0xf59>
f011b1e7:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011b1eb:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access after kfree [15%]
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);
f011b1f2:	83 ec 0c             	sub    $0xc,%esp
f011b1f5:	6a 03                	push   $0x3
f011b1f7:	e8 eb 28 ff ff       	call   f010dae7 <sys_bypassPageFault>
f011b1fc:	83 c4 10             	add    $0x10,%esp

		for (i = 0; i <= 10; ++i)
f011b1ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b206:	e9 af 00 00 00       	jmp    f011b2ba <test_kfree_bestfirstfit+0x1028>
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
f011b20b:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f011b20f:	0f 84 a1 00 00 00    	je     f011b2b6 <test_kfree_bestfirstfit+0x1024>
f011b215:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f011b219:	0f 84 97 00 00 00    	je     f011b2b6 <test_kfree_bestfirstfit+0x1024>
f011b21f:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
f011b223:	0f 84 8d 00 00 00    	je     f011b2b6 <test_kfree_bestfirstfit+0x1024>
			{
				continue;
			}
			ptr = (char *) ptr_allocations[i];
f011b229:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b22c:	8b 84 85 c8 fe ff ff 	mov    -0x138(%ebp,%eax,4),%eax
f011b233:	89 45 c0             	mov    %eax,-0x40(%ebp)
			ptr[0] = 10;
f011b236:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b239:	c6 00 0a             	movb   $0xa,(%eax)
			//cprintf("\n\ncr2 = %x, faulted addr = %x", sys_rcr2(), (uint32)&(ptr[0]));
			if (sys_rcr2() != (uint32)&(ptr[0]))
f011b23c:	e8 94 28 ff ff       	call   f010dad5 <sys_rcr2>
f011b241:	89 c2                	mov    %eax,%edx
f011b243:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b246:	39 c2                	cmp    %eax,%edx
f011b248:	74 1d                	je     f011b267 <test_kfree_bestfirstfit+0xfd5>
				if (correct)
f011b24a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b24e:	74 17                	je     f011b267 <test_kfree_bestfirstfit+0xfd5>
				{ correct = 0; cprintf("kfree: successful access to freed space!! it should not be succeeded\n"); }
f011b250:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b257:	83 ec 0c             	sub    $0xc,%esp
f011b25a:	68 28 c4 12 f0       	push   $0xf012c428
f011b25f:	e8 08 5d fe ff       	call   f0100f6c <cprintf>
f011b264:	83 c4 10             	add    $0x10,%esp
			ptr[lastIndices[i]] = 10;
f011b267:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b26a:	8b 84 85 68 ff ff ff 	mov    -0x98(%ebp,%eax,4),%eax
f011b271:	89 c2                	mov    %eax,%edx
f011b273:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b276:	01 d0                	add    %edx,%eax
f011b278:	c6 00 0a             	movb   $0xa,(%eax)
			if (sys_rcr2() != (uint32)&(ptr[lastIndices[i]]))
f011b27b:	e8 55 28 ff ff       	call   f010dad5 <sys_rcr2>
f011b280:	89 c2                	mov    %eax,%edx
f011b282:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b285:	8b 84 85 68 ff ff ff 	mov    -0x98(%ebp,%eax,4),%eax
f011b28c:	89 c1                	mov    %eax,%ecx
f011b28e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b291:	01 c8                	add    %ecx,%eax
f011b293:	39 c2                	cmp    %eax,%edx
f011b295:	74 20                	je     f011b2b7 <test_kfree_bestfirstfit+0x1025>
				if (correct)
f011b297:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b29b:	74 1a                	je     f011b2b7 <test_kfree_bestfirstfit+0x1025>
				{ correct = 0; cprintf("kfree: successful access to freed space!! it should not be succeeded\n"); }
f011b29d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b2a4:	83 ec 0c             	sub    $0xc,%esp
f011b2a7:	68 28 c4 12 f0       	push   $0xf012c428
f011b2ac:	e8 bb 5c fe ff       	call   f0100f6c <cprintf>
f011b2b1:	83 c4 10             	add    $0x10,%esp
f011b2b4:	eb 01                	jmp    f011b2b7 <test_kfree_bestfirstfit+0x1025>
		for (i = 0; i <= 10; ++i)
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
			{
				continue;
f011b2b6:	90                   	nop
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);

		for (i = 0; i <= 10; ++i)
f011b2b7:	ff 45 f4             	incl   -0xc(%ebp)
f011b2ba:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
f011b2be:	0f 8e 47 ff ff ff    	jle    f011b20b <test_kfree_bestfirstfit+0xf79>
				if (correct)
				{ correct = 0; cprintf("kfree: successful access to freed space!! it should not be succeeded\n"); }
		}

		//set it to 0 again to cancel the bypassing option
		sys_bypassPageFault(0);
f011b2c4:	83 ec 0c             	sub    $0xc,%esp
f011b2c7:	6a 00                	push   $0x0
f011b2c9:	e8 19 28 ff ff       	call   f010dae7 <sys_bypassPageFault>
f011b2ce:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=15 ;
f011b2d1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b2d5:	74 04                	je     f011b2db <test_kfree_bestfirstfit+0x1049>
f011b2d7:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011b2db:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	//Allocate after kfree ALL [30%]
	{
		//[DYNAMIC ALLOCATOR] Allocate in merged freed space
		//1 KB
		freeFrames = sys_calculate_free_frames() ;
f011b2e2:	e8 40 24 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b2e7:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b2ea:	e8 6f 92 fe ff       	call   f010455e <pf_calculate_free_frames>
f011b2ef:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[11] = kmalloc(1*kilo);
f011b2f2:	83 ec 0c             	sub    $0xc,%esp
f011b2f5:	68 00 04 00 00       	push   $0x400
f011b2fa:	e8 d5 d4 fe ff       	call   f01087d4 <kmalloc>
f011b2ff:	83 c4 10             	add    $0x10,%esp
f011b302:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
		if ((ptr_allocations[11] < ptr_allocations[2]) || (ptr_allocations[11] > (ptr_allocations[2] + 1*kilo)))
f011b308:	8b 95 f4 fe ff ff    	mov    -0x10c(%ebp),%edx
f011b30e:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011b314:	39 c2                	cmp    %eax,%edx
f011b316:	72 16                	jb     f011b32e <test_kfree_bestfirstfit+0x109c>
f011b318:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011b31e:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011b324:	81 c2 00 04 00 00    	add    $0x400,%edx
f011b32a:	39 d0                	cmp    %edx,%eax
f011b32c:	76 17                	jbe    f011b345 <test_kfree_bestfirstfit+0x10b3>
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b32e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b335:	83 ec 0c             	sub    $0xc,%esp
f011b338:	68 f0 bf 12 f0       	push   $0xf012bff0
f011b33d:	e8 2a 5c fe ff       	call   f0100f6c <cprintf>
f011b342:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b345:	e8 14 92 fe ff       	call   f010455e <pf_calculate_free_frames>
f011b34a:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b34d:	74 17                	je     f011b366 <test_kfree_bestfirstfit+0x10d4>
f011b34f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b356:	83 ec 0c             	sub    $0xc,%esp
f011b359:	68 40 bf 12 f0       	push   $0xf012bf40
f011b35e:	e8 09 5c fe ff       	call   f0100f6c <cprintf>
f011b363:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011b366:	e8 bc 23 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b36b:	89 c2                	mov    %eax,%edx
f011b36d:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b370:	39 c2                	cmp    %eax,%edx
f011b372:	74 17                	je     f011b38b <test_kfree_bestfirstfit+0x10f9>
f011b374:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b37b:	83 ec 0c             	sub    $0xc,%esp
f011b37e:	68 b0 c3 12 f0       	push   $0xf012c3b0
f011b383:	e8 e4 5b fe ff       	call   f0100f6c <cprintf>
f011b388:	83 c4 10             	add    $0x10,%esp
		lastIndices[11] = (1*kilo)/sizeof(char) - 1;
f011b38b:	c7 45 94 ff 03 00 00 	movl   $0x3ff,-0x6c(%ebp)
		ptr = (char*)ptr_allocations[11];
f011b392:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011b398:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[11]; ++i)
f011b39b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b3a2:	eb 0e                	jmp    f011b3b2 <test_kfree_bestfirstfit+0x1120>
		{
			ptr[i] = 11 ;
f011b3a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011b3a7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b3aa:	01 d0                	add    %edx,%eax
f011b3ac:	c6 00 0b             	movb   $0xb,(%eax)
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[11] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[11];
		for (i = 0; i < lastIndices[11]; ++i)
f011b3af:	ff 45 f4             	incl   -0xc(%ebp)
f011b3b2:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011b3b5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b3b8:	7f ea                	jg     f011b3a4 <test_kfree_bestfirstfit+0x1112>
			ptr[i] = 11 ;
		}

		//[DYNAMIC ALLOCATOR] Allocate in merged freed space
		//2 KB
		freeFrames = sys_calculate_free_frames() ;
f011b3ba:	e8 68 23 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b3bf:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b3c2:	e8 97 91 fe ff       	call   f010455e <pf_calculate_free_frames>
f011b3c7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[12] = kmalloc(2*kilo);
f011b3ca:	83 ec 0c             	sub    $0xc,%esp
f011b3cd:	68 00 08 00 00       	push   $0x800
f011b3d2:	e8 fd d3 fe ff       	call   f01087d4 <kmalloc>
f011b3d7:	83 c4 10             	add    $0x10,%esp
f011b3da:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
		//expected = ptr_allocations[2] + 1*kilo + sizeOfMetaData();
		//if (ptr_allocations[12] != expected)
		if ((ptr_allocations[12] < ptr_allocations[2] + 1*kilo) || (ptr_allocations[12] > (ptr_allocations[2] + 2*kilo)))
f011b3e0:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011b3e6:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011b3ec:	81 c2 00 04 00 00    	add    $0x400,%edx
f011b3f2:	39 d0                	cmp    %edx,%eax
f011b3f4:	72 16                	jb     f011b40c <test_kfree_bestfirstfit+0x117a>
f011b3f6:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011b3fc:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011b402:	81 c2 00 08 00 00    	add    $0x800,%edx
f011b408:	39 d0                	cmp    %edx,%eax
f011b40a:	76 35                	jbe    f011b441 <test_kfree_bestfirstfit+0x11af>
		{
			correct = 0;
f011b40c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
			cprintf("Wrong start address for the allocated space... check return address of kmalloc. Expected [%x, %x], Actual %x\n", (ptr_allocations[2] + 1*kilo), (ptr_allocations[2] + 2*kilo), ptr_allocations[12]);
f011b413:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011b419:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011b41f:	8d 8a 00 08 00 00    	lea    0x800(%edx),%ecx
f011b425:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011b42b:	81 c2 00 04 00 00    	add    $0x400,%edx
f011b431:	50                   	push   %eax
f011b432:	51                   	push   %ecx
f011b433:	52                   	push   %edx
f011b434:	68 70 c4 12 f0       	push   $0xf012c470
f011b439:	e8 2e 5b fe ff       	call   f0100f6c <cprintf>
f011b43e:	83 c4 10             	add    $0x10,%esp
		}
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b441:	e8 18 91 fe ff       	call   f010455e <pf_calculate_free_frames>
f011b446:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b449:	74 17                	je     f011b462 <test_kfree_bestfirstfit+0x11d0>
f011b44b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b452:	83 ec 0c             	sub    $0xc,%esp
f011b455:	68 40 bf 12 f0       	push   $0xf012bf40
f011b45a:	e8 0d 5b fe ff       	call   f0100f6c <cprintf>
f011b45f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011b462:	e8 c0 22 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b467:	89 c2                	mov    %eax,%edx
f011b469:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b46c:	39 c2                	cmp    %eax,%edx
f011b46e:	74 17                	je     f011b487 <test_kfree_bestfirstfit+0x11f5>
f011b470:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b477:	83 ec 0c             	sub    $0xc,%esp
f011b47a:	68 b0 c3 12 f0       	push   $0xf012c3b0
f011b47f:	e8 e8 5a fe ff       	call   f0100f6c <cprintf>
f011b484:	83 c4 10             	add    $0x10,%esp
		lastIndices[12] = (2*kilo)/sizeof(char) - 1;
f011b487:	c7 45 98 ff 07 00 00 	movl   $0x7ff,-0x68(%ebp)
		ptr = (char*)ptr_allocations[12];
f011b48e:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011b494:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[12]; ++i)
f011b497:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b49e:	eb 0e                	jmp    f011b4ae <test_kfree_bestfirstfit+0x121c>
		{
			ptr[i] = 12 ;
f011b4a0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011b4a3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b4a6:	01 d0                	add    %edx,%eax
f011b4a8:	c6 00 0c             	movb   $0xc,(%eax)
		}
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[12] = (2*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[12];
		for (i = 0; i < lastIndices[12]; ++i)
f011b4ab:	ff 45 f4             	incl   -0xc(%ebp)
f011b4ae:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b4b1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b4b4:	7f ea                	jg     f011b4a0 <test_kfree_bestfirstfit+0x120e>
			ptr[i] = 12 ;
		}

		//[DYNAMIC ALLOCATOR] Allocate in merged freed space
		//1.5 KB
		freeFrames = sys_calculate_free_frames() ;
f011b4b6:	e8 6c 22 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b4bb:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b4be:	e8 9b 90 fe ff       	call   f010455e <pf_calculate_free_frames>
f011b4c3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[13] = kmalloc(3*kilo/2);
f011b4c6:	83 ec 0c             	sub    $0xc,%esp
f011b4c9:	68 00 06 00 00       	push   $0x600
f011b4ce:	e8 01 d3 fe ff       	call   f01087d4 <kmalloc>
f011b4d3:	83 c4 10             	add    $0x10,%esp
f011b4d6:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
		//if (ptr_allocations[13] != ptr_allocations[12] + 2*kilo + sizeOfMetaData())
		if ((ptr_allocations[13] < ptr_allocations[2] + 3*kilo) || (ptr_allocations[13] > (ptr_allocations[2] + 4*kilo)))
f011b4dc:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011b4e2:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011b4e8:	81 c2 00 0c 00 00    	add    $0xc00,%edx
f011b4ee:	39 d0                	cmp    %edx,%eax
f011b4f0:	72 16                	jb     f011b508 <test_kfree_bestfirstfit+0x1276>
f011b4f2:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011b4f8:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011b4fe:	81 c2 00 10 00 00    	add    $0x1000,%edx
f011b504:	39 d0                	cmp    %edx,%eax
f011b506:	76 17                	jbe    f011b51f <test_kfree_bestfirstfit+0x128d>
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b508:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b50f:	83 ec 0c             	sub    $0xc,%esp
f011b512:	68 f0 bf 12 f0       	push   $0xf012bff0
f011b517:	e8 50 5a fe ff       	call   f0100f6c <cprintf>
f011b51c:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b51f:	e8 3a 90 fe ff       	call   f010455e <pf_calculate_free_frames>
f011b524:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b527:	74 17                	je     f011b540 <test_kfree_bestfirstfit+0x12ae>
f011b529:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b530:	83 ec 0c             	sub    $0xc,%esp
f011b533:	68 40 bf 12 f0       	push   $0xf012bf40
f011b538:	e8 2f 5a fe ff       	call   f0100f6c <cprintf>
f011b53d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011b540:	e8 e2 21 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b545:	89 c2                	mov    %eax,%edx
f011b547:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b54a:	39 c2                	cmp    %eax,%edx
f011b54c:	74 17                	je     f011b565 <test_kfree_bestfirstfit+0x12d3>
f011b54e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b555:	83 ec 0c             	sub    $0xc,%esp
f011b558:	68 b0 c3 12 f0       	push   $0xf012c3b0
f011b55d:	e8 0a 5a fe ff       	call   f0100f6c <cprintf>
f011b562:	83 c4 10             	add    $0x10,%esp
		lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
f011b565:	c7 45 9c ff 05 00 00 	movl   $0x5ff,-0x64(%ebp)
		ptr = (char*)ptr_allocations[13];
f011b56c:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011b572:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[13]; ++i)
f011b575:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b57c:	eb 0e                	jmp    f011b58c <test_kfree_bestfirstfit+0x12fa>
		{
			ptr[i] = 13 ;
f011b57e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011b581:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b584:	01 d0                	add    %edx,%eax
f011b586:	c6 00 0d             	movb   $0xd,(%eax)
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[13];
		for (i = 0; i < lastIndices[13]; ++i)
f011b589:	ff 45 f4             	incl   -0xc(%ebp)
f011b58c:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011b58f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b592:	7f ea                	jg     f011b57e <test_kfree_bestfirstfit+0x12ec>
			ptr[i] = 13 ;
		}

		//[PAGE ALLOCATOR] Allocate in merged freed space
		//30 MB
		freeFrames = sys_calculate_free_frames() ;
f011b594:	e8 8e 21 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b599:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b59c:	e8 bd 8f fe ff       	call   f010455e <pf_calculate_free_frames>
f011b5a1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(30*Mega);
f011b5a4:	83 ec 0c             	sub    $0xc,%esp
f011b5a7:	68 00 00 e0 01       	push   $0x1e00000
f011b5ac:	e8 23 d2 fe ff       	call   f01087d4 <kmalloc>
f011b5b1:	83 c4 10             	add    $0x10,%esp
f011b5b4:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b5ba:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011b5c0:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011b5c5:	74 17                	je     f011b5de <test_kfree_bestfirstfit+0x134c>
f011b5c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b5ce:	83 ec 0c             	sub    $0xc,%esp
f011b5d1:	68 f0 bf 12 f0       	push   $0xf012bff0
f011b5d6:	e8 91 59 fe ff       	call   f0100f6c <cprintf>
f011b5db:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b5de:	e8 7b 8f fe ff       	call   f010455e <pf_calculate_free_frames>
f011b5e3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b5e6:	74 17                	je     f011b5ff <test_kfree_bestfirstfit+0x136d>
f011b5e8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b5ef:	83 ec 0c             	sub    $0xc,%esp
f011b5f2:	68 40 bf 12 f0       	push   $0xf012bf40
f011b5f7:	e8 70 59 fe ff       	call   f0100f6c <cprintf>
f011b5fc:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b5ff:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011b602:	e8 20 21 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b607:	29 c3                	sub    %eax,%ebx
f011b609:	89 d8                	mov    %ebx,%eax
f011b60b:	3d ff 1d 00 00       	cmp    $0x1dff,%eax
f011b610:	77 17                	ja     f011b629 <test_kfree_bestfirstfit+0x1397>
f011b612:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b619:	83 ec 0c             	sub    $0xc,%esp
f011b61c:	68 ac bf 12 f0       	push   $0xf012bfac
f011b621:	e8 46 59 fe ff       	call   f0100f6c <cprintf>
f011b626:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (30*Mega)/sizeof(char) - 1;
f011b629:	c7 45 90 ff ff df 01 	movl   $0x1dfffff,-0x70(%ebp)
		ptr = (char*)ptr_allocations[10];
f011b630:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011b636:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f011b639:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b640:	eb 0e                	jmp    f011b650 <test_kfree_bestfirstfit+0x13be>
		{
			ptr[i] = 10 ;
f011b642:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011b645:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b648:	01 d0                	add    %edx,%eax
f011b64a:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (30*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011b64d:	ff 45 f4             	incl   -0xc(%ebp)
f011b650:	8b 45 90             	mov    -0x70(%ebp),%eax
f011b653:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b656:	7f ea                	jg     f011b642 <test_kfree_bestfirstfit+0x13b0>
			ptr[i] = 10 ;
		}


		//30 MB
		ptr = (char*)ptr_allocations[10];
f011b658:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011b65e:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f011b661:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b668:	eb 1e                	jmp    f011b688 <test_kfree_bestfirstfit+0x13f6>
		{
			sums[10] += ptr[i] ;
f011b66a:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011b670:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011b673:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b676:	01 c8                	add    %ecx,%eax
f011b678:	8a 00                	mov    (%eax),%al
f011b67a:	0f be c0             	movsbl %al,%eax
f011b67d:	01 d0                	add    %edx,%eax
f011b67f:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
		}


		//30 MB
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011b685:	ff 45 f4             	incl   -0xc(%ebp)
f011b688:	8b 45 90             	mov    -0x70(%ebp),%eax
f011b68b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b68e:	7f da                	jg     f011b66a <test_kfree_bestfirstfit+0x13d8>
		{
			sums[10] += ptr[i] ;
		}
		if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }
f011b690:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f011b696:	8b 55 90             	mov    -0x70(%ebp),%edx
f011b699:	89 d0                	mov    %edx,%eax
f011b69b:	c1 e0 02             	shl    $0x2,%eax
f011b69e:	01 d0                	add    %edx,%eax
f011b6a0:	01 c0                	add    %eax,%eax
f011b6a2:	39 c1                	cmp    %eax,%ecx
f011b6a4:	74 17                	je     f011b6bd <test_kfree_bestfirstfit+0x142b>
f011b6a6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b6ad:	83 ec 0c             	sub    $0xc,%esp
f011b6b0:	68 e0 c4 12 f0       	push   $0xf012c4e0
f011b6b5:	e8 b2 58 fe ff       	call   f0100f6c <cprintf>
f011b6ba:	83 c4 10             	add    $0x10,%esp

		//1 KB
		ptr = (char*)ptr_allocations[11];
f011b6bd:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011b6c3:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[11]; ++i)
f011b6c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b6cd:	eb 1e                	jmp    f011b6ed <test_kfree_bestfirstfit+0x145b>
		{
			sums[11] += ptr[i] ;
f011b6cf:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f011b6d5:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011b6d8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b6db:	01 c8                	add    %ecx,%eax
f011b6dd:	8a 00                	mov    (%eax),%al
f011b6df:	0f be c0             	movsbl %al,%eax
f011b6e2:	01 d0                	add    %edx,%eax
f011b6e4:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
		}
		if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }

		//1 KB
		ptr = (char*)ptr_allocations[11];
		for (i = 0; i < lastIndices[11]; ++i)
f011b6ea:	ff 45 f4             	incl   -0xc(%ebp)
f011b6ed:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011b6f0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b6f3:	7f da                	jg     f011b6cf <test_kfree_bestfirstfit+0x143d>
		{
			sums[11] += ptr[i] ;
		}
		if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }
f011b6f5:	8b 8d 44 ff ff ff    	mov    -0xbc(%ebp),%ecx
f011b6fb:	8b 55 94             	mov    -0x6c(%ebp),%edx
f011b6fe:	89 d0                	mov    %edx,%eax
f011b700:	c1 e0 02             	shl    $0x2,%eax
f011b703:	01 d0                	add    %edx,%eax
f011b705:	01 c0                	add    %eax,%eax
f011b707:	01 d0                	add    %edx,%eax
f011b709:	39 c1                	cmp    %eax,%ecx
f011b70b:	74 17                	je     f011b724 <test_kfree_bestfirstfit+0x1492>
f011b70d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b714:	83 ec 0c             	sub    $0xc,%esp
f011b717:	68 e0 c4 12 f0       	push   $0xf012c4e0
f011b71c:	e8 4b 58 fe ff       	call   f0100f6c <cprintf>
f011b721:	83 c4 10             	add    $0x10,%esp

		//2 KB
		ptr = (char*)ptr_allocations[12];
f011b724:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011b72a:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[12]; ++i)
f011b72d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b734:	eb 1e                	jmp    f011b754 <test_kfree_bestfirstfit+0x14c2>
		{
			sums[12] += ptr[i] ;
f011b736:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011b73c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011b73f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b742:	01 c8                	add    %ecx,%eax
f011b744:	8a 00                	mov    (%eax),%al
f011b746:	0f be c0             	movsbl %al,%eax
f011b749:	01 d0                	add    %edx,%eax
f011b74b:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		}
		if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }

		//2 KB
		ptr = (char*)ptr_allocations[12];
		for (i = 0; i < lastIndices[12]; ++i)
f011b751:	ff 45 f4             	incl   -0xc(%ebp)
f011b754:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b757:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b75a:	7f da                	jg     f011b736 <test_kfree_bestfirstfit+0x14a4>
		{
			sums[12] += ptr[i] ;
		}
		if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }
f011b75c:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
f011b762:	8b 55 98             	mov    -0x68(%ebp),%edx
f011b765:	89 d0                	mov    %edx,%eax
f011b767:	01 c0                	add    %eax,%eax
f011b769:	01 d0                	add    %edx,%eax
f011b76b:	c1 e0 02             	shl    $0x2,%eax
f011b76e:	39 c1                	cmp    %eax,%ecx
f011b770:	74 17                	je     f011b789 <test_kfree_bestfirstfit+0x14f7>
f011b772:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b779:	83 ec 0c             	sub    $0xc,%esp
f011b77c:	68 e0 c4 12 f0       	push   $0xf012c4e0
f011b781:	e8 e6 57 fe ff       	call   f0100f6c <cprintf>
f011b786:	83 c4 10             	add    $0x10,%esp

		//1.5 KB
		ptr = (char*)ptr_allocations[13];
f011b789:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011b78f:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[13]; ++i)
f011b792:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b799:	eb 1e                	jmp    f011b7b9 <test_kfree_bestfirstfit+0x1527>
		{
			sums[13] += ptr[i] ;
f011b79b:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f011b7a1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011b7a4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b7a7:	01 c8                	add    %ecx,%eax
f011b7a9:	8a 00                	mov    (%eax),%al
f011b7ab:	0f be c0             	movsbl %al,%eax
f011b7ae:	01 d0                	add    %edx,%eax
f011b7b0:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		}
		if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }

		//1.5 KB
		ptr = (char*)ptr_allocations[13];
		for (i = 0; i < lastIndices[13]; ++i)
f011b7b6:	ff 45 f4             	incl   -0xc(%ebp)
f011b7b9:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011b7bc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b7bf:	7f da                	jg     f011b79b <test_kfree_bestfirstfit+0x1509>
		{
			sums[13] += ptr[i] ;
		}
		if (sums[13] != 13*lastIndices[13])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }
f011b7c1:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f011b7c7:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011b7ca:	89 d0                	mov    %edx,%eax
f011b7cc:	01 c0                	add    %eax,%eax
f011b7ce:	01 d0                	add    %edx,%eax
f011b7d0:	c1 e0 02             	shl    $0x2,%eax
f011b7d3:	01 d0                	add    %edx,%eax
f011b7d5:	39 c1                	cmp    %eax,%ecx
f011b7d7:	74 17                	je     f011b7f0 <test_kfree_bestfirstfit+0x155e>
f011b7d9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b7e0:	83 ec 0c             	sub    $0xc,%esp
f011b7e3:	68 e0 c4 12 f0       	push   $0xf012c4e0
f011b7e8:	e8 7f 57 fe ff       	call   f0100f6c <cprintf>
f011b7ed:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f011b7f0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b7f4:	74 04                	je     f011b7fa <test_kfree_bestfirstfit+0x1568>
f011b7f6:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011b7fa:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//check tables	[5%]
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011b801:	c7 45 e0 00 00 00 f6 	movl   $0xf6000000,-0x20(%ebp)
f011b808:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011b80f:	eb 4e                	jmp    f011b85f <test_kfree_bestfirstfit+0x15cd>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va, &ptr_table);
f011b811:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011b814:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011b819:	83 ec 04             	sub    $0x4,%esp
f011b81c:	8d 8d c4 fe ff ff    	lea    -0x13c(%ebp),%ecx
f011b822:	51                   	push   %ecx
f011b823:	52                   	push   %edx
f011b824:	50                   	push   %eax
f011b825:	e8 01 c9 fe ff       	call   f010812b <get_page_table>
f011b82a:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b82d:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f011b833:	85 c0                	test   %eax,%eax
f011b835:	75 1d                	jne    f011b854 <test_kfree_bestfirstfit+0x15c2>
			{
				if (correct)
f011b837:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b83b:	74 17                	je     f011b854 <test_kfree_bestfirstfit+0x15c2>
				{ correct = 0; cprintf("Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
f011b83d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b844:	83 ec 0c             	sub    $0xc,%esp
f011b847:	68 0c c5 12 f0       	push   $0xf012c50c
f011b84c:	e8 1b 57 fe ff       	call   f0100f6c <cprintf>
f011b851:	83 c4 10             	add    $0x10,%esp

	correct = 1 ;
	//check tables	[5%]
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011b854:	81 45 e0 00 00 40 00 	addl   $0x400000,-0x20(%ebp)
f011b85b:	83 55 e4 00          	adcl   $0x0,-0x1c(%ebp)
f011b85f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011b863:	78 ac                	js     f011b811 <test_kfree_bestfirstfit+0x157f>
f011b865:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011b869:	7f 09                	jg     f011b874 <test_kfree_bestfirstfit+0x15e2>
f011b86b:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f011b872:	76 9d                	jbe    f011b811 <test_kfree_bestfirstfit+0x157f>
				if (correct)
				{ correct = 0; cprintf("Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
			}
		}
	}
	if (correct)	eval+=5 ;
f011b874:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b878:	74 04                	je     f011b87e <test_kfree_bestfirstfit+0x15ec>
f011b87a:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)

	cprintf("\ntest kfree completed. Eval = %d%\n", eval);
f011b87e:	83 ec 08             	sub    $0x8,%esp
f011b881:	ff 75 f0             	pushl  -0x10(%ebp)
f011b884:	68 74 c5 12 f0       	push   $0xf012c574
f011b889:	e8 de 56 fe ff       	call   f0100f6c <cprintf>
f011b88e:	83 c4 10             	add    $0x10,%esp

	return 1;
f011b891:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011b896:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011b899:	5b                   	pop    %ebx
f011b89a:	5f                   	pop    %edi
f011b89b:	5d                   	pop    %ebp
f011b89c:	c3                   	ret    

f011b89d <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f011b89d:	55                   	push   %ebp
f011b89e:	89 e5                	mov    %esp,%ebp
f011b8a0:	57                   	push   %edi
f011b8a1:	53                   	push   %ebx
f011b8a2:	81 ec b0 35 00 00    	sub    $0x35b0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011b8a8:	83 ec 0c             	sub    $0xc,%esp
f011b8ab:	68 80 be 12 f0       	push   $0xf012be80
f011b8b0:	e8 b7 56 fe ff       	call   f0100f6c <cprintf>
f011b8b5:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011b8b8:	83 ec 0c             	sub    $0xc,%esp
f011b8bb:	68 b0 be 12 f0       	push   $0xf012beb0
f011b8c0:	e8 a7 56 fe ff       	call   f0100f6c <cprintf>
f011b8c5:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011b8c8:	83 ec 0c             	sub    $0xc,%esp
f011b8cb:	68 80 be 12 f0       	push   $0xf012be80
f011b8d0:	e8 97 56 fe ff       	call   f0100f6c <cprintf>
f011b8d5:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011b8d8:	c6 45 bf 80          	movb   $0x80,-0x41(%ebp)
	char maxByte = 0x7F;
f011b8dc:	c6 45 be 7f          	movb   $0x7f,-0x42(%ebp)
	short minShort = 1<<15 ;
f011b8e0:	66 c7 45 bc 00 80    	movw   $0x8000,-0x44(%ebp)
	short maxShort = 0x7FFF;
f011b8e6:	66 c7 45 ba ff 7f    	movw   $0x7fff,-0x46(%ebp)
	int minInt = 1<<31 ;
f011b8ec:	c7 45 b4 00 00 00 80 	movl   $0x80000000,-0x4c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011b8f3:	c7 45 b0 ff ff ff 7f 	movl   $0x7fffffff,-0x50(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011b8fa:	e8 28 1e ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b8ff:	89 45 ac             	mov    %eax,-0x54(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011b902:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
f011b908:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b90d:	b8 00 00 00 00       	mov    $0x0,%eax
f011b912:	89 d7                	mov    %edx,%edi
f011b914:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011b916:	8d 95 c4 fe ff ff    	lea    -0x13c(%ebp),%edx
f011b91c:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b921:	b8 00 00 00 00       	mov    $0x0,%eax
f011b926:	89 d7                	mov    %edx,%edi
f011b928:	f3 ab                	rep stos %eax,%es:(%edi)
	int eval = 0;
f011b92a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011b931:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011b938:	8d 95 74 fe ff ff    	lea    -0x18c(%ebp),%edx
f011b93e:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b943:	b8 00 00 00 00       	mov    $0x0,%eax
f011b948:	89 d7                	mov    %edx,%edi
f011b94a:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b94c:	e8 d6 1d ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b951:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b954:	e8 05 8c fe ff       	call   f010455e <pf_calculate_free_frames>
f011b959:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011b95c:	83 ec 0c             	sub    $0xc,%esp
f011b95f:	68 00 fc 1f 00       	push   $0x1ffc00
f011b964:	e8 6b ce fe ff       	call   f01087d4 <kmalloc>
f011b969:	83 c4 10             	add    $0x10,%esp
f011b96c:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b972:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011b978:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011b97d:	74 17                	je     f011b996 <test_kheap_phys_addr+0xf9>
f011b97f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b986:	83 ec 0c             	sub    $0xc,%esp
f011b989:	68 f0 bf 12 f0       	push   $0xf012bff0
f011b98e:	e8 d9 55 fe ff       	call   f0100f6c <cprintf>
f011b993:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b996:	e8 c3 8b fe ff       	call   f010455e <pf_calculate_free_frames>
f011b99b:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b99e:	74 17                	je     f011b9b7 <test_kheap_phys_addr+0x11a>
f011b9a0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b9a7:	83 ec 0c             	sub    $0xc,%esp
f011b9aa:	68 40 bf 12 f0       	push   $0xf012bf40
f011b9af:	e8 b8 55 fe ff       	call   f0100f6c <cprintf>
f011b9b4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b9b7:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b9ba:	e8 68 1d ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b9bf:	29 c3                	sub    %eax,%ebx
f011b9c1:	89 d8                	mov    %ebx,%eax
f011b9c3:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b9c8:	77 17                	ja     f011b9e1 <test_kheap_phys_addr+0x144>
f011b9ca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b9d1:	83 ec 0c             	sub    $0xc,%esp
f011b9d4:	68 ac bf 12 f0       	push   $0xf012bfac
f011b9d9:	e8 8e 55 fe ff       	call   f0100f6c <cprintf>
f011b9de:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b9e1:	e8 41 1d ff ff       	call   f010d727 <sys_calculate_free_frames>
f011b9e6:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b9e9:	e8 70 8b fe ff       	call   f010455e <pf_calculate_free_frames>
f011b9ee:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011b9f1:	83 ec 0c             	sub    $0xc,%esp
f011b9f4:	68 00 fc 1f 00       	push   $0x1ffc00
f011b9f9:	e8 d6 cd fe ff       	call   f01087d4 <kmalloc>
f011b9fe:	83 c4 10             	add    $0x10,%esp
f011ba01:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ba07:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011ba0d:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011ba12:	74 17                	je     f011ba2b <test_kheap_phys_addr+0x18e>
f011ba14:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ba1b:	83 ec 0c             	sub    $0xc,%esp
f011ba1e:	68 f0 bf 12 f0       	push   $0xf012bff0
f011ba23:	e8 44 55 fe ff       	call   f0100f6c <cprintf>
f011ba28:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ba2b:	e8 2e 8b fe ff       	call   f010455e <pf_calculate_free_frames>
f011ba30:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011ba33:	74 17                	je     f011ba4c <test_kheap_phys_addr+0x1af>
f011ba35:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ba3c:	83 ec 0c             	sub    $0xc,%esp
f011ba3f:	68 40 bf 12 f0       	push   $0xf012bf40
f011ba44:	e8 23 55 fe ff       	call   f0100f6c <cprintf>
f011ba49:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ba4c:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011ba4f:	e8 d3 1c ff ff       	call   f010d727 <sys_calculate_free_frames>
f011ba54:	29 c3                	sub    %eax,%ebx
f011ba56:	89 d8                	mov    %ebx,%eax
f011ba58:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011ba5d:	77 17                	ja     f011ba76 <test_kheap_phys_addr+0x1d9>
f011ba5f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ba66:	83 ec 0c             	sub    $0xc,%esp
f011ba69:	68 ac bf 12 f0       	push   $0xf012bfac
f011ba6e:	e8 f9 54 fe ff       	call   f0100f6c <cprintf>
f011ba73:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011ba76:	e8 ac 1c ff ff       	call   f010d727 <sys_calculate_free_frames>
f011ba7b:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011ba7e:	e8 db 8a fe ff       	call   f010455e <pf_calculate_free_frames>
f011ba83:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011ba86:	83 ec 0c             	sub    $0xc,%esp
f011ba89:	68 00 04 00 00       	push   $0x400
f011ba8e:	e8 41 cd fe ff       	call   f01087d4 <kmalloc>
f011ba93:	83 c4 10             	add    $0x10,%esp
f011ba96:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011ba9c:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011baa2:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011baa7:	76 28                	jbe    f011bad1 <test_kheap_phys_addr+0x234>
f011baa9:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011baaf:	83 ec 0c             	sub    $0xc,%esp
f011bab2:	6a 00                	push   $0x0
f011bab4:	e8 11 cd fe ff       	call   f01087ca <sbrk>
f011bab9:	83 c4 10             	add    $0x10,%esp
f011babc:	39 c3                	cmp    %eax,%ebx
f011babe:	73 11                	jae    f011bad1 <test_kheap_phys_addr+0x234>
f011bac0:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011bac6:	89 c2                	mov    %eax,%edx
f011bac8:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011bacd:	39 c2                	cmp    %eax,%edx
f011bacf:	72 17                	jb     f011bae8 <test_kheap_phys_addr+0x24b>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011bad1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bad8:	83 ec 0c             	sub    $0xc,%esp
f011badb:	68 40 c0 12 f0       	push   $0xf012c040
f011bae0:	e8 87 54 fe ff       	call   f0100f6c <cprintf>
f011bae5:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bae8:	e8 71 8a fe ff       	call   f010455e <pf_calculate_free_frames>
f011baed:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011baf0:	74 17                	je     f011bb09 <test_kheap_phys_addr+0x26c>
f011baf2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011baf9:	83 ec 0c             	sub    $0xc,%esp
f011bafc:	68 40 bf 12 f0       	push   $0xf012bf40
f011bb01:	e8 66 54 fe ff       	call   f0100f6c <cprintf>
f011bb06:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011bb09:	e8 19 1c ff ff       	call   f010d727 <sys_calculate_free_frames>
f011bb0e:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011bb11:	e8 48 8a fe ff       	call   f010455e <pf_calculate_free_frames>
f011bb16:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011bb19:	83 ec 0c             	sub    $0xc,%esp
f011bb1c:	68 00 08 00 00       	push   $0x800
f011bb21:	e8 ae cc fe ff       	call   f01087d4 <kmalloc>
f011bb26:	83 c4 10             	add    $0x10,%esp
f011bb29:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011bb2f:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011bb35:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011bb3a:	76 28                	jbe    f011bb64 <test_kheap_phys_addr+0x2c7>
f011bb3c:	8b 9d 80 fe ff ff    	mov    -0x180(%ebp),%ebx
f011bb42:	83 ec 0c             	sub    $0xc,%esp
f011bb45:	6a 00                	push   $0x0
f011bb47:	e8 7e cc fe ff       	call   f01087ca <sbrk>
f011bb4c:	83 c4 10             	add    $0x10,%esp
f011bb4f:	39 c3                	cmp    %eax,%ebx
f011bb51:	73 11                	jae    f011bb64 <test_kheap_phys_addr+0x2c7>
f011bb53:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011bb59:	89 c2                	mov    %eax,%edx
f011bb5b:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011bb60:	39 c2                	cmp    %eax,%edx
f011bb62:	72 17                	jb     f011bb7b <test_kheap_phys_addr+0x2de>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011bb64:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bb6b:	83 ec 0c             	sub    $0xc,%esp
f011bb6e:	68 40 c0 12 f0       	push   $0xf012c040
f011bb73:	e8 f4 53 fe ff       	call   f0100f6c <cprintf>
f011bb78:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bb7b:	e8 de 89 fe ff       	call   f010455e <pf_calculate_free_frames>
f011bb80:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011bb83:	74 17                	je     f011bb9c <test_kheap_phys_addr+0x2ff>
f011bb85:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bb8c:	83 ec 0c             	sub    $0xc,%esp
f011bb8f:	68 40 bf 12 f0       	push   $0xf012bf40
f011bb94:	e8 d3 53 fe ff       	call   f0100f6c <cprintf>
f011bb99:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011bb9c:	e8 86 1b ff ff       	call   f010d727 <sys_calculate_free_frames>
f011bba1:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011bba4:	e8 b5 89 fe ff       	call   f010455e <pf_calculate_free_frames>
f011bba9:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011bbac:	83 ec 0c             	sub    $0xc,%esp
f011bbaf:	68 00 06 00 00       	push   $0x600
f011bbb4:	e8 1b cc fe ff       	call   f01087d4 <kmalloc>
f011bbb9:	83 c4 10             	add    $0x10,%esp
f011bbbc:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011bbc2:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011bbc8:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011bbcd:	76 28                	jbe    f011bbf7 <test_kheap_phys_addr+0x35a>
f011bbcf:	8b 9d 84 fe ff ff    	mov    -0x17c(%ebp),%ebx
f011bbd5:	83 ec 0c             	sub    $0xc,%esp
f011bbd8:	6a 00                	push   $0x0
f011bbda:	e8 eb cb fe ff       	call   f01087ca <sbrk>
f011bbdf:	83 c4 10             	add    $0x10,%esp
f011bbe2:	39 c3                	cmp    %eax,%ebx
f011bbe4:	73 11                	jae    f011bbf7 <test_kheap_phys_addr+0x35a>
f011bbe6:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011bbec:	89 c2                	mov    %eax,%edx
f011bbee:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011bbf3:	39 c2                	cmp    %eax,%edx
f011bbf5:	72 17                	jb     f011bc0e <test_kheap_phys_addr+0x371>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011bbf7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bbfe:	83 ec 0c             	sub    $0xc,%esp
f011bc01:	68 40 c0 12 f0       	push   $0xf012c040
f011bc06:	e8 61 53 fe ff       	call   f0100f6c <cprintf>
f011bc0b:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bc0e:	e8 4b 89 fe ff       	call   f010455e <pf_calculate_free_frames>
f011bc13:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011bc16:	74 17                	je     f011bc2f <test_kheap_phys_addr+0x392>
f011bc18:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bc1f:	83 ec 0c             	sub    $0xc,%esp
f011bc22:	68 40 bf 12 f0       	push   $0xf012bf40
f011bc27:	e8 40 53 fe ff       	call   f0100f6c <cprintf>
f011bc2c:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011bc2f:	e8 f3 1a ff ff       	call   f010d727 <sys_calculate_free_frames>
f011bc34:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bc37:	e8 22 89 fe ff       	call   f010455e <pf_calculate_free_frames>
f011bc3c:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011bc3f:	83 ec 0c             	sub    $0xc,%esp
f011bc42:	68 00 1c 00 00       	push   $0x1c00
f011bc47:	e8 88 cb fe ff       	call   f01087d4 <kmalloc>
f011bc4c:	83 c4 10             	add    $0x10,%esp
f011bc4f:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bc55:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011bc5b:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011bc60:	74 17                	je     f011bc79 <test_kheap_phys_addr+0x3dc>
f011bc62:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bc69:	83 ec 0c             	sub    $0xc,%esp
f011bc6c:	68 f0 bf 12 f0       	push   $0xf012bff0
f011bc71:	e8 f6 52 fe ff       	call   f0100f6c <cprintf>
f011bc76:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bc79:	e8 e0 88 fe ff       	call   f010455e <pf_calculate_free_frames>
f011bc7e:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011bc81:	74 17                	je     f011bc9a <test_kheap_phys_addr+0x3fd>
f011bc83:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bc8a:	83 ec 0c             	sub    $0xc,%esp
f011bc8d:	68 40 bf 12 f0       	push   $0xf012bf40
f011bc92:	e8 d5 52 fe ff       	call   f0100f6c <cprintf>
f011bc97:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bc9a:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011bc9d:	e8 85 1a ff ff       	call   f010d727 <sys_calculate_free_frames>
f011bca2:	29 c3                	sub    %eax,%ebx
f011bca4:	89 d8                	mov    %ebx,%eax
f011bca6:	83 f8 01             	cmp    $0x1,%eax
f011bca9:	77 17                	ja     f011bcc2 <test_kheap_phys_addr+0x425>
f011bcab:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bcb2:	83 ec 0c             	sub    $0xc,%esp
f011bcb5:	68 ac bf 12 f0       	push   $0xf012bfac
f011bcba:	e8 ad 52 fe ff       	call   f0100f6c <cprintf>
f011bcbf:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011bcc2:	e8 60 1a ff ff       	call   f010d727 <sys_calculate_free_frames>
f011bcc7:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bcca:	e8 8f 88 fe ff       	call   f010455e <pf_calculate_free_frames>
f011bccf:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011bcd2:	83 ec 0c             	sub    $0xc,%esp
f011bcd5:	68 00 fc 2f 00       	push   $0x2ffc00
f011bcda:	e8 f5 ca fe ff       	call   f01087d4 <kmalloc>
f011bcdf:	83 c4 10             	add    $0x10,%esp
f011bce2:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bce8:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011bcee:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011bcf3:	74 17                	je     f011bd0c <test_kheap_phys_addr+0x46f>
f011bcf5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bcfc:	83 ec 0c             	sub    $0xc,%esp
f011bcff:	68 f0 bf 12 f0       	push   $0xf012bff0
f011bd04:	e8 63 52 fe ff       	call   f0100f6c <cprintf>
f011bd09:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bd0c:	e8 4d 88 fe ff       	call   f010455e <pf_calculate_free_frames>
f011bd11:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011bd14:	74 17                	je     f011bd2d <test_kheap_phys_addr+0x490>
f011bd16:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bd1d:	83 ec 0c             	sub    $0xc,%esp
f011bd20:	68 40 bf 12 f0       	push   $0xf012bf40
f011bd25:	e8 42 52 fe ff       	call   f0100f6c <cprintf>
f011bd2a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bd2d:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011bd30:	e8 f2 19 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011bd35:	29 c3                	sub    %eax,%ebx
f011bd37:	89 d8                	mov    %ebx,%eax
f011bd39:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011bd3e:	77 17                	ja     f011bd57 <test_kheap_phys_addr+0x4ba>
f011bd40:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bd47:	83 ec 0c             	sub    $0xc,%esp
f011bd4a:	68 ac bf 12 f0       	push   $0xf012bfac
f011bd4f:	e8 18 52 fe ff       	call   f0100f6c <cprintf>
f011bd54:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011bd57:	e8 cb 19 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011bd5c:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bd5f:	e8 fa 87 fe ff       	call   f010455e <pf_calculate_free_frames>
f011bd64:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011bd67:	83 ec 0c             	sub    $0xc,%esp
f011bd6a:	68 00 fc 5f 00       	push   $0x5ffc00
f011bd6f:	e8 60 ca fe ff       	call   f01087d4 <kmalloc>
f011bd74:	83 c4 10             	add    $0x10,%esp
f011bd77:	89 85 90 fe ff ff    	mov    %eax,-0x170(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bd7d:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011bd83:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011bd88:	74 17                	je     f011bda1 <test_kheap_phys_addr+0x504>
f011bd8a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bd91:	83 ec 0c             	sub    $0xc,%esp
f011bd94:	68 f0 bf 12 f0       	push   $0xf012bff0
f011bd99:	e8 ce 51 fe ff       	call   f0100f6c <cprintf>
f011bd9e:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bda1:	e8 b8 87 fe ff       	call   f010455e <pf_calculate_free_frames>
f011bda6:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011bda9:	74 17                	je     f011bdc2 <test_kheap_phys_addr+0x525>
f011bdab:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bdb2:	83 ec 0c             	sub    $0xc,%esp
f011bdb5:	68 40 bf 12 f0       	push   $0xf012bf40
f011bdba:	e8 ad 51 fe ff       	call   f0100f6c <cprintf>
f011bdbf:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bdc2:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011bdc5:	e8 5d 19 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011bdca:	29 c3                	sub    %eax,%ebx
f011bdcc:	89 d8                	mov    %ebx,%eax
f011bdce:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011bdd3:	77 17                	ja     f011bdec <test_kheap_phys_addr+0x54f>
f011bdd5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bddc:	83 ec 0c             	sub    $0xc,%esp
f011bddf:	68 ac bf 12 f0       	push   $0xf012bfac
f011bde4:	e8 83 51 fe ff       	call   f0100f6c <cprintf>
f011bde9:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011bdec:	e8 36 19 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011bdf1:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bdf4:	e8 65 87 fe ff       	call   f010455e <pf_calculate_free_frames>
f011bdf9:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011bdfc:	83 ec 0c             	sub    $0xc,%esp
f011bdff:	68 00 38 00 00       	push   $0x3800
f011be04:	e8 cb c9 fe ff       	call   f01087d4 <kmalloc>
f011be09:	83 c4 10             	add    $0x10,%esp
f011be0c:	89 85 94 fe ff ff    	mov    %eax,-0x16c(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011be12:	8b 85 94 fe ff ff    	mov    -0x16c(%ebp),%eax
f011be18:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011be1d:	74 17                	je     f011be36 <test_kheap_phys_addr+0x599>
f011be1f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011be26:	83 ec 0c             	sub    $0xc,%esp
f011be29:	68 f0 bf 12 f0       	push   $0xf012bff0
f011be2e:	e8 39 51 fe ff       	call   f0100f6c <cprintf>
f011be33:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011be36:	e8 23 87 fe ff       	call   f010455e <pf_calculate_free_frames>
f011be3b:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011be3e:	74 17                	je     f011be57 <test_kheap_phys_addr+0x5ba>
f011be40:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011be47:	83 ec 0c             	sub    $0xc,%esp
f011be4a:	68 40 bf 12 f0       	push   $0xf012bf40
f011be4f:	e8 18 51 fe ff       	call   f0100f6c <cprintf>
f011be54:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011be57:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011be5a:	e8 c8 18 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011be5f:	29 c3                	sub    %eax,%ebx
f011be61:	89 d8                	mov    %ebx,%eax
f011be63:	83 f8 03             	cmp    $0x3,%eax
f011be66:	77 17                	ja     f011be7f <test_kheap_phys_addr+0x5e2>
f011be68:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011be6f:	83 ec 0c             	sub    $0xc,%esp
f011be72:	68 ac bf 12 f0       	push   $0xf012bfac
f011be77:	e8 f0 50 fe ff       	call   f0100f6c <cprintf>
f011be7c:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011be7f:	c7 45 a0 00 70 d0 f8 	movl   $0xf8d07000,-0x60(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011be86:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 1;
f011be8d:	c7 45 9c 01 00 00 00 	movl   $0x1,-0x64(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011be94:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011be99:	05 00 10 00 00       	add    $0x1000,%eax
f011be9e:	89 45 98             	mov    %eax,-0x68(%ebp)
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011bea1:	8b 45 98             	mov    -0x68(%ebp),%eax
f011bea4:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011bea7:	eb 2e                	jmp    f011bed7 <test_kheap_phys_addr+0x63a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011bea9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011beac:	8d 43 01             	lea    0x1(%ebx),%eax
f011beaf:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011beb2:	83 ec 0c             	sub    $0xc,%esp
f011beb5:	ff 75 e8             	pushl  -0x18(%ebp)
f011beb8:	e8 65 c9 fe ff       	call   f0108822 <kheap_physical_address>
f011bebd:	83 c4 10             	add    $0x10,%esp
f011bec0:	89 84 9d 48 ca ff ff 	mov    %eax,-0x35b8(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 1;
		uint32 startVA = da_limit + PAGE_SIZE;
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011bec7:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011beca:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011becd:	01 d0                	add    %edx,%eax
f011becf:	05 00 10 00 00       	add    $0x1000,%eax
f011bed4:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011bed7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011beda:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011bedd:	72 ca                	jb     f011bea9 <test_kheap_phys_addr+0x60c>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011bedf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bee2:	89 45 94             	mov    %eax,-0x6c(%ebp)
		i = 0;
f011bee5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011beec:	8b 45 98             	mov    -0x68(%ebp),%eax
f011beef:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011bef2:	e9 ce 00 00 00       	jmp    f011bfc5 <test_kheap_phys_addr+0x728>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011bef7:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011befc:	83 ec 04             	sub    $0x4,%esp
f011beff:	8d 95 70 fe ff ff    	lea    -0x190(%ebp),%edx
f011bf05:	52                   	push   %edx
f011bf06:	ff 75 e8             	pushl  -0x18(%ebp)
f011bf09:	50                   	push   %eax
f011bf0a:	e8 1c c2 fe ff       	call   f010812b <get_page_table>
f011bf0f:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011bf12:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011bf18:	85 c0                	test   %eax,%eax
f011bf1a:	75 1e                	jne    f011bf3a <test_kheap_phys_addr+0x69d>
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011bf1c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bf23:	83 ec 04             	sub    $0x4,%esp
f011bf26:	68 98 c5 12 f0       	push   $0xf012c598
f011bf2b:	68 30 05 00 00       	push   $0x530
f011bf30:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011bf35:	e8 e0 43 fe ff       	call   f010031a <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011bf3a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bf3d:	c1 e8 0c             	shr    $0xc,%eax
f011bf40:	25 ff 03 00 00       	and    $0x3ff,%eax
f011bf45:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011bf48:	eb 62                	jmp    f011bfac <test_kheap_phys_addr+0x70f>
			{
				if (((ptr_table[j] & 0xFFFFF000)+(va & 0x00000FFF))!= allPAs[i])
f011bf4a:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011bf50:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011bf53:	c1 e2 02             	shl    $0x2,%edx
f011bf56:	01 d0                	add    %edx,%eax
f011bf58:	8b 00                	mov    (%eax),%eax
f011bf5a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011bf5f:	89 c2                	mov    %eax,%edx
f011bf61:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bf64:	25 ff 0f 00 00       	and    $0xfff,%eax
f011bf69:	01 c2                	add    %eax,%edx
f011bf6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bf6e:	8b 84 85 48 ca ff ff 	mov    -0x35b8(%ebp,%eax,4),%eax
f011bf75:	39 c2                	cmp    %eax,%edx
f011bf77:	74 1d                	je     f011bf96 <test_kheap_phys_addr+0x6f9>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011bf79:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bf7d:	74 17                	je     f011bf96 <test_kheap_phys_addr+0x6f9>
					{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
f011bf7f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bf86:	83 ec 0c             	sub    $0xc,%esp
f011bf89:	68 0a c6 12 f0       	push   $0xf012c60a
f011bf8e:	e8 d9 4f fe ff       	call   f0100f6c <cprintf>
f011bf93:	83 c4 10             	add    $0x10,%esp
				}
				va+=PAGE_SIZE+offset;
f011bf96:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011bf99:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bf9c:	01 d0                	add    %edx,%eax
f011bf9e:	05 00 10 00 00       	add    $0x1000,%eax
f011bfa3:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011bfa6:	ff 45 e4             	incl   -0x1c(%ebp)
f011bfa9:	ff 45 f4             	incl   -0xc(%ebp)
f011bfac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bfaf:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f011bfb2:	7d 11                	jge    f011bfc5 <test_kheap_phys_addr+0x728>
f011bfb4:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f011bfbb:	7f 08                	jg     f011bfc5 <test_kheap_phys_addr+0x728>
f011bfbd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bfc0:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011bfc3:	72 85                	jb     f011bf4a <test_kheap_phys_addr+0x6ad>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011bfc5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bfc8:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011bfcb:	0f 82 26 ff ff ff    	jb     f011bef7 <test_kheap_phys_addr+0x65a>
				}
				va+=PAGE_SIZE+offset;
			}
		}
	}
	if (correct)	eval+=30 ;
f011bfd1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bfd5:	74 04                	je     f011bfdb <test_kheap_phys_addr+0x73e>
f011bfd7:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011bfdb:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011bfe2:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
f011bfe9:	e9 b0 00 00 00       	jmp    f011c09e <test_kheap_phys_addr+0x801>
		{
			va = (uint32)ptr_allocations[i];
f011bfee:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011bff1:	8b 84 85 74 fe ff ff 	mov    -0x18c(%ebp,%eax,4),%eax
f011bff8:	89 45 90             	mov    %eax,-0x70(%ebp)
			pa = kheap_physical_address(va);
f011bffb:	83 ec 0c             	sub    $0xc,%esp
f011bffe:	ff 75 90             	pushl  -0x70(%ebp)
f011c001:	e8 1c c8 fe ff       	call   f0108822 <kheap_physical_address>
f011c006:	83 c4 10             	add    $0x10,%esp
f011c009:	89 45 8c             	mov    %eax,-0x74(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c00c:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011c011:	83 ec 04             	sub    $0x4,%esp
f011c014:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011c01a:	52                   	push   %edx
f011c01b:	ff 75 90             	pushl  -0x70(%ebp)
f011c01e:	50                   	push   %eax
f011c01f:	e8 07 c1 fe ff       	call   f010812b <get_page_table>
f011c024:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c027:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011c02d:	85 c0                	test   %eax,%eax
f011c02f:	75 1e                	jne    f011c04f <test_kheap_phys_addr+0x7b2>
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c031:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c038:	83 ec 04             	sub    $0x4,%esp
f011c03b:	68 98 c5 12 f0       	push   $0xf012c598
f011c040:	68 4c 05 00 00       	push   $0x54c
f011c045:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011c04a:	e8 cb 42 fe ff       	call   f010031a <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011c04f:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011c055:	8b 55 90             	mov    -0x70(%ebp),%edx
f011c058:	c1 ea 0c             	shr    $0xc,%edx
f011c05b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011c061:	c1 e2 02             	shl    $0x2,%edx
f011c064:	01 d0                	add    %edx,%eax
f011c066:	8b 00                	mov    (%eax),%eax
f011c068:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c06d:	89 c2                	mov    %eax,%edx
f011c06f:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c072:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c077:	01 d0                	add    %edx,%eax
f011c079:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011c07c:	74 1d                	je     f011c09b <test_kheap_phys_addr+0x7fe>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011c07e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c082:	74 17                	je     f011c09b <test_kheap_phys_addr+0x7fe>
				{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
f011c084:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c08b:	83 ec 0c             	sub    $0xc,%esp
f011c08e:	68 0a c6 12 f0       	push   $0xf012c60a
f011c093:	e8 d4 4e fe ff       	call   f0100f6c <cprintf>
f011c098:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011c09b:	ff 45 e0             	incl   -0x20(%ebp)
f011c09e:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
f011c0a2:	0f 8e 46 ff ff ff    	jle    f011bfee <test_kheap_phys_addr+0x751>
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=10 ;
f011c0a8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c0ac:	74 04                	je     f011c0b2 <test_kheap_phys_addr+0x815>
f011c0ae:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011c0b2:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree some of the allocated spaces
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011c0b9:	e8 69 16 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011c0be:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011c0c1:	e8 98 84 fe ff       	call   f010455e <pf_calculate_free_frames>
f011c0c6:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011c0c9:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011c0cf:	83 ec 0c             	sub    $0xc,%esp
f011c0d2:	50                   	push   %eax
f011c0d3:	e8 16 c7 fe ff       	call   f01087ee <kfree>
f011c0d8:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c0db:	e8 7e 84 fe ff       	call   f010455e <pf_calculate_free_frames>
f011c0e0:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c0e3:	74 17                	je     f011c0fc <test_kheap_phys_addr+0x85f>
f011c0e5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c0ec:	83 ec 0c             	sub    $0xc,%esp
f011c0ef:	68 40 bf 12 f0       	push   $0xf012bf40
f011c0f4:	e8 73 4e fe ff       	call   f0100f6c <cprintf>
f011c0f9:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011c0fc:	e8 26 16 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011c101:	89 c2                	mov    %eax,%edx
f011c103:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c106:	29 c2                	sub    %eax,%edx
f011c108:	89 d0                	mov    %edx,%eax
f011c10a:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c10f:	77 17                	ja     f011c128 <test_kheap_phys_addr+0x88b>
f011c111:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c118:	83 ec 0c             	sub    $0xc,%esp
f011c11b:	68 44 c3 12 f0       	push   $0xf012c344
f011c120:	e8 47 4e fe ff       	call   f0100f6c <cprintf>
f011c125:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011c128:	e8 fa 15 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011c12d:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c130:	e8 29 84 fe ff       	call   f010455e <pf_calculate_free_frames>
f011c135:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011c138:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011c13e:	83 ec 0c             	sub    $0xc,%esp
f011c141:	50                   	push   %eax
f011c142:	e8 a7 c6 fe ff       	call   f01087ee <kfree>
f011c147:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c14a:	e8 0f 84 fe ff       	call   f010455e <pf_calculate_free_frames>
f011c14f:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c152:	74 17                	je     f011c16b <test_kheap_phys_addr+0x8ce>
f011c154:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c15b:	83 ec 0c             	sub    $0xc,%esp
f011c15e:	68 40 bf 12 f0       	push   $0xf012bf40
f011c163:	e8 04 4e fe ff       	call   f0100f6c <cprintf>
f011c168:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011c16b:	e8 b7 15 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011c170:	89 c2                	mov    %eax,%edx
f011c172:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c175:	29 c2                	sub    %eax,%edx
f011c177:	89 d0                	mov    %edx,%eax
f011c179:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c17e:	77 17                	ja     f011c197 <test_kheap_phys_addr+0x8fa>
f011c180:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c187:	83 ec 0c             	sub    $0xc,%esp
f011c18a:	68 44 c3 12 f0       	push   $0xf012c344
f011c18f:	e8 d8 4d fe ff       	call   f0100f6c <cprintf>
f011c194:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011c197:	e8 8b 15 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011c19c:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c19f:	e8 ba 83 fe ff       	call   f010455e <pf_calculate_free_frames>
f011c1a4:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011c1a7:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011c1ad:	83 ec 0c             	sub    $0xc,%esp
f011c1b0:	50                   	push   %eax
f011c1b1:	e8 38 c6 fe ff       	call   f01087ee <kfree>
f011c1b6:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c1b9:	e8 a0 83 fe ff       	call   f010455e <pf_calculate_free_frames>
f011c1be:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c1c1:	74 17                	je     f011c1da <test_kheap_phys_addr+0x93d>
f011c1c3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c1ca:	83 ec 0c             	sub    $0xc,%esp
f011c1cd:	68 40 bf 12 f0       	push   $0xf012bf40
f011c1d2:	e8 95 4d fe ff       	call   f0100f6c <cprintf>
f011c1d7:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011c1da:	e8 48 15 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011c1df:	89 c2                	mov    %eax,%edx
f011c1e1:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c1e4:	29 c2                	sub    %eax,%edx
f011c1e6:	89 d0                	mov    %edx,%eax
f011c1e8:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c1ed:	77 17                	ja     f011c206 <test_kheap_phys_addr+0x969>
f011c1ef:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c1f6:	83 ec 0c             	sub    $0xc,%esp
f011c1f9:	68 44 c3 12 f0       	push   $0xf012c344
f011c1fe:	e8 69 4d fe ff       	call   f0100f6c <cprintf>
f011c203:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011c206:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011c20d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011c214:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011c219:	05 00 10 00 00       	add    $0x1000,%eax
f011c21e:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011c224:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c22a:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011c22d:	eb 25                	jmp    f011c254 <test_kheap_phys_addr+0x9b7>
		{
			allPAs[i++] = kheap_physical_address(va);
f011c22f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011c232:	8d 43 01             	lea    0x1(%ebx),%eax
f011c235:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011c238:	83 ec 0c             	sub    $0xc,%esp
f011c23b:	ff 75 dc             	pushl  -0x24(%ebp)
f011c23e:	e8 df c5 fe ff       	call   f0108822 <kheap_physical_address>
f011c243:	83 c4 10             	add    $0x10,%esp
f011c246:	89 84 9d 48 ca ff ff 	mov    %eax,-0x35b8(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 startVA = da_limit + PAGE_SIZE;

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011c24d:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f011c254:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c257:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011c25a:	72 d3                	jb     f011c22f <test_kheap_phys_addr+0x992>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011c25c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011c25f:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
		i = 0;
f011c265:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011c26c:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c272:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011c275:	e9 f1 00 00 00       	jmp    f011c36b <test_kheap_phys_addr+0xace>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c27a:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011c27f:	83 ec 04             	sub    $0x4,%esp
f011c282:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011c288:	52                   	push   %edx
f011c289:	ff 75 dc             	pushl  -0x24(%ebp)
f011c28c:	50                   	push   %eax
f011c28d:	e8 99 be fe ff       	call   f010812b <get_page_table>
f011c292:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c295:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c29b:	85 c0                	test   %eax,%eax
f011c29d:	75 24                	jne    f011c2c3 <test_kheap_phys_addr+0xa26>
				if (correct)
f011c29f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c2a3:	74 1e                	je     f011c2c3 <test_kheap_phys_addr+0xa26>
				{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c2a5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c2ac:	83 ec 04             	sub    $0x4,%esp
f011c2af:	68 98 c5 12 f0       	push   $0xf012c598
f011c2b4:	68 86 05 00 00       	push   $0x586
f011c2b9:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011c2be:	e8 57 40 fe ff       	call   f010031a <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011c2c3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c2c6:	c1 e8 0c             	shr    $0xc,%eax
f011c2c9:	25 ff 03 00 00       	and    $0x3ff,%eax
f011c2ce:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011c2d1:	eb 78                	jmp    f011c34b <test_kheap_phys_addr+0xaae>
			{
				if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : va & 0x00000FFF)) != allPAs[i])
f011c2d3:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c2d9:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c2dc:	c1 e2 02             	shl    $0x2,%edx
f011c2df:	01 d0                	add    %edx,%eax
f011c2e1:	8b 00                	mov    (%eax),%eax
f011c2e3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c2e8:	89 c1                	mov    %eax,%ecx
f011c2ea:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c2f0:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c2f3:	c1 e2 02             	shl    $0x2,%edx
f011c2f6:	01 d0                	add    %edx,%eax
f011c2f8:	8b 00                	mov    (%eax),%eax
f011c2fa:	83 e0 01             	and    $0x1,%eax
f011c2fd:	85 c0                	test   %eax,%eax
f011c2ff:	74 0a                	je     f011c30b <test_kheap_phys_addr+0xa6e>
f011c301:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c304:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c309:	eb 05                	jmp    f011c310 <test_kheap_phys_addr+0xa73>
f011c30b:	b8 00 00 00 00       	mov    $0x0,%eax
f011c310:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f011c313:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011c316:	8b 84 85 48 ca ff ff 	mov    -0x35b8(%ebp,%eax,4),%eax
f011c31d:	39 c2                	cmp    %eax,%edx
f011c31f:	74 1d                	je     f011c33e <test_kheap_phys_addr+0xaa1>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011c321:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c325:	74 17                	je     f011c33e <test_kheap_phys_addr+0xaa1>
					{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
f011c327:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c32e:	83 ec 0c             	sub    $0xc,%esp
f011c331:	68 0a c6 12 f0       	push   $0xf012c60a
f011c336:	e8 31 4c fe ff       	call   f0100f6c <cprintf>
f011c33b:	83 c4 10             	add    $0x10,%esp
				}
				va += PAGE_SIZE;
f011c33e:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
				if (correct)
				{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011c345:	ff 45 d8             	incl   -0x28(%ebp)
f011c348:	ff 45 f4             	incl   -0xc(%ebp)
f011c34b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011c34e:	3b 85 78 ff ff ff    	cmp    -0x88(%ebp),%eax
f011c354:	7d 15                	jge    f011c36b <test_kheap_phys_addr+0xace>
f011c356:	81 7d d8 ff 03 00 00 	cmpl   $0x3ff,-0x28(%ebp)
f011c35d:	7f 0c                	jg     f011c36b <test_kheap_phys_addr+0xace>
f011c35f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c362:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011c365:	0f 82 68 ff ff ff    	jb     f011c2d3 <test_kheap_phys_addr+0xa36>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011c36b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c36e:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011c371:	0f 82 03 ff ff ff    	jb     f011c27a <test_kheap_phys_addr+0x9dd>
				}
				va += PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011c377:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c37b:	74 04                	je     f011c381 <test_kheap_phys_addr+0xae4>
f011c37d:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	correct = 1 ;
f011c381:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	{
		uint32 va, pa;
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c388:	c7 45 d4 00 00 00 f6 	movl   $0xf6000000,-0x2c(%ebp)
f011c38f:	e9 af 00 00 00       	jmp    f011c443 <test_kheap_phys_addr+0xba6>
		{
			pa = kheap_physical_address(va);
f011c394:	83 ec 0c             	sub    $0xc,%esp
f011c397:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c39a:	e8 83 c4 fe ff       	call   f0108822 <kheap_physical_address>
f011c39f:	83 c4 10             	add    $0x10,%esp
f011c3a2:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c3a8:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011c3ad:	83 ec 04             	sub    $0x4,%esp
f011c3b0:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011c3b6:	52                   	push   %edx
f011c3b7:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c3ba:	50                   	push   %eax
f011c3bb:	e8 6b bd fe ff       	call   f010812b <get_page_table>
f011c3c0:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c3c3:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c3c9:	85 c0                	test   %eax,%eax
f011c3cb:	75 24                	jne    f011c3f1 <test_kheap_phys_addr+0xb54>
				if (correct)
f011c3cd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c3d1:	74 1e                	je     f011c3f1 <test_kheap_phys_addr+0xb54>
				{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c3d3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c3da:	83 ec 04             	sub    $0x4,%esp
f011c3dd:	68 98 c5 12 f0       	push   $0xf012c598
f011c3e2:	68 a1 05 00 00       	push   $0x5a1
f011c3e7:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011c3ec:	e8 29 3f fe ff       	call   f010031a <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011c3f1:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c3f7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c3fa:	c1 ea 0c             	shr    $0xc,%edx
f011c3fd:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011c403:	c1 e2 02             	shl    $0x2,%edx
f011c406:	01 d0                	add    %edx,%eax
f011c408:	8b 00                	mov    (%eax),%eax
f011c40a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c40f:	89 c2                	mov    %eax,%edx
f011c411:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c414:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c419:	01 d0                	add    %edx,%eax
f011c41b:	3b 85 74 ff ff ff    	cmp    -0x8c(%ebp),%eax
f011c421:	74 1d                	je     f011c440 <test_kheap_phys_addr+0xba3>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011c423:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c427:	74 17                	je     f011c440 <test_kheap_phys_addr+0xba3>
				{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
f011c429:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c430:	83 ec 0c             	sub    $0xc,%esp
f011c433:	68 0a c6 12 f0       	push   $0xf012c60a
f011c438:	e8 2f 4b fe ff       	call   f0100f6c <cprintf>
f011c43d:	83 c4 10             	add    $0x10,%esp

	correct = 1 ;
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	{
		uint32 va, pa;
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c440:	ff 45 d4             	incl   -0x2c(%ebp)
f011c443:	83 ec 0c             	sub    $0xc,%esp
f011c446:	6a 00                	push   $0x0
f011c448:	e8 7d c3 fe ff       	call   f01087ca <sbrk>
f011c44d:	83 c4 10             	add    $0x10,%esp
f011c450:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011c453:	0f 87 3b ff ff ff    	ja     f011c394 <test_kheap_phys_addr+0xaf7>
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=30 ;
f011c459:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c45d:	74 04                	je     f011c463 <test_kheap_phys_addr+0xbc6>
f011c45f:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011c463:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
f011c46a:	c7 85 70 ff ff ff 00 	movl   $0xf9001000,-0x90(%ebp)
f011c471:	10 00 f9 
		i = 0;
f011c474:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011c47b:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011c481:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c484:	eb 0a                	jmp    f011c490 <test_kheap_phys_addr+0xbf3>
		{
			i++;
f011c486:	ff 45 f4             	incl   -0xc(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
		i = 0;
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011c489:	81 45 d0 00 10 00 00 	addl   $0x1000,-0x30(%ebp)
f011c490:	81 7d d0 ff ef ff ff 	cmpl   $0xffffefff,-0x30(%ebp)
f011c497:	76 ed                	jbe    f011c486 <test_kheap_phys_addr+0xbe9>
		{
			i++;
		}
		int ii = i ;
f011c499:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011c49c:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
		i = 0;
f011c4a2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011c4a9:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011c4af:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011c4b2:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f011c4b9:	e9 13 01 00 00       	jmp    f011c5d1 <test_kheap_phys_addr+0xd34>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va2, &ptr_table);
f011c4be:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011c4c1:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011c4c6:	83 ec 04             	sub    $0x4,%esp
f011c4c9:	8d 8d 60 fe ff ff    	lea    -0x1a0(%ebp),%ecx
f011c4cf:	51                   	push   %ecx
f011c4d0:	52                   	push   %edx
f011c4d1:	50                   	push   %eax
f011c4d2:	e8 54 bc fe ff       	call   f010812b <get_page_table>
f011c4d7:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c4da:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011c4e0:	85 c0                	test   %eax,%eax
f011c4e2:	75 24                	jne    f011c508 <test_kheap_phys_addr+0xc6b>
			{
				if (correct)
f011c4e4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c4e8:	74 1e                	je     f011c508 <test_kheap_phys_addr+0xc6b>
				{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c4ea:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c4f1:	83 ec 04             	sub    $0x4,%esp
f011c4f4:	68 98 c5 12 f0       	push   $0xf012c598
f011c4f9:	68 c2 05 00 00       	push   $0x5c2
f011c4fe:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011c503:	e8 12 3e fe ff       	call   f010031a <_panic>
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011c508:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f011c50f:	e9 9a 00 00 00       	jmp    f011c5ae <test_kheap_phys_addr+0xd11>
			{
				//if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
				unsigned int page_va = startVA+i*PAGE_SIZE;
f011c514:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011c517:	c1 e0 0c             	shl    $0xc,%eax
f011c51a:	89 c2                	mov    %eax,%edx
f011c51c:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011c522:	01 d0                	add    %edx,%eax
f011c524:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
				unsigned int supposed_kheap_phys_add = kheap_physical_address(page_va);
f011c52a:	83 ec 0c             	sub    $0xc,%esp
f011c52d:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
f011c533:	e8 ea c2 fe ff       	call   f0108822 <kheap_physical_address>
f011c538:	83 c4 10             	add    $0x10,%esp
f011c53b:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
				if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : page_va & 0x00000FFF)) != supposed_kheap_phys_add)
f011c541:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011c547:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011c54a:	c1 e2 02             	shl    $0x2,%edx
f011c54d:	01 d0                	add    %edx,%eax
f011c54f:	8b 00                	mov    (%eax),%eax
f011c551:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c556:	89 c1                	mov    %eax,%ecx
f011c558:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011c55e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011c561:	c1 e2 02             	shl    $0x2,%edx
f011c564:	01 d0                	add    %edx,%eax
f011c566:	8b 00                	mov    (%eax),%eax
f011c568:	83 e0 01             	and    $0x1,%eax
f011c56b:	85 c0                	test   %eax,%eax
f011c56d:	74 0d                	je     f011c57c <test_kheap_phys_addr+0xcdf>
f011c56f:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f011c575:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c57a:	eb 05                	jmp    f011c581 <test_kheap_phys_addr+0xce4>
f011c57c:	b8 00 00 00 00       	mov    $0x0,%eax
f011c581:	01 c8                	add    %ecx,%eax
f011c583:	3b 85 64 ff ff ff    	cmp    -0x9c(%ebp),%eax
f011c589:	74 1d                	je     f011c5a8 <test_kheap_phys_addr+0xd0b>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va2 + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011c58b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c58f:	74 17                	je     f011c5a8 <test_kheap_phys_addr+0xd0b>
					{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
f011c591:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c598:	83 ec 0c             	sub    $0xc,%esp
f011c59b:	68 0a c6 12 f0       	push   $0xf012c60a
f011c5a0:	e8 c7 49 fe ff       	call   f0100f6c <cprintf>
f011c5a5:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
			{
				if (correct)
				{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011c5a8:	ff 45 cc             	incl   -0x34(%ebp)
f011c5ab:	ff 45 f4             	incl   -0xc(%ebp)
f011c5ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011c5b1:	3b 85 6c ff ff ff    	cmp    -0x94(%ebp),%eax
f011c5b7:	7d 0d                	jge    f011c5c6 <test_kheap_phys_addr+0xd29>
f011c5b9:	81 7d cc ff 03 00 00 	cmpl   $0x3ff,-0x34(%ebp)
f011c5c0:	0f 8e 4e ff ff ff    	jle    f011c514 <test_kheap_phys_addr+0xc77>
		}
		int ii = i ;
		i = 0;
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011c5c6:	81 45 c0 00 00 40 00 	addl   $0x400000,-0x40(%ebp)
f011c5cd:	83 55 c4 00          	adcl   $0x0,-0x3c(%ebp)
f011c5d1:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011c5d5:	0f 88 e3 fe ff ff    	js     f011c4be <test_kheap_phys_addr+0xc21>
f011c5db:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011c5df:	7f 0d                	jg     f011c5ee <test_kheap_phys_addr+0xd51>
f011c5e1:	81 7d c0 ff ef ff ff 	cmpl   $0xffffefff,-0x40(%ebp)
f011c5e8:	0f 86 d0 fe ff ff    	jbe    f011c4be <test_kheap_phys_addr+0xc21>
					{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011c5ee:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c5f2:	74 04                	je     f011c5f8 <test_kheap_phys_addr+0xd5b>
f011c5f4:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	cprintf("\ntest kheap_physical_address completed. Eval = %d%\n", eval);
f011c5f8:	83 ec 08             	sub    $0x8,%esp
f011c5fb:	ff 75 f0             	pushl  -0x10(%ebp)
f011c5fe:	68 28 c6 12 f0       	push   $0xf012c628
f011c603:	e8 64 49 fe ff       	call   f0100f6c <cprintf>
f011c608:	83 c4 10             	add    $0x10,%esp

	return 1;
f011c60b:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011c610:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011c613:	5b                   	pop    %ebx
f011c614:	5f                   	pop    %edi
f011c615:	5d                   	pop    %ebp
f011c616:	c3                   	ret    

f011c617 <test_kheap_virt_addr>:

int test_kheap_virt_addr()
{
f011c617:	55                   	push   %ebp
f011c618:	89 e5                	mov    %esp,%ebp
f011c61a:	57                   	push   %edi
f011c61b:	56                   	push   %esi
f011c61c:	53                   	push   %ebx
f011c61d:	81 ec 9c 01 00 00    	sub    $0x19c,%esp
f011c623:	89 e0                	mov    %esp,%eax
f011c625:	89 c6                	mov    %eax,%esi
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011c627:	83 ec 0c             	sub    $0xc,%esp
f011c62a:	68 80 be 12 f0       	push   $0xf012be80
f011c62f:	e8 38 49 fe ff       	call   f0100f6c <cprintf>
f011c634:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011c637:	83 ec 0c             	sub    $0xc,%esp
f011c63a:	68 b0 be 12 f0       	push   $0xf012beb0
f011c63f:	e8 28 49 fe ff       	call   f0100f6c <cprintf>
f011c644:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011c647:	83 ec 0c             	sub    $0xc,%esp
f011c64a:	68 80 be 12 f0       	push   $0xf012be80
f011c64f:	e8 18 49 fe ff       	call   f0100f6c <cprintf>
f011c654:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011c657:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
	char maxByte = 0x7F;
f011c65b:	c6 45 c6 7f          	movb   $0x7f,-0x3a(%ebp)
	short minShort = 1<<15 ;
f011c65f:	66 c7 45 c4 00 80    	movw   $0x8000,-0x3c(%ebp)
	short maxShort = 0x7FFF;
f011c665:	66 c7 45 c2 ff 7f    	movw   $0x7fff,-0x3e(%ebp)
	int minInt = 1<<31 ;
f011c66b:	c7 45 bc 00 00 00 80 	movl   $0x80000000,-0x44(%ebp)
	int maxInt = 0x7FFFFFFF;
f011c672:	c7 45 b8 ff ff ff 7f 	movl   $0x7fffffff,-0x48(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011c679:	e8 a9 10 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011c67e:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011c681:	8d 95 0c ff ff ff    	lea    -0xf4(%ebp),%edx
f011c687:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c68c:	b8 00 00 00 00       	mov    $0x0,%eax
f011c691:	89 d7                	mov    %edx,%edi
f011c693:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011c695:	8d 95 bc fe ff ff    	lea    -0x144(%ebp),%edx
f011c69b:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c6a0:	b8 00 00 00 00       	mov    $0x0,%eax
f011c6a5:	89 d7                	mov    %edx,%edi
f011c6a7:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011c6a9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011c6b0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	void* ptr_allocations[20] = {0};
f011c6b7:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011c6bd:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c6c2:	b8 00 00 00 00       	mov    $0x0,%eax
f011c6c7:	89 d7                	mov    %edx,%edi
f011c6c9:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011c6cb:	e8 57 10 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011c6d0:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c6d3:	e8 86 7e fe ff       	call   f010455e <pf_calculate_free_frames>
f011c6d8:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011c6db:	83 ec 0c             	sub    $0xc,%esp
f011c6de:	68 00 fc 1f 00       	push   $0x1ffc00
f011c6e3:	e8 ec c0 fe ff       	call   f01087d4 <kmalloc>
f011c6e8:	83 c4 10             	add    $0x10,%esp
f011c6eb:	89 85 6c fe ff ff    	mov    %eax,-0x194(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c6f1:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011c6f7:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011c6fc:	74 17                	je     f011c715 <test_kheap_virt_addr+0xfe>
f011c6fe:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c705:	83 ec 0c             	sub    $0xc,%esp
f011c708:	68 f0 bf 12 f0       	push   $0xf012bff0
f011c70d:	e8 5a 48 fe ff       	call   f0100f6c <cprintf>
f011c712:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c715:	e8 44 7e fe ff       	call   f010455e <pf_calculate_free_frames>
f011c71a:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c71d:	74 17                	je     f011c736 <test_kheap_virt_addr+0x11f>
f011c71f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c726:	83 ec 0c             	sub    $0xc,%esp
f011c729:	68 40 bf 12 f0       	push   $0xf012bf40
f011c72e:	e8 39 48 fe ff       	call   f0100f6c <cprintf>
f011c733:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c736:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c739:	e8 e9 0f ff ff       	call   f010d727 <sys_calculate_free_frames>
f011c73e:	29 c3                	sub    %eax,%ebx
f011c740:	89 d8                	mov    %ebx,%eax
f011c742:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c747:	77 17                	ja     f011c760 <test_kheap_virt_addr+0x149>
f011c749:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c750:	83 ec 0c             	sub    $0xc,%esp
f011c753:	68 ac bf 12 f0       	push   $0xf012bfac
f011c758:	e8 0f 48 fe ff       	call   f0100f6c <cprintf>
f011c75d:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011c760:	e8 c2 0f ff ff       	call   f010d727 <sys_calculate_free_frames>
f011c765:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c768:	e8 f1 7d fe ff       	call   f010455e <pf_calculate_free_frames>
f011c76d:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011c770:	83 ec 0c             	sub    $0xc,%esp
f011c773:	68 00 fc 1f 00       	push   $0x1ffc00
f011c778:	e8 57 c0 fe ff       	call   f01087d4 <kmalloc>
f011c77d:	83 c4 10             	add    $0x10,%esp
f011c780:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c786:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011c78c:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011c791:	74 17                	je     f011c7aa <test_kheap_virt_addr+0x193>
f011c793:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c79a:	83 ec 0c             	sub    $0xc,%esp
f011c79d:	68 f0 bf 12 f0       	push   $0xf012bff0
f011c7a2:	e8 c5 47 fe ff       	call   f0100f6c <cprintf>
f011c7a7:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c7aa:	e8 af 7d fe ff       	call   f010455e <pf_calculate_free_frames>
f011c7af:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c7b2:	74 17                	je     f011c7cb <test_kheap_virt_addr+0x1b4>
f011c7b4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c7bb:	83 ec 0c             	sub    $0xc,%esp
f011c7be:	68 40 bf 12 f0       	push   $0xf012bf40
f011c7c3:	e8 a4 47 fe ff       	call   f0100f6c <cprintf>
f011c7c8:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c7cb:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c7ce:	e8 54 0f ff ff       	call   f010d727 <sys_calculate_free_frames>
f011c7d3:	29 c3                	sub    %eax,%ebx
f011c7d5:	89 d8                	mov    %ebx,%eax
f011c7d7:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c7dc:	77 17                	ja     f011c7f5 <test_kheap_virt_addr+0x1de>
f011c7de:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c7e5:	83 ec 0c             	sub    $0xc,%esp
f011c7e8:	68 ac bf 12 f0       	push   $0xf012bfac
f011c7ed:	e8 7a 47 fe ff       	call   f0100f6c <cprintf>
f011c7f2:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011c7f5:	e8 2d 0f ff ff       	call   f010d727 <sys_calculate_free_frames>
f011c7fa:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c7fd:	e8 5c 7d fe ff       	call   f010455e <pf_calculate_free_frames>
f011c802:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011c805:	83 ec 0c             	sub    $0xc,%esp
f011c808:	68 00 04 00 00       	push   $0x400
f011c80d:	e8 c2 bf fe ff       	call   f01087d4 <kmalloc>
f011c812:	83 c4 10             	add    $0x10,%esp
f011c815:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011c81b:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011c821:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c826:	76 28                	jbe    f011c850 <test_kheap_virt_addr+0x239>
f011c828:	8b 9d 74 fe ff ff    	mov    -0x18c(%ebp),%ebx
f011c82e:	83 ec 0c             	sub    $0xc,%esp
f011c831:	6a 00                	push   $0x0
f011c833:	e8 92 bf fe ff       	call   f01087ca <sbrk>
f011c838:	83 c4 10             	add    $0x10,%esp
f011c83b:	39 c3                	cmp    %eax,%ebx
f011c83d:	73 11                	jae    f011c850 <test_kheap_virt_addr+0x239>
f011c83f:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011c845:	89 c2                	mov    %eax,%edx
f011c847:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011c84c:	39 c2                	cmp    %eax,%edx
f011c84e:	72 17                	jb     f011c867 <test_kheap_virt_addr+0x250>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011c850:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c857:	83 ec 0c             	sub    $0xc,%esp
f011c85a:	68 40 c0 12 f0       	push   $0xf012c040
f011c85f:	e8 08 47 fe ff       	call   f0100f6c <cprintf>
f011c864:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c867:	e8 f2 7c fe ff       	call   f010455e <pf_calculate_free_frames>
f011c86c:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c86f:	74 17                	je     f011c888 <test_kheap_virt_addr+0x271>
f011c871:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c878:	83 ec 0c             	sub    $0xc,%esp
f011c87b:	68 40 bf 12 f0       	push   $0xf012bf40
f011c880:	e8 e7 46 fe ff       	call   f0100f6c <cprintf>
f011c885:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011c888:	e8 9a 0e ff ff       	call   f010d727 <sys_calculate_free_frames>
f011c88d:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c890:	e8 c9 7c fe ff       	call   f010455e <pf_calculate_free_frames>
f011c895:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011c898:	83 ec 0c             	sub    $0xc,%esp
f011c89b:	68 00 08 00 00       	push   $0x800
f011c8a0:	e8 2f bf fe ff       	call   f01087d4 <kmalloc>
f011c8a5:	83 c4 10             	add    $0x10,%esp
f011c8a8:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011c8ae:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011c8b4:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c8b9:	76 28                	jbe    f011c8e3 <test_kheap_virt_addr+0x2cc>
f011c8bb:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011c8c1:	83 ec 0c             	sub    $0xc,%esp
f011c8c4:	6a 00                	push   $0x0
f011c8c6:	e8 ff be fe ff       	call   f01087ca <sbrk>
f011c8cb:	83 c4 10             	add    $0x10,%esp
f011c8ce:	39 c3                	cmp    %eax,%ebx
f011c8d0:	73 11                	jae    f011c8e3 <test_kheap_virt_addr+0x2cc>
f011c8d2:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011c8d8:	89 c2                	mov    %eax,%edx
f011c8da:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011c8df:	39 c2                	cmp    %eax,%edx
f011c8e1:	72 17                	jb     f011c8fa <test_kheap_virt_addr+0x2e3>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011c8e3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c8ea:	83 ec 0c             	sub    $0xc,%esp
f011c8ed:	68 40 c0 12 f0       	push   $0xf012c040
f011c8f2:	e8 75 46 fe ff       	call   f0100f6c <cprintf>
f011c8f7:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c8fa:	e8 5f 7c fe ff       	call   f010455e <pf_calculate_free_frames>
f011c8ff:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c902:	74 17                	je     f011c91b <test_kheap_virt_addr+0x304>
f011c904:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c90b:	83 ec 0c             	sub    $0xc,%esp
f011c90e:	68 40 bf 12 f0       	push   $0xf012bf40
f011c913:	e8 54 46 fe ff       	call   f0100f6c <cprintf>
f011c918:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011c91b:	e8 07 0e ff ff       	call   f010d727 <sys_calculate_free_frames>
f011c920:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c923:	e8 36 7c fe ff       	call   f010455e <pf_calculate_free_frames>
f011c928:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011c92b:	83 ec 0c             	sub    $0xc,%esp
f011c92e:	68 00 06 00 00       	push   $0x600
f011c933:	e8 9c be fe ff       	call   f01087d4 <kmalloc>
f011c938:	83 c4 10             	add    $0x10,%esp
f011c93b:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011c941:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011c947:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c94c:	76 28                	jbe    f011c976 <test_kheap_virt_addr+0x35f>
f011c94e:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011c954:	83 ec 0c             	sub    $0xc,%esp
f011c957:	6a 00                	push   $0x0
f011c959:	e8 6c be fe ff       	call   f01087ca <sbrk>
f011c95e:	83 c4 10             	add    $0x10,%esp
f011c961:	39 c3                	cmp    %eax,%ebx
f011c963:	73 11                	jae    f011c976 <test_kheap_virt_addr+0x35f>
f011c965:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011c96b:	89 c2                	mov    %eax,%edx
f011c96d:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011c972:	39 c2                	cmp    %eax,%edx
f011c974:	72 17                	jb     f011c98d <test_kheap_virt_addr+0x376>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011c976:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c97d:	83 ec 0c             	sub    $0xc,%esp
f011c980:	68 40 c0 12 f0       	push   $0xf012c040
f011c985:	e8 e2 45 fe ff       	call   f0100f6c <cprintf>
f011c98a:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c98d:	e8 cc 7b fe ff       	call   f010455e <pf_calculate_free_frames>
f011c992:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c995:	74 17                	je     f011c9ae <test_kheap_virt_addr+0x397>
f011c997:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c99e:	83 ec 0c             	sub    $0xc,%esp
f011c9a1:	68 40 bf 12 f0       	push   $0xf012bf40
f011c9a6:	e8 c1 45 fe ff       	call   f0100f6c <cprintf>
f011c9ab:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011c9ae:	e8 74 0d ff ff       	call   f010d727 <sys_calculate_free_frames>
f011c9b3:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c9b6:	e8 a3 7b fe ff       	call   f010455e <pf_calculate_free_frames>
f011c9bb:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011c9be:	83 ec 0c             	sub    $0xc,%esp
f011c9c1:	68 00 1c 00 00       	push   $0x1c00
f011c9c6:	e8 09 be fe ff       	call   f01087d4 <kmalloc>
f011c9cb:	83 c4 10             	add    $0x10,%esp
f011c9ce:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c9d4:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011c9da:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011c9df:	74 17                	je     f011c9f8 <test_kheap_virt_addr+0x3e1>
f011c9e1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c9e8:	83 ec 0c             	sub    $0xc,%esp
f011c9eb:	68 f0 bf 12 f0       	push   $0xf012bff0
f011c9f0:	e8 77 45 fe ff       	call   f0100f6c <cprintf>
f011c9f5:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c9f8:	e8 61 7b fe ff       	call   f010455e <pf_calculate_free_frames>
f011c9fd:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011ca00:	74 17                	je     f011ca19 <test_kheap_virt_addr+0x402>
f011ca02:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca09:	83 ec 0c             	sub    $0xc,%esp
f011ca0c:	68 40 bf 12 f0       	push   $0xf012bf40
f011ca11:	e8 56 45 fe ff       	call   f0100f6c <cprintf>
f011ca16:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ca19:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011ca1c:	e8 06 0d ff ff       	call   f010d727 <sys_calculate_free_frames>
f011ca21:	29 c3                	sub    %eax,%ebx
f011ca23:	89 d8                	mov    %ebx,%eax
f011ca25:	83 f8 01             	cmp    $0x1,%eax
f011ca28:	77 17                	ja     f011ca41 <test_kheap_virt_addr+0x42a>
f011ca2a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca31:	83 ec 0c             	sub    $0xc,%esp
f011ca34:	68 ac bf 12 f0       	push   $0xf012bfac
f011ca39:	e8 2e 45 fe ff       	call   f0100f6c <cprintf>
f011ca3e:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011ca41:	e8 e1 0c ff ff       	call   f010d727 <sys_calculate_free_frames>
f011ca46:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ca49:	e8 10 7b fe ff       	call   f010455e <pf_calculate_free_frames>
f011ca4e:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011ca51:	83 ec 0c             	sub    $0xc,%esp
f011ca54:	68 00 fc 2f 00       	push   $0x2ffc00
f011ca59:	e8 76 bd fe ff       	call   f01087d4 <kmalloc>
f011ca5e:	83 c4 10             	add    $0x10,%esp
f011ca61:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ca67:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011ca6d:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011ca72:	74 17                	je     f011ca8b <test_kheap_virt_addr+0x474>
f011ca74:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca7b:	83 ec 0c             	sub    $0xc,%esp
f011ca7e:	68 f0 bf 12 f0       	push   $0xf012bff0
f011ca83:	e8 e4 44 fe ff       	call   f0100f6c <cprintf>
f011ca88:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ca8b:	e8 ce 7a fe ff       	call   f010455e <pf_calculate_free_frames>
f011ca90:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011ca93:	74 17                	je     f011caac <test_kheap_virt_addr+0x495>
f011ca95:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca9c:	83 ec 0c             	sub    $0xc,%esp
f011ca9f:	68 40 bf 12 f0       	push   $0xf012bf40
f011caa4:	e8 c3 44 fe ff       	call   f0100f6c <cprintf>
f011caa9:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011caac:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011caaf:	e8 73 0c ff ff       	call   f010d727 <sys_calculate_free_frames>
f011cab4:	29 c3                	sub    %eax,%ebx
f011cab6:	89 d8                	mov    %ebx,%eax
f011cab8:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011cabd:	77 17                	ja     f011cad6 <test_kheap_virt_addr+0x4bf>
f011cabf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cac6:	83 ec 0c             	sub    $0xc,%esp
f011cac9:	68 ac bf 12 f0       	push   $0xf012bfac
f011cace:	e8 99 44 fe ff       	call   f0100f6c <cprintf>
f011cad3:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011cad6:	e8 4c 0c ff ff       	call   f010d727 <sys_calculate_free_frames>
f011cadb:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cade:	e8 7b 7a fe ff       	call   f010455e <pf_calculate_free_frames>
f011cae3:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011cae6:	83 ec 0c             	sub    $0xc,%esp
f011cae9:	68 00 fc 5f 00       	push   $0x5ffc00
f011caee:	e8 e1 bc fe ff       	call   f01087d4 <kmalloc>
f011caf3:	83 c4 10             	add    $0x10,%esp
f011caf6:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011cafc:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011cb02:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011cb07:	74 17                	je     f011cb20 <test_kheap_virt_addr+0x509>
f011cb09:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb10:	83 ec 0c             	sub    $0xc,%esp
f011cb13:	68 f0 bf 12 f0       	push   $0xf012bff0
f011cb18:	e8 4f 44 fe ff       	call   f0100f6c <cprintf>
f011cb1d:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cb20:	e8 39 7a fe ff       	call   f010455e <pf_calculate_free_frames>
f011cb25:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011cb28:	74 17                	je     f011cb41 <test_kheap_virt_addr+0x52a>
f011cb2a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb31:	83 ec 0c             	sub    $0xc,%esp
f011cb34:	68 40 bf 12 f0       	push   $0xf012bf40
f011cb39:	e8 2e 44 fe ff       	call   f0100f6c <cprintf>
f011cb3e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011cb41:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011cb44:	e8 de 0b ff ff       	call   f010d727 <sys_calculate_free_frames>
f011cb49:	29 c3                	sub    %eax,%ebx
f011cb4b:	89 d8                	mov    %ebx,%eax
f011cb4d:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011cb52:	77 17                	ja     f011cb6b <test_kheap_virt_addr+0x554>
f011cb54:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb5b:	83 ec 0c             	sub    $0xc,%esp
f011cb5e:	68 ac bf 12 f0       	push   $0xf012bfac
f011cb63:	e8 04 44 fe ff       	call   f0100f6c <cprintf>
f011cb68:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011cb6b:	e8 b7 0b ff ff       	call   f010d727 <sys_calculate_free_frames>
f011cb70:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cb73:	e8 e6 79 fe ff       	call   f010455e <pf_calculate_free_frames>
f011cb78:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011cb7b:	83 ec 0c             	sub    $0xc,%esp
f011cb7e:	68 00 38 00 00       	push   $0x3800
f011cb83:	e8 4c bc fe ff       	call   f01087d4 <kmalloc>
f011cb88:	83 c4 10             	add    $0x10,%esp
f011cb8b:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011cb91:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011cb97:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011cb9c:	74 17                	je     f011cbb5 <test_kheap_virt_addr+0x59e>
f011cb9e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cba5:	83 ec 0c             	sub    $0xc,%esp
f011cba8:	68 f0 bf 12 f0       	push   $0xf012bff0
f011cbad:	e8 ba 43 fe ff       	call   f0100f6c <cprintf>
f011cbb2:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cbb5:	e8 a4 79 fe ff       	call   f010455e <pf_calculate_free_frames>
f011cbba:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011cbbd:	74 17                	je     f011cbd6 <test_kheap_virt_addr+0x5bf>
f011cbbf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cbc6:	83 ec 0c             	sub    $0xc,%esp
f011cbc9:	68 40 bf 12 f0       	push   $0xf012bf40
f011cbce:	e8 99 43 fe ff       	call   f0100f6c <cprintf>
f011cbd3:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011cbd6:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011cbd9:	e8 49 0b ff ff       	call   f010d727 <sys_calculate_free_frames>
f011cbde:	29 c3                	sub    %eax,%ebx
f011cbe0:	89 d8                	mov    %ebx,%eax
f011cbe2:	83 f8 03             	cmp    $0x3,%eax
f011cbe5:	77 17                	ja     f011cbfe <test_kheap_virt_addr+0x5e7>
f011cbe7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cbee:	83 ec 0c             	sub    $0xc,%esp
f011cbf1:	68 ac bf 12 f0       	push   $0xf012bfac
f011cbf6:	e8 71 43 fe ff       	call   f0100f6c <cprintf>
f011cbfb:	83 c4 10             	add    $0x10,%esp
	}

	uint32 allocatedSpace = (13*Mega + 24*kilo + (INITIAL_KHEAP_ALLOCATIONS));
f011cbfe:	c7 45 a8 00 60 d0 00 	movl   $0xd06000,-0x58(%ebp)
	uint32 allPAs[allocatedSpace/PAGE_SIZE] ;
f011cc05:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011cc08:	c1 e8 0c             	shr    $0xc,%eax
f011cc0b:	89 c2                	mov    %eax,%edx
f011cc0d:	4a                   	dec    %edx
f011cc0e:	89 55 a4             	mov    %edx,-0x5c(%ebp)
f011cc11:	c1 e0 02             	shl    $0x2,%eax
f011cc14:	8d 50 03             	lea    0x3(%eax),%edx
f011cc17:	b8 10 00 00 00       	mov    $0x10,%eax
f011cc1c:	48                   	dec    %eax
f011cc1d:	01 d0                	add    %edx,%eax
f011cc1f:	bf 10 00 00 00       	mov    $0x10,%edi
f011cc24:	ba 00 00 00 00       	mov    $0x0,%edx
f011cc29:	f7 f7                	div    %edi
f011cc2b:	6b c0 10             	imul   $0x10,%eax,%eax
f011cc2e:	29 c4                	sub    %eax,%esp
f011cc30:	89 e0                	mov    %esp,%eax
f011cc32:	83 c0 03             	add    $0x3,%eax
f011cc35:	c1 e8 02             	shr    $0x2,%eax
f011cc38:	c1 e0 02             	shl    $0x2,%eax
f011cc3b:	89 45 a0             	mov    %eax,-0x60(%ebp)
	int numOfFrames = allocatedSpace/PAGE_SIZE ;
f011cc3e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011cc41:	c1 e8 0c             	shr    $0xc,%eax
f011cc44:	89 45 9c             	mov    %eax,-0x64(%ebp)

	//test kheap_virtual_address after kmalloc only [20%]
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011cc47:	c7 45 98 00 70 d0 f8 	movl   $0xf8d07000,-0x68(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011cc4e:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011cc53:	05 00 10 00 00       	add    $0x1000,%eax
f011cc58:	89 45 94             	mov    %eax,-0x6c(%ebp)
		int i = 0;
f011cc5b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011cc62:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011cc65:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011cc68:	e9 2d 01 00 00       	jmp    f011cd9a <test_kheap_virt_addr+0x783>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011cc6d:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011cc72:	83 ec 04             	sub    $0x4,%esp
f011cc75:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011cc7b:	52                   	push   %edx
f011cc7c:	ff 75 dc             	pushl  -0x24(%ebp)
f011cc7f:	50                   	push   %eax
f011cc80:	e8 a6 b4 fe ff       	call   f010812b <get_page_table>
f011cc85:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011cc88:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011cc8e:	85 c0                	test   %eax,%eax
f011cc90:	75 1e                	jne    f011ccb0 <test_kheap_virt_addr+0x699>
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011cc92:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cc99:	83 ec 04             	sub    $0x4,%esp
f011cc9c:	68 98 c5 12 f0       	push   $0xf012c598
f011cca1:	68 5e 06 00 00       	push   $0x65e
f011cca6:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011ccab:	e8 6a 36 fe ff       	call   f010031a <_panic>

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011ccb0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ccb3:	c1 e8 0c             	shr    $0xc,%eax
f011ccb6:	25 ff 03 00 00       	and    $0x3ff,%eax
f011ccbb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011ccbe:	e9 ba 00 00 00       	jmp    f011cd7d <test_kheap_virt_addr+0x766>
			{
				uint32 offset = j;
f011ccc3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011ccc6:	89 45 90             	mov    %eax,-0x70(%ebp)
				allPAs[i] = (ptr_table[j] & 0xFFFFF000) + offset;
f011ccc9:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011cccf:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011ccd2:	c1 e2 02             	shl    $0x2,%edx
f011ccd5:	01 d0                	add    %edx,%eax
f011ccd7:	8b 00                	mov    (%eax),%eax
f011ccd9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011ccde:	89 c2                	mov    %eax,%edx
f011cce0:	8b 45 90             	mov    -0x70(%ebp),%eax
f011cce3:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011cce6:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011cce9:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011ccec:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
				uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011ccef:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ccf2:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011ccf5:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011ccf8:	83 ec 0c             	sub    $0xc,%esp
f011ccfb:	50                   	push   %eax
f011ccfc:	e8 07 bb fe ff       	call   f0108808 <kheap_virtual_address>
f011cd01:	83 c4 10             	add    $0x10,%esp
f011cd04:	89 45 8c             	mov    %eax,-0x74(%ebp)
				//cprintf("va to check = %x\n", va);
				if (retrievedVA != (va+offset))
f011cd07:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011cd0a:	8b 45 90             	mov    -0x70(%ebp),%eax
f011cd0d:	01 d0                	add    %edx,%eax
f011cd0f:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011cd12:	74 5c                	je     f011cd70 <test_kheap_virt_addr+0x759>
				{
					if (correct)
f011cd14:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cd18:	74 56                	je     f011cd70 <test_kheap_virt_addr+0x759>
					{
						cprintf("\nretrievedVA = %x, Actual VA = %x, table entry = %x, khep_pa = %x\n",retrievedVA, va + offset /*+ j*PAGE_SIZE*/, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
f011cd1a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011cd1d:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011cd20:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011cd23:	8b 95 68 fe ff ff    	mov    -0x198(%ebp),%edx
f011cd29:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011cd2c:	c1 e1 02             	shl    $0x2,%ecx
f011cd2f:	01 ca                	add    %ecx,%edx
f011cd31:	8b 12                	mov    (%edx),%edx
f011cd33:	89 d1                	mov    %edx,%ecx
f011cd35:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f011cd3b:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f011cd3e:	8b 55 90             	mov    -0x70(%ebp),%edx
f011cd41:	01 da                	add    %ebx,%edx
f011cd43:	83 ec 0c             	sub    $0xc,%esp
f011cd46:	50                   	push   %eax
f011cd47:	51                   	push   %ecx
f011cd48:	52                   	push   %edx
f011cd49:	ff 75 8c             	pushl  -0x74(%ebp)
f011cd4c:	68 5c c6 12 f0       	push   $0xf012c65c
f011cd51:	e8 16 42 fe ff       	call   f0100f6c <cprintf>
f011cd56:	83 c4 20             	add    $0x20,%esp
						correct = 0; cprintf("Wrong kheap_virtual_address\n");
f011cd59:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cd60:	83 ec 0c             	sub    $0xc,%esp
f011cd63:	68 9f c6 12 f0       	push   $0xf012c69f
f011cd68:	e8 ff 41 fe ff       	call   f0100f6c <cprintf>
f011cd6d:	83 c4 10             	add    $0x10,%esp
					}
				}
				va+=PAGE_SIZE;
f011cd70:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011cd77:	ff 45 d4             	incl   -0x2c(%ebp)
f011cd7a:	ff 45 d8             	incl   -0x28(%ebp)
f011cd7d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011cd80:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011cd83:	7d 15                	jge    f011cd9a <test_kheap_virt_addr+0x783>
f011cd85:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011cd8c:	7f 0c                	jg     f011cd9a <test_kheap_virt_addr+0x783>
f011cd8e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011cd91:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011cd94:	0f 82 29 ff ff ff    	jb     f011ccc3 <test_kheap_virt_addr+0x6ac>
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011cd9a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011cd9d:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011cda0:	0f 82 c7 fe ff ff    	jb     f011cc6d <test_kheap_virt_addr+0x656>
				}
				va+=PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011cda6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cdaa:	74 04                	je     f011cdb0 <test_kheap_virt_addr+0x799>
f011cdac:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011cdb0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//kfree some of the allocated spaces
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011cdb7:	e8 6b 09 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011cdbc:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011cdbf:	e8 9a 77 fe ff       	call   f010455e <pf_calculate_free_frames>
f011cdc4:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011cdc7:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011cdcd:	83 ec 0c             	sub    $0xc,%esp
f011cdd0:	50                   	push   %eax
f011cdd1:	e8 18 ba fe ff       	call   f01087ee <kfree>
f011cdd6:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cdd9:	e8 80 77 fe ff       	call   f010455e <pf_calculate_free_frames>
f011cdde:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011cde1:	74 17                	je     f011cdfa <test_kheap_virt_addr+0x7e3>
f011cde3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cdea:	83 ec 0c             	sub    $0xc,%esp
f011cded:	68 40 bf 12 f0       	push   $0xf012bf40
f011cdf2:	e8 75 41 fe ff       	call   f0100f6c <cprintf>
f011cdf7:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011cdfa:	e8 28 09 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011cdff:	89 c2                	mov    %eax,%edx
f011ce01:	8b 45 88             	mov    -0x78(%ebp),%eax
f011ce04:	29 c2                	sub    %eax,%edx
f011ce06:	89 d0                	mov    %edx,%eax
f011ce08:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011ce0d:	77 17                	ja     f011ce26 <test_kheap_virt_addr+0x80f>
f011ce0f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce16:	83 ec 0c             	sub    $0xc,%esp
f011ce19:	68 44 c3 12 f0       	push   $0xf012c344
f011ce1e:	e8 49 41 fe ff       	call   f0100f6c <cprintf>
f011ce23:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011ce26:	e8 fc 08 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011ce2b:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ce2e:	e8 2b 77 fe ff       	call   f010455e <pf_calculate_free_frames>
f011ce33:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011ce36:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011ce3c:	83 ec 0c             	sub    $0xc,%esp
f011ce3f:	50                   	push   %eax
f011ce40:	e8 a9 b9 fe ff       	call   f01087ee <kfree>
f011ce45:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ce48:	e8 11 77 fe ff       	call   f010455e <pf_calculate_free_frames>
f011ce4d:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011ce50:	74 17                	je     f011ce69 <test_kheap_virt_addr+0x852>
f011ce52:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce59:	83 ec 0c             	sub    $0xc,%esp
f011ce5c:	68 40 bf 12 f0       	push   $0xf012bf40
f011ce61:	e8 06 41 fe ff       	call   f0100f6c <cprintf>
f011ce66:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011ce69:	e8 b9 08 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011ce6e:	89 c2                	mov    %eax,%edx
f011ce70:	8b 45 88             	mov    -0x78(%ebp),%eax
f011ce73:	29 c2                	sub    %eax,%edx
f011ce75:	89 d0                	mov    %edx,%eax
f011ce77:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011ce7c:	77 17                	ja     f011ce95 <test_kheap_virt_addr+0x87e>
f011ce7e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce85:	83 ec 0c             	sub    $0xc,%esp
f011ce88:	68 44 c3 12 f0       	push   $0xf012c344
f011ce8d:	e8 da 40 fe ff       	call   f0100f6c <cprintf>
f011ce92:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011ce95:	e8 8d 08 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011ce9a:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ce9d:	e8 bc 76 fe ff       	call   f010455e <pf_calculate_free_frames>
f011cea2:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011cea5:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011ceab:	83 ec 0c             	sub    $0xc,%esp
f011ceae:	50                   	push   %eax
f011ceaf:	e8 3a b9 fe ff       	call   f01087ee <kfree>
f011ceb4:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ceb7:	e8 a2 76 fe ff       	call   f010455e <pf_calculate_free_frames>
f011cebc:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011cebf:	74 17                	je     f011ced8 <test_kheap_virt_addr+0x8c1>
f011cec1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cec8:	83 ec 0c             	sub    $0xc,%esp
f011cecb:	68 40 bf 12 f0       	push   $0xf012bf40
f011ced0:	e8 97 40 fe ff       	call   f0100f6c <cprintf>
f011ced5:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011ced8:	e8 4a 08 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011cedd:	89 c2                	mov    %eax,%edx
f011cedf:	8b 45 88             	mov    -0x78(%ebp),%eax
f011cee2:	29 c2                	sub    %eax,%edx
f011cee4:	89 d0                	mov    %edx,%eax
f011cee6:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011ceeb:	77 17                	ja     f011cf04 <test_kheap_virt_addr+0x8ed>
f011ceed:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cef4:	83 ec 0c             	sub    $0xc,%esp
f011cef7:	68 44 c3 12 f0       	push   $0xf012c344
f011cefc:	e8 6b 40 fe ff       	call   f0100f6c <cprintf>
f011cf01:	83 c4 10             	add    $0x10,%esp


	//test kheap_virtual_address after kmalloc and kfree [20%]
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011cf04:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011cf0b:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011cf10:	05 00 10 00 00       	add    $0x1000,%eax
f011cf15:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
		int i = 0;
f011cf1b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
f011cf22:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f011cf29:	00 00 00 
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011cf2c:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011cf32:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011cf35:	eb 44                	jmp    f011cf7b <test_kheap_virt_addr+0x964>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011cf37:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011cf3a:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011cf3d:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011cf40:	83 ec 0c             	sub    $0xc,%esp
f011cf43:	50                   	push   %eax
f011cf44:	e8 bf b8 fe ff       	call   f0108808 <kheap_virtual_address>
f011cf49:	83 c4 10             	add    $0x10,%esp
f011cf4c:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			if (retrievedVA != 0)
f011cf52:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
f011cf59:	74 1d                	je     f011cf78 <test_kheap_virt_addr+0x961>
			{
				if (correct)
f011cf5b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cf5f:	74 17                	je     f011cf78 <test_kheap_virt_addr+0x961>
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
f011cf61:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf68:	83 ec 0c             	sub    $0xc,%esp
f011cf6b:	68 9f c6 12 f0       	push   $0xf012c69f
f011cf70:	e8 f7 3f fe ff       	call   f0100f6c <cprintf>
f011cf75:	83 c4 10             	add    $0x10,%esp
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011cf78:	ff 45 d0             	incl   -0x30(%ebp)
f011cf7b:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011cf81:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
f011cf87:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cf8a:	39 c2                	cmp    %eax,%edx
f011cf8c:	77 a9                	ja     f011cf37 <test_kheap_virt_addr+0x920>
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011cf8e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011cf94:	05 00 04 00 00       	add    $0x400,%eax
f011cf99:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011cf9c:	eb 64                	jmp    f011d002 <test_kheap_virt_addr+0x9eb>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011cf9e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011cfa1:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011cfa4:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011cfa7:	83 ec 0c             	sub    $0xc,%esp
f011cfaa:	50                   	push   %eax
f011cfab:	e8 58 b8 fe ff       	call   f0108808 <kheap_virtual_address>
f011cfb0:	83 c4 10             	add    $0x10,%esp
f011cfb3:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011cfb9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cfbc:	c1 e0 0c             	shl    $0xc,%eax
f011cfbf:	89 c2                	mov    %eax,%edx
f011cfc1:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011cfc7:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011cfca:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011cfcd:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011cfd0:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011cfd3:	25 ff 0f 00 00       	and    $0xfff,%eax
f011cfd8:	01 c8                	add    %ecx,%eax
f011cfda:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011cfe0:	74 1d                	je     f011cfff <test_kheap_virt_addr+0x9e8>
			{
				if (correct)
f011cfe2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cfe6:	74 17                	je     f011cfff <test_kheap_virt_addr+0x9e8>
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
f011cfe8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cfef:	83 ec 0c             	sub    $0xc,%esp
f011cff2:	68 9f c6 12 f0       	push   $0xf012c69f
f011cff7:	e8 70 3f fe ff       	call   f0100f6c <cprintf>
f011cffc:	83 c4 10             	add    $0x10,%esp
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011cfff:	ff 45 d0             	incl   -0x30(%ebp)
f011d002:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011d008:	8d 90 02 07 00 00    	lea    0x702(%eax),%edx
f011d00e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d011:	39 c2                	cmp    %eax,%edx
f011d013:	77 89                	ja     f011cf9e <test_kheap_virt_addr+0x987>
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011d015:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011d01b:	05 02 07 00 00       	add    $0x702,%eax
f011d020:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011d023:	eb 44                	jmp    f011d069 <test_kheap_virt_addr+0xa52>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011d025:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011d028:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011d02b:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011d02e:	83 ec 0c             	sub    $0xc,%esp
f011d031:	50                   	push   %eax
f011d032:	e8 d1 b7 fe ff       	call   f0108808 <kheap_virtual_address>
f011d037:	83 c4 10             	add    $0x10,%esp
f011d03a:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			if (retrievedVA != 0)
f011d040:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f011d047:	74 1d                	je     f011d066 <test_kheap_virt_addr+0xa4f>
			{
				if (correct)
f011d049:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d04d:	74 17                	je     f011d066 <test_kheap_virt_addr+0xa4f>
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
f011d04f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d056:	83 ec 0c             	sub    $0xc,%esp
f011d059:	68 9f c6 12 f0       	push   $0xf012c69f
f011d05e:	e8 09 3f fe ff       	call   f0100f6c <cprintf>
f011d063:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011d066:	ff 45 d0             	incl   -0x30(%ebp)
f011d069:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011d06f:	8d 90 02 0d 00 00    	lea    0xd02(%eax),%edx
f011d075:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d078:	39 c2                	cmp    %eax,%edx
f011d07a:	77 a9                	ja     f011d025 <test_kheap_virt_addr+0xa0e>
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011d07c:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011d082:	05 02 0d 00 00       	add    $0xd02,%eax
f011d087:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011d08a:	eb 64                	jmp    f011d0f0 <test_kheap_virt_addr+0xad9>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011d08c:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011d08f:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011d092:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011d095:	83 ec 0c             	sub    $0xc,%esp
f011d098:	50                   	push   %eax
f011d099:	e8 6a b7 fe ff       	call   f0108808 <kheap_virtual_address>
f011d09e:	83 c4 10             	add    $0x10,%esp
f011d0a1:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011d0a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d0aa:	c1 e0 0c             	shl    $0xc,%eax
f011d0ad:	89 c2                	mov    %eax,%edx
f011d0af:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011d0b5:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011d0b8:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011d0bb:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011d0be:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011d0c1:	25 ff 0f 00 00       	and    $0xfff,%eax
f011d0c6:	01 c8                	add    %ecx,%eax
f011d0c8:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011d0ce:	74 1d                	je     f011d0ed <test_kheap_virt_addr+0xad6>
			{
				if (correct)
f011d0d0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d0d4:	74 17                	je     f011d0ed <test_kheap_virt_addr+0xad6>
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
f011d0d6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d0dd:	83 ec 0c             	sub    $0xc,%esp
f011d0e0:	68 9f c6 12 f0       	push   $0xf012c69f
f011d0e5:	e8 82 3e fe ff       	call   f0100f6c <cprintf>
f011d0ea:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011d0ed:	ff 45 d0             	incl   -0x30(%ebp)
f011d0f0:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011d0f6:	8d 90 06 0d 00 00    	lea    0xd06(%eax),%edx
f011d0fc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d0ff:	39 c2                	cmp    %eax,%edx
f011d101:	77 89                	ja     f011d08c <test_kheap_virt_addr+0xa75>
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}
		}
	}
	if (correct)	eval+=20 ;
f011d103:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d107:	74 04                	je     f011d10d <test_kheap_virt_addr+0xaf6>
f011d109:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011d10d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	{
		uint32 va, pa;
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011d114:	c7 45 cc 00 00 00 f6 	movl   $0xf6000000,-0x34(%ebp)
f011d11b:	e9 d1 00 00 00       	jmp    f011d1f1 <test_kheap_virt_addr+0xbda>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011d120:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011d125:	83 ec 04             	sub    $0x4,%esp
f011d128:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011d12e:	52                   	push   %edx
f011d12f:	ff 75 cc             	pushl  -0x34(%ebp)
f011d132:	50                   	push   %eax
f011d133:	e8 f3 af fe ff       	call   f010812b <get_page_table>
f011d138:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011d13b:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011d141:	85 c0                	test   %eax,%eax
f011d143:	75 1e                	jne    f011d163 <test_kheap_virt_addr+0xb4c>
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011d145:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d14c:	83 ec 04             	sub    $0x4,%esp
f011d14f:	68 98 c5 12 f0       	push   $0xf012c598
f011d154:	68 cb 06 00 00       	push   $0x6cb
f011d159:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011d15e:	e8 b7 31 fe ff       	call   f010031a <_panic>
			pa = (ptr_table[PTX(va)] & 0xFFFFF000) + (va & 0xFFF);
f011d163:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011d169:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011d16c:	c1 ea 0c             	shr    $0xc,%edx
f011d16f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011d175:	c1 e2 02             	shl    $0x2,%edx
f011d178:	01 d0                	add    %edx,%eax
f011d17a:	8b 00                	mov    (%eax),%eax
f011d17c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011d181:	89 c2                	mov    %eax,%edx
f011d183:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011d186:	25 ff 0f 00 00       	and    $0xfff,%eax
f011d18b:	01 d0                	add    %edx,%eax
f011d18d:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			uint32 retrievedVA = kheap_virtual_address(pa);
f011d193:	83 ec 0c             	sub    $0xc,%esp
f011d196:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011d19c:	e8 67 b6 fe ff       	call   f0108808 <kheap_virtual_address>
f011d1a1:	83 c4 10             	add    $0x10,%esp
f011d1a4:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			if (retrievedVA != va)
f011d1aa:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011d1b0:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011d1b3:	74 39                	je     f011d1ee <test_kheap_virt_addr+0xbd7>
			{
				if (correct)
f011d1b5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d1b9:	74 33                	je     f011d1ee <test_kheap_virt_addr+0xbd7>
				{
					cprintf("\nPA = %x, retrievedVA = %x expectedVA = %x\n", pa, retrievedVA, va);
f011d1bb:	ff 75 cc             	pushl  -0x34(%ebp)
f011d1be:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
f011d1c4:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011d1ca:	68 bc c6 12 f0       	push   $0xf012c6bc
f011d1cf:	e8 98 3d fe ff       	call   f0100f6c <cprintf>
f011d1d4:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("Wrong kheap_virtual_address\n");
f011d1d7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d1de:	83 ec 0c             	sub    $0xc,%esp
f011d1e1:	68 9f c6 12 f0       	push   $0xf012c69f
f011d1e6:	e8 81 3d fe ff       	call   f0100f6c <cprintf>
f011d1eb:	83 c4 10             	add    $0x10,%esp

	correct = 1 ;
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	{
		uint32 va, pa;
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011d1ee:	ff 45 cc             	incl   -0x34(%ebp)
f011d1f1:	83 ec 0c             	sub    $0xc,%esp
f011d1f4:	6a 00                	push   $0x0
f011d1f6:	e8 cf b5 fe ff       	call   f01087ca <sbrk>
f011d1fb:	83 c4 10             	add    $0x10,%esp
f011d1fe:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011d201:	0f 87 19 ff ff ff    	ja     f011d120 <test_kheap_virt_addr+0xb09>
					correct = 0; cprintf("Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=40 ;
f011d207:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d20b:	74 04                	je     f011d211 <test_kheap_virt_addr+0xbfa>
f011d20d:	83 45 e4 28          	addl   $0x28,-0x1c(%ebp)

	correct = 1 ;
f011d211:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011d218:	c7 45 c8 00 00 10 00 	movl   $0x100000,-0x38(%ebp)
f011d21f:	eb 5a                	jmp    f011d27b <test_kheap_virt_addr+0xc64>
		{
			uint32 retrievedVA = kheap_virtual_address(i);
f011d221:	83 ec 0c             	sub    $0xc,%esp
f011d224:	ff 75 c8             	pushl  -0x38(%ebp)
f011d227:	e8 dc b5 fe ff       	call   f0108808 <kheap_virtual_address>
f011d22c:	83 c4 10             	add    $0x10,%esp
f011d22f:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
			if (retrievedVA != 0)
f011d235:	83 bd 5c ff ff ff 00 	cmpl   $0x0,-0xa4(%ebp)
f011d23c:	74 36                	je     f011d274 <test_kheap_virt_addr+0xc5d>
			{
				if (correct)
f011d23e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d242:	74 30                	je     f011d274 <test_kheap_virt_addr+0xc5d>
				{
					cprintf("\nPA = %x, retrievedVA = %x\n", i, retrievedVA);
f011d244:	83 ec 04             	sub    $0x4,%esp
f011d247:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
f011d24d:	ff 75 c8             	pushl  -0x38(%ebp)
f011d250:	68 e8 c6 12 f0       	push   $0xf012c6e8
f011d255:	e8 12 3d fe ff       	call   f0100f6c <cprintf>
f011d25a:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("Wrong kheap_virtual_address\n");
f011d25d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d264:	83 ec 0c             	sub    $0xc,%esp
f011d267:	68 9f c6 12 f0       	push   $0xf012c69f
f011d26c:	e8 fb 3c fe ff       	call   f0100f6c <cprintf>
f011d271:	83 c4 10             	add    $0x10,%esp

	correct = 1 ;
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011d274:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f011d27b:	b8 a8 79 57 00       	mov    $0x5779a8,%eax
f011d280:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f011d283:	72 9c                	jb     f011d221 <test_kheap_virt_addr+0xc0a>
					correct = 0; cprintf("Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=20 ;
f011d285:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d289:	74 04                	je     f011d28f <test_kheap_virt_addr+0xc78>
f011d28b:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	cprintf("\ntest kheap_virtual_address completed. Eval = %d%\n", eval);
f011d28f:	83 ec 08             	sub    $0x8,%esp
f011d292:	ff 75 e4             	pushl  -0x1c(%ebp)
f011d295:	68 04 c7 12 f0       	push   $0xf012c704
f011d29a:	e8 cd 3c fe ff       	call   f0100f6c <cprintf>
f011d29f:	83 c4 10             	add    $0x10,%esp

	return 1;
f011d2a2:	b8 01 00 00 00       	mov    $0x1,%eax
f011d2a7:	89 f4                	mov    %esi,%esp

}
f011d2a9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d2ac:	5b                   	pop    %ebx
f011d2ad:	5e                   	pop    %esi
f011d2ae:	5f                   	pop    %edi
f011d2af:	5d                   	pop    %ebp
f011d2b0:	c3                   	ret    

f011d2b1 <test_ksbrk>:


// 2023
int test_ksbrk()
{
f011d2b1:	55                   	push   %ebp
f011d2b2:	89 e5                	mov    %esp,%ebp
f011d2b4:	57                   	push   %edi
f011d2b5:	56                   	push   %esi
f011d2b6:	53                   	push   %ebx
f011d2b7:	81 ec 1c 01 00 00    	sub    $0x11c,%esp

	// malloc some spaces
	int i, freeFrames, freeDiskFrames;
	char *ptr;
	// int lastIndices[20] = {0};
	int sums[20] = {0};
f011d2bd:	8d 95 7c ff ff ff    	lea    -0x84(%ebp),%edx
f011d2c3:	b9 14 00 00 00       	mov    $0x14,%ecx
f011d2c8:	b8 00 00 00 00       	mov    $0x0,%eax
f011d2cd:	89 d7                	mov    %edx,%edi
f011d2cf:	f3 ab                	rep stos %eax,%es:(%edi)
	void *ptr_allocations[20] = {0};
f011d2d1:	8d 95 2c ff ff ff    	lea    -0xd4(%ebp),%edx
f011d2d7:	b9 14 00 00 00       	mov    $0x14,%ecx
f011d2dc:	b8 00 00 00 00       	mov    $0x0,%eax
f011d2e1:	89 d7                	mov    %edx,%edi
f011d2e3:	f3 ab                	rep stos %eax,%es:(%edi)

	// uint32 inputIncrementValues[] = {0, kilo, 2*kilo, -512, -2 * kilo, -2* kilo, 128, kilo};
	uint32 expectedVAs[] = {
f011d2e5:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011d2eb:	bb a0 cc 12 f0       	mov    $0xf012cca0,%ebx
f011d2f0:	ba 0a 00 00 00       	mov    $0xa,%edx
f011d2f5:	89 c7                	mov    %eax,%edi
f011d2f7:	89 de                	mov    %ebx,%esi
f011d2f9:	89 d1                	mov    %edx,%ecx
f011d2fb:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x1E00, // 128
			KERNEL_HEAP_START + 0x2000, // kilo
			KERNEL_HEAP_START + 0x0C00, // -9*kilo
			KERNEL_HEAP_START + 0x0C00, // +6*kilo
	};
	uint32 expectedSbrks[] = {
f011d2fd:	8d 85 dc fe ff ff    	lea    -0x124(%ebp),%eax
f011d303:	bb e0 cc 12 f0       	mov    $0xf012cce0,%ebx
f011d308:	ba 0a 00 00 00       	mov    $0xa,%edx
f011d30d:	89 c7                	mov    %eax,%edi
f011d30f:	89 de                	mov    %ebx,%esi
f011d311:	89 d1                	mov    %edx,%ecx
f011d313:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x3000, // kilo
			KERNEL_HEAP_START + 0x0C00, // -9*kilo
			KERNEL_HEAP_START + 0x4000, // +10*kilo
	};
	uint32 oldBrk, newBrk;
	int eval = 0;
f011d315:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011d31c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	cprintf("STEP A: checking increment with ZERO\n");
f011d323:	83 ec 0c             	sub    $0xc,%esp
f011d326:	68 38 c7 12 f0       	push   $0xf012c738
f011d32b:	e8 3c 3c fe ff       	call   f0100f6c <cprintf>
f011d330:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames();
f011d333:	e8 ef 03 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011d338:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011d33b:	e8 1e 72 fe ff       	call   f010455e <pf_calculate_free_frames>
f011d340:	89 45 d8             	mov    %eax,-0x28(%ebp)
		ptr_allocations[0] = sbrk(0);
f011d343:	83 ec 0c             	sub    $0xc,%esp
f011d346:	6a 00                	push   $0x0
f011d348:	e8 7d b4 fe ff       	call   f01087ca <sbrk>
f011d34d:	83 c4 10             	add    $0x10,%esp
f011d350:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d356:	e8 03 72 fe ff       	call   f010455e <pf_calculate_free_frames>
f011d35b:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011d35e:	74 17                	je     f011d377 <test_ksbrk+0xc6>
		{
			correct = 0;
f011d360:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d367:	83 ec 0c             	sub    $0xc,%esp
f011d36a:	68 60 c7 12 f0       	push   $0xf012c760
f011d36f:	e8 f8 3b fe ff       	call   f0100f6c <cprintf>
f011d374:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d377:	e8 ab 03 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011d37c:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011d37f:	74 17                	je     f011d398 <test_ksbrk+0xe7>
		{
			correct = 0;
f011d381:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011d388:	83 ec 0c             	sub    $0xc,%esp
f011d38b:	68 c8 c7 12 f0       	push   $0xf012c7c8
f011d390:	e8 d7 3b fe ff       	call   f0100f6c <cprintf>
f011d395:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[0] != expectedVAs[0])
f011d398:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011d39e:	89 c2                	mov    %eax,%edx
f011d3a0:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f011d3a6:	39 c2                	cmp    %eax,%edx
f011d3a8:	74 25                	je     f011d3cf <test_ksbrk+0x11e>
		{
			correct = 0;
f011d3aa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[0], ptr_allocations[0]);
f011d3b1:	8b 95 2c ff ff ff    	mov    -0xd4(%ebp),%edx
f011d3b7:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f011d3bd:	83 ec 04             	sub    $0x4,%esp
f011d3c0:	52                   	push   %edx
f011d3c1:	50                   	push   %eax
f011d3c2:	68 08 c8 12 f0       	push   $0xf012c808
f011d3c7:	e8 a0 3b fe ff       	call   f0100f6c <cprintf>
f011d3cc:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011d3cf:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d3d3:	74 04                	je     f011d3d9 <test_ksbrk+0x128>
			eval += 5;
f011d3d5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	}
	cprintf("STEP B: checking increment with +ve value\n");
f011d3d9:	83 ec 0c             	sub    $0xc,%esp
f011d3dc:	68 38 c8 12 f0       	push   $0xf012c838
f011d3e1:	e8 86 3b fe ff       	call   f0100f6c <cprintf>
f011d3e6:	83 c4 10             	add    $0x10,%esp
	{ // +1 KB
		freeFrames = (int)sys_calculate_free_frames();
f011d3e9:	e8 39 03 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011d3ee:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011d3f1:	e8 68 71 fe ff       	call   f010455e <pf_calculate_free_frames>
f011d3f6:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011d3f9:	83 ec 0c             	sub    $0xc,%esp
f011d3fc:	6a 00                	push   $0x0
f011d3fe:	e8 c7 b3 fe ff       	call   f01087ca <sbrk>
f011d403:	83 c4 10             	add    $0x10,%esp
f011d406:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[1] = sbrk(kilo);
f011d409:	83 ec 0c             	sub    $0xc,%esp
f011d40c:	68 00 04 00 00       	push   $0x400
f011d411:	e8 b4 b3 fe ff       	call   f01087ca <sbrk>
f011d416:	83 c4 10             	add    $0x10,%esp
f011d419:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		newBrk = (uint32)sbrk(0);
f011d41f:	83 ec 0c             	sub    $0xc,%esp
f011d422:	6a 00                	push   $0x0
f011d424:	e8 a1 b3 fe ff       	call   f01087ca <sbrk>
f011d429:	83 c4 10             	add    $0x10,%esp
f011d42c:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011d42f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d436:	e8 23 71 fe ff       	call   f010455e <pf_calculate_free_frames>
f011d43b:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011d43e:	74 17                	je     f011d457 <test_ksbrk+0x1a6>
		{
			correct = 0;
f011d440:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d447:	83 ec 0c             	sub    $0xc,%esp
f011d44a:	68 60 c7 12 f0       	push   $0xf012c760
f011d44f:	e8 18 3b fe ff       	call   f0100f6c <cprintf>
f011d454:	83 c4 10             	add    $0x10,%esp
		}
		// cprintf("####### %x - %x\n", freeFrames - (int)sys_calculate_free_frames(), -1 * ((ROUNDUP(oldBrk, PAGE_SIZE) - newBrk) / PAGE_SIZE));
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011d457:	e8 cb 02 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011d45c:	89 c2                	mov    %eax,%edx
f011d45e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d461:	29 d0                	sub    %edx,%eax
f011d463:	83 f8 01             	cmp    $0x1,%eax
f011d466:	74 17                	je     f011d47f <test_ksbrk+0x1ce>
		{
			correct = 0;
f011d468:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011d46f:	83 ec 0c             	sub    $0xc,%esp
f011d472:	68 c8 c7 12 f0       	push   $0xf012c7c8
f011d477:	e8 f0 3a fe ff       	call   f0100f6c <cprintf>
f011d47c:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[1] != expectedVAs[1])
f011d47f:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011d485:	89 c2                	mov    %eax,%edx
f011d487:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
f011d48d:	39 c2                	cmp    %eax,%edx
f011d48f:	74 25                	je     f011d4b6 <test_ksbrk+0x205>
		{
			correct = 0;
f011d491:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[1], ptr_allocations[1]);
f011d498:	8b 95 30 ff ff ff    	mov    -0xd0(%ebp),%edx
f011d49e:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
f011d4a4:	83 ec 04             	sub    $0x4,%esp
f011d4a7:	52                   	push   %edx
f011d4a8:	50                   	push   %eax
f011d4a9:	68 08 c8 12 f0       	push   $0xf012c808
f011d4ae:	e8 b9 3a fe ff       	call   f0100f6c <cprintf>
f011d4b3:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[1])
f011d4b6:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011d4bc:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011d4bf:	74 21                	je     f011d4e2 <test_ksbrk+0x231>
		{
			correct = 0;
f011d4c1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[1]);
f011d4c8:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011d4ce:	83 ec 04             	sub    $0x4,%esp
f011d4d1:	50                   	push   %eax
f011d4d2:	ff 75 d0             	pushl  -0x30(%ebp)
f011d4d5:	68 64 c8 12 f0       	push   $0xf012c864
f011d4da:	e8 8d 3a fe ff       	call   f0100f6c <cprintf>
f011d4df:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011d4e2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d4e6:	74 04                	je     f011d4ec <test_ksbrk+0x23b>
			eval += 5;
f011d4e8:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	}
	{ // +2 KB
		freeFrames = (int)sys_calculate_free_frames();
f011d4ec:	e8 36 02 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011d4f1:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011d4f4:	e8 65 70 fe ff       	call   f010455e <pf_calculate_free_frames>
f011d4f9:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011d4fc:	83 ec 0c             	sub    $0xc,%esp
f011d4ff:	6a 00                	push   $0x0
f011d501:	e8 c4 b2 fe ff       	call   f01087ca <sbrk>
f011d506:	83 c4 10             	add    $0x10,%esp
f011d509:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[2] = sbrk(2 * kilo);
f011d50c:	83 ec 0c             	sub    $0xc,%esp
f011d50f:	68 00 08 00 00       	push   $0x800
f011d514:	e8 b1 b2 fe ff       	call   f01087ca <sbrk>
f011d519:	83 c4 10             	add    $0x10,%esp
f011d51c:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
		newBrk = (uint32)sbrk(0);
f011d522:	83 ec 0c             	sub    $0xc,%esp
f011d525:	6a 00                	push   $0x0
f011d527:	e8 9e b2 fe ff       	call   f01087ca <sbrk>
f011d52c:	83 c4 10             	add    $0x10,%esp
f011d52f:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011d532:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d539:	e8 20 70 fe ff       	call   f010455e <pf_calculate_free_frames>
f011d53e:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011d541:	74 17                	je     f011d55a <test_ksbrk+0x2a9>
		{
			correct = 0;
f011d543:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d54a:	83 ec 0c             	sub    $0xc,%esp
f011d54d:	68 60 c7 12 f0       	push   $0xf012c760
f011d552:	e8 15 3a fe ff       	call   f0100f6c <cprintf>
f011d557:	83 c4 10             	add    $0x10,%esp
		}
		int x = (freeFrames - (int)sys_calculate_free_frames());
f011d55a:	e8 c8 01 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011d55f:	89 c2                	mov    %eax,%edx
f011d561:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d564:	29 d0                	sub    %edx,%eax
f011d566:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011d569:	e8 b9 01 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011d56e:	89 c2                	mov    %eax,%edx
f011d570:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d573:	29 d0                	sub    %edx,%eax
f011d575:	83 f8 01             	cmp    $0x1,%eax
f011d578:	74 17                	je     f011d591 <test_ksbrk+0x2e0>
		{
			correct = 0;
f011d57a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011d581:	83 ec 0c             	sub    $0xc,%esp
f011d584:	68 c8 c7 12 f0       	push   $0xf012c7c8
f011d589:	e8 de 39 fe ff       	call   f0100f6c <cprintf>
f011d58e:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[2] != expectedVAs[2])
f011d591:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011d597:	89 c2                	mov    %eax,%edx
f011d599:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
f011d59f:	39 c2                	cmp    %eax,%edx
f011d5a1:	74 25                	je     f011d5c8 <test_ksbrk+0x317>
		{
			correct = 0;
f011d5a3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[2], ptr_allocations[2]);
f011d5aa:	8b 95 34 ff ff ff    	mov    -0xcc(%ebp),%edx
f011d5b0:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
f011d5b6:	83 ec 04             	sub    $0x4,%esp
f011d5b9:	52                   	push   %edx
f011d5ba:	50                   	push   %eax
f011d5bb:	68 08 c8 12 f0       	push   $0xf012c808
f011d5c0:	e8 a7 39 fe ff       	call   f0100f6c <cprintf>
f011d5c5:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[2])
f011d5c8:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011d5ce:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011d5d1:	74 21                	je     f011d5f4 <test_ksbrk+0x343>
		{
			correct = 0;
f011d5d3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[2]);
f011d5da:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011d5e0:	83 ec 04             	sub    $0x4,%esp
f011d5e3:	50                   	push   %eax
f011d5e4:	ff 75 d0             	pushl  -0x30(%ebp)
f011d5e7:	68 64 c8 12 f0       	push   $0xf012c864
f011d5ec:	e8 7b 39 fe ff       	call   f0100f6c <cprintf>
f011d5f1:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011d5f4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d5f8:	74 04                	je     f011d5fe <test_ksbrk+0x34d>
			eval += 5;
f011d5fa:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	}
	cprintf("STEP C: checking increment with -ve value [No Frames to be Deallocated]\n");
f011d5fe:	83 ec 0c             	sub    $0xc,%esp
f011d601:	68 90 c8 12 f0       	push   $0xf012c890
f011d606:	e8 61 39 fe ff       	call   f0100f6c <cprintf>
f011d60b:	83 c4 10             	add    $0x10,%esp
	{ // -512 Bytes
		freeFrames = (int)sys_calculate_free_frames();
f011d60e:	e8 14 01 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011d613:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011d616:	e8 43 6f fe ff       	call   f010455e <pf_calculate_free_frames>
f011d61b:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011d61e:	83 ec 0c             	sub    $0xc,%esp
f011d621:	6a 00                	push   $0x0
f011d623:	e8 a2 b1 fe ff       	call   f01087ca <sbrk>
f011d628:	83 c4 10             	add    $0x10,%esp
f011d62b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[3] = sbrk(-512);
f011d62e:	83 ec 0c             	sub    $0xc,%esp
f011d631:	68 00 fe ff ff       	push   $0xfffffe00
f011d636:	e8 8f b1 fe ff       	call   f01087ca <sbrk>
f011d63b:	83 c4 10             	add    $0x10,%esp
f011d63e:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		newBrk = (uint32)sbrk(0);
f011d644:	83 ec 0c             	sub    $0xc,%esp
f011d647:	6a 00                	push   $0x0
f011d649:	e8 7c b1 fe ff       	call   f01087ca <sbrk>
f011d64e:	83 c4 10             	add    $0x10,%esp
f011d651:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011d654:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d65b:	e8 fe 6e fe ff       	call   f010455e <pf_calculate_free_frames>
f011d660:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011d663:	74 17                	je     f011d67c <test_ksbrk+0x3cb>
		{
			correct = 0;
f011d665:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d66c:	83 ec 0c             	sub    $0xc,%esp
f011d66f:	68 60 c7 12 f0       	push   $0xf012c760
f011d674:	e8 f3 38 fe ff       	call   f0100f6c <cprintf>
f011d679:	83 c4 10             	add    $0x10,%esp
		}
		// cprintf("####### %x - %x\n", freeFrames - (int)sys_calculate_free_frames(), -1 * ((ROUNDUP(oldBrk, PAGE_SIZE) - newBrk) / PAGE_SIZE));
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d67c:	e8 a6 00 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011d681:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011d684:	74 17                	je     f011d69d <test_ksbrk+0x3ec>
		{
			correct = 0;
f011d686:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011d68d:	83 ec 0c             	sub    $0xc,%esp
f011d690:	68 c8 c7 12 f0       	push   $0xf012c7c8
f011d695:	e8 d2 38 fe ff       	call   f0100f6c <cprintf>
f011d69a:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[3] != expectedVAs[3])
f011d69d:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011d6a3:	89 c2                	mov    %eax,%edx
f011d6a5:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f011d6ab:	39 c2                	cmp    %eax,%edx
f011d6ad:	74 25                	je     f011d6d4 <test_ksbrk+0x423>
		{
			correct = 0;
f011d6af:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[3], ptr_allocations[3]);
f011d6b6:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f011d6bc:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f011d6c2:	83 ec 04             	sub    $0x4,%esp
f011d6c5:	52                   	push   %edx
f011d6c6:	50                   	push   %eax
f011d6c7:	68 08 c8 12 f0       	push   $0xf012c808
f011d6cc:	e8 9b 38 fe ff       	call   f0100f6c <cprintf>
f011d6d1:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[3])
f011d6d4:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011d6da:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011d6dd:	74 21                	je     f011d700 <test_ksbrk+0x44f>
		{
			correct = 0;
f011d6df:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[3]);
f011d6e6:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011d6ec:	83 ec 04             	sub    $0x4,%esp
f011d6ef:	50                   	push   %eax
f011d6f0:	ff 75 d0             	pushl  -0x30(%ebp)
f011d6f3:	68 64 c8 12 f0       	push   $0xf012c864
f011d6f8:	e8 6f 38 fe ff       	call   f0100f6c <cprintf>
f011d6fd:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011d700:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d704:	74 04                	je     f011d70a <test_ksbrk+0x459>
			eval += 10;
f011d706:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	{ // -2 KB
		freeFrames = (int)sys_calculate_free_frames();
f011d70a:	e8 18 00 ff ff       	call   f010d727 <sys_calculate_free_frames>
f011d70f:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011d712:	e8 47 6e fe ff       	call   f010455e <pf_calculate_free_frames>
f011d717:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011d71a:	83 ec 0c             	sub    $0xc,%esp
f011d71d:	6a 00                	push   $0x0
f011d71f:	e8 a6 b0 fe ff       	call   f01087ca <sbrk>
f011d724:	83 c4 10             	add    $0x10,%esp
f011d727:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[4] = sbrk(-2 * kilo);
f011d72a:	83 ec 0c             	sub    $0xc,%esp
f011d72d:	68 00 f8 ff ff       	push   $0xfffff800
f011d732:	e8 93 b0 fe ff       	call   f01087ca <sbrk>
f011d737:	83 c4 10             	add    $0x10,%esp
f011d73a:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		newBrk = (uint32)sbrk(0);
f011d740:	83 ec 0c             	sub    $0xc,%esp
f011d743:	6a 00                	push   $0x0
f011d745:	e8 80 b0 fe ff       	call   f01087ca <sbrk>
f011d74a:	83 c4 10             	add    $0x10,%esp
f011d74d:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011d750:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d757:	e8 02 6e fe ff       	call   f010455e <pf_calculate_free_frames>
f011d75c:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011d75f:	74 17                	je     f011d778 <test_ksbrk+0x4c7>
		{
			correct = 0;
f011d761:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d768:	83 ec 0c             	sub    $0xc,%esp
f011d76b:	68 60 c7 12 f0       	push   $0xf012c760
f011d770:	e8 f7 37 fe ff       	call   f0100f6c <cprintf>
f011d775:	83 c4 10             	add    $0x10,%esp
		}
		// cprintf("####### %x - %x\n", freeFrames - (int)sys_calculate_free_frames(), -1 * ((ROUNDUP(oldBrk, PAGE_SIZE) - newBrk) / PAGE_SIZE));
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d778:	e8 aa ff fe ff       	call   f010d727 <sys_calculate_free_frames>
f011d77d:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011d780:	74 17                	je     f011d799 <test_ksbrk+0x4e8>
		{
			correct = 0;
f011d782:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011d789:	83 ec 0c             	sub    $0xc,%esp
f011d78c:	68 c8 c7 12 f0       	push   $0xf012c7c8
f011d791:	e8 d6 37 fe ff       	call   f0100f6c <cprintf>
f011d796:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[4] != expectedVAs[4])
f011d799:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f011d79f:	89 c2                	mov    %eax,%edx
f011d7a1:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
f011d7a7:	39 c2                	cmp    %eax,%edx
f011d7a9:	74 25                	je     f011d7d0 <test_ksbrk+0x51f>
		{
			correct = 0;
f011d7ab:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[4], ptr_allocations[4]);
f011d7b2:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f011d7b8:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
f011d7be:	83 ec 04             	sub    $0x4,%esp
f011d7c1:	52                   	push   %edx
f011d7c2:	50                   	push   %eax
f011d7c3:	68 08 c8 12 f0       	push   $0xf012c808
f011d7c8:	e8 9f 37 fe ff       	call   f0100f6c <cprintf>
f011d7cd:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[4])
f011d7d0:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011d7d6:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011d7d9:	74 21                	je     f011d7fc <test_ksbrk+0x54b>
		{
			correct = 0;
f011d7db:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[4]);
f011d7e2:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011d7e8:	83 ec 04             	sub    $0x4,%esp
f011d7eb:	50                   	push   %eax
f011d7ec:	ff 75 d0             	pushl  -0x30(%ebp)
f011d7ef:	68 64 c8 12 f0       	push   $0xf012c864
f011d7f4:	e8 73 37 fe ff       	call   f0100f6c <cprintf>
f011d7f9:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011d7fc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d800:	74 04                	je     f011d806 <test_ksbrk+0x555>
			eval += 10;
f011d802:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	cprintf("STEP D: checking increment with -ve value [ONE Frame should be Deallocated]\n");
f011d806:	83 ec 0c             	sub    $0xc,%esp
f011d809:	68 dc c8 12 f0       	push   $0xf012c8dc
f011d80e:	e8 59 37 fe ff       	call   f0100f6c <cprintf>
f011d813:	83 c4 10             	add    $0x10,%esp
	{ // -2 KB
		freeFrames = (int)sys_calculate_free_frames();
f011d816:	e8 0c ff fe ff       	call   f010d727 <sys_calculate_free_frames>
f011d81b:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011d81e:	e8 3b 6d fe ff       	call   f010455e <pf_calculate_free_frames>
f011d823:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011d826:	83 ec 0c             	sub    $0xc,%esp
f011d829:	6a 00                	push   $0x0
f011d82b:	e8 9a af fe ff       	call   f01087ca <sbrk>
f011d830:	83 c4 10             	add    $0x10,%esp
f011d833:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[5] = sbrk(-2 * kilo);
f011d836:	83 ec 0c             	sub    $0xc,%esp
f011d839:	68 00 f8 ff ff       	push   $0xfffff800
f011d83e:	e8 87 af fe ff       	call   f01087ca <sbrk>
f011d843:	83 c4 10             	add    $0x10,%esp
f011d846:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
		newBrk = (uint32)sbrk(0);
f011d84c:	83 ec 0c             	sub    $0xc,%esp
f011d84f:	6a 00                	push   $0x0
f011d851:	e8 74 af fe ff       	call   f01087ca <sbrk>
f011d856:	83 c4 10             	add    $0x10,%esp
f011d859:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011d85c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)(int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d863:	e8 f6 6c fe ff       	call   f010455e <pf_calculate_free_frames>
f011d868:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011d86b:	74 17                	je     f011d884 <test_ksbrk+0x5d3>
		{
			correct = 0;
f011d86d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d874:	83 ec 0c             	sub    $0xc,%esp
f011d877:	68 60 c7 12 f0       	push   $0xf012c760
f011d87c:	e8 eb 36 fe ff       	call   f0100f6c <cprintf>
f011d881:	83 c4 10             	add    $0x10,%esp
		}
		// cprintf("####### %x - %x\n", freeFrames - (int)sys_calculate_free_frames(), -1 * ((ROUNDUP(oldBrk, PAGE_SIZE) - newBrk) / PAGE_SIZE));
		if (((int)(int)sys_calculate_free_frames() - freeFrames) != 1)
f011d884:	e8 9e fe fe ff       	call   f010d727 <sys_calculate_free_frames>
f011d889:	2b 45 dc             	sub    -0x24(%ebp),%eax
f011d88c:	83 f8 01             	cmp    $0x1,%eax
f011d88f:	74 17                	je     f011d8a8 <test_ksbrk+0x5f7>
		{
			correct = 0;
f011d891:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011d898:	83 ec 0c             	sub    $0xc,%esp
f011d89b:	68 c8 c7 12 f0       	push   $0xf012c7c8
f011d8a0:	e8 c7 36 fe ff       	call   f0100f6c <cprintf>
f011d8a5:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[5] != expectedVAs[5])
f011d8a8:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f011d8ae:	89 c2                	mov    %eax,%edx
f011d8b0:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
f011d8b6:	39 c2                	cmp    %eax,%edx
f011d8b8:	74 25                	je     f011d8df <test_ksbrk+0x62e>
		{
			correct = 0;
f011d8ba:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[5], ptr_allocations[5]);
f011d8c1:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011d8c7:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
f011d8cd:	83 ec 04             	sub    $0x4,%esp
f011d8d0:	52                   	push   %edx
f011d8d1:	50                   	push   %eax
f011d8d2:	68 08 c8 12 f0       	push   $0xf012c808
f011d8d7:	e8 90 36 fe ff       	call   f0100f6c <cprintf>
f011d8dc:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[5])
f011d8df:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011d8e5:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011d8e8:	74 21                	je     f011d90b <test_ksbrk+0x65a>
		{
			correct = 0;
f011d8ea:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[5]);
f011d8f1:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011d8f7:	83 ec 04             	sub    $0x4,%esp
f011d8fa:	50                   	push   %eax
f011d8fb:	ff 75 d0             	pushl  -0x30(%ebp)
f011d8fe:	68 64 c8 12 f0       	push   $0xf012c864
f011d903:	e8 64 36 fe ff       	call   f0100f6c <cprintf>
f011d908:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011d90b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d90f:	74 04                	je     f011d915 <test_ksbrk+0x664>
			eval += 15;
f011d911:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	cprintf("STEP E: checking increment with +ve value [No Frames to be Allocated]\n");
f011d915:	83 ec 0c             	sub    $0xc,%esp
f011d918:	68 2c c9 12 f0       	push   $0xf012c92c
f011d91d:	e8 4a 36 fe ff       	call   f0100f6c <cprintf>
f011d922:	83 c4 10             	add    $0x10,%esp
	{ // 128 Bytes
		freeFrames = (int)(int)sys_calculate_free_frames();
f011d925:	e8 fd fd fe ff       	call   f010d727 <sys_calculate_free_frames>
f011d92a:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)(int)pf_calculate_free_frames();
f011d92d:	e8 2c 6c fe ff       	call   f010455e <pf_calculate_free_frames>
f011d932:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011d935:	83 ec 0c             	sub    $0xc,%esp
f011d938:	6a 00                	push   $0x0
f011d93a:	e8 8b ae fe ff       	call   f01087ca <sbrk>
f011d93f:	83 c4 10             	add    $0x10,%esp
f011d942:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[6] = sbrk(128);
f011d945:	83 ec 0c             	sub    $0xc,%esp
f011d948:	68 80 00 00 00       	push   $0x80
f011d94d:	e8 78 ae fe ff       	call   f01087ca <sbrk>
f011d952:	83 c4 10             	add    $0x10,%esp
f011d955:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
		newBrk = (uint32)sbrk(0);
f011d95b:	83 ec 0c             	sub    $0xc,%esp
f011d95e:	6a 00                	push   $0x0
f011d960:	e8 65 ae fe ff       	call   f01087ca <sbrk>
f011d965:	83 c4 10             	add    $0x10,%esp
f011d968:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011d96b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d972:	e8 e7 6b fe ff       	call   f010455e <pf_calculate_free_frames>
f011d977:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011d97a:	74 17                	je     f011d993 <test_ksbrk+0x6e2>
		{
			correct = 0;
f011d97c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d983:	83 ec 0c             	sub    $0xc,%esp
f011d986:	68 60 c7 12 f0       	push   $0xf012c760
f011d98b:	e8 dc 35 fe ff       	call   f0100f6c <cprintf>
f011d990:	83 c4 10             	add    $0x10,%esp
		}
		if (((int)(int)sys_calculate_free_frames() - freeFrames) != 0)
f011d993:	e8 8f fd fe ff       	call   f010d727 <sys_calculate_free_frames>
f011d998:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011d99b:	74 17                	je     f011d9b4 <test_ksbrk+0x703>
		{
			correct = 0;
f011d99d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011d9a4:	83 ec 0c             	sub    $0xc,%esp
f011d9a7:	68 c8 c7 12 f0       	push   $0xf012c7c8
f011d9ac:	e8 bb 35 fe ff       	call   f0100f6c <cprintf>
f011d9b1:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[6] != expectedVAs[6])
f011d9b4:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011d9ba:	89 c2                	mov    %eax,%edx
f011d9bc:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
f011d9c2:	39 c2                	cmp    %eax,%edx
f011d9c4:	74 25                	je     f011d9eb <test_ksbrk+0x73a>
		{
			correct = 0;
f011d9c6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[6], ptr_allocations[6]);
f011d9cd:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f011d9d3:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
f011d9d9:	83 ec 04             	sub    $0x4,%esp
f011d9dc:	52                   	push   %edx
f011d9dd:	50                   	push   %eax
f011d9de:	68 08 c8 12 f0       	push   $0xf012c808
f011d9e3:	e8 84 35 fe ff       	call   f0100f6c <cprintf>
f011d9e8:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[6])
f011d9eb:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011d9f1:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011d9f4:	74 21                	je     f011da17 <test_ksbrk+0x766>
		{
			correct = 0;
f011d9f6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[6]);
f011d9fd:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011da03:	83 ec 04             	sub    $0x4,%esp
f011da06:	50                   	push   %eax
f011da07:	ff 75 d0             	pushl  -0x30(%ebp)
f011da0a:	68 64 c8 12 f0       	push   $0xf012c864
f011da0f:	e8 58 35 fe ff       	call   f0100f6c <cprintf>
f011da14:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011da17:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011da1b:	74 04                	je     f011da21 <test_ksbrk+0x770>
			eval += 15;
f011da1d:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	cprintf("STEP F: checking increment with +ve value [ONE Frame should be Allocated]\n");
f011da21:	83 ec 0c             	sub    $0xc,%esp
f011da24:	68 74 c9 12 f0       	push   $0xf012c974
f011da29:	e8 3e 35 fe ff       	call   f0100f6c <cprintf>
f011da2e:	83 c4 10             	add    $0x10,%esp
	{ // 1 KB
		freeFrames = (int)(int)sys_calculate_free_frames();
f011da31:	e8 f1 fc fe ff       	call   f010d727 <sys_calculate_free_frames>
f011da36:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011da39:	e8 20 6b fe ff       	call   f010455e <pf_calculate_free_frames>
f011da3e:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011da41:	83 ec 0c             	sub    $0xc,%esp
f011da44:	6a 00                	push   $0x0
f011da46:	e8 7f ad fe ff       	call   f01087ca <sbrk>
f011da4b:	83 c4 10             	add    $0x10,%esp
f011da4e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[7] = sbrk(kilo);
f011da51:	83 ec 0c             	sub    $0xc,%esp
f011da54:	68 00 04 00 00       	push   $0x400
f011da59:	e8 6c ad fe ff       	call   f01087ca <sbrk>
f011da5e:	83 c4 10             	add    $0x10,%esp
f011da61:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		newBrk = (uint32)sbrk(0);
f011da67:	83 ec 0c             	sub    $0xc,%esp
f011da6a:	6a 00                	push   $0x0
f011da6c:	e8 59 ad fe ff       	call   f01087ca <sbrk>
f011da71:	83 c4 10             	add    $0x10,%esp
f011da74:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011da77:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011da7e:	e8 db 6a fe ff       	call   f010455e <pf_calculate_free_frames>
f011da83:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011da86:	74 17                	je     f011da9f <test_ksbrk+0x7ee>
		{
			correct = 0;
f011da88:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011da8f:	83 ec 0c             	sub    $0xc,%esp
f011da92:	68 60 c7 12 f0       	push   $0xf012c760
f011da97:	e8 d0 34 fe ff       	call   f0100f6c <cprintf>
f011da9c:	83 c4 10             	add    $0x10,%esp
		}
		//cprintf("((int)(int)sys_calculate_free_frames() - freeFrames) = %d\n", ((int)(int)sys_calculate_free_frames() - freeFrames));
		if ((freeFrames - (int)(int)sys_calculate_free_frames()) != 1)
f011da9f:	e8 83 fc fe ff       	call   f010d727 <sys_calculate_free_frames>
f011daa4:	89 c2                	mov    %eax,%edx
f011daa6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011daa9:	29 d0                	sub    %edx,%eax
f011daab:	83 f8 01             	cmp    $0x1,%eax
f011daae:	74 17                	je     f011dac7 <test_ksbrk+0x816>
		{
			correct = 0;
f011dab0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("7 Wrong allocation: pages are not loaded successfully into memory");
f011dab7:	83 ec 0c             	sub    $0xc,%esp
f011daba:	68 c0 c9 12 f0       	push   $0xf012c9c0
f011dabf:	e8 a8 34 fe ff       	call   f0100f6c <cprintf>
f011dac4:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[7] != expectedVAs[7])
f011dac7:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011dacd:	89 c2                	mov    %eax,%edx
f011dacf:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011dad5:	39 c2                	cmp    %eax,%edx
f011dad7:	74 25                	je     f011dafe <test_ksbrk+0x84d>
		{
			correct = 0;
f011dad9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("7 Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[7], ptr_allocations[7]);
f011dae0:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011dae6:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011daec:	83 ec 04             	sub    $0x4,%esp
f011daef:	52                   	push   %edx
f011daf0:	50                   	push   %eax
f011daf1:	68 04 ca 12 f0       	push   $0xf012ca04
f011daf6:	e8 71 34 fe ff       	call   f0100f6c <cprintf>
f011dafb:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[7])
f011dafe:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011db04:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011db07:	74 21                	je     f011db2a <test_ksbrk+0x879>
		{
			correct = 0;
f011db09:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("7 Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[7]);
f011db10:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011db16:	83 ec 04             	sub    $0x4,%esp
f011db19:	50                   	push   %eax
f011db1a:	ff 75 d0             	pushl  -0x30(%ebp)
f011db1d:	68 38 ca 12 f0       	push   $0xf012ca38
f011db22:	e8 45 34 fe ff       	call   f0100f6c <cprintf>
f011db27:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011db2a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011db2e:	74 04                	je     f011db34 <test_ksbrk+0x883>
			eval += 15;
f011db30:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	cprintf("STEP G: checking increment with -ve value [TWO Frames should be Deallocated]\n");
f011db34:	83 ec 0c             	sub    $0xc,%esp
f011db37:	68 68 ca 12 f0       	push   $0xf012ca68
f011db3c:	e8 2b 34 fe ff       	call   f0100f6c <cprintf>
f011db41:	83 c4 10             	add    $0x10,%esp
	{ // -9 KB
		freeFrames = (int)sys_calculate_free_frames();
f011db44:	e8 de fb fe ff       	call   f010d727 <sys_calculate_free_frames>
f011db49:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011db4c:	e8 0d 6a fe ff       	call   f010455e <pf_calculate_free_frames>
f011db51:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011db54:	83 ec 0c             	sub    $0xc,%esp
f011db57:	6a 00                	push   $0x0
f011db59:	e8 6c ac fe ff       	call   f01087ca <sbrk>
f011db5e:	83 c4 10             	add    $0x10,%esp
f011db61:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[8] = sbrk(-9 * kilo);
f011db64:	83 ec 0c             	sub    $0xc,%esp
f011db67:	68 00 dc ff ff       	push   $0xffffdc00
f011db6c:	e8 59 ac fe ff       	call   f01087ca <sbrk>
f011db71:	83 c4 10             	add    $0x10,%esp
f011db74:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		newBrk = (uint32)sbrk(0);
f011db7a:	83 ec 0c             	sub    $0xc,%esp
f011db7d:	6a 00                	push   $0x0
f011db7f:	e8 46 ac fe ff       	call   f01087ca <sbrk>
f011db84:	83 c4 10             	add    $0x10,%esp
f011db87:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011db8a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)(int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011db91:	e8 c8 69 fe ff       	call   f010455e <pf_calculate_free_frames>
f011db96:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011db99:	74 17                	je     f011dbb2 <test_ksbrk+0x901>
		{
			correct = 0;
f011db9b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011dba2:	83 ec 0c             	sub    $0xc,%esp
f011dba5:	68 60 c7 12 f0       	push   $0xf012c760
f011dbaa:	e8 bd 33 fe ff       	call   f0100f6c <cprintf>
f011dbaf:	83 c4 10             	add    $0x10,%esp
		}
		// cprintf("####### %x - %x\n", freeFrames - (int)sys_calculate_free_frames(), -1 * ((ROUNDUP(oldBrk, PAGE_SIZE) - newBrk) / PAGE_SIZE));
		if (((int)(int)sys_calculate_free_frames() - freeFrames) != 2)
f011dbb2:	e8 70 fb fe ff       	call   f010d727 <sys_calculate_free_frames>
f011dbb7:	2b 45 dc             	sub    -0x24(%ebp),%eax
f011dbba:	83 f8 02             	cmp    $0x2,%eax
f011dbbd:	74 17                	je     f011dbd6 <test_ksbrk+0x925>
		{
			correct = 0;
f011dbbf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("8 Wrong allocation: pages are not loaded successfully into memory");
f011dbc6:	83 ec 0c             	sub    $0xc,%esp
f011dbc9:	68 b8 ca 12 f0       	push   $0xf012cab8
f011dbce:	e8 99 33 fe ff       	call   f0100f6c <cprintf>
f011dbd3:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[8] != expectedVAs[8])
f011dbd6:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011dbdc:	89 c2                	mov    %eax,%edx
f011dbde:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011dbe4:	39 c2                	cmp    %eax,%edx
f011dbe6:	74 25                	je     f011dc0d <test_ksbrk+0x95c>
		{
			correct = 0;
f011dbe8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("8 Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[5], ptr_allocations[5]);
f011dbef:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011dbf5:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
f011dbfb:	83 ec 04             	sub    $0x4,%esp
f011dbfe:	52                   	push   %edx
f011dbff:	50                   	push   %eax
f011dc00:	68 fc ca 12 f0       	push   $0xf012cafc
f011dc05:	e8 62 33 fe ff       	call   f0100f6c <cprintf>
f011dc0a:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[8])
f011dc0d:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011dc13:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011dc16:	74 21                	je     f011dc39 <test_ksbrk+0x988>
		{
			correct = 0;
f011dc18:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("8 Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[5]);
f011dc1f:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011dc25:	83 ec 04             	sub    $0x4,%esp
f011dc28:	50                   	push   %eax
f011dc29:	ff 75 d0             	pushl  -0x30(%ebp)
f011dc2c:	68 30 cb 12 f0       	push   $0xf012cb30
f011dc31:	e8 36 33 fe ff       	call   f0100f6c <cprintf>
f011dc36:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011dc39:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011dc3d:	74 04                	je     f011dc43 <test_ksbrk+0x992>
			eval += 10;
f011dc3f:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	cprintf("STEP H: checking increment with +ve value [THREE Frames should be Allocated]\n");
f011dc43:	83 ec 0c             	sub    $0xc,%esp
f011dc46:	68 60 cb 12 f0       	push   $0xf012cb60
f011dc4b:	e8 1c 33 fe ff       	call   f0100f6c <cprintf>
f011dc50:	83 c4 10             	add    $0x10,%esp
	{ // 10 KB
		freeFrames = (int)(int)sys_calculate_free_frames();
f011dc53:	e8 cf fa fe ff       	call   f010d727 <sys_calculate_free_frames>
f011dc58:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011dc5b:	e8 fe 68 fe ff       	call   f010455e <pf_calculate_free_frames>
f011dc60:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011dc63:	83 ec 0c             	sub    $0xc,%esp
f011dc66:	6a 00                	push   $0x0
f011dc68:	e8 5d ab fe ff       	call   f01087ca <sbrk>
f011dc6d:	83 c4 10             	add    $0x10,%esp
f011dc70:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[9] = sbrk(10*kilo);
f011dc73:	83 ec 0c             	sub    $0xc,%esp
f011dc76:	68 00 28 00 00       	push   $0x2800
f011dc7b:	e8 4a ab fe ff       	call   f01087ca <sbrk>
f011dc80:	83 c4 10             	add    $0x10,%esp
f011dc83:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		newBrk = (uint32)sbrk(0);
f011dc89:	83 ec 0c             	sub    $0xc,%esp
f011dc8c:	6a 00                	push   $0x0
f011dc8e:	e8 37 ab fe ff       	call   f01087ca <sbrk>
f011dc93:	83 c4 10             	add    $0x10,%esp
f011dc96:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011dc99:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011dca0:	e8 b9 68 fe ff       	call   f010455e <pf_calculate_free_frames>
f011dca5:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011dca8:	74 17                	je     f011dcc1 <test_ksbrk+0xa10>
		{
			correct = 0;
f011dcaa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011dcb1:	83 ec 0c             	sub    $0xc,%esp
f011dcb4:	68 60 c7 12 f0       	push   $0xf012c760
f011dcb9:	e8 ae 32 fe ff       	call   f0100f6c <cprintf>
f011dcbe:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)(int)sys_calculate_free_frames()) != 3)
f011dcc1:	e8 61 fa fe ff       	call   f010d727 <sys_calculate_free_frames>
f011dcc6:	89 c2                	mov    %eax,%edx
f011dcc8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011dccb:	29 d0                	sub    %edx,%eax
f011dccd:	83 f8 03             	cmp    $0x3,%eax
f011dcd0:	74 17                	je     f011dce9 <test_ksbrk+0xa38>
		{
			correct = 0;
f011dcd2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("9 Wrong allocation: pages are not loaded successfully into memory");
f011dcd9:	83 ec 0c             	sub    $0xc,%esp
f011dcdc:	68 b0 cb 12 f0       	push   $0xf012cbb0
f011dce1:	e8 86 32 fe ff       	call   f0100f6c <cprintf>
f011dce6:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[9] != expectedVAs[9])
f011dce9:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011dcef:	89 c2                	mov    %eax,%edx
f011dcf1:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
f011dcf7:	39 c2                	cmp    %eax,%edx
f011dcf9:	74 25                	je     f011dd20 <test_ksbrk+0xa6f>
		{
			correct = 0;
f011dcfb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("9 Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[7], ptr_allocations[7]);
f011dd02:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011dd08:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011dd0e:	83 ec 04             	sub    $0x4,%esp
f011dd11:	52                   	push   %edx
f011dd12:	50                   	push   %eax
f011dd13:	68 f4 cb 12 f0       	push   $0xf012cbf4
f011dd18:	e8 4f 32 fe ff       	call   f0100f6c <cprintf>
f011dd1d:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[9])
f011dd20:	8b 85 00 ff ff ff    	mov    -0x100(%ebp),%eax
f011dd26:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011dd29:	74 21                	je     f011dd4c <test_ksbrk+0xa9b>
		{
			correct = 0;
f011dd2b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("9 Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[7]);
f011dd32:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011dd38:	83 ec 04             	sub    $0x4,%esp
f011dd3b:	50                   	push   %eax
f011dd3c:	ff 75 d0             	pushl  -0x30(%ebp)
f011dd3f:	68 28 cc 12 f0       	push   $0xf012cc28
f011dd44:	e8 23 32 fe ff       	call   f0100f6c <cprintf>
f011dd49:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011dd4c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011dd50:	74 04                	je     f011dd56 <test_ksbrk+0xaa5>
			eval += 10;
f011dd52:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}

	//cprintf("Test kheap sbrk completed. Evaluation = %d%%\n", eval);
	cprintf("[AUTO_GR@DING_PARTIAL]%d\n", eval);
f011dd56:	83 ec 08             	sub    $0x8,%esp
f011dd59:	ff 75 e4             	pushl  -0x1c(%ebp)
f011dd5c:	68 55 cc 12 f0       	push   $0xf012cc55
f011dd61:	e8 06 32 fe ff       	call   f0100f6c <cprintf>
f011dd66:	83 c4 10             	add    $0x10,%esp

	cprintf("=================\n\n");
f011dd69:	83 ec 0c             	sub    $0xc,%esp
f011dd6c:	68 6f cc 12 f0       	push   $0xf012cc6f
f011dd71:	e8 f6 31 fe ff       	call   f0100f6c <cprintf>
f011dd76:	83 c4 10             	add    $0x10,%esp
	return 0;
f011dd79:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011dd7e:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011dd81:	5b                   	pop    %ebx
f011dd82:	5e                   	pop    %esi
f011dd83:	5f                   	pop    %edi
f011dd84:	5d                   	pop    %ebp
f011dd85:	c3                   	ret    

f011dd86 <test_kmalloc_nextfit>:




int test_kmalloc_nextfit()
{
f011dd86:	55                   	push   %ebp
f011dd87:	89 e5                	mov    %esp,%ebp
f011dd89:	81 ec 88 02 00 00    	sub    $0x288,%esp
	panic("not handled yet after applying dynamic allocator with page allocator");
f011dd8f:	83 ec 04             	sub    $0x4,%esp
f011dd92:	68 08 cd 12 f0       	push   $0xf012cd08
f011dd97:	68 76 08 00 00       	push   $0x876
f011dd9c:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011dda1:	e8 74 25 fe ff       	call   f010031a <_panic>

f011dda6 <test_kmalloc_bestfit1>:
	return 1;

}

int test_kmalloc_bestfit1()
{
f011dda6:	55                   	push   %ebp
f011dda7:	89 e5                	mov    %esp,%ebp
f011dda9:	83 ec 58             	sub    $0x58,%esp
	panic("not handled yet after applying dynamic allocator with page allocator");
f011ddac:	83 ec 04             	sub    $0x4,%esp
f011ddaf:	68 08 cd 12 f0       	push   $0xf012cd08
f011ddb4:	68 1c 09 00 00       	push   $0x91c
f011ddb9:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011ddbe:	e8 57 25 fe ff       	call   f010031a <_panic>

f011ddc3 <test_kmalloc_bestfit2>:
	return 1;

}

int test_kmalloc_bestfit2()
{
f011ddc3:	55                   	push   %ebp
f011ddc4:	89 e5                	mov    %esp,%ebp
f011ddc6:	83 ec 58             	sub    $0x58,%esp
	panic("not handled yet after applying dynamic allocator with page allocator");
f011ddc9:	83 ec 04             	sub    $0x4,%esp
f011ddcc:	68 08 cd 12 f0       	push   $0xf012cd08
f011ddd1:	68 c8 09 00 00       	push   $0x9c8
f011ddd6:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011dddb:	e8 3a 25 fe ff       	call   f010031a <_panic>

f011dde0 <test_kmalloc_worstfit>:
	return 1;

}

int test_kmalloc_worstfit()
{
f011dde0:	55                   	push   %ebp
f011dde1:	89 e5                	mov    %esp,%ebp
f011dde3:	81 ec 88 02 00 00    	sub    $0x288,%esp
	panic("not handled yet after applying dynamic allocator with page allocator");
f011dde9:	83 ec 04             	sub    $0x4,%esp
f011ddec:	68 08 cd 12 f0       	push   $0xf012cd08
f011ddf1:	68 6e 0a 00 00       	push   $0xa6e
f011ddf6:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011ddfb:	e8 1a 25 fe ff       	call   f010031a <_panic>

f011de00 <test_kfree>:

	return 1;
}

int test_kfree()
{
f011de00:	55                   	push   %ebp
f011de01:	89 e5                	mov    %esp,%ebp
f011de03:	81 ec 08 01 00 00    	sub    $0x108,%esp
	panic("not handled yet after applying dynamic allocator with page allocator");
f011de09:	83 ec 04             	sub    $0x4,%esp
f011de0c:	68 08 cd 12 f0       	push   $0xf012cd08
f011de11:	68 14 0b 00 00       	push   $0xb14
f011de16:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011de1b:	e8 fa 24 fe ff       	call   f010031a <_panic>

f011de20 <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f011de20:	55                   	push   %ebp
f011de21:	89 e5                	mov    %esp,%ebp
f011de23:	57                   	push   %edi
f011de24:	56                   	push   %esi
f011de25:	53                   	push   %ebx
f011de26:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f011de2c:	a0 9c 9d 17 f0       	mov    0xf0179d9c,%al
f011de31:	84 c0                	test   %al,%al
f011de33:	74 56                	je     f011de8b <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f011de35:	c6 05 9c 9d 17 f0 00 	movb   $0x0,0xf0179d9c
		initFreeFrames = sys_calculate_free_frames() ;
f011de3c:	e8 e6 f8 fe ff       	call   f010d727 <sys_calculate_free_frames>
f011de41:	a3 c8 78 57 f0       	mov    %eax,0xf05778c8
		initFreeDiskFrames = pf_calculate_free_frames() ;
f011de46:	e8 13 67 fe ff       	call   f010455e <pf_calculate_free_frames>
f011de4b:	a3 c4 78 57 f0       	mov    %eax,0xf05778c4
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f011de50:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011de56:	bb 65 ce 12 f0       	mov    $0xf012ce65,%ebx
f011de5b:	ba 11 00 00 00       	mov    $0x11,%edx
f011de60:	89 c7                	mov    %eax,%edi
f011de62:	89 de                	mov    %ebx,%esi
f011de64:	89 d1                	mov    %edx,%ecx
f011de66:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011de68:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f011de6e:	b9 53 00 00 00       	mov    $0x53,%ecx
f011de73:	b0 00                	mov    $0x0,%al
f011de75:	89 d7                	mov    %edx,%edi
f011de77:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f011de79:	83 ec 0c             	sub    $0xc,%esp
f011de7c:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011de82:	50                   	push   %eax
f011de83:	e8 54 40 fe ff       	call   f0101edc <execute_command>
f011de88:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f011de8b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f011de92:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011de99:	a1 e0 24 55 f0       	mov    0xf05524e0,%eax
f011de9e:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011dea1:	eb 2b                	jmp    f011dece <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f011dea3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011dea6:	83 c0 20             	add    $0x20,%eax
f011dea9:	83 ec 08             	sub    $0x8,%esp
f011deac:	68 4d cd 12 f0       	push   $0xf012cd4d
f011deb1:	50                   	push   %eax
f011deb2:	e8 a6 27 00 00       	call   f012065d <strcmp>
f011deb7:	83 c4 10             	add    $0x10,%esp
f011deba:	85 c0                	test   %eax,%eax
f011debc:	75 08                	jne    f011dec6 <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f011debe:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011dec1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f011dec4:	eb 2f                	jmp    f011def5 <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011dec6:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f011decb:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011dece:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ded2:	74 08                	je     f011dedc <test_three_creation_functions+0xbc>
f011ded4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ded7:	8b 40 08             	mov    0x8(%eax),%eax
f011deda:	eb 05                	jmp    f011dee1 <test_three_creation_functions+0xc1>
f011dedc:	b8 00 00 00 00       	mov    $0x0,%eax
f011dee1:	a3 e8 24 55 f0       	mov    %eax,0xf05524e8
f011dee6:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f011deeb:	85 c0                	test   %eax,%eax
f011deed:	75 b4                	jne    f011dea3 <test_three_creation_functions+0x83>
f011deef:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011def3:	75 ae                	jne    f011dea3 <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f011def5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011def8:	8b 80 40 da 01 00    	mov    0x1da40(%eax),%eax
f011defe:	85 c0                	test   %eax,%eax
f011df00:	74 17                	je     f011df19 <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f011df02:	83 ec 04             	sub    $0x4,%esp
f011df05:	68 58 cd 12 f0       	push   $0xf012cd58
f011df0a:	68 f0 0c 00 00       	push   $0xcf0
f011df0f:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011df14:	e8 01 24 fe ff       	call   f010031a <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
#else
		int pagesInWS = env_page_ws_get_size(e);
f011df19:	83 ec 0c             	sub    $0xc,%esp
f011df1c:	ff 75 e4             	pushl  -0x1c(%ebp)
f011df1f:	e8 58 ab fe ff       	call   f0108a7c <env_page_ws_get_size>
f011df24:	83 c4 10             	add    $0x10,%esp
f011df27:	89 45 dc             	mov    %eax,-0x24(%ebp)
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f011df2a:	e8 f8 f7 fe ff       	call   f010d727 <sys_calculate_free_frames>
f011df2f:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f011df32:	e8 27 66 fe ff       	call   f010455e <pf_calculate_free_frames>
f011df37:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011df3a:	a1 c4 78 57 f0       	mov    0xf05778c4,%eax
f011df3f:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f011df42:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011df45:	74 17                	je     f011df5e <test_three_creation_functions+0x13e>
f011df47:	83 ec 04             	sub    $0x4,%esp
f011df4a:	68 60 c7 12 f0       	push   $0xf012c760
f011df4f:	68 fa 0c 00 00       	push   $0xcfa
f011df54:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011df59:	e8 bc 23 fe ff       	call   f010031a <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f011df5e:	a1 c8 78 57 f0       	mov    0xf05778c8,%eax
f011df63:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011df66:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011df69:	83 c2 15             	add    $0x15,%edx
f011df6c:	39 d0                	cmp    %edx,%eax
f011df6e:	74 17                	je     f011df87 <test_three_creation_functions+0x167>
f011df70:	83 ec 04             	sub    $0x4,%esp
f011df73:	68 c8 c7 12 f0       	push   $0xf012c7c8
f011df78:	68 fc 0c 00 00       	push   $0xcfc
f011df7d:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011df82:	e8 93 23 fe ff       	call   f010031a <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f011df87:	83 ec 0c             	sub    $0xc,%esp
f011df8a:	68 00 10 00 00       	push   $0x1000
f011df8f:	e8 40 a8 fe ff       	call   f01087d4 <kmalloc>
f011df94:	83 c4 10             	add    $0x10,%esp
f011df97:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f011df9a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011df9d:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f011dfa2:	74 17                	je     f011dfbb <test_three_creation_functions+0x19b>
f011dfa4:	83 ec 04             	sub    $0x4,%esp
f011dfa7:	68 a8 cd 12 f0       	push   $0xf012cda8
f011dfac:	68 00 0d 00 00       	push   $0xd00
f011dfb1:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011dfb6:	e8 5f 23 fe ff       	call   f010031a <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f011dfbb:	83 ec 0c             	sub    $0xc,%esp
f011dfbe:	68 18 ce 12 f0       	push   $0xf012ce18
f011dfc3:	e8 a4 2f fe ff       	call   f0100f6c <cprintf>
f011dfc8:	83 c4 10             	add    $0x10,%esp

	return 1;
f011dfcb:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011dfd0:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011dfd3:	5b                   	pop    %ebx
f011dfd4:	5e                   	pop    %esi
f011dfd5:	5f                   	pop    %edi
f011dfd6:	5d                   	pop    %ebp
f011dfd7:	c3                   	ret    

f011dfd8 <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f011dfd8:	55                   	push   %ebp
f011dfd9:	89 e5                	mov    %esp,%ebp
f011dfdb:	83 ec 08             	sub    $0x8,%esp
	panic("test not available yet");
f011dfde:	83 ec 04             	sub    $0x4,%esp
f011dfe1:	68 c9 ce 12 f0       	push   $0xf012cec9
f011dfe6:	68 0e 0d 00 00       	push   $0xd0e
f011dfeb:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011dff0:	e8 25 23 fe ff       	call   f010031a <_panic>

f011dff5 <test_kexpand>:

	return 1;

}
int test_kexpand(){
f011dff5:	55                   	push   %ebp
f011dff6:	89 e5                	mov    %esp,%ebp
f011dff8:	83 ec 08             	sub    $0x8,%esp
	panic("test not available yet");
f011dffb:	83 ec 04             	sub    $0x4,%esp
f011dffe:	68 c9 ce 12 f0       	push   $0xf012cec9
f011e003:	68 14 0d 00 00       	push   $0xd14
f011e008:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011e00d:	e8 08 23 fe ff       	call   f010031a <_panic>

f011e012 <test_kshrink>:
	return 1;
}

int test_kshrink(){
f011e012:	55                   	push   %ebp
f011e013:	89 e5                	mov    %esp,%ebp
f011e015:	83 ec 08             	sub    $0x8,%esp
	panic("test not available yet");
f011e018:	83 ec 04             	sub    $0x4,%esp
f011e01b:	68 c9 ce 12 f0       	push   $0xf012cec9
f011e020:	68 19 0d 00 00       	push   $0xd19
f011e025:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011e02a:	e8 eb 22 fe ff       	call   f010031a <_panic>

f011e02f <test_kfreelast>:
	return 1;
}
int test_kfreelast(){
f011e02f:	55                   	push   %ebp
f011e030:	89 e5                	mov    %esp,%ebp
f011e032:	83 ec 08             	sub    $0x8,%esp
	panic("test not available yet");
f011e035:	83 ec 04             	sub    $0x4,%esp
f011e038:	68 c9 ce 12 f0       	push   $0xf012cec9
f011e03d:	68 1d 0d 00 00       	push   $0xd1d
f011e042:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011e047:	e8 ce 22 fe ff       	call   f010031a <_panic>

f011e04c <test_krealloc>:
	return 1;
}

int test_krealloc() {
f011e04c:	55                   	push   %ebp
f011e04d:	89 e5                	mov    %esp,%ebp
f011e04f:	83 ec 08             	sub    $0x8,%esp
	cprintf("==============================================\n");
f011e052:	83 ec 0c             	sub    $0xc,%esp
f011e055:	68 80 be 12 f0       	push   $0xf012be80
f011e05a:	e8 0d 2f fe ff       	call   f0100f6c <cprintf>
f011e05f:	83 c4 10             	add    $0x10,%esp
	cprintf(
f011e062:	83 ec 0c             	sub    $0xc,%esp
f011e065:	68 b0 be 12 f0       	push   $0xf012beb0
f011e06a:	e8 fd 2e fe ff       	call   f0100f6c <cprintf>
f011e06f:	83 c4 10             	add    $0x10,%esp
			"MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
	cprintf("==============================================\n");
f011e072:	83 ec 0c             	sub    $0xc,%esp
f011e075:	68 80 be 12 f0       	push   $0xf012be80
f011e07a:	e8 ed 2e fe ff       	call   f0100f6c <cprintf>
f011e07f:	83 c4 10             	add    $0x10,%esp
	panic("test not available yet");
f011e082:	83 ec 04             	sub    $0x4,%esp
f011e085:	68 c9 ce 12 f0       	push   $0xf012cec9
f011e08a:	68 26 0d 00 00       	push   $0xd26
f011e08f:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011e094:	e8 81 22 fe ff       	call   f010031a <_panic>

f011e099 <test_krealloc_BF>:
	return 0;
}


int test_krealloc_BF() {
f011e099:	55                   	push   %ebp
f011e09a:	89 e5                	mov    %esp,%ebp
f011e09c:	83 ec 08             	sub    $0x8,%esp
	cprintf("==============================================\n");
f011e09f:	83 ec 0c             	sub    $0xc,%esp
f011e0a2:	68 80 be 12 f0       	push   $0xf012be80
f011e0a7:	e8 c0 2e fe ff       	call   f0100f6c <cprintf>
f011e0ac:	83 c4 10             	add    $0x10,%esp
	cprintf(
f011e0af:	83 ec 0c             	sub    $0xc,%esp
f011e0b2:	68 b0 be 12 f0       	push   $0xf012beb0
f011e0b7:	e8 b0 2e fe ff       	call   f0100f6c <cprintf>
f011e0bc:	83 c4 10             	add    $0x10,%esp
			"MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
	cprintf("==============================================\n");
f011e0bf:	83 ec 0c             	sub    $0xc,%esp
f011e0c2:	68 80 be 12 f0       	push   $0xf012be80
f011e0c7:	e8 a0 2e fe ff       	call   f0100f6c <cprintf>
f011e0cc:	83 c4 10             	add    $0x10,%esp
	panic("test not available yet");
f011e0cf:	83 ec 04             	sub    $0x4,%esp
f011e0d2:	68 c9 ce 12 f0       	push   $0xf012cec9
f011e0d7:	68 30 0d 00 00       	push   $0xd30
f011e0dc:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011e0e1:	e8 34 22 fe ff       	call   f010031a <_panic>

f011e0e6 <test_krealloc_FF1>:
	return 0;
}

int test_krealloc_FF1()
{
f011e0e6:	55                   	push   %ebp
f011e0e7:	89 e5                	mov    %esp,%ebp
f011e0e9:	83 ec 08             	sub    $0x8,%esp
	cprintf("===================================================\n");
f011e0ec:	83 ec 0c             	sub    $0xc,%esp
f011e0ef:	68 e0 ce 12 f0       	push   $0xf012cee0
f011e0f4:	e8 73 2e fe ff       	call   f0100f6c <cprintf>
f011e0f9:	83 c4 10             	add    $0x10,%esp
	cprintf("*****NOTE: THIS IS A COMPLETE TEST FOR KREALLOC [BLOCK ALLOCATOR]******\n") ;
f011e0fc:	83 ec 0c             	sub    $0xc,%esp
f011e0ff:	68 18 cf 12 f0       	push   $0xf012cf18
f011e104:	e8 63 2e fe ff       	call   f0100f6c <cprintf>
f011e109:	83 c4 10             	add    $0x10,%esp
	cprintf("===================================================\n");
f011e10c:	83 ec 0c             	sub    $0xc,%esp
f011e10f:	68 e0 ce 12 f0       	push   $0xf012cee0
f011e114:	e8 53 2e fe ff       	call   f0100f6c <cprintf>
f011e119:	83 c4 10             	add    $0x10,%esp

	panic("test not available yet");
f011e11c:	83 ec 04             	sub    $0x4,%esp
f011e11f:	68 c9 ce 12 f0       	push   $0xf012cec9
f011e124:	68 3a 0d 00 00       	push   $0xd3a
f011e129:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011e12e:	e8 e7 21 fe ff       	call   f010031a <_panic>

f011e133 <test_krealloc_FF2>:
	return 0;

}
int test_krealloc_FF2()
{
f011e133:	55                   	push   %ebp
f011e134:	89 e5                	mov    %esp,%ebp
f011e136:	83 ec 08             	sub    $0x8,%esp
	cprintf("===================================================\n");
f011e139:	83 ec 0c             	sub    $0xc,%esp
f011e13c:	68 e0 ce 12 f0       	push   $0xf012cee0
f011e141:	e8 26 2e fe ff       	call   f0100f6c <cprintf>
f011e146:	83 c4 10             	add    $0x10,%esp
	cprintf("*****NOTE: THIS IS A COMPLETE TEST FOR KREALLOC [PAGE ALLOCATOR]******\n") ;
f011e149:	83 ec 0c             	sub    $0xc,%esp
f011e14c:	68 64 cf 12 f0       	push   $0xf012cf64
f011e151:	e8 16 2e fe ff       	call   f0100f6c <cprintf>
f011e156:	83 c4 10             	add    $0x10,%esp
	cprintf("===================================================\n");
f011e159:	83 ec 0c             	sub    $0xc,%esp
f011e15c:	68 e0 ce 12 f0       	push   $0xf012cee0
f011e161:	e8 06 2e fe ff       	call   f0100f6c <cprintf>
f011e166:	83 c4 10             	add    $0x10,%esp

	panic("test not available yet");
f011e169:	83 ec 04             	sub    $0x4,%esp
f011e16c:	68 c9 ce 12 f0       	push   $0xf012cec9
f011e171:	68 44 0d 00 00       	push   $0xd44
f011e176:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011e17b:	e8 9a 21 fe ff       	call   f010031a <_panic>

f011e180 <test_krealloc_FF3>:
	return 0;
}

int test_krealloc_FF3()
{
f011e180:	55                   	push   %ebp
f011e181:	89 e5                	mov    %esp,%ebp
f011e183:	83 ec 08             	sub    $0x8,%esp
	cprintf("===================================================\n");
f011e186:	83 ec 0c             	sub    $0xc,%esp
f011e189:	68 e0 ce 12 f0       	push   $0xf012cee0
f011e18e:	e8 d9 2d fe ff       	call   f0100f6c <cprintf>
f011e193:	83 c4 10             	add    $0x10,%esp
	cprintf("*****NOTE: THIS IS A COMPLETE TEST FOR KREALLOC [SWITCH FROM PAGE ALLOCATOR TO DYNAMIC ALLOCATOR AND VICE VERSA]******\n") ;
f011e196:	83 ec 0c             	sub    $0xc,%esp
f011e199:	68 ac cf 12 f0       	push   $0xf012cfac
f011e19e:	e8 c9 2d fe ff       	call   f0100f6c <cprintf>
f011e1a3:	83 c4 10             	add    $0x10,%esp
	cprintf("===================================================\n");
f011e1a6:	83 ec 0c             	sub    $0xc,%esp
f011e1a9:	68 e0 ce 12 f0       	push   $0xf012cee0
f011e1ae:	e8 b9 2d fe ff       	call   f0100f6c <cprintf>
f011e1b3:	83 c4 10             	add    $0x10,%esp

	panic("test not available yet");
f011e1b6:	83 ec 04             	sub    $0x4,%esp
f011e1b9:	68 c9 ce 12 f0       	push   $0xf012cec9
f011e1be:	68 4e 0d 00 00       	push   $0xd4e
f011e1c3:	68 f2 c5 12 f0       	push   $0xf012c5f2
f011e1c8:	e8 4d 21 fe ff       	call   f010031a <_panic>

f011e1cd <print_order>:
uint8 firstTimeTestBSD = 1;
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f011e1cd:	55                   	push   %ebp
f011e1ce:	89 e5                	mov    %esp,%ebp
f011e1d0:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011e1d3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e1da:	e9 84 00 00 00       	jmp    f011e263 <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f011e1df:	83 ec 08             	sub    $0x8,%esp
f011e1e2:	ff 75 f4             	pushl  -0xc(%ebp)
f011e1e5:	68 24 d0 12 f0       	push   $0xf012d024
f011e1ea:	e8 7d 2d fe ff       	call   f0100f6c <cprintf>
f011e1ef:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011e1f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011e1f9:	eb 4c                	jmp    f011e247 <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f011e1fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e1fe:	89 d0                	mov    %edx,%eax
f011e200:	c1 e0 02             	shl    $0x2,%eax
f011e203:	01 d0                	add    %edx,%eax
f011e205:	c1 e0 03             	shl    $0x3,%eax
f011e208:	89 c2                	mov    %eax,%edx
f011e20a:	8b 45 08             	mov    0x8(%ebp),%eax
f011e20d:	01 c2                	add    %eax,%edx
f011e20f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e212:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011e215:	85 c0                	test   %eax,%eax
f011e217:	74 36                	je     f011e24f <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f011e219:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e21c:	89 d0                	mov    %edx,%eax
f011e21e:	c1 e0 02             	shl    $0x2,%eax
f011e221:	01 d0                	add    %edx,%eax
f011e223:	c1 e0 03             	shl    $0x3,%eax
f011e226:	89 c2                	mov    %eax,%edx
f011e228:	8b 45 08             	mov    0x8(%ebp),%eax
f011e22b:	01 c2                	add    %eax,%edx
f011e22d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e230:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011e233:	83 ec 08             	sub    $0x8,%esp
f011e236:	50                   	push   %eax
f011e237:	68 2c d0 12 f0       	push   $0xf012d02c
f011e23c:	e8 2b 2d fe ff       	call   f0100f6c <cprintf>
f011e241:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011e244:	ff 45 f0             	incl   -0x10(%ebp)
f011e247:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011e24b:	7e ae                	jle    f011e1fb <print_order+0x2e>
f011e24d:	eb 01                	jmp    f011e250 <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f011e24f:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f011e250:	83 ec 0c             	sub    $0xc,%esp
f011e253:	68 31 d0 12 f0       	push   $0xf012d031
f011e258:	e8 0f 2d fe ff       	call   f0100f6c <cprintf>
f011e25d:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011e260:	ff 45 f4             	incl   -0xc(%ebp)
f011e263:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f011e267:	0f 8e 72 ff ff ff    	jle    f011e1df <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f011e26d:	90                   	nop
f011e26e:	c9                   	leave  
f011e26f:	c3                   	ret    

f011e270 <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f011e270:	55                   	push   %ebp
f011e271:	89 e5                	mov    %esp,%ebp
f011e273:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f011e276:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_spinlock(&ProcessQueues.qlock);
f011e27d:	83 ec 0c             	sub    $0xc,%esp
f011e280:	68 60 24 55 f0       	push   $0xf0552460
f011e285:	e8 14 05 ff ff       	call   f010e79e <acquire_spinlock>
f011e28a:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f011e28d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f011e294:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e29b:	8b 55 0c             	mov    0xc(%ebp),%edx
f011e29e:	8b 45 10             	mov    0x10(%ebp),%eax
f011e2a1:	01 d0                	add    %edx,%eax
f011e2a3:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011e2a6:	a1 ec 24 55 f0       	mov    0xf05524ec,%eax
f011e2ab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011e2ae:	a1 e4 24 55 f0       	mov    0xf05524e4,%eax
f011e2b3:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f011e2b6:	ff 75 e8             	pushl  -0x18(%ebp)
f011e2b9:	ff 75 0c             	pushl  0xc(%ebp)
f011e2bc:	ff 75 08             	pushl  0x8(%ebp)
f011e2bf:	68 34 d0 12 f0       	push   $0xf012d034
f011e2c4:	e8 a3 2c fe ff       	call   f0100f6c <cprintf>
f011e2c9:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011e2cc:	eb 34                	jmp    f011e302 <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f011e2ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e2d1:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e2d4:	7d 05                	jge    f011e2db <find_in_range+0x6b>
			{
				i++;
f011e2d6:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f011e2d9:	eb 1e                	jmp    f011e2f9 <find_in_range+0x89>
			}
			if (i >= end)
f011e2db:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e2de:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011e2e1:	7d 29                	jge    f011e30c <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f011e2e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e2e6:	8b 40 10             	mov    0x10(%eax),%eax
f011e2e9:	3b 45 08             	cmp    0x8(%ebp),%eax
f011e2ec:	75 08                	jne    f011e2f6 <find_in_range+0x86>
			{
				ret = i;
f011e2ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e2f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f011e2f4:	eb 17                	jmp    f011e30d <find_in_range+0x9d>
			}
			i++;
f011e2f6:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011e2f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e2fc:	8b 40 0c             	mov    0xc(%eax),%eax
f011e2ff:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e302:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e305:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011e308:	7c c4                	jl     f011e2ce <find_in_range+0x5e>
f011e30a:	eb 01                	jmp    f011e30d <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f011e30c:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011e30d:	83 ec 0c             	sub    $0xc,%esp
f011e310:	68 60 24 55 f0       	push   $0xf0552460
f011e315:	e8 0b 05 ff ff       	call   f010e825 <release_spinlock>
f011e31a:	83 c4 10             	add    $0x10,%esp
	return ret;
f011e31d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011e320:	c9                   	leave  
f011e321:	c3                   	ret    

f011e322 <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f011e322:	55                   	push   %ebp
f011e323:	89 e5                	mov    %esp,%ebp
f011e325:	57                   	push   %edi
f011e326:	56                   	push   %esi
f011e327:	53                   	push   %ebx
f011e328:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011e32b:	a0 9d 9d 17 f0       	mov    0xf0179d9d,%al
f011e330:	84 c0                	test   %al,%al
f011e332:	0f 84 9b 01 00 00    	je     f011e4d3 <test_bsd_nice_0+0x1b1>
	{
		firstTimeTestBSD = 0;
f011e338:	c6 05 9d 9d 17 f0 00 	movb   $0x0,0xf0179d9d
		int nice_values[] = {-10, -5, 0, 5, 10};
f011e33f:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011e342:	bb ac d1 12 f0       	mov    $0xf012d1ac,%ebx
f011e347:	ba 05 00 00 00       	mov    $0x5,%edx
f011e34c:	89 c7                	mov    %eax,%edi
f011e34e:	89 de                	mov    %ebx,%esi
f011e350:	89 d1                	mov    %edx,%ecx
f011e352:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011e354:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011e35b:	e9 44 01 00 00       	jmp    f011e4a4 <test_bsd_nice_0+0x182>
		{
			struct Env *env = env_create("bsd_fib", 500, 0, 0);
f011e360:	6a 00                	push   $0x0
f011e362:	6a 00                	push   $0x0
f011e364:	68 f4 01 00 00       	push   $0x1f4
f011e369:	68 65 d0 12 f0       	push   $0xf012d065
f011e36e:	e8 1b b4 fe ff       	call   f010978e <env_create>
f011e373:	83 c4 10             	add    $0x10,%esp
f011e376:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011e379:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e37c:	b9 05 00 00 00       	mov    $0x5,%ecx
f011e381:	99                   	cltd   
f011e382:	f7 f9                	idiv   %ecx
f011e384:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011e387:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e38a:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011e38e:	83 ec 08             	sub    $0x8,%esp
f011e391:	50                   	push   %eax
f011e392:	ff 75 d4             	pushl  -0x2c(%ebp)
f011e395:	e8 2b 80 fe ff       	call   f01063c5 <env_set_nice>
f011e39a:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011e39d:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011e3a1:	75 14                	jne    f011e3b7 <test_bsd_nice_0+0x95>
				panic("Loading programs failed\n");
f011e3a3:	83 ec 04             	sub    $0x4,%esp
f011e3a6:	68 6d d0 12 f0       	push   $0xf012d06d
f011e3ab:	6a 53                	push   $0x53
f011e3ad:	68 86 d0 12 f0       	push   $0xf012d086
f011e3b2:	e8 63 1f fe ff       	call   f010031a <_panic>
			if (env->page_WS_max_size != 500)
f011e3b7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011e3ba:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011e3c0:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011e3c5:	74 14                	je     f011e3db <test_bsd_nice_0+0xb9>
				panic("The program working set size is not correct\n");
f011e3c7:	83 ec 04             	sub    $0x4,%esp
f011e3ca:	68 a4 d0 12 f0       	push   $0xf012d0a4
f011e3cf:	6a 55                	push   $0x55
f011e3d1:	68 86 d0 12 f0       	push   $0xf012d086
f011e3d6:	e8 3f 1f fe ff       	call   f010031a <_panic>

			switch (nice_values[nice_index])
f011e3db:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e3de:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011e3e2:	83 c0 0a             	add    $0xa,%eax
f011e3e5:	83 f8 14             	cmp    $0x14,%eax
f011e3e8:	0f 87 a5 00 00 00    	ja     f011e493 <test_bsd_nice_0+0x171>
f011e3ee:	8b 04 85 c0 d1 12 f0 	mov    -0xfed2e40(,%eax,4),%eax
f011e3f5:	ff e0                	jmp    *%eax
			{
			case -10:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011e3f7:	a1 9c 22 55 f0       	mov    0xf055229c,%eax
f011e3fc:	8d 50 01             	lea    0x1(%eax),%edx
f011e3ff:	89 15 9c 22 55 f0    	mov    %edx,0xf055229c
f011e405:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e408:	8b 52 10             	mov    0x10(%edx),%edx
f011e40b:	89 14 85 e0 78 57 f0 	mov    %edx,-0xfa88720(,%eax,4)
				break;
f011e412:	eb 7f                	jmp    f011e493 <test_bsd_nice_0+0x171>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011e414:	a1 a0 22 55 f0       	mov    0xf05522a0,%eax
f011e419:	8d 50 01             	lea    0x1(%eax),%edx
f011e41c:	89 15 a0 22 55 f0    	mov    %edx,0xf05522a0
f011e422:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e425:	8b 52 10             	mov    0x10(%edx),%edx
f011e428:	83 c0 0a             	add    $0xa,%eax
f011e42b:	89 14 85 e0 78 57 f0 	mov    %edx,-0xfa88720(,%eax,4)
				break;
f011e432:	eb 5f                	jmp    f011e493 <test_bsd_nice_0+0x171>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011e434:	a1 a4 22 55 f0       	mov    0xf05522a4,%eax
f011e439:	8d 50 01             	lea    0x1(%eax),%edx
f011e43c:	89 15 a4 22 55 f0    	mov    %edx,0xf05522a4
f011e442:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e445:	8b 52 10             	mov    0x10(%edx),%edx
f011e448:	83 c0 14             	add    $0x14,%eax
f011e44b:	89 14 85 e0 78 57 f0 	mov    %edx,-0xfa88720(,%eax,4)
				break;
f011e452:	eb 3f                	jmp    f011e493 <test_bsd_nice_0+0x171>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011e454:	a1 a8 22 55 f0       	mov    0xf05522a8,%eax
f011e459:	8d 50 01             	lea    0x1(%eax),%edx
f011e45c:	89 15 a8 22 55 f0    	mov    %edx,0xf05522a8
f011e462:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e465:	8b 52 10             	mov    0x10(%edx),%edx
f011e468:	83 c0 1e             	add    $0x1e,%eax
f011e46b:	89 14 85 e0 78 57 f0 	mov    %edx,-0xfa88720(,%eax,4)
				break;
f011e472:	eb 1f                	jmp    f011e493 <test_bsd_nice_0+0x171>
			case 10:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011e474:	a1 ac 22 55 f0       	mov    0xf05522ac,%eax
f011e479:	8d 50 01             	lea    0x1(%eax),%edx
f011e47c:	89 15 ac 22 55 f0    	mov    %edx,0xf05522ac
f011e482:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e485:	8b 52 10             	mov    0x10(%edx),%edx
f011e488:	83 c0 28             	add    $0x28,%eax
f011e48b:	89 14 85 e0 78 57 f0 	mov    %edx,-0xfa88720(,%eax,4)
				break;
f011e492:	90                   	nop
			}
			sched_new_env(env);
f011e493:	83 ec 0c             	sub    $0xc,%esp
f011e496:	ff 75 d4             	pushl  -0x2c(%ebp)
f011e499:	e8 25 6f fe ff       	call   f01053c3 <sched_new_env>
f011e49e:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTestBSD)
	{
		firstTimeTestBSD = 0;
		int nice_values[] = {-10, -5, 0, 5, 10};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011e4a1:	ff 45 e4             	incl   -0x1c(%ebp)
f011e4a4:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f011e4a8:	0f 8e b2 fe ff ff    	jle    f011e360 <test_bsd_nice_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011e4ae:	83 ec 0c             	sub    $0xc,%esp
f011e4b1:	68 d4 d0 12 f0       	push   $0xf012d0d4
f011e4b6:	e8 b1 2a fe ff       	call   f0100f6c <cprintf>
f011e4bb:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011e4be:	83 ec 0c             	sub    $0xc,%esp
f011e4c1:	68 23 d1 12 f0       	push   $0xf012d123
f011e4c6:	e8 11 3a fe ff       	call   f0101edc <execute_command>
f011e4cb:	83 c4 10             	add    $0x10,%esp
f011e4ce:	e9 c0 00 00 00       	jmp    f011e593 <test_bsd_nice_0+0x271>
	}
	else
	{
		cprintf("> Checking...\n");
f011e4d3:	83 ec 0c             	sub    $0xc,%esp
f011e4d6:	68 2a d1 12 f0       	push   $0xf012d12a
f011e4db:	e8 8c 2a fe ff       	call   f0100f6c <cprintf>
f011e4e0:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011e4e3:	e8 57 76 fe ff       	call   f0105b3f <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011e4e8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011e4ef:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011e4f6:	e9 87 00 00 00       	jmp    f011e582 <test_bsd_nice_0+0x260>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011e4fb:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011e502:	eb 52                	jmp    f011e556 <test_bsd_nice_0+0x234>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011e504:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e507:	8b 14 85 9c 22 55 f0 	mov    -0xfaadd64(,%eax,4),%edx
f011e50e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011e511:	89 c8                	mov    %ecx,%eax
f011e513:	c1 e0 02             	shl    $0x2,%eax
f011e516:	01 c8                	add    %ecx,%eax
f011e518:	01 c0                	add    %eax,%eax
f011e51a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011e51d:	01 c8                	add    %ecx,%eax
f011e51f:	8b 04 85 e0 78 57 f0 	mov    -0xfa88720(,%eax,4),%eax
f011e526:	83 ec 04             	sub    $0x4,%esp
f011e529:	52                   	push   %edx
f011e52a:	ff 75 e0             	pushl  -0x20(%ebp)
f011e52d:	50                   	push   %eax
f011e52e:	e8 3d fd ff ff       	call   f011e270 <find_in_range>
f011e533:	83 c4 10             	add    $0x10,%esp
f011e536:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011e539:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011e53d:	75 14                	jne    f011e553 <test_bsd_nice_0+0x231>
					panic("The programs' order of finishing is not correct\n");
f011e53f:	83 ec 04             	sub    $0x4,%esp
f011e542:	68 3c d1 12 f0       	push   $0xf012d13c
f011e547:	6a 7b                	push   $0x7b
f011e549:	68 86 d0 12 f0       	push   $0xf012d086
f011e54e:	e8 c7 1d fe ff       	call   f010031a <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011e553:	ff 45 d8             	incl   -0x28(%ebp)
f011e556:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011e559:	89 d0                	mov    %edx,%eax
f011e55b:	c1 e0 02             	shl    $0x2,%eax
f011e55e:	01 d0                	add    %edx,%eax
f011e560:	01 c0                	add    %eax,%eax
f011e562:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011e565:	01 d0                	add    %edx,%eax
f011e567:	8b 04 85 e0 78 57 f0 	mov    -0xfa88720(,%eax,4),%eax
f011e56e:	85 c0                	test   %eax,%eax
f011e570:	75 92                	jne    f011e504 <test_bsd_nice_0+0x1e2>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011e572:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e575:	8b 04 85 9c 22 55 f0 	mov    -0xfaadd64(,%eax,4),%eax
f011e57c:	01 45 e0             	add    %eax,-0x20(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011e57f:	ff 45 dc             	incl   -0x24(%ebp)
f011e582:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011e586:	0f 8e 6f ff ff ff    	jle    f011e4fb <test_bsd_nice_0+0x1d9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011e58c:	c6 05 9d 9d 17 f0 00 	movb   $0x0,0xf0179d9d
	}
	cprintf("\nCongratulations!! test_bsd_nice_0 completed successfully.\n");
f011e593:	83 ec 0c             	sub    $0xc,%esp
f011e596:	68 70 d1 12 f0       	push   $0xf012d170
f011e59b:	e8 cc 29 fe ff       	call   f0100f6c <cprintf>
f011e5a0:	83 c4 10             	add    $0x10,%esp
}
f011e5a3:	90                   	nop
f011e5a4:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011e5a7:	5b                   	pop    %ebx
f011e5a8:	5e                   	pop    %esi
f011e5a9:	5f                   	pop    %edi
f011e5aa:	5d                   	pop    %ebp
f011e5ab:	c3                   	ret    

f011e5ac <test_bsd_nice_1>:


void test_bsd_nice_1()
{
f011e5ac:	55                   	push   %ebp
f011e5ad:	89 e5                	mov    %esp,%ebp
f011e5af:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTestBSD)
f011e5b2:	a0 9d 9d 17 f0       	mov    0xf0179d9d,%al
f011e5b7:	84 c0                	test   %al,%al
f011e5b9:	0f 84 50 01 00 00    	je     f011e70f <test_bsd_nice_1+0x163>
	{
		firstTimeTestBSD = 0;
f011e5bf:	c6 05 9d 9d 17 f0 00 	movb   $0x0,0xf0179d9d
		struct Env *fibEnv = env_create("bsd_fib", 500, 0, 0);
f011e5c6:	6a 00                	push   $0x0
f011e5c8:	6a 00                	push   $0x0
f011e5ca:	68 f4 01 00 00       	push   $0x1f4
f011e5cf:	68 65 d0 12 f0       	push   $0xf012d065
f011e5d4:	e8 b5 b1 fe ff       	call   f010978e <env_create>
f011e5d9:	83 c4 10             	add    $0x10,%esp
f011e5dc:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibposnEnv = env_create("bsd_fib_posn", 500, 0, 0);
f011e5df:	6a 00                	push   $0x0
f011e5e1:	6a 00                	push   $0x0
f011e5e3:	68 f4 01 00 00       	push   $0x1f4
f011e5e8:	68 14 d2 12 f0       	push   $0xf012d214
f011e5ed:	e8 9c b1 fe ff       	call   f010978e <env_create>
f011e5f2:	83 c4 10             	add    $0x10,%esp
f011e5f5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibnegnEnv = env_create("bsd_fib_negn", 500, 0, 0);
f011e5f8:	6a 00                	push   $0x0
f011e5fa:	6a 00                	push   $0x0
f011e5fc:	68 f4 01 00 00       	push   $0x1f4
f011e601:	68 21 d2 12 f0       	push   $0xf012d221
f011e606:	e8 83 b1 fe ff       	call   f010978e <env_create>
f011e60b:	83 c4 10             	add    $0x10,%esp
f011e60e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (fibEnv == NULL || fibposnEnv == NULL || fibnegnEnv == NULL)
f011e611:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e615:	74 0c                	je     f011e623 <test_bsd_nice_1+0x77>
f011e617:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011e61b:	74 06                	je     f011e623 <test_bsd_nice_1+0x77>
f011e61d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e621:	75 17                	jne    f011e63a <test_bsd_nice_1+0x8e>
			panic("Loading programs failed\n");
f011e623:	83 ec 04             	sub    $0x4,%esp
f011e626:	68 6d d0 12 f0       	push   $0xf012d06d
f011e62b:	68 8e 00 00 00       	push   $0x8e
f011e630:	68 86 d0 12 f0       	push   $0xf012d086
f011e635:	e8 e0 1c fe ff       	call   f010031a <_panic>
		if (fibEnv->page_WS_max_size != 500 || fibposnEnv->page_WS_max_size != 500 || fibnegnEnv->page_WS_max_size != 500)
f011e63a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e63d:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011e643:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011e648:	75 20                	jne    f011e66a <test_bsd_nice_1+0xbe>
f011e64a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e64d:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011e653:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011e658:	75 10                	jne    f011e66a <test_bsd_nice_1+0xbe>
f011e65a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e65d:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011e663:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011e668:	74 35                	je     f011e69f <test_bsd_nice_1+0xf3>
			panic("The programs should be initially loaded with the given working set size. fib: %d, fibposn: %d, fibnegn: %d\n", fibEnv->page_WS_max_size, fibposnEnv->page_WS_max_size, fibnegnEnv->page_WS_max_size);
f011e66a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e66d:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
f011e673:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e676:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f011e67c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e67f:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011e685:	83 ec 08             	sub    $0x8,%esp
f011e688:	51                   	push   %ecx
f011e689:	52                   	push   %edx
f011e68a:	50                   	push   %eax
f011e68b:	68 30 d2 12 f0       	push   $0xf012d230
f011e690:	68 90 00 00 00       	push   $0x90
f011e695:	68 86 d0 12 f0       	push   $0xf012d086
f011e69a:	e8 7b 1c fe ff       	call   f010031a <_panic>
		sched_new_env(fibEnv);
f011e69f:	83 ec 0c             	sub    $0xc,%esp
f011e6a2:	ff 75 ec             	pushl  -0x14(%ebp)
f011e6a5:	e8 19 6d fe ff       	call   f01053c3 <sched_new_env>
f011e6aa:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibposnEnv);
f011e6ad:	83 ec 0c             	sub    $0xc,%esp
f011e6b0:	ff 75 e8             	pushl  -0x18(%ebp)
f011e6b3:	e8 0b 6d fe ff       	call   f01053c3 <sched_new_env>
f011e6b8:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibnegnEnv);
f011e6bb:	83 ec 0c             	sub    $0xc,%esp
f011e6be:	ff 75 e4             	pushl  -0x1c(%ebp)
f011e6c1:	e8 fd 6c fe ff       	call   f01053c3 <sched_new_env>
f011e6c6:	83 c4 10             	add    $0x10,%esp
		prog_orders[0][0] = fibnegnEnv->env_id;
f011e6c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e6cc:	8b 40 10             	mov    0x10(%eax),%eax
f011e6cf:	a3 e0 78 57 f0       	mov    %eax,0xf05778e0
		prog_orders[1][0] = fibEnv->env_id;
f011e6d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e6d7:	8b 40 10             	mov    0x10(%eax),%eax
f011e6da:	a3 08 79 57 f0       	mov    %eax,0xf0577908
		prog_orders[2][0] = fibposnEnv->env_id;
f011e6df:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e6e2:	8b 40 10             	mov    0x10(%eax),%eax
f011e6e5:	a3 30 79 57 f0       	mov    %eax,0xf0577930
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011e6ea:	83 ec 0c             	sub    $0xc,%esp
f011e6ed:	68 d4 d0 12 f0       	push   $0xf012d0d4
f011e6f2:	e8 75 28 fe ff       	call   f0100f6c <cprintf>
f011e6f7:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011e6fa:	83 ec 0c             	sub    $0xc,%esp
f011e6fd:	68 23 d1 12 f0       	push   $0xf012d123
f011e702:	e8 d5 37 fe ff       	call   f0101edc <execute_command>
f011e707:	83 c4 10             	add    $0x10,%esp
f011e70a:	e9 9e 00 00 00       	jmp    f011e7ad <test_bsd_nice_1+0x201>
	}
	else
	{
		cprintf("> Checking...\n");
f011e70f:	83 ec 0c             	sub    $0xc,%esp
f011e712:	68 2a d1 12 f0       	push   $0xf012d12a
f011e717:	e8 50 28 fe ff       	call   f0100f6c <cprintf>
f011e71c:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011e71f:	e8 1b 74 fe ff       	call   f0105b3f <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f011e724:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f011e72b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
f011e732:	83 ec 0c             	sub    $0xc,%esp
f011e735:	68 60 24 55 f0       	push   $0xf0552460
f011e73a:	e8 5f 00 ff ff       	call   f010e79e <acquire_spinlock>
f011e73f:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011e742:	a1 ec 24 55 f0       	mov    0xf05524ec,%eax
f011e747:	89 45 e0             	mov    %eax,-0x20(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011e74a:	a1 e4 24 55 f0       	mov    0xf05524e4,%eax
f011e74f:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011e752:	eb 41                	jmp    f011e795 <test_bsd_nice_1+0x1e9>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				//cprintf("%s - id=%d, priority=%d, nice=%d\n", env->prog_name, env->env_id, env->priority, env->nice);
				if (prog_orders[i][0] != env->env_id)
f011e754:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e757:	89 d0                	mov    %edx,%eax
f011e759:	c1 e0 02             	shl    $0x2,%eax
f011e75c:	01 d0                	add    %edx,%eax
f011e75e:	c1 e0 03             	shl    $0x3,%eax
f011e761:	05 e0 78 57 f0       	add    $0xf05778e0,%eax
f011e766:	8b 10                	mov    (%eax),%edx
f011e768:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e76b:	8b 40 10             	mov    0x10(%eax),%eax
f011e76e:	39 c2                	cmp    %eax,%edx
f011e770:	74 17                	je     f011e789 <test_bsd_nice_1+0x1dd>
					panic("The programs' order of finishing is not correct\n");
f011e772:	83 ec 04             	sub    $0x4,%esp
f011e775:	68 3c d1 12 f0       	push   $0xf012d13c
f011e77a:	68 ab 00 00 00       	push   $0xab
f011e77f:	68 86 d0 12 f0       	push   $0xf012d086
f011e784:	e8 91 1b fe ff       	call   f010031a <_panic>
				i++;
f011e789:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011e78c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e78f:	8b 40 0c             	mov    0xc(%eax),%eax
f011e792:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e795:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e798:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011e79b:	7c b7                	jl     f011e754 <test_bsd_nice_1+0x1a8>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011e79d:	83 ec 0c             	sub    $0xc,%esp
f011e7a0:	68 60 24 55 f0       	push   $0xf0552460
f011e7a5:	e8 7b 00 ff ff       	call   f010e825 <release_spinlock>
f011e7aa:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_bsd_nice_1 completed successfully.\n");
f011e7ad:	83 ec 0c             	sub    $0xc,%esp
f011e7b0:	68 9c d2 12 f0       	push   $0xf012d29c
f011e7b5:	e8 b2 27 fe ff       	call   f0100f6c <cprintf>
f011e7ba:	83 c4 10             	add    $0x10,%esp
}
f011e7bd:	90                   	nop
f011e7be:	c9                   	leave  
f011e7bf:	c3                   	ret    

f011e7c0 <test_bsd_nice_2>:

void test_bsd_nice_2()
{
f011e7c0:	55                   	push   %ebp
f011e7c1:	89 e5                	mov    %esp,%ebp
f011e7c3:	57                   	push   %edi
f011e7c4:	56                   	push   %esi
f011e7c5:	53                   	push   %ebx
f011e7c6:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011e7c9:	a0 9d 9d 17 f0       	mov    0xf0179d9d,%al
f011e7ce:	84 c0                	test   %al,%al
f011e7d0:	0f 84 ae 01 00 00    	je     f011e984 <test_bsd_nice_2+0x1c4>
	{
		chksch(1);
f011e7d6:	83 ec 0c             	sub    $0xc,%esp
f011e7d9:	6a 01                	push   $0x1
f011e7db:	e8 ce 0e 00 00       	call   f011f6ae <chksch>
f011e7e0:	83 c4 10             	add    $0x10,%esp
		firstTimeTestBSD = 0;
f011e7e3:	c6 05 9d 9d 17 f0 00 	movb   $0x0,0xf0179d9d
		int nice_values[] = {15, 5, 0, -5, -15};
f011e7ea:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011e7ed:	bb 20 d3 12 f0       	mov    $0xf012d320,%ebx
f011e7f2:	ba 05 00 00 00       	mov    $0x5,%edx
f011e7f7:	89 c7                	mov    %eax,%edi
f011e7f9:	89 de                	mov    %ebx,%esi
f011e7fb:	89 d1                	mov    %edx,%ecx
f011e7fd:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011e7ff:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011e806:	e9 4a 01 00 00       	jmp    f011e955 <test_bsd_nice_2+0x195>
		{
			struct Env *env = env_create("bsd_matops", 10000, 0, 0);
f011e80b:	6a 00                	push   $0x0
f011e80d:	6a 00                	push   $0x0
f011e80f:	68 10 27 00 00       	push   $0x2710
f011e814:	68 d8 d2 12 f0       	push   $0xf012d2d8
f011e819:	e8 70 af fe ff       	call   f010978e <env_create>
f011e81e:	83 c4 10             	add    $0x10,%esp
f011e821:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011e824:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e827:	b9 05 00 00 00       	mov    $0x5,%ecx
f011e82c:	99                   	cltd   
f011e82d:	f7 f9                	idiv   %ecx
f011e82f:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011e832:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e835:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011e839:	83 ec 08             	sub    $0x8,%esp
f011e83c:	50                   	push   %eax
f011e83d:	ff 75 d4             	pushl  -0x2c(%ebp)
f011e840:	e8 80 7b fe ff       	call   f01063c5 <env_set_nice>
f011e845:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011e848:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011e84c:	75 17                	jne    f011e865 <test_bsd_nice_2+0xa5>
				panic("Loading programs failed\n");
f011e84e:	83 ec 04             	sub    $0x4,%esp
f011e851:	68 6d d0 12 f0       	push   $0xf012d06d
f011e856:	68 c1 00 00 00       	push   $0xc1
f011e85b:	68 86 d0 12 f0       	push   $0xf012d086
f011e860:	e8 b5 1a fe ff       	call   f010031a <_panic>
			if (env->page_WS_max_size != 10000)
f011e865:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011e868:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011e86e:	3d 10 27 00 00       	cmp    $0x2710,%eax
f011e873:	74 17                	je     f011e88c <test_bsd_nice_2+0xcc>
				panic("The program working set size is not correct\n");
f011e875:	83 ec 04             	sub    $0x4,%esp
f011e878:	68 a4 d0 12 f0       	push   $0xf012d0a4
f011e87d:	68 c3 00 00 00       	push   $0xc3
f011e882:	68 86 d0 12 f0       	push   $0xf012d086
f011e887:	e8 8e 1a fe ff       	call   f010031a <_panic>

			switch (nice_values[nice_index])
f011e88c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e88f:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011e893:	83 c0 0f             	add    $0xf,%eax
f011e896:	83 f8 1e             	cmp    $0x1e,%eax
f011e899:	0f 87 a5 00 00 00    	ja     f011e944 <test_bsd_nice_2+0x184>
f011e89f:	8b 04 85 34 d3 12 f0 	mov    -0xfed2ccc(,%eax,4),%eax
f011e8a6:	ff e0                	jmp    *%eax
			{
			case -15:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011e8a8:	a1 9c 22 55 f0       	mov    0xf055229c,%eax
f011e8ad:	8d 50 01             	lea    0x1(%eax),%edx
f011e8b0:	89 15 9c 22 55 f0    	mov    %edx,0xf055229c
f011e8b6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e8b9:	8b 52 10             	mov    0x10(%edx),%edx
f011e8bc:	89 14 85 e0 78 57 f0 	mov    %edx,-0xfa88720(,%eax,4)
				break;
f011e8c3:	eb 7f                	jmp    f011e944 <test_bsd_nice_2+0x184>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011e8c5:	a1 a0 22 55 f0       	mov    0xf05522a0,%eax
f011e8ca:	8d 50 01             	lea    0x1(%eax),%edx
f011e8cd:	89 15 a0 22 55 f0    	mov    %edx,0xf05522a0
f011e8d3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e8d6:	8b 52 10             	mov    0x10(%edx),%edx
f011e8d9:	83 c0 0a             	add    $0xa,%eax
f011e8dc:	89 14 85 e0 78 57 f0 	mov    %edx,-0xfa88720(,%eax,4)
				break;
f011e8e3:	eb 5f                	jmp    f011e944 <test_bsd_nice_2+0x184>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011e8e5:	a1 a4 22 55 f0       	mov    0xf05522a4,%eax
f011e8ea:	8d 50 01             	lea    0x1(%eax),%edx
f011e8ed:	89 15 a4 22 55 f0    	mov    %edx,0xf05522a4
f011e8f3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e8f6:	8b 52 10             	mov    0x10(%edx),%edx
f011e8f9:	83 c0 14             	add    $0x14,%eax
f011e8fc:	89 14 85 e0 78 57 f0 	mov    %edx,-0xfa88720(,%eax,4)
				break;
f011e903:	eb 3f                	jmp    f011e944 <test_bsd_nice_2+0x184>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011e905:	a1 a8 22 55 f0       	mov    0xf05522a8,%eax
f011e90a:	8d 50 01             	lea    0x1(%eax),%edx
f011e90d:	89 15 a8 22 55 f0    	mov    %edx,0xf05522a8
f011e913:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e916:	8b 52 10             	mov    0x10(%edx),%edx
f011e919:	83 c0 1e             	add    $0x1e,%eax
f011e91c:	89 14 85 e0 78 57 f0 	mov    %edx,-0xfa88720(,%eax,4)
				break;
f011e923:	eb 1f                	jmp    f011e944 <test_bsd_nice_2+0x184>
			case 15:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011e925:	a1 ac 22 55 f0       	mov    0xf05522ac,%eax
f011e92a:	8d 50 01             	lea    0x1(%eax),%edx
f011e92d:	89 15 ac 22 55 f0    	mov    %edx,0xf05522ac
f011e933:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e936:	8b 52 10             	mov    0x10(%edx),%edx
f011e939:	83 c0 28             	add    $0x28,%eax
f011e93c:	89 14 85 e0 78 57 f0 	mov    %edx,-0xfa88720(,%eax,4)
				break;
f011e943:	90                   	nop
			}
			sched_new_env(env);
f011e944:	83 ec 0c             	sub    $0xc,%esp
f011e947:	ff 75 d4             	pushl  -0x2c(%ebp)
f011e94a:	e8 74 6a fe ff       	call   f01053c3 <sched_new_env>
f011e94f:	83 c4 10             	add    $0x10,%esp
	if (firstTimeTestBSD)
	{
		chksch(1);
		firstTimeTestBSD = 0;
		int nice_values[] = {15, 5, 0, -5, -15};
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011e952:	ff 45 e4             	incl   -0x1c(%ebp)
f011e955:	83 7d e4 09          	cmpl   $0x9,-0x1c(%ebp)
f011e959:	0f 8e ac fe ff ff    	jle    f011e80b <test_bsd_nice_2+0x4b>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011e95f:	83 ec 0c             	sub    $0xc,%esp
f011e962:	68 d4 d0 12 f0       	push   $0xf012d0d4
f011e967:	e8 00 26 fe ff       	call   f0100f6c <cprintf>
f011e96c:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011e96f:	83 ec 0c             	sub    $0xc,%esp
f011e972:	68 23 d1 12 f0       	push   $0xf012d123
f011e977:	e8 60 35 fe ff       	call   f0101edc <execute_command>
f011e97c:	83 c4 10             	add    $0x10,%esp
f011e97f:	e9 d0 00 00 00       	jmp    f011ea54 <test_bsd_nice_2+0x294>
	}
	else
	{
		chksch(0);
f011e984:	83 ec 0c             	sub    $0xc,%esp
f011e987:	6a 00                	push   $0x0
f011e989:	e8 20 0d 00 00       	call   f011f6ae <chksch>
f011e98e:	83 c4 10             	add    $0x10,%esp
		cprintf("> Checking...\n");
f011e991:	83 ec 0c             	sub    $0xc,%esp
f011e994:	68 2a d1 12 f0       	push   $0xf012d12a
f011e999:	e8 ce 25 fe ff       	call   f0100f6c <cprintf>
f011e99e:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011e9a1:	e8 99 71 fe ff       	call   f0105b3f <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011e9a6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011e9ad:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011e9b4:	e9 8a 00 00 00       	jmp    f011ea43 <test_bsd_nice_2+0x283>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011e9b9:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011e9c0:	eb 55                	jmp    f011ea17 <test_bsd_nice_2+0x257>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011e9c2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e9c5:	8b 14 85 9c 22 55 f0 	mov    -0xfaadd64(,%eax,4),%edx
f011e9cc:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011e9cf:	89 c8                	mov    %ecx,%eax
f011e9d1:	c1 e0 02             	shl    $0x2,%eax
f011e9d4:	01 c8                	add    %ecx,%eax
f011e9d6:	01 c0                	add    %eax,%eax
f011e9d8:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011e9db:	01 c8                	add    %ecx,%eax
f011e9dd:	8b 04 85 e0 78 57 f0 	mov    -0xfa88720(,%eax,4),%eax
f011e9e4:	83 ec 04             	sub    $0x4,%esp
f011e9e7:	52                   	push   %edx
f011e9e8:	ff 75 e0             	pushl  -0x20(%ebp)
f011e9eb:	50                   	push   %eax
f011e9ec:	e8 7f f8 ff ff       	call   f011e270 <find_in_range>
f011e9f1:	83 c4 10             	add    $0x10,%esp
f011e9f4:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011e9f7:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011e9fb:	75 17                	jne    f011ea14 <test_bsd_nice_2+0x254>
					panic("The programs' order of finishing is not correct\n");
f011e9fd:	83 ec 04             	sub    $0x4,%esp
f011ea00:	68 3c d1 12 f0       	push   $0xf012d13c
f011ea05:	68 ea 00 00 00       	push   $0xea
f011ea0a:	68 86 d0 12 f0       	push   $0xf012d086
f011ea0f:	e8 06 19 fe ff       	call   f010031a <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011ea14:	ff 45 d8             	incl   -0x28(%ebp)
f011ea17:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011ea1a:	89 d0                	mov    %edx,%eax
f011ea1c:	c1 e0 02             	shl    $0x2,%eax
f011ea1f:	01 d0                	add    %edx,%eax
f011ea21:	01 c0                	add    %eax,%eax
f011ea23:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011ea26:	01 d0                	add    %edx,%eax
f011ea28:	8b 04 85 e0 78 57 f0 	mov    -0xfa88720(,%eax,4),%eax
f011ea2f:	85 c0                	test   %eax,%eax
f011ea31:	75 8f                	jne    f011e9c2 <test_bsd_nice_2+0x202>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011ea33:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ea36:	8b 04 85 9c 22 55 f0 	mov    -0xfaadd64(,%eax,4),%eax
f011ea3d:	01 45 e0             	add    %eax,-0x20(%ebp)
		chksch(0);
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011ea40:	ff 45 dc             	incl   -0x24(%ebp)
f011ea43:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011ea47:	0f 8e 6c ff ff ff    	jle    f011e9b9 <test_bsd_nice_2+0x1f9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011ea4d:	c6 05 9d 9d 17 f0 00 	movb   $0x0,0xf0179d9d
	}
	cprintf("\nCongratulations!! test_bsd_nice_2 completed successfully.\n");
f011ea54:	83 ec 0c             	sub    $0xc,%esp
f011ea57:	68 e4 d2 12 f0       	push   $0xf012d2e4
f011ea5c:	e8 0b 25 fe ff       	call   f0100f6c <cprintf>
f011ea61:	83 c4 10             	add    $0x10,%esp
}
f011ea64:	90                   	nop
f011ea65:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011ea68:	5b                   	pop    %ebx
f011ea69:	5e                   	pop    %esi
f011ea6a:	5f                   	pop    %edi
f011ea6b:	5d                   	pop    %ebp
f011ea6c:	c3                   	ret    

f011ea6d <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f011ea6d:	55                   	push   %ebp
f011ea6e:	89 e5                	mov    %esp,%ebp
f011ea70:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f011ea73:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ea76:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f011ea79:	8b 45 08             	mov    0x8(%ebp),%eax
f011ea7c:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011ea7f:	89 10                	mov    %edx,(%eax)
}
f011ea81:	8b 45 08             	mov    0x8(%ebp),%eax
f011ea84:	c9                   	leave  
f011ea85:	c2 04 00             	ret    $0x4

f011ea88 <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f011ea88:	55                   	push   %ebp
f011ea89:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f011ea8b:	8b 45 08             	mov    0x8(%ebp),%eax
f011ea8e:	85 c0                	test   %eax,%eax
f011ea90:	78 16                	js     f011eaa8 <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f011ea92:	8b 45 08             	mov    0x8(%ebp),%eax
f011ea95:	05 00 20 00 00       	add    $0x2000,%eax
f011ea9a:	85 c0                	test   %eax,%eax
f011ea9c:	79 05                	jns    f011eaa3 <fix_round+0x1b>
f011ea9e:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011eaa3:	c1 f8 0e             	sar    $0xe,%eax
f011eaa6:	eb 14                	jmp    f011eabc <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f011eaa8:	8b 45 08             	mov    0x8(%ebp),%eax
f011eaab:	2d 00 20 00 00       	sub    $0x2000,%eax
f011eab0:	85 c0                	test   %eax,%eax
f011eab2:	79 05                	jns    f011eab9 <fix_round+0x31>
f011eab4:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011eab9:	c1 f8 0e             	sar    $0xe,%eax
}
f011eabc:	5d                   	pop    %ebp
f011eabd:	c3                   	ret    

f011eabe <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f011eabe:	55                   	push   %ebp
f011eabf:	89 e5                	mov    %esp,%ebp
f011eac1:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f011eac4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011eac8:	79 16                	jns    f011eae0 <fix_scale+0x22>
f011eaca:	68 b0 d3 12 f0       	push   $0xf012d3b0
f011eacf:	68 b7 d3 12 f0       	push   $0xf012d3b7
f011ead4:	6a 5a                	push   $0x5a
f011ead6:	68 cc d3 12 f0       	push   $0xf012d3cc
f011eadb:	e8 3a 18 fe ff       	call   f010031a <_panic>
  return __mk_fix (x.f * n);
f011eae0:	8b 45 0c             	mov    0xc(%ebp),%eax
f011eae3:	0f af 45 10          	imul   0x10(%ebp),%eax
f011eae7:	89 c2                	mov    %eax,%edx
f011eae9:	8b 45 08             	mov    0x8(%ebp),%eax
f011eaec:	83 ec 08             	sub    $0x8,%esp
f011eaef:	52                   	push   %edx
f011eaf0:	50                   	push   %eax
f011eaf1:	e8 77 ff ff ff       	call   f011ea6d <__mk_fix>
f011eaf6:	83 c4 0c             	add    $0xc,%esp
}
f011eaf9:	8b 45 08             	mov    0x8(%ebp),%eax
f011eafc:	c9                   	leave  
f011eafd:	c2 04 00             	ret    $0x4

f011eb00 <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f011eb00:	55                   	push   %ebp
f011eb01:	89 e5                	mov    %esp,%ebp
f011eb03:	83 ec 08             	sub    $0x8,%esp
	init_spinlock(&tstcntlock, "tstcnt lock");
f011eb06:	83 ec 08             	sub    $0x8,%esp
f011eb09:	68 e0 d3 12 f0       	push   $0xf012d3e0
f011eb0e:	68 00 52 55 f0       	push   $0xf0555200
f011eb13:	e8 55 fc fe ff       	call   f010e76d <init_spinlock>
f011eb18:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&tstcntlock);
f011eb1b:	83 ec 0c             	sub    $0xc,%esp
f011eb1e:	68 00 52 55 f0       	push   $0xf0555200
f011eb23:	e8 76 fc fe ff       	call   f010e79e <acquire_spinlock>
f011eb28:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f011eb2b:	c7 05 e8 23 55 f0 00 	movl   $0x0,0xf05523e8
f011eb32:	00 00 00 
	}
	release_spinlock(&tstcntlock);
f011eb35:	83 ec 0c             	sub    $0xc,%esp
f011eb38:	68 00 52 55 f0       	push   $0xf0555200
f011eb3d:	e8 e3 fc fe ff       	call   f010e825 <release_spinlock>
f011eb42:	83 c4 10             	add    $0x10,%esp
}
f011eb45:	90                   	nop
f011eb46:	c9                   	leave  
f011eb47:	c3                   	ret    

f011eb48 <inctst>:
void inctst()
{
f011eb48:	55                   	push   %ebp
f011eb49:	89 e5                	mov    %esp,%ebp
f011eb4b:	83 ec 08             	sub    $0x8,%esp
	acquire_spinlock(&tstcntlock);
f011eb4e:	83 ec 0c             	sub    $0xc,%esp
f011eb51:	68 00 52 55 f0       	push   $0xf0555200
f011eb56:	e8 43 fc fe ff       	call   f010e79e <acquire_spinlock>
f011eb5b:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f011eb5e:	a1 e8 23 55 f0       	mov    0xf05523e8,%eax
f011eb63:	40                   	inc    %eax
f011eb64:	a3 e8 23 55 f0       	mov    %eax,0xf05523e8
	}
	release_spinlock(&tstcntlock);
f011eb69:	83 ec 0c             	sub    $0xc,%esp
f011eb6c:	68 00 52 55 f0       	push   $0xf0555200
f011eb71:	e8 af fc fe ff       	call   f010e825 <release_spinlock>
f011eb76:	83 c4 10             	add    $0x10,%esp
}
f011eb79:	90                   	nop
f011eb7a:	c9                   	leave  
f011eb7b:	c3                   	ret    

f011eb7c <gettst>:
uint32 gettst()
{
f011eb7c:	55                   	push   %ebp
f011eb7d:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f011eb7f:	a1 e8 23 55 f0       	mov    0xf05523e8,%eax
}
f011eb84:	5d                   	pop    %ebp
f011eb85:	c3                   	ret    

f011eb86 <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f011eb86:	55                   	push   %ebp
f011eb87:	89 e5                	mov    %esp,%ebp
f011eb89:	83 ec 28             	sub    $0x28,%esp
f011eb8c:	8b 45 14             	mov    0x14(%ebp),%eax
f011eb8f:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f011eb92:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f011eb99:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f011eb9d:	83 f8 65             	cmp    $0x65,%eax
f011eba0:	74 5d                	je     f011ebff <tst+0x79>
f011eba2:	83 f8 65             	cmp    $0x65,%eax
f011eba5:	7f 0a                	jg     f011ebb1 <tst+0x2b>
f011eba7:	83 f8 62             	cmp    $0x62,%eax
f011ebaa:	74 73                	je     f011ec1f <tst+0x99>
f011ebac:	e9 91 00 00 00       	jmp    f011ec42 <tst+0xbc>
f011ebb1:	83 f8 67             	cmp    $0x67,%eax
f011ebb4:	74 29                	je     f011ebdf <tst+0x59>
f011ebb6:	83 f8 6c             	cmp    $0x6c,%eax
f011ebb9:	0f 85 83 00 00 00    	jne    f011ec42 <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f011ebbf:	8b 45 08             	mov    0x8(%ebp),%eax
f011ebc2:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011ebc5:	73 09                	jae    f011ebd0 <tst+0x4a>
			chk = 1;
f011ebc7:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011ebce:	eb 68                	jmp    f011ec38 <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f011ebd0:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011ebd4:	74 62                	je     f011ec38 <tst+0xb2>
			chk = 1;
f011ebd6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011ebdd:	eb 59                	jmp    f011ec38 <tst+0xb2>
	case 'g':
		if (n > v1)
f011ebdf:	8b 45 08             	mov    0x8(%ebp),%eax
f011ebe2:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011ebe5:	76 09                	jbe    f011ebf0 <tst+0x6a>
			chk = 1;
f011ebe7:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011ebee:	eb 4b                	jmp    f011ec3b <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f011ebf0:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011ebf4:	74 45                	je     f011ec3b <tst+0xb5>
			chk = 1;
f011ebf6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011ebfd:	eb 3c                	jmp    f011ec3b <tst+0xb5>
	case 'e':
		if (n == v1)
f011ebff:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec02:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011ec05:	75 09                	jne    f011ec10 <tst+0x8a>
			chk = 1;
f011ec07:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011ec0e:	eb 2e                	jmp    f011ec3e <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f011ec10:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011ec14:	74 28                	je     f011ec3e <tst+0xb8>
			chk = 1;
f011ec16:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011ec1d:	eb 1f                	jmp    f011ec3e <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f011ec1f:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec22:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011ec25:	72 1a                	jb     f011ec41 <tst+0xbb>
f011ec27:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec2a:	3b 45 10             	cmp    0x10(%ebp),%eax
f011ec2d:	77 12                	ja     f011ec41 <tst+0xbb>
			chk = 1;
f011ec2f:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011ec36:	eb 09                	jmp    f011ec41 <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011ec38:	90                   	nop
f011ec39:	eb 07                	jmp    f011ec42 <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011ec3b:	90                   	nop
f011ec3c:	eb 04                	jmp    f011ec42 <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011ec3e:	90                   	nop
f011ec3f:	eb 01                	jmp    f011ec42 <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f011ec41:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f011ec42:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011ec46:	75 14                	jne    f011ec5c <tst+0xd6>
f011ec48:	83 ec 04             	sub    $0x4,%esp
f011ec4b:	68 ec d3 12 f0       	push   $0xf012d3ec
f011ec50:	6a 47                	push   $0x47
f011ec52:	68 ff d3 12 f0       	push   $0xf012d3ff
f011ec57:	e8 be 16 fe ff       	call   f010031a <_panic>

	acquire_spinlock(&tstcntlock);
f011ec5c:	83 ec 0c             	sub    $0xc,%esp
f011ec5f:	68 00 52 55 f0       	push   $0xf0555200
f011ec64:	e8 35 fb fe ff       	call   f010e79e <acquire_spinlock>
f011ec69:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f011ec6c:	a1 e8 23 55 f0       	mov    0xf05523e8,%eax
f011ec71:	40                   	inc    %eax
f011ec72:	a3 e8 23 55 f0       	mov    %eax,0xf05523e8
	}
	release_spinlock(&tstcntlock);
f011ec77:	83 ec 0c             	sub    $0xc,%esp
f011ec7a:	68 00 52 55 f0       	push   $0xf0555200
f011ec7f:	e8 a1 fb fe ff       	call   f010e825 <release_spinlock>
f011ec84:	83 c4 10             	add    $0x10,%esp

	return;
f011ec87:	90                   	nop
}
f011ec88:	c9                   	leave  
f011ec89:	c3                   	ret    

f011ec8a <chktst>:

void chktst(uint32 n)
{
f011ec8a:	55                   	push   %ebp
f011ec8b:	89 e5                	mov    %esp,%ebp
f011ec8d:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_spinlock(&tstcntlock);
f011ec90:	83 ec 0c             	sub    $0xc,%esp
f011ec93:	68 00 52 55 f0       	push   $0xf0555200
f011ec98:	e8 01 fb fe ff       	call   f010e79e <acquire_spinlock>
f011ec9d:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f011eca0:	a1 e8 23 55 f0       	mov    0xf05523e8,%eax
f011eca5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_spinlock(&tstcntlock);
f011eca8:	83 ec 0c             	sub    $0xc,%esp
f011ecab:	68 00 52 55 f0       	push   $0xf0555200
f011ecb0:	e8 70 fb fe ff       	call   f010e825 <release_spinlock>
f011ecb5:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f011ecb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ecbb:	3b 45 08             	cmp    0x8(%ebp),%eax
f011ecbe:	75 12                	jne    f011ecd2 <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f011ecc0:	83 ec 0c             	sub    $0xc,%esp
f011ecc3:	68 18 d4 12 f0       	push   $0xf012d418
f011ecc8:	e8 9f 22 fe ff       	call   f0100f6c <cprintf>
f011eccd:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f011ecd0:	eb 14                	jmp    f011ece6 <chktst+0x5c>
	}
	release_spinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f011ecd2:	83 ec 04             	sub    $0x4,%esp
f011ecd5:	68 44 d4 12 f0       	push   $0xf012d444
f011ecda:	6a 5d                	push   $0x5d
f011ecdc:	68 ff d3 12 f0       	push   $0xf012d3ff
f011ece1:	e8 34 16 fe ff       	call   f010031a <_panic>
}
f011ece6:	c9                   	leave  
f011ece7:	c3                   	ret    

f011ece8 <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f011ece8:	55                   	push   %ebp
f011ece9:	89 e5                	mov    %esp,%ebp
f011eceb:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011ecee:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011ecf2:	77 07                	ja     f011ecfb <nearest_pow2_ceil+0x13>
f011ecf4:	b8 01 00 00 00       	mov    $0x1,%eax
f011ecf9:	eb 20                	jmp    f011ed1b <nearest_pow2_ceil+0x33>
	int power = 2;
f011ecfb:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011ed02:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011ed05:	eb 08                	jmp    f011ed0f <nearest_pow2_ceil+0x27>
		power <<= 1;
f011ed07:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ed0a:	01 c0                	add    %eax,%eax
f011ed0c:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f011ed0f:	d1 6d 08             	shrl   0x8(%ebp)
f011ed12:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011ed16:	75 ef                	jne    f011ed07 <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f011ed18:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011ed1b:	c9                   	leave  
f011ed1c:	c3                   	ret    

f011ed1d <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f011ed1d:	55                   	push   %ebp
f011ed1e:	89 e5                	mov    %esp,%ebp
f011ed20:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011ed23:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011ed27:	77 07                	ja     f011ed30 <log2_ceil+0x13>
f011ed29:	b8 01 00 00 00       	mov    $0x1,%eax
f011ed2e:	eb 1b                	jmp    f011ed4b <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f011ed30:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011ed37:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011ed3a:	eb 03                	jmp    f011ed3f <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f011ed3c:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f011ed3f:	d1 6d 08             	shrl   0x8(%ebp)
f011ed42:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011ed46:	75 f4                	jne    f011ed3c <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f011ed48:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011ed4b:	c9                   	leave  
f011ed4c:	c3                   	ret    

f011ed4d <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f011ed4d:	55                   	push   %ebp
f011ed4e:	89 e5                	mov    %esp,%ebp
f011ed50:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f011ed53:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f011ed5a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ed61:	eb 12                	jmp    f011ed75 <fixedPt2Str+0x28>
		mulFactor *= 10;
f011ed63:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ed66:	89 d0                	mov    %edx,%eax
f011ed68:	c1 e0 02             	shl    $0x2,%eax
f011ed6b:	01 d0                	add    %edx,%eax
f011ed6d:	01 c0                	add    %eax,%eax
f011ed6f:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f011ed72:	ff 45 f0             	incl   -0x10(%ebp)
f011ed75:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ed78:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011ed7b:	7c e6                	jl     f011ed63 <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f011ed7d:	8d 45 dc             	lea    -0x24(%ebp),%eax
f011ed80:	83 ec 04             	sub    $0x4,%esp
f011ed83:	ff 75 f4             	pushl  -0xc(%ebp)
f011ed86:	ff 75 08             	pushl  0x8(%ebp)
f011ed89:	50                   	push   %eax
f011ed8a:	e8 2f fd ff ff       	call   f011eabe <fix_scale>
f011ed8f:	83 c4 0c             	add    $0xc,%esp
f011ed92:	83 ec 0c             	sub    $0xc,%esp
f011ed95:	ff 75 dc             	pushl  -0x24(%ebp)
f011ed98:	e8 eb fc ff ff       	call   f011ea88 <fix_round>
f011ed9d:	83 c4 10             	add    $0x10,%esp
f011eda0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f011eda3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011eda6:	99                   	cltd   
f011eda7:	f7 7d f4             	idivl  -0xc(%ebp)
f011edaa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f011edad:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011edb0:	99                   	cltd   
f011edb1:	f7 7d f4             	idivl  -0xc(%ebp)
f011edb4:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f011edb7:	83 ec 08             	sub    $0x8,%esp
f011edba:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011edbd:	50                   	push   %eax
f011edbe:	ff 75 e4             	pushl  -0x1c(%ebp)
f011edc1:	e8 31 1c 00 00       	call   f01209f7 <ltostr>
f011edc6:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f011edc9:	83 ec 08             	sub    $0x8,%esp
f011edcc:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011edcf:	50                   	push   %eax
f011edd0:	ff 75 e0             	pushl  -0x20(%ebp)
f011edd3:	e8 1f 1c 00 00       	call   f01209f7 <ltostr>
f011edd8:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f011eddb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011edde:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011ede3:	f7 e9                	imul   %ecx
f011ede5:	c1 fa 02             	sar    $0x2,%edx
f011ede8:	89 c8                	mov    %ecx,%eax
f011edea:	c1 f8 1f             	sar    $0x1f,%eax
f011eded:	29 c2                	sub    %eax,%edx
f011edef:	89 d0                	mov    %edx,%eax
f011edf1:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f011edf4:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f011edfb:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f011ee02:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f011ee08:	eb 31                	jmp    f011ee3b <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f011ee0a:	83 ec 04             	sub    $0x4,%esp
f011ee0d:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011ee10:	50                   	push   %eax
f011ee11:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011ee14:	50                   	push   %eax
f011ee15:	68 60 d4 12 f0       	push   $0xf012d460
f011ee1a:	e8 b1 1c 00 00       	call   f0120ad0 <strcconcat>
f011ee1f:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f011ee22:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f011ee25:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011ee2a:	f7 e9                	imul   %ecx
f011ee2c:	c1 fa 02             	sar    $0x2,%edx
f011ee2f:	89 c8                	mov    %ecx,%eax
f011ee31:	c1 f8 1f             	sar    $0x1f,%eax
f011ee34:	29 c2                	sub    %eax,%edx
f011ee36:	89 d0                	mov    %edx,%eax
f011ee38:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f011ee3b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ee3e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011ee41:	7c c7                	jl     f011ee0a <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f011ee43:	83 ec 04             	sub    $0x4,%esp
f011ee46:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011ee49:	50                   	push   %eax
f011ee4a:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011ee4d:	50                   	push   %eax
f011ee4e:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011ee51:	50                   	push   %eax
f011ee52:	e8 79 1c 00 00       	call   f0120ad0 <strcconcat>
f011ee57:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f011ee5a:	83 ec 04             	sub    $0x4,%esp
f011ee5d:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011ee60:	50                   	push   %eax
f011ee61:	68 62 d4 12 f0       	push   $0xf012d462
f011ee66:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011ee69:	50                   	push   %eax
f011ee6a:	e8 61 1c 00 00       	call   f0120ad0 <strcconcat>
f011ee6f:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f011ee72:	83 ec 04             	sub    $0x4,%esp
f011ee75:	ff 75 10             	pushl  0x10(%ebp)
f011ee78:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011ee7b:	50                   	push   %eax
f011ee7c:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011ee7f:	50                   	push   %eax
f011ee80:	e8 4b 1c 00 00       	call   f0120ad0 <strcconcat>
f011ee85:	83 c4 10             	add    $0x10,%esp

}
f011ee88:	90                   	nop
f011ee89:	c9                   	leave  
f011ee8a:	c3                   	ret    

f011ee8b <sys_utilities>:

void sys_utilities(char* utilityName, int value)
{
f011ee8b:	55                   	push   %ebp
f011ee8c:	89 e5                	mov    %esp,%ebp
f011ee8e:	83 ec 78             	sub    $0x78,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f011ee91:	83 ec 0c             	sub    $0xc,%esp
f011ee94:	68 64 d4 12 f0       	push   $0xf012d464
f011ee99:	e8 b3 16 00 00       	call   f0120551 <strlen>
f011ee9e:	83 c4 10             	add    $0x10,%esp
f011eea1:	83 ec 04             	sub    $0x4,%esp
f011eea4:	50                   	push   %eax
f011eea5:	68 64 d4 12 f0       	push   $0xf012d464
f011eeaa:	ff 75 08             	pushl  0x8(%ebp)
f011eead:	e8 e3 17 00 00       	call   f0120695 <strncmp>
f011eeb2:	83 c4 10             	add    $0x10,%esp
f011eeb5:	85 c0                	test   %eax,%eax
f011eeb7:	0f 85 84 00 00 00    	jne    f011ef41 <sys_utilities+0xb6>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011eebd:	8d 45 d0             	lea    -0x30(%ebp),%eax
f011eec0:	50                   	push   %eax
f011eec1:	8d 45 88             	lea    -0x78(%ebp),%eax
f011eec4:	50                   	push   %eax
f011eec5:	68 72 d4 12 f0       	push   $0xf012d472
f011eeca:	ff 75 08             	pushl  0x8(%ebp)
f011eecd:	e8 94 1c 00 00       	call   f0120b66 <strsplit>
f011eed2:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f011eed5:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011eed8:	83 ec 04             	sub    $0x4,%esp
f011eedb:	6a 0a                	push   $0xa
f011eedd:	6a 00                	push   $0x0
f011eedf:	50                   	push   %eax
f011eee0:	e8 cc 19 00 00       	call   f01208b1 <strtol>
f011eee5:	83 c4 10             	add    $0x10,%esp
f011eee8:	89 45 e0             	mov    %eax,-0x20(%ebp)
		struct Env* env = NULL ;
f011eeeb:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
		envid2env(envID, &env, 0);
f011eef2:	83 ec 04             	sub    $0x4,%esp
f011eef5:	6a 00                	push   $0x0
f011eef7:	8d 45 cc             	lea    -0x34(%ebp),%eax
f011eefa:	50                   	push   %eax
f011eefb:	ff 75 e0             	pushl  -0x20(%ebp)
f011eefe:	e8 db b5 fe ff       	call   f010a4de <envid2env>
f011ef03:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f011ef06:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011ef09:	8b 40 10             	mov    0x10(%eax),%eax
f011ef0c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011ef0f:	74 19                	je     f011ef2a <sys_utilities+0x9f>
f011ef11:	68 74 d4 12 f0       	push   $0xf012d474
f011ef16:	68 b7 d3 12 f0       	push   $0xf012d3b7
f011ef1b:	68 9d 00 00 00       	push   $0x9d
f011ef20:	68 ff d3 12 f0       	push   $0xf012d3ff
f011ef25:	e8 f0 13 fe ff       	call   f010031a <_panic>
		env_set_nice(env, value);
f011ef2a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011ef2d:	83 ec 08             	sub    $0x8,%esp
f011ef30:	ff 75 0c             	pushl  0xc(%ebp)
f011ef33:	50                   	push   %eax
f011ef34:	e8 8c 74 fe ff       	call   f01063c5 <env_set_nice>
f011ef39:	83 c4 10             	add    $0x10,%esp
f011ef3c:	e9 c4 01 00 00       	jmp    f011f105 <sys_utilities+0x27a>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f011ef41:	83 ec 0c             	sub    $0xc,%esp
f011ef44:	68 89 d4 12 f0       	push   $0xf012d489
f011ef49:	e8 03 16 00 00       	call   f0120551 <strlen>
f011ef4e:	83 c4 10             	add    $0x10,%esp
f011ef51:	83 ec 04             	sub    $0x4,%esp
f011ef54:	50                   	push   %eax
f011ef55:	68 89 d4 12 f0       	push   $0xf012d489
f011ef5a:	ff 75 08             	pushl  0x8(%ebp)
f011ef5d:	e8 33 17 00 00       	call   f0120695 <strncmp>
f011ef62:	83 c4 10             	add    $0x10,%esp
f011ef65:	85 c0                	test   %eax,%eax
f011ef67:	0f 85 98 01 00 00    	jne    f011f105 <sys_utilities+0x27a>
	{
		int* numOfInstances = (int*) value ;
f011ef6d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ef70:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011ef73:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011ef76:	50                   	push   %eax
f011ef77:	8d 45 88             	lea    -0x78(%ebp),%eax
f011ef7a:	50                   	push   %eax
f011ef7b:	68 72 d4 12 f0       	push   $0xf012d472
f011ef80:	ff 75 08             	pushl  0x8(%ebp)
f011ef83:	e8 de 1b 00 00       	call   f0120b66 <strsplit>
f011ef88:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f011ef8b:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011ef8e:	89 45 d8             	mov    %eax,-0x28(%ebp)
		struct Env* env = NULL ;
f011ef91:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f011ef98:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f011ef9f:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f011efa6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011efa9:	8b 00                	mov    (%eax),%eax
f011efab:	85 c0                	test   %eax,%eax
f011efad:	79 1c                	jns    f011efcb <sys_utilities+0x140>
		{
			chkAscending = 0;
f011efaf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f011efb6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011efb9:	8b 00                	mov    (%eax),%eax
f011efbb:	f7 d8                	neg    %eax
f011efbd:	89 c2                	mov    %eax,%edx
f011efbf:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011efc2:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f011efc4:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f011efcb:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_spinlock(&ProcessQueues.qlock);
f011efd2:	83 ec 0c             	sub    $0xc,%esp
f011efd5:	68 60 24 55 f0       	push   $0xf0552460
f011efda:	e8 bf f7 fe ff       	call   f010e79e <acquire_spinlock>
f011efdf:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011efe2:	a1 ec 24 55 f0       	mov    0xf05524ec,%eax
f011efe7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011efea:	a1 e4 24 55 f0       	mov    0xf05524e4,%eax
f011efef:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011eff2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011eff5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011eff8:	eb 6c                	jmp    f011f066 <sys_utilities+0x1db>
			{
				if (strcmp(env->prog_name, progName) != 0)
f011effa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011effd:	83 c0 20             	add    $0x20,%eax
f011f000:	83 ec 08             	sub    $0x8,%esp
f011f003:	ff 75 d8             	pushl  -0x28(%ebp)
f011f006:	50                   	push   %eax
f011f007:	e8 51 16 00 00       	call   f012065d <strcmp>
f011f00c:	83 c4 10             	add    $0x10,%esp
f011f00f:	85 c0                	test   %eax,%eax
f011f011:	75 46                	jne    f011f059 <sys_utilities+0x1ce>
					continue;
				(*numOfInstances)-- ;
f011f013:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f016:	8b 00                	mov    (%eax),%eax
f011f018:	8d 50 ff             	lea    -0x1(%eax),%edx
f011f01b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f01e:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f011f020:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f024:	74 14                	je     f011f03a <sys_utilities+0x1af>
				{
					if (prevEnvID > env->env_id)
f011f026:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f029:	8b 40 10             	mov    0x10(%eax),%eax
f011f02c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f02f:	7d 1d                	jge    f011f04e <sys_utilities+0x1c3>
					{
						success = 0;
f011f031:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011f038:	eb 32                	jmp    f011f06c <sys_utilities+0x1e1>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f011f03a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f03d:	8b 40 10             	mov    0x10(%eax),%eax
f011f040:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f043:	7e 09                	jle    f011f04e <sys_utilities+0x1c3>
					{
						success = 0;
f011f045:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011f04c:	eb 1e                	jmp    f011f06c <sys_utilities+0x1e1>
					}
				}
				prevEnvID = env->env_id;
f011f04e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f051:	8b 40 10             	mov    0x10(%eax),%eax
f011f054:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011f057:	eb 01                	jmp    f011f05a <sys_utilities+0x1cf>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f011f059:	90                   	nop
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011f05a:	ff 4d e4             	decl   -0x1c(%ebp)
f011f05d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f060:	8b 40 0c             	mov    0xc(%eax),%eax
f011f063:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f066:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f06a:	7f 8e                	jg     f011effa <sys_utilities+0x16f>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011f06c:	83 ec 0c             	sub    $0xc,%esp
f011f06f:	68 60 24 55 f0       	push   $0xf0552460
f011f074:	e8 ac f7 fe ff       	call   f010e825 <release_spinlock>
f011f079:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f011f07c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f07f:	8b 00                	mov    (%eax),%eax
f011f081:	85 c0                	test   %eax,%eax
f011f083:	75 06                	jne    f011f08b <sys_utilities+0x200>
f011f085:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011f089:	75 3e                	jne    f011f0c9 <sys_utilities+0x23e>
		{
			cprintf("###########################################\n");
f011f08b:	83 ec 0c             	sub    $0xc,%esp
f011f08e:	68 9c d4 12 f0       	push   $0xf012d49c
f011f093:	e8 d4 1e fe ff       	call   f0100f6c <cprintf>
f011f098:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is FAILED\n", progName);
f011f09b:	83 ec 08             	sub    $0x8,%esp
f011f09e:	ff 75 d8             	pushl  -0x28(%ebp)
f011f0a1:	68 cc d4 12 f0       	push   $0xf012d4cc
f011f0a6:	e8 c1 1e fe ff       	call   f0100f6c <cprintf>
f011f0ab:	83 c4 10             	add    $0x10,%esp
			cprintf("###########################################\n");
f011f0ae:	83 ec 0c             	sub    $0xc,%esp
f011f0b1:	68 9c d4 12 f0       	push   $0xf012d49c
f011f0b6:	e8 b1 1e fe ff       	call   f0100f6c <cprintf>
f011f0bb:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 0; //to indicate the failure of test
f011f0be:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f0c1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011f0c7:	eb 3c                	jmp    f011f105 <sys_utilities+0x27a>
		}
		else
		{
			cprintf("####################################################\n");
f011f0c9:	83 ec 0c             	sub    $0xc,%esp
f011f0cc:	68 ec d4 12 f0       	push   $0xf012d4ec
f011f0d1:	e8 96 1e fe ff       	call   f0100f6c <cprintf>
f011f0d6:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is SUCCEEDED\n", progName);
f011f0d9:	83 ec 08             	sub    $0x8,%esp
f011f0dc:	ff 75 d8             	pushl  -0x28(%ebp)
f011f0df:	68 24 d5 12 f0       	push   $0xf012d524
f011f0e4:	e8 83 1e fe ff       	call   f0100f6c <cprintf>
f011f0e9:	83 c4 10             	add    $0x10,%esp
			cprintf("####################################################\n");
f011f0ec:	83 ec 0c             	sub    $0xc,%esp
f011f0ef:	68 ec d4 12 f0       	push   $0xf012d4ec
f011f0f4:	e8 73 1e fe ff       	call   f0100f6c <cprintf>
f011f0f9:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 1; //to indicate the success of test
f011f0fc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f0ff:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		}
	}
	if ((int)value < 0)
f011f105:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f109:	79 5b                	jns    f011f166 <sys_utilities+0x2db>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f011f10b:	83 ec 08             	sub    $0x8,%esp
f011f10e:	68 47 d5 12 f0       	push   $0xf012d547
f011f113:	ff 75 08             	pushl  0x8(%ebp)
f011f116:	e8 42 15 00 00       	call   f012065d <strcmp>
f011f11b:	83 c4 10             	add    $0x10,%esp
f011f11e:	85 c0                	test   %eax,%eax
f011f120:	75 44                	jne    f011f166 <sys_utilities+0x2db>
		{
			switch (value)
f011f122:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f125:	83 f8 fc             	cmp    $0xfffffffc,%eax
f011f128:	74 07                	je     f011f131 <sys_utilities+0x2a6>
f011f12a:	83 f8 fe             	cmp    $0xfffffffe,%eax
f011f12d:	74 19                	je     f011f148 <sys_utilities+0x2bd>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
				break;
			default:
				break;
f011f12f:	eb 35                	jmp    f011f166 <sys_utilities+0x2db>
		if (strcmp(utilityName, "__ReplStrat__") == 0)
		{
			switch (value)
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f011f131:	83 ec 0c             	sub    $0xc,%esp
f011f134:	68 58 d5 12 f0       	push   $0xf012d558
f011f139:	e8 2e 1e fe ff       	call   f0100f6c <cprintf>
f011f13e:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f011f141:	e8 ff f1 fe ff       	call   f010e345 <setPageReplacmentAlgorithmFIFO>
				break;
f011f146:	eb 1e                	jmp    f011f166 <sys_utilities+0x2db>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f011f148:	83 ec 0c             	sub    $0xc,%esp
f011f14b:	68 c8 d5 12 f0       	push   $0xf012d5c8
f011f150:	e8 17 1e fe ff       	call   f0100f6c <cprintf>
f011f155:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f011f158:	83 ec 0c             	sub    $0xc,%esp
f011f15b:	6a 02                	push   $0x2
f011f15d:	e8 a0 f1 fe ff       	call   f010e302 <setPageReplacmentAlgorithmLRU>
f011f162:	83 c4 10             	add    $0x10,%esp
				break;
f011f165:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f011f166:	90                   	nop
f011f167:	c9                   	leave  
f011f168:	c3                   	ret    

f011f169 <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f011f169:	55                   	push   %ebp
f011f16a:	89 e5                	mov    %esp,%ebp
f011f16c:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f011f16f:	8b 45 08             	mov    0x8(%ebp),%eax
f011f172:	8b 00                	mov    (%eax),%eax
f011f174:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f011f177:	8b 45 08             	mov    0x8(%ebp),%eax
f011f17a:	8b 00                	mov    (%eax),%eax
f011f17c:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f011f17f:	eb 52                	jmp    f011f1d3 <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f011f181:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f184:	8b 00                	mov    (%eax),%eax
f011f186:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f011f189:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f18c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011f18f:	75 12                	jne    f011f1a3 <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f011f191:	83 ec 0c             	sub    $0xc,%esp
f011f194:	68 3c d6 12 f0       	push   $0xf012d63c
f011f199:	e8 ce 1d fe ff       	call   f0100f6c <cprintf>
f011f19e:	83 c4 10             	add    $0x10,%esp
			break;
f011f1a1:	eb 3f                	jmp    f011f1e2 <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f011f1a3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f1a7:	74 38                	je     f011f1e1 <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f011f1a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f1ac:	8b 00                	mov    (%eax),%eax
f011f1ae:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f011f1b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f1b4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011f1b7:	75 12                	jne    f011f1cb <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f011f1b9:	83 ec 0c             	sub    $0xc,%esp
f011f1bc:	68 58 d6 12 f0       	push   $0xf012d658
f011f1c1:	e8 a6 1d fe ff       	call   f0100f6c <cprintf>
f011f1c6:	83 c4 10             	add    $0x10,%esp
			break;
f011f1c9:	eb 17                	jmp    f011f1e2 <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f011f1cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f1ce:	8b 00                	mov    (%eax),%eax
f011f1d0:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f011f1d3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f1d7:	74 09                	je     f011f1e2 <detect_loop_in_FrameInfo_list+0x79>
f011f1d9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f1dd:	75 a2                	jne    f011f181 <detect_loop_in_FrameInfo_list+0x18>
f011f1df:	eb 01                	jmp    f011f1e2 <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f011f1e1:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f011f1e2:	83 ec 0c             	sub    $0xc,%esp
f011f1e5:	68 6f d6 12 f0       	push   $0xf012d66f
f011f1ea:	e8 7d 1d fe ff       	call   f0100f6c <cprintf>
f011f1ef:	83 c4 10             	add    $0x10,%esp
}
f011f1f2:	90                   	nop
f011f1f3:	c9                   	leave  
f011f1f4:	c3                   	ret    

f011f1f5 <scarce_memory>:

void scarce_memory()
{
f011f1f5:	55                   	push   %ebp
f011f1f6:	89 e5                	mov    %esp,%ebp
f011f1f8:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f011f1fb:	a1 e0 4b 55 f0       	mov    0xf0554be0,%eax
f011f200:	ba 64 00 00 00       	mov    $0x64,%edx
f011f205:	29 c2                	sub    %eax,%edx
f011f207:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f011f20c:	0f af c2             	imul   %edx,%eax
f011f20f:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011f214:	f7 e2                	mul    %edx
f011f216:	89 d0                	mov    %edx,%eax
f011f218:	c1 e8 05             	shr    $0x5,%eax
f011f21b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f011f21e:	a1 e0 4b 55 f0       	mov    0xf0554be0,%eax
f011f223:	ba 64 00 00 00       	mov    $0x64,%edx
f011f228:	29 c2                	sub    %eax,%edx
f011f22a:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f011f22f:	89 d1                	mov    %edx,%ecx
f011f231:	0f af c8             	imul   %eax,%ecx
f011f234:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f239:	f7 e1                	mul    %ecx
f011f23b:	c1 ea 05             	shr    $0x5,%edx
f011f23e:	89 d0                	mov    %edx,%eax
f011f240:	c1 e0 02             	shl    $0x2,%eax
f011f243:	01 d0                	add    %edx,%eax
f011f245:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f24c:	01 d0                	add    %edx,%eax
f011f24e:	c1 e0 02             	shl    $0x2,%eax
f011f251:	29 c1                	sub    %eax,%ecx
f011f253:	89 ca                	mov    %ecx,%edx
f011f255:	85 d2                	test   %edx,%edx
f011f257:	74 03                	je     f011f25c <scarce_memory+0x67>
		total_size_tobe_allocated++;
f011f259:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f011f25c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_spinlock(&MemFrameLists.mfllock);
f011f263:	83 ec 0c             	sub    $0xc,%esp
f011f266:	68 40 25 55 f0       	push   $0xf0552540
f011f26b:	e8 2e f5 fe ff       	call   f010e79e <acquire_spinlock>
f011f270:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f011f273:	a1 2c 25 55 f0       	mov    0xf055252c,%eax
f011f278:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f011f27b:	8b 15 b8 4c 55 f0    	mov    0xf0554cb8,%edx
f011f281:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011f284:	29 c2                	sub    %eax,%edx
f011f286:	89 d0                	mov    %edx,%eax
f011f288:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f011f28b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f28e:	2b 45 e8             	sub    -0x18(%ebp),%eax
f011f291:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f011f294:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011f29b:	eb 12                	jmp    f011f2af <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f011f29d:	83 ec 0c             	sub    $0xc,%esp
f011f2a0:	8d 45 e0             	lea    -0x20(%ebp),%eax
f011f2a3:	50                   	push   %eax
f011f2a4:	e8 45 8c fe ff       	call   f0107eee <allocate_frame>
f011f2a9:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011f2ac:	ff 45 f0             	incl   -0x10(%ebp)
f011f2af:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f2b2:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011f2b5:	76 e6                	jbe    f011f29d <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f011f2b7:	83 ec 0c             	sub    $0xc,%esp
f011f2ba:	68 40 25 55 f0       	push   $0xf0552540
f011f2bf:	e8 61 f5 fe ff       	call   f010e825 <release_spinlock>
f011f2c4:	83 c4 10             	add    $0x10,%esp

}
f011f2c7:	90                   	nop
f011f2c8:	c9                   	leave  
f011f2c9:	c3                   	ret    

f011f2ca <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f011f2ca:	55                   	push   %ebp
f011f2cb:	89 e5                	mov    %esp,%ebp
f011f2cd:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f011f2d0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f011f2d7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f011f2de:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f011f2e5:	e8 a4 b1 fe ff       	call   f010a48e <get_cpu_proc>
f011f2ea:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f011f2ed:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011f2f1:	75 19                	jne    f011f30c <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f011f2f3:	68 89 d6 12 f0       	push   $0xf012d689
f011f2f8:	68 b7 d3 12 f0       	push   $0xf012d3b7
f011f2fd:	68 38 01 00 00       	push   $0x138
f011f302:	68 ff d3 12 f0       	push   $0xf012d3ff
f011f307:	e8 0e 10 fe ff       	call   f010031a <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f011f30c:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011f310:	0f 85 f7 01 00 00    	jne    f011f50d <calc_no_pages_tobe_removed_from_ready_exit_queues+0x243>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f011f316:	83 ec 0c             	sub    $0xc,%esp
f011f319:	68 60 24 55 f0       	push   $0xf0552460
f011f31e:	e8 7b f4 fe ff       	call   f010e79e <acquire_spinlock>
f011f323:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011f326:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011f32d:	e9 e9 00 00 00       	jmp    f011f41b <calc_no_pages_tobe_removed_from_ready_exit_queues+0x151>
			{
				struct Env * ptr_ready_env = NULL;
f011f332:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011f339:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f33c:	83 c0 09             	add    $0x9,%eax
f011f33f:	c1 e0 04             	shl    $0x4,%eax
f011f342:	05 60 24 55 f0       	add    $0xf0552460,%eax
f011f347:	8b 00                	mov    (%eax),%eax
f011f349:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011f34c:	e9 81 00 00 00       	jmp    f011f3d2 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x108>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
f011f351:	83 ec 0c             	sub    $0xc,%esp
f011f354:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f357:	e8 20 97 fe ff       	call   f0108a7c <env_page_ws_get_size>
f011f35c:	83 c4 10             	add    $0x10,%esp
f011f35f:	89 45 cc             	mov    %eax,-0x34(%ebp)
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011f362:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011f365:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f011f36b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011f36e:	0f af c2             	imul   %edx,%eax
f011f371:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011f376:	f7 e2                	mul    %edx
f011f378:	89 d0                	mov    %edx,%eax
f011f37a:	c1 e8 05             	shr    $0x5,%eax
f011f37d:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011f380:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011f383:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f011f389:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011f38c:	89 d1                	mov    %edx,%ecx
f011f38e:	0f af c8             	imul   %eax,%ecx
f011f391:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f396:	f7 e1                	mul    %ecx
f011f398:	c1 ea 05             	shr    $0x5,%edx
f011f39b:	89 d0                	mov    %edx,%eax
f011f39d:	c1 e0 02             	shl    $0x2,%eax
f011f3a0:	01 d0                	add    %edx,%eax
f011f3a2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f3a9:	01 d0                	add    %edx,%eax
f011f3ab:	c1 e0 02             	shl    $0x2,%eax
f011f3ae:	29 c1                	sub    %eax,%ecx
f011f3b0:	89 ca                	mov    %ecx,%edx
f011f3b2:	85 d2                	test   %edx,%edx
f011f3b4:	74 03                	je     f011f3b9 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xef>
						num_of_pages_to_be_removed++;
f011f3b6:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f011f3b9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f3bc:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011f3bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f3c2:	83 c0 09             	add    $0x9,%eax
f011f3c5:	c1 e0 04             	shl    $0x4,%eax
f011f3c8:	05 68 24 55 f0       	add    $0xf0552468,%eax
f011f3cd:	8b 00                	mov    (%eax),%eax
f011f3cf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011f3d2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f3d6:	74 08                	je     f011f3e0 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x116>
f011f3d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f3db:	8b 40 08             	mov    0x8(%eax),%eax
f011f3de:	eb 05                	jmp    f011f3e5 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11b>
f011f3e0:	b8 00 00 00 00       	mov    $0x0,%eax
f011f3e5:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011f3e8:	83 c2 09             	add    $0x9,%edx
f011f3eb:	c1 e2 04             	shl    $0x4,%edx
f011f3ee:	81 c2 68 24 55 f0    	add    $0xf0552468,%edx
f011f3f4:	89 02                	mov    %eax,(%edx)
f011f3f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f3f9:	83 c0 09             	add    $0x9,%eax
f011f3fc:	c1 e0 04             	shl    $0x4,%eax
f011f3ff:	05 68 24 55 f0       	add    $0xf0552468,%eax
f011f404:	8b 00                	mov    (%eax),%eax
f011f406:	85 c0                	test   %eax,%eax
f011f408:	0f 85 43 ff ff ff    	jne    f011f351 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x87>
f011f40e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f412:	0f 85 39 ff ff ff    	jne    f011f351 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x87>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011f418:	ff 45 e8             	incl   -0x18(%ebp)
f011f41b:	a0 60 51 55 f0       	mov    0xf0555160,%al
f011f420:	0f b6 c0             	movzbl %al,%eax
f011f423:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011f426:	0f 8f 06 ff ff ff    	jg     f011f332 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f011f42c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011f433:	a1 e0 24 55 f0       	mov    0xf05524e0,%eax
f011f438:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011f43b:	eb 1f                	jmp    f011f45c <calc_no_pages_tobe_removed_from_ready_exit_queues+0x192>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
f011f43d:	83 ec 0c             	sub    $0xc,%esp
f011f440:	ff 75 dc             	pushl  -0x24(%ebp)
f011f443:	e8 34 96 fe ff       	call   f0108a7c <env_page_ws_get_size>
f011f448:	83 c4 10             	add    $0x10,%esp
f011f44b:	89 45 c8             	mov    %eax,-0x38(%ebp)
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f011f44e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011f451:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011f454:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f011f459:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011f45c:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011f460:	74 08                	je     f011f46a <calc_no_pages_tobe_removed_from_ready_exit_queues+0x1a0>
f011f462:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f465:	8b 40 08             	mov    0x8(%eax),%eax
f011f468:	eb 05                	jmp    f011f46f <calc_no_pages_tobe_removed_from_ready_exit_queues+0x1a5>
f011f46a:	b8 00 00 00 00       	mov    $0x0,%eax
f011f46f:	a3 e8 24 55 f0       	mov    %eax,0xf05524e8
f011f474:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f011f479:	85 c0                	test   %eax,%eax
f011f47b:	75 c0                	jne    f011f43d <calc_no_pages_tobe_removed_from_ready_exit_queues+0x173>
f011f47d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011f481:	75 ba                	jne    f011f43d <calc_no_pages_tobe_removed_from_ready_exit_queues+0x173>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011f483:	83 ec 0c             	sub    $0xc,%esp
f011f486:	68 60 24 55 f0       	push   $0xf0552460
f011f48b:	e8 95 f3 fe ff       	call   f010e825 <release_spinlock>
f011f490:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f011f493:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011f497:	0f 84 de 00 00 00    	je     f011f57b <calc_no_pages_tobe_removed_from_ready_exit_queues+0x2b1>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
f011f49d:	83 ec 0c             	sub    $0xc,%esp
f011f4a0:	ff 75 d0             	pushl  -0x30(%ebp)
f011f4a3:	e8 d4 95 fe ff       	call   f0108a7c <env_page_ws_get_size>
f011f4a8:	83 c4 10             	add    $0x10,%esp
f011f4ab:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011f4ae:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011f4b1:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f011f4b7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011f4ba:	0f af c2             	imul   %edx,%eax
f011f4bd:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011f4c2:	f7 e2                	mul    %edx
f011f4c4:	89 d0                	mov    %edx,%eax
f011f4c6:	c1 e8 05             	shr    $0x5,%eax
f011f4c9:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011f4cc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011f4cf:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f011f4d5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011f4d8:	89 d1                	mov    %edx,%ecx
f011f4da:	0f af c8             	imul   %eax,%ecx
f011f4dd:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f4e2:	f7 e1                	mul    %ecx
f011f4e4:	c1 ea 05             	shr    $0x5,%edx
f011f4e7:	89 d0                	mov    %edx,%eax
f011f4e9:	c1 e0 02             	shl    $0x2,%eax
f011f4ec:	01 d0                	add    %edx,%eax
f011f4ee:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f4f5:	01 d0                	add    %edx,%eax
f011f4f7:	c1 e0 02             	shl    $0x2,%eax
f011f4fa:	29 c1                	sub    %eax,%ecx
f011f4fc:	89 ca                	mov    %ecx,%edx
f011f4fe:	85 d2                	test   %edx,%edx
f011f500:	74 03                	je     f011f505 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x23b>
				num_of_pages_to_be_removed++;
f011f502:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011f505:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011f508:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011f50b:	eb 6e                	jmp    f011f57b <calc_no_pages_tobe_removed_from_ready_exit_queues+0x2b1>
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
f011f50d:	83 ec 0c             	sub    $0xc,%esp
f011f510:	ff 75 d0             	pushl  -0x30(%ebp)
f011f513:	e8 64 95 fe ff       	call   f0108a7c <env_page_ws_get_size>
f011f518:	83 c4 10             	add    $0x10,%esp
f011f51b:	89 45 c0             	mov    %eax,-0x40(%ebp)
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011f51e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011f521:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f011f527:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f52a:	0f af c2             	imul   %edx,%eax
f011f52d:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011f532:	f7 e2                	mul    %edx
f011f534:	89 d0                	mov    %edx,%eax
f011f536:	c1 e8 05             	shr    $0x5,%eax
f011f539:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011f53c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011f53f:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f011f545:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f548:	89 d1                	mov    %edx,%ecx
f011f54a:	0f af c8             	imul   %eax,%ecx
f011f54d:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f552:	f7 e1                	mul    %ecx
f011f554:	c1 ea 05             	shr    $0x5,%edx
f011f557:	89 d0                	mov    %edx,%eax
f011f559:	c1 e0 02             	shl    $0x2,%eax
f011f55c:	01 d0                	add    %edx,%eax
f011f55e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f565:	01 d0                	add    %edx,%eax
f011f567:	c1 e0 02             	shl    $0x2,%eax
f011f56a:	29 c1                	sub    %eax,%ecx
f011f56c:	89 ca                	mov    %ecx,%edx
f011f56e:	85 d2                	test   %edx,%edx
f011f570:	74 03                	je     f011f575 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x2ab>
			num_of_pages_to_be_removed++;
f011f572:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011f575:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011f578:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f011f57b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011f57e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f581:	01 c2                	add    %eax,%edx
f011f583:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f586:	01 d0                	add    %edx,%eax
}
f011f588:	c9                   	leave  
f011f589:	c3                   	ret    

f011f58a <schenv>:


void schenv()
{
f011f58a:	55                   	push   %ebp
f011f58b:	89 e5                	mov    %esp,%ebp
f011f58d:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f011f590:	c6 05 e0 51 55 f0 00 	movb   $0x0,0xf05551e0
	__ne = NULL;
f011f597:	c7 05 0c 4f 55 f0 00 	movl   $0x0,0xf0554f0c
f011f59e:	00 00 00 
	acquire_spinlock(&ProcessQueues.qlock);
f011f5a1:	83 ec 0c             	sub    $0xc,%esp
f011f5a4:	68 60 24 55 f0       	push   $0xf0552460
f011f5a9:	e8 f0 f1 fe ff       	call   f010e79e <acquire_spinlock>
f011f5ae:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011f5b1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f5b8:	eb 40                	jmp    f011f5fa <schenv+0x70>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f011f5ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f5bd:	83 c0 09             	add    $0x9,%eax
f011f5c0:	c1 e0 04             	shl    $0x4,%eax
f011f5c3:	05 60 24 55 f0       	add    $0xf0552460,%eax
f011f5c8:	83 ec 0c             	sub    $0xc,%esp
f011f5cb:	50                   	push   %eax
f011f5cc:	e8 ad 56 fe ff       	call   f0104c7e <queue_size>
f011f5d1:	83 c4 10             	add    $0x10,%esp
f011f5d4:	85 c0                	test   %eax,%eax
f011f5d6:	74 1f                	je     f011f5f7 <schenv+0x6d>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f011f5d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f5db:	83 c0 09             	add    $0x9,%eax
f011f5de:	c1 e0 04             	shl    $0x4,%eax
f011f5e1:	05 64 24 55 f0       	add    $0xf0552464,%eax
f011f5e6:	8b 00                	mov    (%eax),%eax
f011f5e8:	a3 0c 4f 55 f0       	mov    %eax,0xf0554f0c
				__nl = i;
f011f5ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f5f0:	a2 e0 51 55 f0       	mov    %al,0xf05551e0
				break;
f011f5f5:	eb 10                	jmp    f011f607 <schenv+0x7d>

	__nl = 0;
	__ne = NULL;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011f5f7:	ff 45 f4             	incl   -0xc(%ebp)
f011f5fa:	a0 60 51 55 f0       	mov    0xf0555160,%al
f011f5ff:	0f b6 c0             	movzbl %al,%eax
f011f602:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011f605:	7f b3                	jg     f011f5ba <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011f607:	83 ec 0c             	sub    $0xc,%esp
f011f60a:	68 60 24 55 f0       	push   $0xf0552460
f011f60f:	e8 11 f2 fe ff       	call   f010e825 <release_spinlock>
f011f614:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f011f617:	e8 72 ae fe ff       	call   f010a48e <get_cpu_proc>
f011f61c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f011f61f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f623:	0f 84 82 00 00 00    	je     f011f6ab <schenv+0x121>
	{
		if (__ne != NULL)
f011f629:	a1 0c 4f 55 f0       	mov    0xf0554f0c,%eax
f011f62e:	85 c0                	test   %eax,%eax
f011f630:	74 49                	je     f011f67b <schenv+0xf1>
		{
			if ((__pl + 1) < __nl)
f011f632:	a0 51 24 55 f0       	mov    0xf0552451,%al
f011f637:	0f b6 c0             	movzbl %al,%eax
f011f63a:	8d 50 01             	lea    0x1(%eax),%edx
f011f63d:	a0 e0 51 55 f0       	mov    0xf05551e0,%al
f011f642:	0f b6 c0             	movzbl %al,%eax
f011f645:	39 c2                	cmp    %eax,%edx
f011f647:	7d 62                	jge    f011f6ab <schenv+0x121>
			{
				__ne = cur_env;
f011f649:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f64c:	a3 0c 4f 55 f0       	mov    %eax,0xf0554f0c
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011f651:	a0 51 24 55 f0       	mov    0xf0552451,%al
f011f656:	0f b6 c0             	movzbl %al,%eax
f011f659:	8a 15 60 51 55 f0    	mov    0xf0555160,%dl
f011f65f:	0f b6 d2             	movzbl %dl,%edx
f011f662:	4a                   	dec    %edx
f011f663:	39 d0                	cmp    %edx,%eax
f011f665:	7d 08                	jge    f011f66f <schenv+0xe5>
f011f667:	a0 51 24 55 f0       	mov    0xf0552451,%al
f011f66c:	40                   	inc    %eax
f011f66d:	eb 05                	jmp    f011f674 <schenv+0xea>
f011f66f:	a0 51 24 55 f0       	mov    0xf0552451,%al
f011f674:	a2 e0 51 55 f0       	mov    %al,0xf05551e0
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f011f679:	eb 30                	jmp    f011f6ab <schenv+0x121>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f011f67b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f67e:	a3 0c 4f 55 f0       	mov    %eax,0xf0554f0c
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011f683:	a0 51 24 55 f0       	mov    0xf0552451,%al
f011f688:	0f b6 c0             	movzbl %al,%eax
f011f68b:	8a 15 60 51 55 f0    	mov    0xf0555160,%dl
f011f691:	0f b6 d2             	movzbl %dl,%edx
f011f694:	4a                   	dec    %edx
f011f695:	39 d0                	cmp    %edx,%eax
f011f697:	7d 08                	jge    f011f6a1 <schenv+0x117>
f011f699:	a0 51 24 55 f0       	mov    0xf0552451,%al
f011f69e:	40                   	inc    %eax
f011f69f:	eb 05                	jmp    f011f6a6 <schenv+0x11c>
f011f6a1:	a0 51 24 55 f0       	mov    0xf0552451,%al
f011f6a6:	a2 e0 51 55 f0       	mov    %al,0xf05551e0
		}
	}
}
f011f6ab:	90                   	nop
f011f6ac:	c9                   	leave  
f011f6ad:	c3                   	ret    

f011f6ae <chksch>:

void chksch(uint8 onoff)
{
f011f6ae:	55                   	push   %ebp
f011f6af:	89 e5                	mov    %esp,%ebp
f011f6b1:	83 ec 18             	sub    $0x18,%esp
f011f6b4:	8b 45 08             	mov    0x8(%ebp),%eax
f011f6b7:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011f6ba:	e8 92 6d fe ff       	call   f0106451 <isSchedMethodBSD>
f011f6bf:	85 c0                	test   %eax,%eax
f011f6c1:	74 48                	je     f011f70b <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f011f6c3:	e8 37 6d fe ff       	call   f01063ff <get_load_average>
f011f6c8:	a3 7c 51 55 f0       	mov    %eax,0xf055517c
f011f6cd:	a1 7c 51 55 f0       	mov    0xf055517c,%eax
f011f6d2:	a3 bc 4c 55 f0       	mov    %eax,0xf0554cbc
		acquire_spinlock(&ProcessQueues.qlock);
f011f6d7:	83 ec 0c             	sub    $0xc,%esp
f011f6da:	68 60 24 55 f0       	push   $0xf0552460
f011f6df:	e8 ba f0 fe ff       	call   f010e79e <acquire_spinlock>
f011f6e4:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f011f6e7:	a1 ec 24 55 f0       	mov    0xf05524ec,%eax
f011f6ec:	a3 c0 25 55 f0       	mov    %eax,0xf05525c0
		}
		release_spinlock(&ProcessQueues.qlock);
f011f6f1:	83 ec 0c             	sub    $0xc,%esp
f011f6f4:	68 60 24 55 f0       	push   $0xf0552460
f011f6f9:	e8 27 f1 fe ff       	call   f010e825 <release_spinlock>
f011f6fe:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f011f701:	c7 05 1c 4f 55 f0 01 	movl   $0x1,0xf0554f1c
f011f708:	00 00 00 
	}
	__chkstatus = onoff;
f011f70b:	8a 45 f4             	mov    -0xc(%ebp),%al
f011f70e:	a2 08 4f 55 f0       	mov    %al,0xf0554f08
}
f011f713:	90                   	nop
f011f714:	c9                   	leave  
f011f715:	c3                   	ret    

f011f716 <chk1>:
void chk1()
{
f011f716:	55                   	push   %ebp
f011f717:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f011f719:	90                   	nop
f011f71a:	5d                   	pop    %ebp
f011f71b:	c3                   	ret    

f011f71c <chk2>:
void chk2(struct Env* __se)
{
f011f71c:	55                   	push   %ebp
f011f71d:	89 e5                	mov    %esp,%ebp
f011f71f:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f011f722:	a0 08 4f 55 f0       	mov    0xf0554f08,%al
f011f727:	84 c0                	test   %al,%al
f011f729:	0f 84 59 03 00 00    	je     f011fa88 <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011f72f:	e8 1d 6d fe ff       	call   f0106451 <isSchedMethodBSD>
f011f734:	85 c0                	test   %eax,%eax
f011f736:	0f 84 4d 03 00 00    	je     f011fa89 <chk2+0x36d>
	{
		__nla = get_load_average();
f011f73c:	e8 be 6c fe ff       	call   f01063ff <get_load_average>
f011f741:	a3 e4 4b 55 f0       	mov    %eax,0xf0554be4
		acquire_spinlock(&ProcessQueues.qlock);
f011f746:	83 ec 0c             	sub    $0xc,%esp
f011f749:	68 60 24 55 f0       	push   $0xf0552460
f011f74e:	e8 4b f0 fe ff       	call   f010e79e <acquire_spinlock>
f011f753:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011f756:	a1 ec 24 55 f0       	mov    0xf05524ec,%eax
f011f75b:	a3 10 4f 55 f0       	mov    %eax,0xf0554f10
		}
		release_spinlock(&ProcessQueues.qlock);
f011f760:	83 ec 0c             	sub    $0xc,%esp
f011f763:	68 60 24 55 f0       	push   $0xf0552460
f011f768:	e8 b8 f0 fe ff       	call   f010e825 <release_spinlock>
f011f76d:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f011f770:	a1 1c 4f 55 f0       	mov    0xf0554f1c,%eax
f011f775:	85 c0                	test   %eax,%eax
f011f777:	74 72                	je     f011f7eb <chk2+0xcf>
		{
			acquire_spinlock(&ProcessQueues.qlock);
f011f779:	83 ec 0c             	sub    $0xc,%esp
f011f77c:	68 60 24 55 f0       	push   $0xf0552460
f011f781:	e8 18 f0 fe ff       	call   f010e79e <acquire_spinlock>
f011f786:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f011f789:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f78d:	0f 95 c0             	setne  %al
f011f790:	0f b6 c0             	movzbl %al,%eax
f011f793:	a3 d4 50 55 f0       	mov    %eax,0xf05550d4
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011f798:	a0 60 51 55 f0       	mov    0xf0555160,%al
f011f79d:	0f b6 c0             	movzbl %al,%eax
f011f7a0:	48                   	dec    %eax
f011f7a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f7a4:	eb 20                	jmp    f011f7c6 <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011f7a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f7a9:	83 c0 09             	add    $0x9,%eax
f011f7ac:	c1 e0 04             	shl    $0x4,%eax
f011f7af:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f011f7b4:	8b 00                	mov    (%eax),%eax
f011f7b6:	8b 15 d4 50 55 f0    	mov    0xf05550d4,%edx
f011f7bc:	01 d0                	add    %edx,%eax
f011f7be:	a3 d4 50 55 f0       	mov    %eax,0xf05550d4
		{
			acquire_spinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011f7c3:	ff 4d f4             	decl   -0xc(%ebp)
f011f7c6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f7ca:	79 da                	jns    f011f7a6 <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f011f7cc:	c7 05 1c 4f 55 f0 00 	movl   $0x0,0xf0554f1c
f011f7d3:	00 00 00 
			}
			release_spinlock(&ProcessQueues.qlock);
f011f7d6:	83 ec 0c             	sub    $0xc,%esp
f011f7d9:	68 60 24 55 f0       	push   $0xf0552460
f011f7de:	e8 42 f0 fe ff       	call   f010e825 <release_spinlock>
f011f7e3:	83 c4 10             	add    $0x10,%esp
f011f7e6:	e9 91 02 00 00       	jmp    f011fa7c <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f011f7eb:	8b 15 c0 25 55 f0    	mov    0xf05525c0,%edx
f011f7f1:	a1 10 4f 55 f0       	mov    0xf0554f10,%eax
f011f7f6:	39 c2                	cmp    %eax,%edx
f011f7f8:	74 63                	je     f011f85d <chk2+0x141>
			{
				acquire_spinlock(&ProcessQueues.qlock);
f011f7fa:	83 ec 0c             	sub    $0xc,%esp
f011f7fd:	68 60 24 55 f0       	push   $0xf0552460
f011f802:	e8 97 ef fe ff       	call   f010e79e <acquire_spinlock>
f011f807:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f011f80a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f80e:	0f 95 c0             	setne  %al
f011f811:	0f b6 c0             	movzbl %al,%eax
f011f814:	a3 d4 50 55 f0       	mov    %eax,0xf05550d4
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011f819:	a0 60 51 55 f0       	mov    0xf0555160,%al
f011f81e:	0f b6 c0             	movzbl %al,%eax
f011f821:	48                   	dec    %eax
f011f822:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f825:	eb 20                	jmp    f011f847 <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011f827:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f82a:	83 c0 09             	add    $0x9,%eax
f011f82d:	c1 e0 04             	shl    $0x4,%eax
f011f830:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f011f835:	8b 00                	mov    (%eax),%eax
f011f837:	8b 15 d4 50 55 f0    	mov    0xf05550d4,%edx
f011f83d:	01 d0                	add    %edx,%eax
f011f83f:	a3 d4 50 55 f0       	mov    %eax,0xf05550d4
			{
				acquire_spinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011f844:	ff 4d f0             	decl   -0x10(%ebp)
f011f847:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f84b:	79 da                	jns    f011f827 <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_spinlock(&ProcessQueues.qlock);
f011f84d:	83 ec 0c             	sub    $0xc,%esp
f011f850:	68 60 24 55 f0       	push   $0xf0552460
f011f855:	e8 cb ef fe ff       	call   f010e825 <release_spinlock>
f011f85a:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f011f85d:	e8 36 6b fe ff       	call   f0106398 <timer_ticks>
f011f862:	6a 00                	push   $0x0
f011f864:	68 e8 03 00 00       	push   $0x3e8
f011f869:	52                   	push   %edx
f011f86a:	50                   	push   %eax
f011f86b:	e8 38 1a 00 00       	call   f01212a8 <__moddi3>
f011f870:	83 c4 10             	add    $0x10,%esp
f011f873:	09 d0                	or     %edx,%eax
f011f875:	85 c0                	test   %eax,%eax
f011f877:	75 32                	jne    f011f8ab <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f011f879:	8b 15 bc 4c 55 f0    	mov    0xf0554cbc,%edx
f011f87f:	a1 e4 4b 55 f0       	mov    0xf0554be4,%eax
f011f884:	39 c2                	cmp    %eax,%edx
f011f886:	75 19                	jne    f011f8a1 <chk2+0x185>
f011f888:	68 99 d6 12 f0       	push   $0xf012d699
f011f88d:	68 b7 d3 12 f0       	push   $0xf012d3b7
f011f892:	68 f4 01 00 00       	push   $0x1f4
f011f897:	68 ff d3 12 f0       	push   $0xf012d3ff
f011f89c:	e8 09 0b fe ff       	call   f01003aa <_panic_all>
				__histla = __nla;
f011f8a1:	a1 e4 4b 55 f0       	mov    0xf0554be4,%eax
f011f8a6:	a3 bc 4c 55 f0       	mov    %eax,0xf0554cbc
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f011f8ab:	e8 e8 6a fe ff       	call   f0106398 <timer_ticks>
f011f8b0:	6a 00                	push   $0x0
f011f8b2:	6a 64                	push   $0x64
f011f8b4:	52                   	push   %edx
f011f8b5:	50                   	push   %eax
f011f8b6:	e8 ed 19 00 00       	call   f01212a8 <__moddi3>
f011f8bb:	83 c4 10             	add    $0x10,%esp
f011f8be:	09 d0                	or     %edx,%eax
f011f8c0:	85 c0                	test   %eax,%eax
f011f8c2:	0f 85 b4 01 00 00    	jne    f011fa7c <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f011f8c8:	8b 0d 7c 51 55 f0    	mov    0xf055517c,%ecx
f011f8ce:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f8d3:	f7 e9                	imul   %ecx
f011f8d5:	c1 fa 05             	sar    $0x5,%edx
f011f8d8:	89 c8                	mov    %ecx,%eax
f011f8da:	c1 f8 1f             	sar    $0x1f,%eax
f011f8dd:	29 c2                	sub    %eax,%edx
f011f8df:	89 d0                	mov    %edx,%eax
f011f8e1:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f011f8e4:	8b 0d 7c 51 55 f0    	mov    0xf055517c,%ecx
f011f8ea:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f8ef:	f7 e9                	imul   %ecx
f011f8f1:	c1 fa 05             	sar    $0x5,%edx
f011f8f4:	89 c8                	mov    %ecx,%eax
f011f8f6:	c1 f8 1f             	sar    $0x1f,%eax
f011f8f9:	29 c2                	sub    %eax,%edx
f011f8fb:	89 d0                	mov    %edx,%eax
f011f8fd:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011f900:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011f903:	89 d0                	mov    %edx,%eax
f011f905:	c1 e0 02             	shl    $0x2,%eax
f011f908:	01 d0                	add    %edx,%eax
f011f90a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f911:	01 d0                	add    %edx,%eax
f011f913:	c1 e0 02             	shl    $0x2,%eax
f011f916:	29 c1                	sub    %eax,%ecx
f011f918:	89 c8                	mov    %ecx,%eax
f011f91a:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f011f91d:	8b 0d e4 4b 55 f0    	mov    0xf0554be4,%ecx
f011f923:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f928:	f7 e9                	imul   %ecx
f011f92a:	c1 fa 05             	sar    $0x5,%edx
f011f92d:	89 c8                	mov    %ecx,%eax
f011f92f:	c1 f8 1f             	sar    $0x1f,%eax
f011f932:	29 c2                	sub    %eax,%edx
f011f934:	89 d0                	mov    %edx,%eax
f011f936:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f011f939:	8b 0d e4 4b 55 f0    	mov    0xf0554be4,%ecx
f011f93f:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f944:	f7 e9                	imul   %ecx
f011f946:	c1 fa 05             	sar    $0x5,%edx
f011f949:	89 c8                	mov    %ecx,%eax
f011f94b:	c1 f8 1f             	sar    $0x1f,%eax
f011f94e:	29 c2                	sub    %eax,%edx
f011f950:	89 d0                	mov    %edx,%eax
f011f952:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011f955:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f958:	89 d0                	mov    %edx,%eax
f011f95a:	c1 e0 02             	shl    $0x2,%eax
f011f95d:	01 d0                	add    %edx,%eax
f011f95f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f966:	01 d0                	add    %edx,%eax
f011f968:	c1 e0 02             	shl    $0x2,%eax
f011f96b:	29 c1                	sub    %eax,%ecx
f011f96d:	89 c8                	mov    %ecx,%eax
f011f96f:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f011f972:	8b 15 10 4f 55 f0    	mov    0xf0554f10,%edx
f011f978:	a1 c0 25 55 f0       	mov    0xf05525c0,%eax
f011f97d:	39 c2                	cmp    %eax,%edx
f011f97f:	0f 85 ed 00 00 00    	jne    f011fa72 <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f011f985:	a1 d4 50 55 f0       	mov    0xf05550d4,%eax
f011f98a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f98d:	7e 5b                	jle    f011f9ea <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011f98f:	a1 d4 50 55 f0       	mov    0xf05550d4,%eax
f011f994:	83 ec 08             	sub    $0x8,%esp
f011f997:	ff 75 e0             	pushl  -0x20(%ebp)
f011f99a:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f99d:	ff 75 e8             	pushl  -0x18(%ebp)
f011f9a0:	ff 75 ec             	pushl  -0x14(%ebp)
f011f9a3:	50                   	push   %eax
f011f9a4:	68 ac d6 12 f0       	push   $0xf012d6ac
f011f9a9:	e8 be 15 fe ff       	call   f0100f6c <cprintf>
f011f9ae:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f011f9b1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f9b4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f9b7:	0f 8f b5 00 00 00    	jg     f011fa72 <chk2+0x356>
f011f9bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f9c0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f9c3:	75 0c                	jne    f011f9d1 <chk2+0x2b5>
f011f9c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f9c8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011f9cb:	0f 8d a1 00 00 00    	jge    f011fa72 <chk2+0x356>
f011f9d1:	68 f4 d6 12 f0       	push   $0xf012d6f4
f011f9d6:	68 b7 d3 12 f0       	push   $0xf012d3b7
f011f9db:	68 09 02 00 00       	push   $0x209
f011f9e0:	68 ff d3 12 f0       	push   $0xf012d3ff
f011f9e5:	e8 c0 09 fe ff       	call   f01003aa <_panic_all>
					}
					else if (__nproc < plaint)
f011f9ea:	a1 d4 50 55 f0       	mov    0xf05550d4,%eax
f011f9ef:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f9f2:	7d 53                	jge    f011fa47 <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011f9f4:	a1 d4 50 55 f0       	mov    0xf05550d4,%eax
f011f9f9:	83 ec 08             	sub    $0x8,%esp
f011f9fc:	ff 75 e0             	pushl  -0x20(%ebp)
f011f9ff:	ff 75 e4             	pushl  -0x1c(%ebp)
f011fa02:	ff 75 e8             	pushl  -0x18(%ebp)
f011fa05:	ff 75 ec             	pushl  -0x14(%ebp)
f011fa08:	50                   	push   %eax
f011fa09:	68 34 d7 12 f0       	push   $0xf012d734
f011fa0e:	e8 59 15 fe ff       	call   f0100f6c <cprintf>
f011fa13:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f011fa16:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011fa19:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011fa1c:	7c 54                	jl     f011fa72 <chk2+0x356>
f011fa1e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011fa21:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011fa24:	75 08                	jne    f011fa2e <chk2+0x312>
f011fa26:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011fa29:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011fa2c:	7e 44                	jle    f011fa72 <chk2+0x356>
f011fa2e:	68 7c d7 12 f0       	push   $0xf012d77c
f011fa33:	68 b7 d3 12 f0       	push   $0xf012d3b7
f011fa38:	68 0f 02 00 00       	push   $0x20f
f011fa3d:	68 ff d3 12 f0       	push   $0xf012d3ff
f011fa42:	e8 63 09 fe ff       	call   f01003aa <_panic_all>
					}
					else if (__nproc == plaint)
f011fa47:	a1 d4 50 55 f0       	mov    0xf05550d4,%eax
f011fa4c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011fa4f:	75 21                	jne    f011fa72 <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f011fa51:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011fa54:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011fa57:	74 19                	je     f011fa72 <chk2+0x356>
f011fa59:	68 bc d7 12 f0       	push   $0xf012d7bc
f011fa5e:	68 b7 d3 12 f0       	push   $0xf012d3b7
f011fa63:	68 13 02 00 00       	push   $0x213
f011fa68:	68 ff d3 12 f0       	push   $0xf012d3ff
f011fa6d:	e8 38 09 fe ff       	call   f01003aa <_panic_all>
					}
				}
				__pla = __nla;
f011fa72:	a1 e4 4b 55 f0       	mov    0xf0554be4,%eax
f011fa77:	a3 7c 51 55 f0       	mov    %eax,0xf055517c
			}
		}
		__pnexit = __nnexit;
f011fa7c:	a1 10 4f 55 f0       	mov    0xf0554f10,%eax
f011fa81:	a3 c0 25 55 f0       	mov    %eax,0xf05525c0
f011fa86:	eb 01                	jmp    f011fa89 <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f011fa88:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f011fa89:	c9                   	leave  
f011fa8a:	c3                   	ret    

f011fa8b <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f011fa8b:	55                   	push   %ebp
f011fa8c:	89 e5                	mov    %esp,%ebp
f011fa8e:	83 ec 18             	sub    $0x18,%esp
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#else
	{
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
f011fa91:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011fa98:	eb 40                	jmp    f011fada <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f011fa9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fa9d:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011faa3:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011faa8:	83 ec 08             	sub    $0x8,%esp
f011faab:	52                   	push   %edx
f011faac:	50                   	push   %eax
f011faad:	e8 a6 01 00 00       	call   f011fc58 <check_va2pa>
f011fab2:	83 c4 10             	add    $0x10,%esp
f011fab5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011fab8:	74 19                	je     f011fad3 <check_boot_pgdir+0x48>
f011faba:	68 d0 d7 12 f0       	push   $0xf012d7d0
f011fabf:	68 b7 d3 12 f0       	push   $0xf012d3b7
f011fac4:	68 5f 02 00 00       	push   $0x25f
f011fac9:	68 ff d3 12 f0       	push   $0xf012d3ff
f011face:	e8 47 08 fe ff       	call   f010031a <_panic>
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#else
	{
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
f011fad3:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011fada:	81 7d f4 00 00 00 10 	cmpl   $0x10000000,-0xc(%ebp)
f011fae1:	75 b7                	jne    f011fa9a <check_boot_pgdir+0xf>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011fae3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011faea:	e9 81 00 00 00       	jmp    f011fb70 <check_boot_pgdir+0xe5>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f011faef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011faf2:	25 ff 7f 00 00       	and    $0x7fff,%eax
f011faf7:	85 c0                	test   %eax,%eax
f011faf9:	74 6d                	je     f011fb68 <check_boot_pgdir+0xdd>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f011fafb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fafe:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f011fb04:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011fb09:	83 ec 08             	sub    $0x8,%esp
f011fb0c:	52                   	push   %edx
f011fb0d:	50                   	push   %eax
f011fb0e:	e8 45 01 00 00       	call   f011fc58 <check_va2pa>
f011fb13:	83 c4 10             	add    $0x10,%esp
f011fb16:	c7 45 f0 00 10 17 f0 	movl   $0xf0171000,-0x10(%ebp)
f011fb1d:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f011fb24:	77 17                	ja     f011fb3d <check_boot_pgdir+0xb2>
f011fb26:	ff 75 f0             	pushl  -0x10(%ebp)
f011fb29:	68 08 d8 12 f0       	push   $0xf012d808
f011fb2e:	68 68 02 00 00       	push   $0x268
f011fb33:	68 ff d3 12 f0       	push   $0xf012d3ff
f011fb38:	e8 dd 07 fe ff       	call   f010031a <_panic>
f011fb3d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011fb40:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f011fb46:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fb49:	01 ca                	add    %ecx,%edx
f011fb4b:	39 d0                	cmp    %edx,%eax
f011fb4d:	74 1a                	je     f011fb69 <check_boot_pgdir+0xde>
f011fb4f:	68 3c d8 12 f0       	push   $0xf012d83c
f011fb54:	68 b7 d3 12 f0       	push   $0xf012d3b7
f011fb59:	68 68 02 00 00       	push   $0x268
f011fb5e:	68 ff d3 12 f0       	push   $0xf012d3ff
f011fb63:	e8 b2 07 fe ff       	call   f010031a <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f011fb68:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011fb69:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011fb70:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f011fb77:	0f 86 72 ff ff ff    	jbe    f011faef <check_boot_pgdir+0x64>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011fb7d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011fb84:	e9 af 00 00 00       	jmp    f011fc38 <check_boot_pgdir+0x1ad>
		switch (i) {
f011fb89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb8c:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011fb91:	74 11                	je     f011fba4 <check_boot_pgdir+0x119>
f011fb93:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011fb98:	72 36                	jb     f011fbd0 <check_boot_pgdir+0x145>
f011fb9a:	2d bd 03 00 00       	sub    $0x3bd,%eax
f011fb9f:	83 f8 02             	cmp    $0x2,%eax
f011fba2:	77 2c                	ja     f011fbd0 <check_boot_pgdir+0x145>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f011fba4:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011fba9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fbac:	c1 e2 02             	shl    $0x2,%edx
f011fbaf:	01 d0                	add    %edx,%eax
f011fbb1:	8b 00                	mov    (%eax),%eax
f011fbb3:	85 c0                	test   %eax,%eax
f011fbb5:	75 7a                	jne    f011fc31 <check_boot_pgdir+0x1a6>
f011fbb7:	68 c2 d8 12 f0       	push   $0xf012d8c2
f011fbbc:	68 b7 d3 12 f0       	push   $0xf012d3b7
f011fbc1:	68 73 02 00 00       	push   $0x273
f011fbc6:	68 ff d3 12 f0       	push   $0xf012d3ff
f011fbcb:	e8 4a 07 fe ff       	call   f010031a <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f011fbd0:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f011fbd7:	76 2c                	jbe    f011fc05 <check_boot_pgdir+0x17a>
				assert(ptr_page_directory[i]);
f011fbd9:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011fbde:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fbe1:	c1 e2 02             	shl    $0x2,%edx
f011fbe4:	01 d0                	add    %edx,%eax
f011fbe6:	8b 00                	mov    (%eax),%eax
f011fbe8:	85 c0                	test   %eax,%eax
f011fbea:	75 48                	jne    f011fc34 <check_boot_pgdir+0x1a9>
f011fbec:	68 c2 d8 12 f0       	push   $0xf012d8c2
f011fbf1:	68 b7 d3 12 f0       	push   $0xf012d3b7
f011fbf6:	68 77 02 00 00       	push   $0x277
f011fbfb:	68 ff d3 12 f0       	push   $0xf012d3ff
f011fc00:	e8 15 07 fe ff       	call   f010031a <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f011fc05:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011fc0a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fc0d:	c1 e2 02             	shl    $0x2,%edx
f011fc10:	01 d0                	add    %edx,%eax
f011fc12:	8b 00                	mov    (%eax),%eax
f011fc14:	85 c0                	test   %eax,%eax
f011fc16:	74 1c                	je     f011fc34 <check_boot_pgdir+0x1a9>
f011fc18:	68 d8 d8 12 f0       	push   $0xf012d8d8
f011fc1d:	68 b7 d3 12 f0       	push   $0xf012d3b7
f011fc22:	68 79 02 00 00       	push   $0x279
f011fc27:	68 ff d3 12 f0       	push   $0xf012d3ff
f011fc2c:	e8 e9 06 fe ff       	call   f010031a <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f011fc31:	90                   	nop
f011fc32:	eb 01                	jmp    f011fc35 <check_boot_pgdir+0x1aa>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f011fc34:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011fc35:	ff 45 f4             	incl   -0xc(%ebp)
f011fc38:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011fc3f:	0f 86 44 ff ff ff    	jbe    f011fb89 <check_boot_pgdir+0xfe>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f011fc45:	83 ec 0c             	sub    $0xc,%esp
f011fc48:	68 f4 d8 12 f0       	push   $0xf012d8f4
f011fc4d:	e8 1a 13 fe ff       	call   f0100f6c <cprintf>
f011fc52:	83 c4 10             	add    $0x10,%esp
}
f011fc55:	90                   	nop
f011fc56:	c9                   	leave  
f011fc57:	c3                   	ret    

f011fc58 <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f011fc58:	55                   	push   %ebp
f011fc59:	89 e5                	mov    %esp,%ebp
f011fc5b:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f011fc5e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fc61:	c1 e8 16             	shr    $0x16,%eax
f011fc64:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011fc6b:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc6e:	01 d0                	add    %edx,%eax
f011fc70:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f011fc73:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc76:	8b 00                	mov    (%eax),%eax
f011fc78:	83 e0 01             	and    $0x1,%eax
f011fc7b:	85 c0                	test   %eax,%eax
f011fc7d:	75 0a                	jne    f011fc89 <check_va2pa+0x31>
		return ~0;
f011fc7f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011fc84:	e9 87 00 00 00       	jmp    f011fd10 <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f011fc89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc8c:	8b 00                	mov    (%eax),%eax
f011fc8e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011fc93:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fc96:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fc99:	c1 e8 0c             	shr    $0xc,%eax
f011fc9c:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011fc9f:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f011fca4:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011fca7:	72 17                	jb     f011fcc0 <check_va2pa+0x68>
f011fca9:	ff 75 f0             	pushl  -0x10(%ebp)
f011fcac:	68 18 d9 12 f0       	push   $0xf012d918
f011fcb1:	68 8f 02 00 00       	push   $0x28f
f011fcb6:	68 ff d3 12 f0       	push   $0xf012d3ff
f011fcbb:	e8 5a 06 fe ff       	call   f010031a <_panic>
f011fcc0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fcc3:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011fcc8:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f011fccb:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fcce:	c1 e8 0c             	shr    $0xc,%eax
f011fcd1:	25 ff 03 00 00       	and    $0x3ff,%eax
f011fcd6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011fcdd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011fce0:	01 d0                	add    %edx,%eax
f011fce2:	8b 00                	mov    (%eax),%eax
f011fce4:	83 e0 01             	and    $0x1,%eax
f011fce7:	85 c0                	test   %eax,%eax
f011fce9:	75 07                	jne    f011fcf2 <check_va2pa+0x9a>
		return ~0;
f011fceb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011fcf0:	eb 1e                	jmp    f011fd10 <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f011fcf2:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fcf5:	c1 e8 0c             	shr    $0xc,%eax
f011fcf8:	25 ff 03 00 00       	and    $0x3ff,%eax
f011fcfd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011fd04:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011fd07:	01 d0                	add    %edx,%eax
f011fd09:	8b 00                	mov    (%eax),%eax
f011fd0b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f011fd10:	c9                   	leave  
f011fd11:	c3                   	ret    

f011fd12 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f011fd12:	55                   	push   %ebp
f011fd13:	89 e5                	mov    %esp,%ebp
f011fd15:	53                   	push   %ebx
f011fd16:	83 ec 14             	sub    $0x14,%esp
f011fd19:	8b 45 10             	mov    0x10(%ebp),%eax
f011fd1c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fd1f:	8b 45 14             	mov    0x14(%ebp),%eax
f011fd22:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f011fd25:	8b 45 18             	mov    0x18(%ebp),%eax
f011fd28:	ba 00 00 00 00       	mov    $0x0,%edx
f011fd2d:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011fd30:	77 55                	ja     f011fd87 <printnum+0x75>
f011fd32:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011fd35:	72 05                	jb     f011fd3c <printnum+0x2a>
f011fd37:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011fd3a:	77 4b                	ja     f011fd87 <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f011fd3c:	8b 45 1c             	mov    0x1c(%ebp),%eax
f011fd3f:	8d 58 ff             	lea    -0x1(%eax),%ebx
f011fd42:	8b 45 18             	mov    0x18(%ebp),%eax
f011fd45:	ba 00 00 00 00       	mov    $0x0,%edx
f011fd4a:	52                   	push   %edx
f011fd4b:	50                   	push   %eax
f011fd4c:	ff 75 f4             	pushl  -0xc(%ebp)
f011fd4f:	ff 75 f0             	pushl  -0x10(%ebp)
f011fd52:	e8 e9 16 00 00       	call   f0121440 <__udivdi3>
f011fd57:	83 c4 10             	add    $0x10,%esp
f011fd5a:	83 ec 04             	sub    $0x4,%esp
f011fd5d:	ff 75 20             	pushl  0x20(%ebp)
f011fd60:	53                   	push   %ebx
f011fd61:	ff 75 18             	pushl  0x18(%ebp)
f011fd64:	52                   	push   %edx
f011fd65:	50                   	push   %eax
f011fd66:	ff 75 0c             	pushl  0xc(%ebp)
f011fd69:	ff 75 08             	pushl  0x8(%ebp)
f011fd6c:	e8 a1 ff ff ff       	call   f011fd12 <printnum>
f011fd71:	83 c4 20             	add    $0x20,%esp
f011fd74:	eb 1a                	jmp    f011fd90 <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f011fd76:	83 ec 08             	sub    $0x8,%esp
f011fd79:	ff 75 0c             	pushl  0xc(%ebp)
f011fd7c:	ff 75 20             	pushl  0x20(%ebp)
f011fd7f:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd82:	ff d0                	call   *%eax
f011fd84:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f011fd87:	ff 4d 1c             	decl   0x1c(%ebp)
f011fd8a:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f011fd8e:	7f e6                	jg     f011fd76 <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f011fd90:	8b 4d 18             	mov    0x18(%ebp),%ecx
f011fd93:	bb 00 00 00 00       	mov    $0x0,%ebx
f011fd98:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fd9b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fd9e:	53                   	push   %ebx
f011fd9f:	51                   	push   %ecx
f011fda0:	52                   	push   %edx
f011fda1:	50                   	push   %eax
f011fda2:	e8 a9 17 00 00       	call   f0121550 <__umoddi3>
f011fda7:	83 c4 10             	add    $0x10,%esp
f011fdaa:	05 74 db 12 f0       	add    $0xf012db74,%eax
f011fdaf:	8a 00                	mov    (%eax),%al
f011fdb1:	0f be c0             	movsbl %al,%eax
f011fdb4:	83 ec 08             	sub    $0x8,%esp
f011fdb7:	ff 75 0c             	pushl  0xc(%ebp)
f011fdba:	50                   	push   %eax
f011fdbb:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdbe:	ff d0                	call   *%eax
f011fdc0:	83 c4 10             	add    $0x10,%esp
}
f011fdc3:	90                   	nop
f011fdc4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011fdc7:	c9                   	leave  
f011fdc8:	c3                   	ret    

f011fdc9 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f011fdc9:	55                   	push   %ebp
f011fdca:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011fdcc:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011fdd0:	7e 1c                	jle    f011fdee <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f011fdd2:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdd5:	8b 00                	mov    (%eax),%eax
f011fdd7:	8d 50 08             	lea    0x8(%eax),%edx
f011fdda:	8b 45 08             	mov    0x8(%ebp),%eax
f011fddd:	89 10                	mov    %edx,(%eax)
f011fddf:	8b 45 08             	mov    0x8(%ebp),%eax
f011fde2:	8b 00                	mov    (%eax),%eax
f011fde4:	83 e8 08             	sub    $0x8,%eax
f011fde7:	8b 50 04             	mov    0x4(%eax),%edx
f011fdea:	8b 00                	mov    (%eax),%eax
f011fdec:	eb 40                	jmp    f011fe2e <getuint+0x65>
	else if (lflag)
f011fdee:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011fdf2:	74 1e                	je     f011fe12 <getuint+0x49>
		return va_arg(*ap, unsigned long);
f011fdf4:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdf7:	8b 00                	mov    (%eax),%eax
f011fdf9:	8d 50 04             	lea    0x4(%eax),%edx
f011fdfc:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdff:	89 10                	mov    %edx,(%eax)
f011fe01:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe04:	8b 00                	mov    (%eax),%eax
f011fe06:	83 e8 04             	sub    $0x4,%eax
f011fe09:	8b 00                	mov    (%eax),%eax
f011fe0b:	ba 00 00 00 00       	mov    $0x0,%edx
f011fe10:	eb 1c                	jmp    f011fe2e <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f011fe12:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe15:	8b 00                	mov    (%eax),%eax
f011fe17:	8d 50 04             	lea    0x4(%eax),%edx
f011fe1a:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe1d:	89 10                	mov    %edx,(%eax)
f011fe1f:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe22:	8b 00                	mov    (%eax),%eax
f011fe24:	83 e8 04             	sub    $0x4,%eax
f011fe27:	8b 00                	mov    (%eax),%eax
f011fe29:	ba 00 00 00 00       	mov    $0x0,%edx
}
f011fe2e:	5d                   	pop    %ebp
f011fe2f:	c3                   	ret    

f011fe30 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f011fe30:	55                   	push   %ebp
f011fe31:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011fe33:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011fe37:	7e 1c                	jle    f011fe55 <getint+0x25>
		return va_arg(*ap, long long);
f011fe39:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe3c:	8b 00                	mov    (%eax),%eax
f011fe3e:	8d 50 08             	lea    0x8(%eax),%edx
f011fe41:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe44:	89 10                	mov    %edx,(%eax)
f011fe46:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe49:	8b 00                	mov    (%eax),%eax
f011fe4b:	83 e8 08             	sub    $0x8,%eax
f011fe4e:	8b 50 04             	mov    0x4(%eax),%edx
f011fe51:	8b 00                	mov    (%eax),%eax
f011fe53:	eb 38                	jmp    f011fe8d <getint+0x5d>
	else if (lflag)
f011fe55:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011fe59:	74 1a                	je     f011fe75 <getint+0x45>
		return va_arg(*ap, long);
f011fe5b:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe5e:	8b 00                	mov    (%eax),%eax
f011fe60:	8d 50 04             	lea    0x4(%eax),%edx
f011fe63:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe66:	89 10                	mov    %edx,(%eax)
f011fe68:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe6b:	8b 00                	mov    (%eax),%eax
f011fe6d:	83 e8 04             	sub    $0x4,%eax
f011fe70:	8b 00                	mov    (%eax),%eax
f011fe72:	99                   	cltd   
f011fe73:	eb 18                	jmp    f011fe8d <getint+0x5d>
	else
		return va_arg(*ap, int);
f011fe75:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe78:	8b 00                	mov    (%eax),%eax
f011fe7a:	8d 50 04             	lea    0x4(%eax),%edx
f011fe7d:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe80:	89 10                	mov    %edx,(%eax)
f011fe82:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe85:	8b 00                	mov    (%eax),%eax
f011fe87:	83 e8 04             	sub    $0x4,%eax
f011fe8a:	8b 00                	mov    (%eax),%eax
f011fe8c:	99                   	cltd   
}
f011fe8d:	5d                   	pop    %ebp
f011fe8e:	c3                   	ret    

f011fe8f <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f011fe8f:	55                   	push   %ebp
f011fe90:	89 e5                	mov    %esp,%ebp
f011fe92:	56                   	push   %esi
f011fe93:	53                   	push   %ebx
f011fe94:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011fe97:	eb 17                	jmp    f011feb0 <vprintfmt+0x21>
			if (ch == '\0')
f011fe99:	85 db                	test   %ebx,%ebx
f011fe9b:	0f 84 c1 03 00 00    	je     f0120262 <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f011fea1:	83 ec 08             	sub    $0x8,%esp
f011fea4:	ff 75 0c             	pushl  0xc(%ebp)
f011fea7:	53                   	push   %ebx
f011fea8:	8b 45 08             	mov    0x8(%ebp),%eax
f011feab:	ff d0                	call   *%eax
f011fead:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011feb0:	8b 45 10             	mov    0x10(%ebp),%eax
f011feb3:	8d 50 01             	lea    0x1(%eax),%edx
f011feb6:	89 55 10             	mov    %edx,0x10(%ebp)
f011feb9:	8a 00                	mov    (%eax),%al
f011febb:	0f b6 d8             	movzbl %al,%ebx
f011febe:	83 fb 25             	cmp    $0x25,%ebx
f011fec1:	75 d6                	jne    f011fe99 <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f011fec3:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f011fec7:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f011fece:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f011fed5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f011fedc:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f011fee3:	8b 45 10             	mov    0x10(%ebp),%eax
f011fee6:	8d 50 01             	lea    0x1(%eax),%edx
f011fee9:	89 55 10             	mov    %edx,0x10(%ebp)
f011feec:	8a 00                	mov    (%eax),%al
f011feee:	0f b6 d8             	movzbl %al,%ebx
f011fef1:	8d 43 dd             	lea    -0x23(%ebx),%eax
f011fef4:	83 f8 5b             	cmp    $0x5b,%eax
f011fef7:	0f 87 3d 03 00 00    	ja     f012023a <vprintfmt+0x3ab>
f011fefd:	8b 04 85 98 db 12 f0 	mov    -0xfed2468(,%eax,4),%eax
f011ff04:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f011ff06:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f011ff0a:	eb d7                	jmp    f011fee3 <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f011ff0c:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f011ff10:	eb d1                	jmp    f011fee3 <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011ff12:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f011ff19:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011ff1c:	89 d0                	mov    %edx,%eax
f011ff1e:	c1 e0 02             	shl    $0x2,%eax
f011ff21:	01 d0                	add    %edx,%eax
f011ff23:	01 c0                	add    %eax,%eax
f011ff25:	01 d8                	add    %ebx,%eax
f011ff27:	83 e8 30             	sub    $0x30,%eax
f011ff2a:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f011ff2d:	8b 45 10             	mov    0x10(%ebp),%eax
f011ff30:	8a 00                	mov    (%eax),%al
f011ff32:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f011ff35:	83 fb 2f             	cmp    $0x2f,%ebx
f011ff38:	7e 3e                	jle    f011ff78 <vprintfmt+0xe9>
f011ff3a:	83 fb 39             	cmp    $0x39,%ebx
f011ff3d:	7f 39                	jg     f011ff78 <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011ff3f:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f011ff42:	eb d5                	jmp    f011ff19 <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f011ff44:	8b 45 14             	mov    0x14(%ebp),%eax
f011ff47:	83 c0 04             	add    $0x4,%eax
f011ff4a:	89 45 14             	mov    %eax,0x14(%ebp)
f011ff4d:	8b 45 14             	mov    0x14(%ebp),%eax
f011ff50:	83 e8 04             	sub    $0x4,%eax
f011ff53:	8b 00                	mov    (%eax),%eax
f011ff55:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f011ff58:	eb 1f                	jmp    f011ff79 <vprintfmt+0xea>

		case '.':
			if (width < 0)
f011ff5a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011ff5e:	79 83                	jns    f011fee3 <vprintfmt+0x54>
				width = 0;
f011ff60:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f011ff67:	e9 77 ff ff ff       	jmp    f011fee3 <vprintfmt+0x54>

		case '#':
			altflag = 1;
f011ff6c:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f011ff73:	e9 6b ff ff ff       	jmp    f011fee3 <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f011ff78:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f011ff79:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011ff7d:	0f 89 60 ff ff ff    	jns    f011fee3 <vprintfmt+0x54>
				width = precision, precision = -1;
f011ff83:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ff86:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011ff89:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f011ff90:	e9 4e ff ff ff       	jmp    f011fee3 <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f011ff95:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f011ff98:	e9 46 ff ff ff       	jmp    f011fee3 <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f011ff9d:	8b 45 14             	mov    0x14(%ebp),%eax
f011ffa0:	83 c0 04             	add    $0x4,%eax
f011ffa3:	89 45 14             	mov    %eax,0x14(%ebp)
f011ffa6:	8b 45 14             	mov    0x14(%ebp),%eax
f011ffa9:	83 e8 04             	sub    $0x4,%eax
f011ffac:	8b 00                	mov    (%eax),%eax
f011ffae:	83 ec 08             	sub    $0x8,%esp
f011ffb1:	ff 75 0c             	pushl  0xc(%ebp)
f011ffb4:	50                   	push   %eax
f011ffb5:	8b 45 08             	mov    0x8(%ebp),%eax
f011ffb8:	ff d0                	call   *%eax
f011ffba:	83 c4 10             	add    $0x10,%esp
			break;
f011ffbd:	e9 9b 02 00 00       	jmp    f012025d <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f011ffc2:	8b 45 14             	mov    0x14(%ebp),%eax
f011ffc5:	83 c0 04             	add    $0x4,%eax
f011ffc8:	89 45 14             	mov    %eax,0x14(%ebp)
f011ffcb:	8b 45 14             	mov    0x14(%ebp),%eax
f011ffce:	83 e8 04             	sub    $0x4,%eax
f011ffd1:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f011ffd3:	85 db                	test   %ebx,%ebx
f011ffd5:	79 02                	jns    f011ffd9 <vprintfmt+0x14a>
				err = -err;
f011ffd7:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f011ffd9:	83 fb 64             	cmp    $0x64,%ebx
f011ffdc:	7f 0b                	jg     f011ffe9 <vprintfmt+0x15a>
f011ffde:	8b 34 9d e0 d9 12 f0 	mov    -0xfed2620(,%ebx,4),%esi
f011ffe5:	85 f6                	test   %esi,%esi
f011ffe7:	75 19                	jne    f0120002 <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f011ffe9:	53                   	push   %ebx
f011ffea:	68 85 db 12 f0       	push   $0xf012db85
f011ffef:	ff 75 0c             	pushl  0xc(%ebp)
f011fff2:	ff 75 08             	pushl  0x8(%ebp)
f011fff5:	e8 70 02 00 00       	call   f012026a <printfmt>
f011fffa:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f011fffd:	e9 5b 02 00 00       	jmp    f012025d <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f0120002:	56                   	push   %esi
f0120003:	68 8e db 12 f0       	push   $0xf012db8e
f0120008:	ff 75 0c             	pushl  0xc(%ebp)
f012000b:	ff 75 08             	pushl  0x8(%ebp)
f012000e:	e8 57 02 00 00       	call   f012026a <printfmt>
f0120013:	83 c4 10             	add    $0x10,%esp
			break;
f0120016:	e9 42 02 00 00       	jmp    f012025d <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f012001b:	8b 45 14             	mov    0x14(%ebp),%eax
f012001e:	83 c0 04             	add    $0x4,%eax
f0120021:	89 45 14             	mov    %eax,0x14(%ebp)
f0120024:	8b 45 14             	mov    0x14(%ebp),%eax
f0120027:	83 e8 04             	sub    $0x4,%eax
f012002a:	8b 30                	mov    (%eax),%esi
f012002c:	85 f6                	test   %esi,%esi
f012002e:	75 05                	jne    f0120035 <vprintfmt+0x1a6>
				p = "(null)";
f0120030:	be 91 db 12 f0       	mov    $0xf012db91,%esi
			if (width > 0 && padc != '-')
f0120035:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0120039:	7e 6d                	jle    f01200a8 <vprintfmt+0x219>
f012003b:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f012003f:	74 67                	je     f01200a8 <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f0120041:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120044:	83 ec 08             	sub    $0x8,%esp
f0120047:	50                   	push   %eax
f0120048:	56                   	push   %esi
f0120049:	e8 26 05 00 00       	call   f0120574 <strnlen>
f012004e:	83 c4 10             	add    $0x10,%esp
f0120051:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f0120054:	eb 16                	jmp    f012006c <vprintfmt+0x1dd>
					putch(padc, putdat);
f0120056:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f012005a:	83 ec 08             	sub    $0x8,%esp
f012005d:	ff 75 0c             	pushl  0xc(%ebp)
f0120060:	50                   	push   %eax
f0120061:	8b 45 08             	mov    0x8(%ebp),%eax
f0120064:	ff d0                	call   *%eax
f0120066:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f0120069:	ff 4d e4             	decl   -0x1c(%ebp)
f012006c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0120070:	7f e4                	jg     f0120056 <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f0120072:	eb 34                	jmp    f01200a8 <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f0120074:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0120078:	74 1c                	je     f0120096 <vprintfmt+0x207>
f012007a:	83 fb 1f             	cmp    $0x1f,%ebx
f012007d:	7e 05                	jle    f0120084 <vprintfmt+0x1f5>
f012007f:	83 fb 7e             	cmp    $0x7e,%ebx
f0120082:	7e 12                	jle    f0120096 <vprintfmt+0x207>
					putch('?', putdat);
f0120084:	83 ec 08             	sub    $0x8,%esp
f0120087:	ff 75 0c             	pushl  0xc(%ebp)
f012008a:	6a 3f                	push   $0x3f
f012008c:	8b 45 08             	mov    0x8(%ebp),%eax
f012008f:	ff d0                	call   *%eax
f0120091:	83 c4 10             	add    $0x10,%esp
f0120094:	eb 0f                	jmp    f01200a5 <vprintfmt+0x216>
				else
					putch(ch, putdat);
f0120096:	83 ec 08             	sub    $0x8,%esp
f0120099:	ff 75 0c             	pushl  0xc(%ebp)
f012009c:	53                   	push   %ebx
f012009d:	8b 45 08             	mov    0x8(%ebp),%eax
f01200a0:	ff d0                	call   *%eax
f01200a2:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f01200a5:	ff 4d e4             	decl   -0x1c(%ebp)
f01200a8:	89 f0                	mov    %esi,%eax
f01200aa:	8d 70 01             	lea    0x1(%eax),%esi
f01200ad:	8a 00                	mov    (%eax),%al
f01200af:	0f be d8             	movsbl %al,%ebx
f01200b2:	85 db                	test   %ebx,%ebx
f01200b4:	74 24                	je     f01200da <vprintfmt+0x24b>
f01200b6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01200ba:	78 b8                	js     f0120074 <vprintfmt+0x1e5>
f01200bc:	ff 4d e0             	decl   -0x20(%ebp)
f01200bf:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01200c3:	79 af                	jns    f0120074 <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f01200c5:	eb 13                	jmp    f01200da <vprintfmt+0x24b>
				putch(' ', putdat);
f01200c7:	83 ec 08             	sub    $0x8,%esp
f01200ca:	ff 75 0c             	pushl  0xc(%ebp)
f01200cd:	6a 20                	push   $0x20
f01200cf:	8b 45 08             	mov    0x8(%ebp),%eax
f01200d2:	ff d0                	call   *%eax
f01200d4:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f01200d7:	ff 4d e4             	decl   -0x1c(%ebp)
f01200da:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01200de:	7f e7                	jg     f01200c7 <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f01200e0:	e9 78 01 00 00       	jmp    f012025d <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f01200e5:	83 ec 08             	sub    $0x8,%esp
f01200e8:	ff 75 e8             	pushl  -0x18(%ebp)
f01200eb:	8d 45 14             	lea    0x14(%ebp),%eax
f01200ee:	50                   	push   %eax
f01200ef:	e8 3c fd ff ff       	call   f011fe30 <getint>
f01200f4:	83 c4 10             	add    $0x10,%esp
f01200f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01200fa:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f01200fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120100:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120103:	85 d2                	test   %edx,%edx
f0120105:	79 23                	jns    f012012a <vprintfmt+0x29b>
				putch('-', putdat);
f0120107:	83 ec 08             	sub    $0x8,%esp
f012010a:	ff 75 0c             	pushl  0xc(%ebp)
f012010d:	6a 2d                	push   $0x2d
f012010f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120112:	ff d0                	call   *%eax
f0120114:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f0120117:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012011a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012011d:	f7 d8                	neg    %eax
f012011f:	83 d2 00             	adc    $0x0,%edx
f0120122:	f7 da                	neg    %edx
f0120124:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0120127:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f012012a:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f0120131:	e9 bc 00 00 00       	jmp    f01201f2 <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f0120136:	83 ec 08             	sub    $0x8,%esp
f0120139:	ff 75 e8             	pushl  -0x18(%ebp)
f012013c:	8d 45 14             	lea    0x14(%ebp),%eax
f012013f:	50                   	push   %eax
f0120140:	e8 84 fc ff ff       	call   f011fdc9 <getuint>
f0120145:	83 c4 10             	add    $0x10,%esp
f0120148:	89 45 f0             	mov    %eax,-0x10(%ebp)
f012014b:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f012014e:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f0120155:	e9 98 00 00 00       	jmp    f01201f2 <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f012015a:	83 ec 08             	sub    $0x8,%esp
f012015d:	ff 75 0c             	pushl  0xc(%ebp)
f0120160:	6a 58                	push   $0x58
f0120162:	8b 45 08             	mov    0x8(%ebp),%eax
f0120165:	ff d0                	call   *%eax
f0120167:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f012016a:	83 ec 08             	sub    $0x8,%esp
f012016d:	ff 75 0c             	pushl  0xc(%ebp)
f0120170:	6a 58                	push   $0x58
f0120172:	8b 45 08             	mov    0x8(%ebp),%eax
f0120175:	ff d0                	call   *%eax
f0120177:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f012017a:	83 ec 08             	sub    $0x8,%esp
f012017d:	ff 75 0c             	pushl  0xc(%ebp)
f0120180:	6a 58                	push   $0x58
f0120182:	8b 45 08             	mov    0x8(%ebp),%eax
f0120185:	ff d0                	call   *%eax
f0120187:	83 c4 10             	add    $0x10,%esp
			break;
f012018a:	e9 ce 00 00 00       	jmp    f012025d <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f012018f:	83 ec 08             	sub    $0x8,%esp
f0120192:	ff 75 0c             	pushl  0xc(%ebp)
f0120195:	6a 30                	push   $0x30
f0120197:	8b 45 08             	mov    0x8(%ebp),%eax
f012019a:	ff d0                	call   *%eax
f012019c:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f012019f:	83 ec 08             	sub    $0x8,%esp
f01201a2:	ff 75 0c             	pushl  0xc(%ebp)
f01201a5:	6a 78                	push   $0x78
f01201a7:	8b 45 08             	mov    0x8(%ebp),%eax
f01201aa:	ff d0                	call   *%eax
f01201ac:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f01201af:	8b 45 14             	mov    0x14(%ebp),%eax
f01201b2:	83 c0 04             	add    $0x4,%eax
f01201b5:	89 45 14             	mov    %eax,0x14(%ebp)
f01201b8:	8b 45 14             	mov    0x14(%ebp),%eax
f01201bb:	83 e8 04             	sub    $0x4,%eax
f01201be:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f01201c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01201c3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f01201ca:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f01201d1:	eb 1f                	jmp    f01201f2 <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f01201d3:	83 ec 08             	sub    $0x8,%esp
f01201d6:	ff 75 e8             	pushl  -0x18(%ebp)
f01201d9:	8d 45 14             	lea    0x14(%ebp),%eax
f01201dc:	50                   	push   %eax
f01201dd:	e8 e7 fb ff ff       	call   f011fdc9 <getuint>
f01201e2:	83 c4 10             	add    $0x10,%esp
f01201e5:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01201e8:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f01201eb:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f01201f2:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f01201f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01201f9:	83 ec 04             	sub    $0x4,%esp
f01201fc:	52                   	push   %edx
f01201fd:	ff 75 e4             	pushl  -0x1c(%ebp)
f0120200:	50                   	push   %eax
f0120201:	ff 75 f4             	pushl  -0xc(%ebp)
f0120204:	ff 75 f0             	pushl  -0x10(%ebp)
f0120207:	ff 75 0c             	pushl  0xc(%ebp)
f012020a:	ff 75 08             	pushl  0x8(%ebp)
f012020d:	e8 00 fb ff ff       	call   f011fd12 <printnum>
f0120212:	83 c4 20             	add    $0x20,%esp
			break;
f0120215:	eb 46                	jmp    f012025d <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f0120217:	83 ec 08             	sub    $0x8,%esp
f012021a:	ff 75 0c             	pushl  0xc(%ebp)
f012021d:	53                   	push   %ebx
f012021e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120221:	ff d0                	call   *%eax
f0120223:	83 c4 10             	add    $0x10,%esp
			break;
f0120226:	eb 35                	jmp    f012025d <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f0120228:	c6 05 50 24 55 f0 00 	movb   $0x0,0xf0552450
			break;
f012022f:	eb 2c                	jmp    f012025d <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f0120231:	c6 05 50 24 55 f0 01 	movb   $0x1,0xf0552450
			break;
f0120238:	eb 23                	jmp    f012025d <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f012023a:	83 ec 08             	sub    $0x8,%esp
f012023d:	ff 75 0c             	pushl  0xc(%ebp)
f0120240:	6a 25                	push   $0x25
f0120242:	8b 45 08             	mov    0x8(%ebp),%eax
f0120245:	ff d0                	call   *%eax
f0120247:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f012024a:	ff 4d 10             	decl   0x10(%ebp)
f012024d:	eb 03                	jmp    f0120252 <vprintfmt+0x3c3>
f012024f:	ff 4d 10             	decl   0x10(%ebp)
f0120252:	8b 45 10             	mov    0x10(%ebp),%eax
f0120255:	48                   	dec    %eax
f0120256:	8a 00                	mov    (%eax),%al
f0120258:	3c 25                	cmp    $0x25,%al
f012025a:	75 f3                	jne    f012024f <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f012025c:	90                   	nop
		}
	}
f012025d:	e9 35 fc ff ff       	jmp    f011fe97 <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f0120262:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f0120263:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0120266:	5b                   	pop    %ebx
f0120267:	5e                   	pop    %esi
f0120268:	5d                   	pop    %ebp
f0120269:	c3                   	ret    

f012026a <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f012026a:	55                   	push   %ebp
f012026b:	89 e5                	mov    %esp,%ebp
f012026d:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f0120270:	8d 45 10             	lea    0x10(%ebp),%eax
f0120273:	83 c0 04             	add    $0x4,%eax
f0120276:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f0120279:	8b 45 10             	mov    0x10(%ebp),%eax
f012027c:	ff 75 f4             	pushl  -0xc(%ebp)
f012027f:	50                   	push   %eax
f0120280:	ff 75 0c             	pushl  0xc(%ebp)
f0120283:	ff 75 08             	pushl  0x8(%ebp)
f0120286:	e8 04 fc ff ff       	call   f011fe8f <vprintfmt>
f012028b:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f012028e:	90                   	nop
f012028f:	c9                   	leave  
f0120290:	c3                   	ret    

f0120291 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f0120291:	55                   	push   %ebp
f0120292:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f0120294:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120297:	8b 40 08             	mov    0x8(%eax),%eax
f012029a:	8d 50 01             	lea    0x1(%eax),%edx
f012029d:	8b 45 0c             	mov    0xc(%ebp),%eax
f01202a0:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f01202a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01202a6:	8b 10                	mov    (%eax),%edx
f01202a8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01202ab:	8b 40 04             	mov    0x4(%eax),%eax
f01202ae:	39 c2                	cmp    %eax,%edx
f01202b0:	73 12                	jae    f01202c4 <sprintputch+0x33>
		*b->buf++ = ch;
f01202b2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01202b5:	8b 00                	mov    (%eax),%eax
f01202b7:	8d 48 01             	lea    0x1(%eax),%ecx
f01202ba:	8b 55 0c             	mov    0xc(%ebp),%edx
f01202bd:	89 0a                	mov    %ecx,(%edx)
f01202bf:	8b 55 08             	mov    0x8(%ebp),%edx
f01202c2:	88 10                	mov    %dl,(%eax)
}
f01202c4:	90                   	nop
f01202c5:	5d                   	pop    %ebp
f01202c6:	c3                   	ret    

f01202c7 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f01202c7:	55                   	push   %ebp
f01202c8:	89 e5                	mov    %esp,%ebp
f01202ca:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f01202cd:	8b 45 08             	mov    0x8(%ebp),%eax
f01202d0:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01202d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01202d6:	8d 50 ff             	lea    -0x1(%eax),%edx
f01202d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01202dc:	01 d0                	add    %edx,%eax
f01202de:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01202e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f01202e8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01202ec:	74 06                	je     f01202f4 <vsnprintf+0x2d>
f01202ee:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01202f2:	7f 07                	jg     f01202fb <vsnprintf+0x34>
		return -E_INVAL;
f01202f4:	b8 03 00 00 00       	mov    $0x3,%eax
f01202f9:	eb 20                	jmp    f012031b <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f01202fb:	ff 75 14             	pushl  0x14(%ebp)
f01202fe:	ff 75 10             	pushl  0x10(%ebp)
f0120301:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0120304:	50                   	push   %eax
f0120305:	68 91 02 12 f0       	push   $0xf0120291
f012030a:	e8 80 fb ff ff       	call   f011fe8f <vprintfmt>
f012030f:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f0120312:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120315:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f0120318:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f012031b:	c9                   	leave  
f012031c:	c3                   	ret    

f012031d <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f012031d:	55                   	push   %ebp
f012031e:	89 e5                	mov    %esp,%ebp
f0120320:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f0120323:	8d 45 10             	lea    0x10(%ebp),%eax
f0120326:	83 c0 04             	add    $0x4,%eax
f0120329:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f012032c:	8b 45 10             	mov    0x10(%ebp),%eax
f012032f:	ff 75 f4             	pushl  -0xc(%ebp)
f0120332:	50                   	push   %eax
f0120333:	ff 75 0c             	pushl  0xc(%ebp)
f0120336:	ff 75 08             	pushl  0x8(%ebp)
f0120339:	e8 89 ff ff ff       	call   f01202c7 <vsnprintf>
f012033e:	83 c4 10             	add    $0x10,%esp
f0120341:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f0120344:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0120347:	c9                   	leave  
f0120348:	c3                   	ret    

f0120349 <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f0120349:	55                   	push   %ebp
f012034a:	89 e5                	mov    %esp,%ebp
f012034c:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f012034f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120353:	74 13                	je     f0120368 <readline+0x1f>
		cprintf("%s", prompt);
f0120355:	83 ec 08             	sub    $0x8,%esp
f0120358:	ff 75 08             	pushl  0x8(%ebp)
f012035b:	68 08 dd 12 f0       	push   $0xf012dd08
f0120360:	e8 07 0c fe ff       	call   f0100f6c <cprintf>
f0120365:	83 c4 10             	add    $0x10,%esp

	i = 0;
f0120368:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f012036f:	83 ec 0c             	sub    $0xc,%esp
f0120372:	6a 00                	push   $0x0
f0120374:	e8 00 0b fe ff       	call   f0100e79 <iscons>
f0120379:	83 c4 10             	add    $0x10,%esp
f012037c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f012037f:	e8 dc 0a fe ff       	call   f0100e60 <getchar>
f0120384:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f0120387:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f012038b:	79 22                	jns    f01203af <readline+0x66>
			if (c != -E_EOF)
f012038d:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f0120391:	0f 84 ad 00 00 00    	je     f0120444 <readline+0xfb>
				cprintf("read error: %e\n", c);
f0120397:	83 ec 08             	sub    $0x8,%esp
f012039a:	ff 75 ec             	pushl  -0x14(%ebp)
f012039d:	68 0b dd 12 f0       	push   $0xf012dd0b
f01203a2:	e8 c5 0b fe ff       	call   f0100f6c <cprintf>
f01203a7:	83 c4 10             	add    $0x10,%esp
			break;
f01203aa:	e9 95 00 00 00       	jmp    f0120444 <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f01203af:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f01203b3:	7e 34                	jle    f01203e9 <readline+0xa0>
f01203b5:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f01203bc:	7f 2b                	jg     f01203e9 <readline+0xa0>
			if (echoing)
f01203be:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01203c2:	74 0e                	je     f01203d2 <readline+0x89>
				cputchar(c);
f01203c4:	83 ec 0c             	sub    $0xc,%esp
f01203c7:	ff 75 ec             	pushl  -0x14(%ebp)
f01203ca:	e8 7a 0a fe ff       	call   f0100e49 <cputchar>
f01203cf:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f01203d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01203d5:	8d 50 01             	lea    0x1(%eax),%edx
f01203d8:	89 55 f4             	mov    %edx,-0xc(%ebp)
f01203db:	89 c2                	mov    %eax,%edx
f01203dd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01203e0:	01 d0                	add    %edx,%eax
f01203e2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01203e5:	88 10                	mov    %dl,(%eax)
f01203e7:	eb 56                	jmp    f012043f <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f01203e9:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f01203ed:	75 1f                	jne    f012040e <readline+0xc5>
f01203ef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01203f3:	7e 19                	jle    f012040e <readline+0xc5>
			if (echoing)
f01203f5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01203f9:	74 0e                	je     f0120409 <readline+0xc0>
				cputchar(c);
f01203fb:	83 ec 0c             	sub    $0xc,%esp
f01203fe:	ff 75 ec             	pushl  -0x14(%ebp)
f0120401:	e8 43 0a fe ff       	call   f0100e49 <cputchar>
f0120406:	83 c4 10             	add    $0x10,%esp

			i--;
f0120409:	ff 4d f4             	decl   -0xc(%ebp)
f012040c:	eb 31                	jmp    f012043f <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f012040e:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f0120412:	74 0a                	je     f012041e <readline+0xd5>
f0120414:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f0120418:	0f 85 61 ff ff ff    	jne    f012037f <readline+0x36>
			if (echoing)
f012041e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120422:	74 0e                	je     f0120432 <readline+0xe9>
				cputchar(c);
f0120424:	83 ec 0c             	sub    $0xc,%esp
f0120427:	ff 75 ec             	pushl  -0x14(%ebp)
f012042a:	e8 1a 0a fe ff       	call   f0100e49 <cputchar>
f012042f:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f0120432:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120435:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120438:	01 d0                	add    %edx,%eax
f012043a:	c6 00 00             	movb   $0x0,(%eax)
			break;
f012043d:	eb 06                	jmp    f0120445 <readline+0xfc>
		}
	}
f012043f:	e9 3b ff ff ff       	jmp    f012037f <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f0120444:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f0120445:	90                   	nop
f0120446:	c9                   	leave  
f0120447:	c3                   	ret    

f0120448 <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f0120448:	55                   	push   %ebp
f0120449:	89 e5                	mov    %esp,%ebp
f012044b:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f012044e:	e8 5c d1 fe ff       	call   f010d5af <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f0120453:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120457:	74 13                	je     f012046c <atomic_readline+0x24>
			cprintf("%s", prompt);
f0120459:	83 ec 08             	sub    $0x8,%esp
f012045c:	ff 75 08             	pushl  0x8(%ebp)
f012045f:	68 08 dd 12 f0       	push   $0xf012dd08
f0120464:	e8 03 0b fe ff       	call   f0100f6c <cprintf>
f0120469:	83 c4 10             	add    $0x10,%esp

		i = 0;
f012046c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f0120473:	83 ec 0c             	sub    $0xc,%esp
f0120476:	6a 00                	push   $0x0
f0120478:	e8 fc 09 fe ff       	call   f0100e79 <iscons>
f012047d:	83 c4 10             	add    $0x10,%esp
f0120480:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f0120483:	e8 d8 09 fe ff       	call   f0100e60 <getchar>
f0120488:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f012048b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f012048f:	79 22                	jns    f01204b3 <atomic_readline+0x6b>
				if (c != -E_EOF)
f0120491:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f0120495:	0f 84 ad 00 00 00    	je     f0120548 <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f012049b:	83 ec 08             	sub    $0x8,%esp
f012049e:	ff 75 ec             	pushl  -0x14(%ebp)
f01204a1:	68 0b dd 12 f0       	push   $0xf012dd0b
f01204a6:	e8 c1 0a fe ff       	call   f0100f6c <cprintf>
f01204ab:	83 c4 10             	add    $0x10,%esp
				break;
f01204ae:	e9 95 00 00 00       	jmp    f0120548 <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f01204b3:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f01204b7:	7e 34                	jle    f01204ed <atomic_readline+0xa5>
f01204b9:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f01204c0:	7f 2b                	jg     f01204ed <atomic_readline+0xa5>
				if (echoing)
f01204c2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01204c6:	74 0e                	je     f01204d6 <atomic_readline+0x8e>
					cputchar(c);
f01204c8:	83 ec 0c             	sub    $0xc,%esp
f01204cb:	ff 75 ec             	pushl  -0x14(%ebp)
f01204ce:	e8 76 09 fe ff       	call   f0100e49 <cputchar>
f01204d3:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f01204d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01204d9:	8d 50 01             	lea    0x1(%eax),%edx
f01204dc:	89 55 f4             	mov    %edx,-0xc(%ebp)
f01204df:	89 c2                	mov    %eax,%edx
f01204e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01204e4:	01 d0                	add    %edx,%eax
f01204e6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01204e9:	88 10                	mov    %dl,(%eax)
f01204eb:	eb 56                	jmp    f0120543 <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f01204ed:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f01204f1:	75 1f                	jne    f0120512 <atomic_readline+0xca>
f01204f3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01204f7:	7e 19                	jle    f0120512 <atomic_readline+0xca>
				if (echoing)
f01204f9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01204fd:	74 0e                	je     f012050d <atomic_readline+0xc5>
					cputchar(c);
f01204ff:	83 ec 0c             	sub    $0xc,%esp
f0120502:	ff 75 ec             	pushl  -0x14(%ebp)
f0120505:	e8 3f 09 fe ff       	call   f0100e49 <cputchar>
f012050a:	83 c4 10             	add    $0x10,%esp
				i--;
f012050d:	ff 4d f4             	decl   -0xc(%ebp)
f0120510:	eb 31                	jmp    f0120543 <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f0120512:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f0120516:	74 0a                	je     f0120522 <atomic_readline+0xda>
f0120518:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f012051c:	0f 85 61 ff ff ff    	jne    f0120483 <atomic_readline+0x3b>
				if (echoing)
f0120522:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120526:	74 0e                	je     f0120536 <atomic_readline+0xee>
					cputchar(c);
f0120528:	83 ec 0c             	sub    $0xc,%esp
f012052b:	ff 75 ec             	pushl  -0x14(%ebp)
f012052e:	e8 16 09 fe ff       	call   f0100e49 <cputchar>
f0120533:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f0120536:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120539:	8b 45 0c             	mov    0xc(%ebp),%eax
f012053c:	01 d0                	add    %edx,%eax
f012053e:	c6 00 00             	movb   $0x0,(%eax)
				break;
f0120541:	eb 06                	jmp    f0120549 <atomic_readline+0x101>
			}
		}
f0120543:	e9 3b ff ff ff       	jmp    f0120483 <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f0120548:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f0120549:	e8 6f d0 fe ff       	call   f010d5bd <sys_unlock_cons>
}
f012054e:	90                   	nop
f012054f:	c9                   	leave  
f0120550:	c3                   	ret    

f0120551 <strlen>:
#include <inc/string.h>
#include <inc/assert.h>

int
strlen(const char *s)
{
f0120551:	55                   	push   %ebp
f0120552:	89 e5                	mov    %esp,%ebp
f0120554:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f0120557:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f012055e:	eb 06                	jmp    f0120566 <strlen+0x15>
		n++;
f0120560:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f0120563:	ff 45 08             	incl   0x8(%ebp)
f0120566:	8b 45 08             	mov    0x8(%ebp),%eax
f0120569:	8a 00                	mov    (%eax),%al
f012056b:	84 c0                	test   %al,%al
f012056d:	75 f1                	jne    f0120560 <strlen+0xf>
		n++;
	return n;
f012056f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0120572:	c9                   	leave  
f0120573:	c3                   	ret    

f0120574 <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f0120574:	55                   	push   %ebp
f0120575:	89 e5                	mov    %esp,%ebp
f0120577:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f012057a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0120581:	eb 09                	jmp    f012058c <strnlen+0x18>
		n++;
f0120583:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f0120586:	ff 45 08             	incl   0x8(%ebp)
f0120589:	ff 4d 0c             	decl   0xc(%ebp)
f012058c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120590:	74 09                	je     f012059b <strnlen+0x27>
f0120592:	8b 45 08             	mov    0x8(%ebp),%eax
f0120595:	8a 00                	mov    (%eax),%al
f0120597:	84 c0                	test   %al,%al
f0120599:	75 e8                	jne    f0120583 <strnlen+0xf>
		n++;
	return n;
f012059b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f012059e:	c9                   	leave  
f012059f:	c3                   	ret    

f01205a0 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f01205a0:	55                   	push   %ebp
f01205a1:	89 e5                	mov    %esp,%ebp
f01205a3:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f01205a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01205a9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f01205ac:	90                   	nop
f01205ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01205b0:	8d 50 01             	lea    0x1(%eax),%edx
f01205b3:	89 55 08             	mov    %edx,0x8(%ebp)
f01205b6:	8b 55 0c             	mov    0xc(%ebp),%edx
f01205b9:	8d 4a 01             	lea    0x1(%edx),%ecx
f01205bc:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f01205bf:	8a 12                	mov    (%edx),%dl
f01205c1:	88 10                	mov    %dl,(%eax)
f01205c3:	8a 00                	mov    (%eax),%al
f01205c5:	84 c0                	test   %al,%al
f01205c7:	75 e4                	jne    f01205ad <strcpy+0xd>
		/* do nothing */;
	return ret;
f01205c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f01205cc:	c9                   	leave  
f01205cd:	c3                   	ret    

f01205ce <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f01205ce:	55                   	push   %ebp
f01205cf:	89 e5                	mov    %esp,%ebp
f01205d1:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f01205d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01205d7:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f01205da:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01205e1:	eb 1f                	jmp    f0120602 <strncpy+0x34>
		*dst++ = *src;
f01205e3:	8b 45 08             	mov    0x8(%ebp),%eax
f01205e6:	8d 50 01             	lea    0x1(%eax),%edx
f01205e9:	89 55 08             	mov    %edx,0x8(%ebp)
f01205ec:	8b 55 0c             	mov    0xc(%ebp),%edx
f01205ef:	8a 12                	mov    (%edx),%dl
f01205f1:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f01205f3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01205f6:	8a 00                	mov    (%eax),%al
f01205f8:	84 c0                	test   %al,%al
f01205fa:	74 03                	je     f01205ff <strncpy+0x31>
			src++;
f01205fc:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f01205ff:	ff 45 fc             	incl   -0x4(%ebp)
f0120602:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120605:	3b 45 10             	cmp    0x10(%ebp),%eax
f0120608:	72 d9                	jb     f01205e3 <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f012060a:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f012060d:	c9                   	leave  
f012060e:	c3                   	ret    

f012060f <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f012060f:	55                   	push   %ebp
f0120610:	89 e5                	mov    %esp,%ebp
f0120612:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f0120615:	8b 45 08             	mov    0x8(%ebp),%eax
f0120618:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f012061b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f012061f:	74 30                	je     f0120651 <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f0120621:	eb 16                	jmp    f0120639 <strlcpy+0x2a>
			*dst++ = *src++;
f0120623:	8b 45 08             	mov    0x8(%ebp),%eax
f0120626:	8d 50 01             	lea    0x1(%eax),%edx
f0120629:	89 55 08             	mov    %edx,0x8(%ebp)
f012062c:	8b 55 0c             	mov    0xc(%ebp),%edx
f012062f:	8d 4a 01             	lea    0x1(%edx),%ecx
f0120632:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f0120635:	8a 12                	mov    (%edx),%dl
f0120637:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f0120639:	ff 4d 10             	decl   0x10(%ebp)
f012063c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120640:	74 09                	je     f012064b <strlcpy+0x3c>
f0120642:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120645:	8a 00                	mov    (%eax),%al
f0120647:	84 c0                	test   %al,%al
f0120649:	75 d8                	jne    f0120623 <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f012064b:	8b 45 08             	mov    0x8(%ebp),%eax
f012064e:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f0120651:	8b 55 08             	mov    0x8(%ebp),%edx
f0120654:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120657:	29 c2                	sub    %eax,%edx
f0120659:	89 d0                	mov    %edx,%eax
}
f012065b:	c9                   	leave  
f012065c:	c3                   	ret    

f012065d <strcmp>:

int
strcmp(const char *p, const char *q)
{
f012065d:	55                   	push   %ebp
f012065e:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f0120660:	eb 06                	jmp    f0120668 <strcmp+0xb>
		p++, q++;
f0120662:	ff 45 08             	incl   0x8(%ebp)
f0120665:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f0120668:	8b 45 08             	mov    0x8(%ebp),%eax
f012066b:	8a 00                	mov    (%eax),%al
f012066d:	84 c0                	test   %al,%al
f012066f:	74 0e                	je     f012067f <strcmp+0x22>
f0120671:	8b 45 08             	mov    0x8(%ebp),%eax
f0120674:	8a 10                	mov    (%eax),%dl
f0120676:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120679:	8a 00                	mov    (%eax),%al
f012067b:	38 c2                	cmp    %al,%dl
f012067d:	74 e3                	je     f0120662 <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f012067f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120682:	8a 00                	mov    (%eax),%al
f0120684:	0f b6 d0             	movzbl %al,%edx
f0120687:	8b 45 0c             	mov    0xc(%ebp),%eax
f012068a:	8a 00                	mov    (%eax),%al
f012068c:	0f b6 c0             	movzbl %al,%eax
f012068f:	29 c2                	sub    %eax,%edx
f0120691:	89 d0                	mov    %edx,%eax
}
f0120693:	5d                   	pop    %ebp
f0120694:	c3                   	ret    

f0120695 <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f0120695:	55                   	push   %ebp
f0120696:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f0120698:	eb 09                	jmp    f01206a3 <strncmp+0xe>
		n--, p++, q++;
f012069a:	ff 4d 10             	decl   0x10(%ebp)
f012069d:	ff 45 08             	incl   0x8(%ebp)
f01206a0:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f01206a3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01206a7:	74 17                	je     f01206c0 <strncmp+0x2b>
f01206a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01206ac:	8a 00                	mov    (%eax),%al
f01206ae:	84 c0                	test   %al,%al
f01206b0:	74 0e                	je     f01206c0 <strncmp+0x2b>
f01206b2:	8b 45 08             	mov    0x8(%ebp),%eax
f01206b5:	8a 10                	mov    (%eax),%dl
f01206b7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01206ba:	8a 00                	mov    (%eax),%al
f01206bc:	38 c2                	cmp    %al,%dl
f01206be:	74 da                	je     f012069a <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f01206c0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01206c4:	75 07                	jne    f01206cd <strncmp+0x38>
		return 0;
f01206c6:	b8 00 00 00 00       	mov    $0x0,%eax
f01206cb:	eb 14                	jmp    f01206e1 <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f01206cd:	8b 45 08             	mov    0x8(%ebp),%eax
f01206d0:	8a 00                	mov    (%eax),%al
f01206d2:	0f b6 d0             	movzbl %al,%edx
f01206d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01206d8:	8a 00                	mov    (%eax),%al
f01206da:	0f b6 c0             	movzbl %al,%eax
f01206dd:	29 c2                	sub    %eax,%edx
f01206df:	89 d0                	mov    %edx,%eax
}
f01206e1:	5d                   	pop    %ebp
f01206e2:	c3                   	ret    

f01206e3 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f01206e3:	55                   	push   %ebp
f01206e4:	89 e5                	mov    %esp,%ebp
f01206e6:	83 ec 04             	sub    $0x4,%esp
f01206e9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01206ec:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f01206ef:	eb 12                	jmp    f0120703 <strchr+0x20>
		if (*s == c)
f01206f1:	8b 45 08             	mov    0x8(%ebp),%eax
f01206f4:	8a 00                	mov    (%eax),%al
f01206f6:	3a 45 fc             	cmp    -0x4(%ebp),%al
f01206f9:	75 05                	jne    f0120700 <strchr+0x1d>
			return (char *) s;
f01206fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01206fe:	eb 11                	jmp    f0120711 <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f0120700:	ff 45 08             	incl   0x8(%ebp)
f0120703:	8b 45 08             	mov    0x8(%ebp),%eax
f0120706:	8a 00                	mov    (%eax),%al
f0120708:	84 c0                	test   %al,%al
f012070a:	75 e5                	jne    f01206f1 <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f012070c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120711:	c9                   	leave  
f0120712:	c3                   	ret    

f0120713 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f0120713:	55                   	push   %ebp
f0120714:	89 e5                	mov    %esp,%ebp
f0120716:	83 ec 04             	sub    $0x4,%esp
f0120719:	8b 45 0c             	mov    0xc(%ebp),%eax
f012071c:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f012071f:	eb 0d                	jmp    f012072e <strfind+0x1b>
		if (*s == c)
f0120721:	8b 45 08             	mov    0x8(%ebp),%eax
f0120724:	8a 00                	mov    (%eax),%al
f0120726:	3a 45 fc             	cmp    -0x4(%ebp),%al
f0120729:	74 0e                	je     f0120739 <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f012072b:	ff 45 08             	incl   0x8(%ebp)
f012072e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120731:	8a 00                	mov    (%eax),%al
f0120733:	84 c0                	test   %al,%al
f0120735:	75 ea                	jne    f0120721 <strfind+0xe>
f0120737:	eb 01                	jmp    f012073a <strfind+0x27>
		if (*s == c)
			break;
f0120739:	90                   	nop
	return (char *) s;
f012073a:	8b 45 08             	mov    0x8(%ebp),%eax
}
f012073d:	c9                   	leave  
f012073e:	c3                   	ret    

f012073f <memset>:


void *
memset(void *v, int c, uint32 n)
{
f012073f:	55                   	push   %ebp
f0120740:	89 e5                	mov    %esp,%ebp
f0120742:	83 ec 10             	sub    $0x10,%esp
	char *p;
	int m;

	p = v;
f0120745:	8b 45 08             	mov    0x8(%ebp),%eax
f0120748:	89 45 fc             	mov    %eax,-0x4(%ebp)
	m = n;
f012074b:	8b 45 10             	mov    0x10(%ebp),%eax
f012074e:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (--m >= 0)
f0120751:	eb 0e                	jmp    f0120761 <memset+0x22>
		*p++ = c;
f0120753:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120756:	8d 50 01             	lea    0x1(%eax),%edx
f0120759:	89 55 fc             	mov    %edx,-0x4(%ebp)
f012075c:	8b 55 0c             	mov    0xc(%ebp),%edx
f012075f:	88 10                	mov    %dl,(%eax)
	char *p;
	int m;

	p = v;
	m = n;
	while (--m >= 0)
f0120761:	ff 4d f8             	decl   -0x8(%ebp)
f0120764:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
f0120768:	79 e9                	jns    f0120753 <memset+0x14>
		*p++ = c;

	return v;
f012076a:	8b 45 08             	mov    0x8(%ebp),%eax
}
f012076d:	c9                   	leave  
f012076e:	c3                   	ret    

f012076f <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f012076f:	55                   	push   %ebp
f0120770:	89 e5                	mov    %esp,%ebp
f0120772:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f0120775:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120778:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f012077b:	8b 45 08             	mov    0x8(%ebp),%eax
f012077e:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (n-- > 0)
f0120781:	eb 16                	jmp    f0120799 <memcpy+0x2a>
		*d++ = *s++;
f0120783:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120786:	8d 50 01             	lea    0x1(%eax),%edx
f0120789:	89 55 f8             	mov    %edx,-0x8(%ebp)
f012078c:	8b 55 fc             	mov    -0x4(%ebp),%edx
f012078f:	8d 4a 01             	lea    0x1(%edx),%ecx
f0120792:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f0120795:	8a 12                	mov    (%edx),%dl
f0120797:	88 10                	mov    %dl,(%eax)
	const char *s;
	char *d;

	s = src;
	d = dst;
	while (n-- > 0)
f0120799:	8b 45 10             	mov    0x10(%ebp),%eax
f012079c:	8d 50 ff             	lea    -0x1(%eax),%edx
f012079f:	89 55 10             	mov    %edx,0x10(%ebp)
f01207a2:	85 c0                	test   %eax,%eax
f01207a4:	75 dd                	jne    f0120783 <memcpy+0x14>
		*d++ = *s++;

	return dst;
f01207a6:	8b 45 08             	mov    0x8(%ebp),%eax
}
f01207a9:	c9                   	leave  
f01207aa:	c3                   	ret    

f01207ab <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f01207ab:	55                   	push   %ebp
f01207ac:	89 e5                	mov    %esp,%ebp
f01207ae:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f01207b1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01207b4:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f01207b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01207ba:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f01207bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01207c0:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f01207c3:	73 50                	jae    f0120815 <memmove+0x6a>
f01207c5:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01207c8:	8b 45 10             	mov    0x10(%ebp),%eax
f01207cb:	01 d0                	add    %edx,%eax
f01207cd:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f01207d0:	76 43                	jbe    f0120815 <memmove+0x6a>
		s += n;
f01207d2:	8b 45 10             	mov    0x10(%ebp),%eax
f01207d5:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f01207d8:	8b 45 10             	mov    0x10(%ebp),%eax
f01207db:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f01207de:	eb 10                	jmp    f01207f0 <memmove+0x45>
			*--d = *--s;
f01207e0:	ff 4d f8             	decl   -0x8(%ebp)
f01207e3:	ff 4d fc             	decl   -0x4(%ebp)
f01207e6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01207e9:	8a 10                	mov    (%eax),%dl
f01207eb:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01207ee:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f01207f0:	8b 45 10             	mov    0x10(%ebp),%eax
f01207f3:	8d 50 ff             	lea    -0x1(%eax),%edx
f01207f6:	89 55 10             	mov    %edx,0x10(%ebp)
f01207f9:	85 c0                	test   %eax,%eax
f01207fb:	75 e3                	jne    f01207e0 <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f01207fd:	eb 23                	jmp    f0120822 <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f01207ff:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120802:	8d 50 01             	lea    0x1(%eax),%edx
f0120805:	89 55 f8             	mov    %edx,-0x8(%ebp)
f0120808:	8b 55 fc             	mov    -0x4(%ebp),%edx
f012080b:	8d 4a 01             	lea    0x1(%edx),%ecx
f012080e:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f0120811:	8a 12                	mov    (%edx),%dl
f0120813:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f0120815:	8b 45 10             	mov    0x10(%ebp),%eax
f0120818:	8d 50 ff             	lea    -0x1(%eax),%edx
f012081b:	89 55 10             	mov    %edx,0x10(%ebp)
f012081e:	85 c0                	test   %eax,%eax
f0120820:	75 dd                	jne    f01207ff <memmove+0x54>
			*d++ = *s++;

	return dst;
f0120822:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0120825:	c9                   	leave  
f0120826:	c3                   	ret    

f0120827 <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f0120827:	55                   	push   %ebp
f0120828:	89 e5                	mov    %esp,%ebp
f012082a:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f012082d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120830:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f0120833:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120836:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f0120839:	eb 2a                	jmp    f0120865 <memcmp+0x3e>
		if (*s1 != *s2)
f012083b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012083e:	8a 10                	mov    (%eax),%dl
f0120840:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120843:	8a 00                	mov    (%eax),%al
f0120845:	38 c2                	cmp    %al,%dl
f0120847:	74 16                	je     f012085f <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f0120849:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012084c:	8a 00                	mov    (%eax),%al
f012084e:	0f b6 d0             	movzbl %al,%edx
f0120851:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120854:	8a 00                	mov    (%eax),%al
f0120856:	0f b6 c0             	movzbl %al,%eax
f0120859:	29 c2                	sub    %eax,%edx
f012085b:	89 d0                	mov    %edx,%eax
f012085d:	eb 18                	jmp    f0120877 <memcmp+0x50>
		s1++, s2++;
f012085f:	ff 45 fc             	incl   -0x4(%ebp)
f0120862:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f0120865:	8b 45 10             	mov    0x10(%ebp),%eax
f0120868:	8d 50 ff             	lea    -0x1(%eax),%edx
f012086b:	89 55 10             	mov    %edx,0x10(%ebp)
f012086e:	85 c0                	test   %eax,%eax
f0120870:	75 c9                	jne    f012083b <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f0120872:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120877:	c9                   	leave  
f0120878:	c3                   	ret    

f0120879 <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f0120879:	55                   	push   %ebp
f012087a:	89 e5                	mov    %esp,%ebp
f012087c:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f012087f:	8b 55 08             	mov    0x8(%ebp),%edx
f0120882:	8b 45 10             	mov    0x10(%ebp),%eax
f0120885:	01 d0                	add    %edx,%eax
f0120887:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f012088a:	eb 15                	jmp    f01208a1 <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f012088c:	8b 45 08             	mov    0x8(%ebp),%eax
f012088f:	8a 00                	mov    (%eax),%al
f0120891:	0f b6 d0             	movzbl %al,%edx
f0120894:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120897:	0f b6 c0             	movzbl %al,%eax
f012089a:	39 c2                	cmp    %eax,%edx
f012089c:	74 0d                	je     f01208ab <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f012089e:	ff 45 08             	incl   0x8(%ebp)
f01208a1:	8b 45 08             	mov    0x8(%ebp),%eax
f01208a4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f01208a7:	72 e3                	jb     f012088c <memfind+0x13>
f01208a9:	eb 01                	jmp    f01208ac <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f01208ab:	90                   	nop
	return (void *) s;
f01208ac:	8b 45 08             	mov    0x8(%ebp),%eax
}
f01208af:	c9                   	leave  
f01208b0:	c3                   	ret    

f01208b1 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f01208b1:	55                   	push   %ebp
f01208b2:	89 e5                	mov    %esp,%ebp
f01208b4:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f01208b7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f01208be:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f01208c5:	eb 03                	jmp    f01208ca <strtol+0x19>
		s++;
f01208c7:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f01208ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01208cd:	8a 00                	mov    (%eax),%al
f01208cf:	3c 20                	cmp    $0x20,%al
f01208d1:	74 f4                	je     f01208c7 <strtol+0x16>
f01208d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01208d6:	8a 00                	mov    (%eax),%al
f01208d8:	3c 09                	cmp    $0x9,%al
f01208da:	74 eb                	je     f01208c7 <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f01208dc:	8b 45 08             	mov    0x8(%ebp),%eax
f01208df:	8a 00                	mov    (%eax),%al
f01208e1:	3c 2b                	cmp    $0x2b,%al
f01208e3:	75 05                	jne    f01208ea <strtol+0x39>
		s++;
f01208e5:	ff 45 08             	incl   0x8(%ebp)
f01208e8:	eb 13                	jmp    f01208fd <strtol+0x4c>
	else if (*s == '-')
f01208ea:	8b 45 08             	mov    0x8(%ebp),%eax
f01208ed:	8a 00                	mov    (%eax),%al
f01208ef:	3c 2d                	cmp    $0x2d,%al
f01208f1:	75 0a                	jne    f01208fd <strtol+0x4c>
		s++, neg = 1;
f01208f3:	ff 45 08             	incl   0x8(%ebp)
f01208f6:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f01208fd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120901:	74 06                	je     f0120909 <strtol+0x58>
f0120903:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f0120907:	75 20                	jne    f0120929 <strtol+0x78>
f0120909:	8b 45 08             	mov    0x8(%ebp),%eax
f012090c:	8a 00                	mov    (%eax),%al
f012090e:	3c 30                	cmp    $0x30,%al
f0120910:	75 17                	jne    f0120929 <strtol+0x78>
f0120912:	8b 45 08             	mov    0x8(%ebp),%eax
f0120915:	40                   	inc    %eax
f0120916:	8a 00                	mov    (%eax),%al
f0120918:	3c 78                	cmp    $0x78,%al
f012091a:	75 0d                	jne    f0120929 <strtol+0x78>
		s += 2, base = 16;
f012091c:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f0120920:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f0120927:	eb 28                	jmp    f0120951 <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f0120929:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f012092d:	75 15                	jne    f0120944 <strtol+0x93>
f012092f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120932:	8a 00                	mov    (%eax),%al
f0120934:	3c 30                	cmp    $0x30,%al
f0120936:	75 0c                	jne    f0120944 <strtol+0x93>
		s++, base = 8;
f0120938:	ff 45 08             	incl   0x8(%ebp)
f012093b:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f0120942:	eb 0d                	jmp    f0120951 <strtol+0xa0>
	else if (base == 0)
f0120944:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120948:	75 07                	jne    f0120951 <strtol+0xa0>
		base = 10;
f012094a:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f0120951:	8b 45 08             	mov    0x8(%ebp),%eax
f0120954:	8a 00                	mov    (%eax),%al
f0120956:	3c 2f                	cmp    $0x2f,%al
f0120958:	7e 19                	jle    f0120973 <strtol+0xc2>
f012095a:	8b 45 08             	mov    0x8(%ebp),%eax
f012095d:	8a 00                	mov    (%eax),%al
f012095f:	3c 39                	cmp    $0x39,%al
f0120961:	7f 10                	jg     f0120973 <strtol+0xc2>
			dig = *s - '0';
f0120963:	8b 45 08             	mov    0x8(%ebp),%eax
f0120966:	8a 00                	mov    (%eax),%al
f0120968:	0f be c0             	movsbl %al,%eax
f012096b:	83 e8 30             	sub    $0x30,%eax
f012096e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120971:	eb 42                	jmp    f01209b5 <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f0120973:	8b 45 08             	mov    0x8(%ebp),%eax
f0120976:	8a 00                	mov    (%eax),%al
f0120978:	3c 60                	cmp    $0x60,%al
f012097a:	7e 19                	jle    f0120995 <strtol+0xe4>
f012097c:	8b 45 08             	mov    0x8(%ebp),%eax
f012097f:	8a 00                	mov    (%eax),%al
f0120981:	3c 7a                	cmp    $0x7a,%al
f0120983:	7f 10                	jg     f0120995 <strtol+0xe4>
			dig = *s - 'a' + 10;
f0120985:	8b 45 08             	mov    0x8(%ebp),%eax
f0120988:	8a 00                	mov    (%eax),%al
f012098a:	0f be c0             	movsbl %al,%eax
f012098d:	83 e8 57             	sub    $0x57,%eax
f0120990:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120993:	eb 20                	jmp    f01209b5 <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f0120995:	8b 45 08             	mov    0x8(%ebp),%eax
f0120998:	8a 00                	mov    (%eax),%al
f012099a:	3c 40                	cmp    $0x40,%al
f012099c:	7e 39                	jle    f01209d7 <strtol+0x126>
f012099e:	8b 45 08             	mov    0x8(%ebp),%eax
f01209a1:	8a 00                	mov    (%eax),%al
f01209a3:	3c 5a                	cmp    $0x5a,%al
f01209a5:	7f 30                	jg     f01209d7 <strtol+0x126>
			dig = *s - 'A' + 10;
f01209a7:	8b 45 08             	mov    0x8(%ebp),%eax
f01209aa:	8a 00                	mov    (%eax),%al
f01209ac:	0f be c0             	movsbl %al,%eax
f01209af:	83 e8 37             	sub    $0x37,%eax
f01209b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f01209b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01209b8:	3b 45 10             	cmp    0x10(%ebp),%eax
f01209bb:	7d 19                	jge    f01209d6 <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f01209bd:	ff 45 08             	incl   0x8(%ebp)
f01209c0:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01209c3:	0f af 45 10          	imul   0x10(%ebp),%eax
f01209c7:	89 c2                	mov    %eax,%edx
f01209c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01209cc:	01 d0                	add    %edx,%eax
f01209ce:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f01209d1:	e9 7b ff ff ff       	jmp    f0120951 <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f01209d6:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f01209d7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01209db:	74 08                	je     f01209e5 <strtol+0x134>
		*endptr = (char *) s;
f01209dd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01209e0:	8b 55 08             	mov    0x8(%ebp),%edx
f01209e3:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f01209e5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01209e9:	74 07                	je     f01209f2 <strtol+0x141>
f01209eb:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01209ee:	f7 d8                	neg    %eax
f01209f0:	eb 03                	jmp    f01209f5 <strtol+0x144>
f01209f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f01209f5:	c9                   	leave  
f01209f6:	c3                   	ret    

f01209f7 <ltostr>:

void
ltostr(long value, char *str)
{
f01209f7:	55                   	push   %ebp
f01209f8:	89 e5                	mov    %esp,%ebp
f01209fa:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f01209fd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f0120a04:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f0120a0b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120a0f:	79 13                	jns    f0120a24 <ltostr+0x2d>
	{
		neg = 1;
f0120a11:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f0120a18:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120a1b:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f0120a1e:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f0120a21:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f0120a24:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a27:	b9 0a 00 00 00       	mov    $0xa,%ecx
f0120a2c:	99                   	cltd   
f0120a2d:	f7 f9                	idiv   %ecx
f0120a2f:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f0120a32:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120a35:	8d 50 01             	lea    0x1(%eax),%edx
f0120a38:	89 55 f8             	mov    %edx,-0x8(%ebp)
f0120a3b:	89 c2                	mov    %eax,%edx
f0120a3d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120a40:	01 d0                	add    %edx,%eax
f0120a42:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120a45:	83 c2 30             	add    $0x30,%edx
f0120a48:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f0120a4a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0120a4d:	b8 67 66 66 66       	mov    $0x66666667,%eax
f0120a52:	f7 e9                	imul   %ecx
f0120a54:	c1 fa 02             	sar    $0x2,%edx
f0120a57:	89 c8                	mov    %ecx,%eax
f0120a59:	c1 f8 1f             	sar    $0x1f,%eax
f0120a5c:	29 c2                	sub    %eax,%edx
f0120a5e:	89 d0                	mov    %edx,%eax
f0120a60:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f0120a63:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120a67:	75 bb                	jne    f0120a24 <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f0120a69:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f0120a70:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120a73:	48                   	dec    %eax
f0120a74:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f0120a77:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0120a7b:	74 3d                	je     f0120aba <ltostr+0xc3>
		start = 1 ;
f0120a7d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f0120a84:	eb 34                	jmp    f0120aba <ltostr+0xc3>
	{
		char tmp = str[start] ;
f0120a86:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120a89:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120a8c:	01 d0                	add    %edx,%eax
f0120a8e:	8a 00                	mov    (%eax),%al
f0120a90:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f0120a93:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120a96:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120a99:	01 c2                	add    %eax,%edx
f0120a9b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f0120a9e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120aa1:	01 c8                	add    %ecx,%eax
f0120aa3:	8a 00                	mov    (%eax),%al
f0120aa5:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f0120aa7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120aaa:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120aad:	01 c2                	add    %eax,%edx
f0120aaf:	8a 45 eb             	mov    -0x15(%ebp),%al
f0120ab2:	88 02                	mov    %al,(%edx)
		start++ ;
f0120ab4:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f0120ab7:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f0120aba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120abd:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0120ac0:	7c c4                	jl     f0120a86 <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f0120ac2:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0120ac5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120ac8:	01 d0                	add    %edx,%eax
f0120aca:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f0120acd:	90                   	nop
f0120ace:	c9                   	leave  
f0120acf:	c3                   	ret    

f0120ad0 <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f0120ad0:	55                   	push   %ebp
f0120ad1:	89 e5                	mov    %esp,%ebp
f0120ad3:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f0120ad6:	ff 75 08             	pushl  0x8(%ebp)
f0120ad9:	e8 73 fa ff ff       	call   f0120551 <strlen>
f0120ade:	83 c4 04             	add    $0x4,%esp
f0120ae1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f0120ae4:	ff 75 0c             	pushl  0xc(%ebp)
f0120ae7:	e8 65 fa ff ff       	call   f0120551 <strlen>
f0120aec:	83 c4 04             	add    $0x4,%esp
f0120aef:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f0120af2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f0120af9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0120b00:	eb 17                	jmp    f0120b19 <strcconcat+0x49>
		final[s] = str1[s] ;
f0120b02:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0120b05:	8b 45 10             	mov    0x10(%ebp),%eax
f0120b08:	01 c2                	add    %eax,%edx
f0120b0a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f0120b0d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b10:	01 c8                	add    %ecx,%eax
f0120b12:	8a 00                	mov    (%eax),%al
f0120b14:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f0120b16:	ff 45 fc             	incl   -0x4(%ebp)
f0120b19:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120b1c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0120b1f:	7c e1                	jl     f0120b02 <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f0120b21:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f0120b28:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f0120b2f:	eb 1f                	jmp    f0120b50 <strcconcat+0x80>
		final[s++] = str2[i] ;
f0120b31:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120b34:	8d 50 01             	lea    0x1(%eax),%edx
f0120b37:	89 55 fc             	mov    %edx,-0x4(%ebp)
f0120b3a:	89 c2                	mov    %eax,%edx
f0120b3c:	8b 45 10             	mov    0x10(%ebp),%eax
f0120b3f:	01 c2                	add    %eax,%edx
f0120b41:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f0120b44:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120b47:	01 c8                	add    %ecx,%eax
f0120b49:	8a 00                	mov    (%eax),%al
f0120b4b:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f0120b4d:	ff 45 f8             	incl   -0x8(%ebp)
f0120b50:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120b53:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0120b56:	7c d9                	jl     f0120b31 <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f0120b58:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0120b5b:	8b 45 10             	mov    0x10(%ebp),%eax
f0120b5e:	01 d0                	add    %edx,%eax
f0120b60:	c6 00 00             	movb   $0x0,(%eax)
}
f0120b63:	90                   	nop
f0120b64:	c9                   	leave  
f0120b65:	c3                   	ret    

f0120b66 <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f0120b66:	55                   	push   %ebp
f0120b67:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f0120b69:	8b 45 14             	mov    0x14(%ebp),%eax
f0120b6c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f0120b72:	8b 45 14             	mov    0x14(%ebp),%eax
f0120b75:	8b 00                	mov    (%eax),%eax
f0120b77:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0120b7e:	8b 45 10             	mov    0x10(%ebp),%eax
f0120b81:	01 d0                	add    %edx,%eax
f0120b83:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f0120b89:	eb 0c                	jmp    f0120b97 <strsplit+0x31>
			*string++ = 0;
f0120b8b:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b8e:	8d 50 01             	lea    0x1(%eax),%edx
f0120b91:	89 55 08             	mov    %edx,0x8(%ebp)
f0120b94:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f0120b97:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b9a:	8a 00                	mov    (%eax),%al
f0120b9c:	84 c0                	test   %al,%al
f0120b9e:	74 18                	je     f0120bb8 <strsplit+0x52>
f0120ba0:	8b 45 08             	mov    0x8(%ebp),%eax
f0120ba3:	8a 00                	mov    (%eax),%al
f0120ba5:	0f be c0             	movsbl %al,%eax
f0120ba8:	50                   	push   %eax
f0120ba9:	ff 75 0c             	pushl  0xc(%ebp)
f0120bac:	e8 32 fb ff ff       	call   f01206e3 <strchr>
f0120bb1:	83 c4 08             	add    $0x8,%esp
f0120bb4:	85 c0                	test   %eax,%eax
f0120bb6:	75 d3                	jne    f0120b8b <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f0120bb8:	8b 45 08             	mov    0x8(%ebp),%eax
f0120bbb:	8a 00                	mov    (%eax),%al
f0120bbd:	84 c0                	test   %al,%al
f0120bbf:	74 5a                	je     f0120c1b <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f0120bc1:	8b 45 14             	mov    0x14(%ebp),%eax
f0120bc4:	8b 00                	mov    (%eax),%eax
f0120bc6:	83 f8 0f             	cmp    $0xf,%eax
f0120bc9:	75 07                	jne    f0120bd2 <strsplit+0x6c>
		{
			return 0;
f0120bcb:	b8 00 00 00 00       	mov    $0x0,%eax
f0120bd0:	eb 66                	jmp    f0120c38 <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f0120bd2:	8b 45 14             	mov    0x14(%ebp),%eax
f0120bd5:	8b 00                	mov    (%eax),%eax
f0120bd7:	8d 48 01             	lea    0x1(%eax),%ecx
f0120bda:	8b 55 14             	mov    0x14(%ebp),%edx
f0120bdd:	89 0a                	mov    %ecx,(%edx)
f0120bdf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0120be6:	8b 45 10             	mov    0x10(%ebp),%eax
f0120be9:	01 c2                	add    %eax,%edx
f0120beb:	8b 45 08             	mov    0x8(%ebp),%eax
f0120bee:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f0120bf0:	eb 03                	jmp    f0120bf5 <strsplit+0x8f>
			string++;
f0120bf2:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f0120bf5:	8b 45 08             	mov    0x8(%ebp),%eax
f0120bf8:	8a 00                	mov    (%eax),%al
f0120bfa:	84 c0                	test   %al,%al
f0120bfc:	74 8b                	je     f0120b89 <strsplit+0x23>
f0120bfe:	8b 45 08             	mov    0x8(%ebp),%eax
f0120c01:	8a 00                	mov    (%eax),%al
f0120c03:	0f be c0             	movsbl %al,%eax
f0120c06:	50                   	push   %eax
f0120c07:	ff 75 0c             	pushl  0xc(%ebp)
f0120c0a:	e8 d4 fa ff ff       	call   f01206e3 <strchr>
f0120c0f:	83 c4 08             	add    $0x8,%esp
f0120c12:	85 c0                	test   %eax,%eax
f0120c14:	74 dc                	je     f0120bf2 <strsplit+0x8c>
			string++;
	}
f0120c16:	e9 6e ff ff ff       	jmp    f0120b89 <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f0120c1b:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f0120c1c:	8b 45 14             	mov    0x14(%ebp),%eax
f0120c1f:	8b 00                	mov    (%eax),%eax
f0120c21:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0120c28:	8b 45 10             	mov    0x10(%ebp),%eax
f0120c2b:	01 d0                	add    %edx,%eax
f0120c2d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f0120c33:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0120c38:	c9                   	leave  
f0120c39:	c3                   	ret    

f0120c3a <str2lower>:


char* str2lower(char *dst, const char *src)
{
f0120c3a:	55                   	push   %ebp
f0120c3b:	89 e5                	mov    %esp,%ebp
f0120c3d:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT]
	panic("str2lower is not implemented yet!");
f0120c40:	83 ec 04             	sub    $0x4,%esp
f0120c43:	68 1c dd 12 f0       	push   $0xf012dd1c
f0120c48:	68 3f 01 00 00       	push   $0x13f
f0120c4d:	68 3e dd 12 f0       	push   $0xf012dd3e
f0120c52:	e8 c3 f6 fd ff       	call   f010031a <_panic>

f0120c57 <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f0120c57:	55                   	push   %ebp
f0120c58:	89 e5                	mov    %esp,%ebp
f0120c5a:	83 ec 18             	sub    $0x18,%esp
f0120c5d:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0120c64:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c67:	89 c2                	mov    %eax,%edx
f0120c69:	ec                   	in     (%dx),%al
f0120c6a:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f0120c6d:	8a 45 ef             	mov    -0x11(%ebp),%al
	int r;
	//cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f0120c70:	0f b6 c0             	movzbl %al,%eax
f0120c73:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120c76:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c79:	25 c0 00 00 00       	and    $0xc0,%eax
f0120c7e:	83 f8 40             	cmp    $0x40,%eax
f0120c81:	75 10                	jne    f0120c93 <disk_interrupt_handler+0x3c>
	{
		//cprintf("NOT READY\n");
	}
	else
	{
		wakeup_one(&DISKchannel);
f0120c83:	83 ec 0c             	sub    $0xc,%esp
f0120c86:	68 00 24 55 f0       	push   $0xf0552400
f0120c8b:	e8 a7 de fe ff       	call   f010eb37 <wakeup_one>
f0120c90:	83 c4 10             	add    $0x10,%esp
	}

}
f0120c93:	90                   	nop
f0120c94:	c9                   	leave  
f0120c95:	c3                   	ret    

f0120c96 <ide_init>:

void ide_init()
{
f0120c96:	55                   	push   %ebp
f0120c97:	89 e5                	mov    %esp,%ebp
f0120c99:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(14, &disk_interrupt_handler);
f0120c9c:	83 ec 08             	sub    $0x8,%esp
f0120c9f:	68 57 0c 12 f0       	push   $0xf0120c57
f0120ca4:	6a 0e                	push   $0xe
f0120ca6:	e8 0b c4 fe ff       	call   f010d0b6 <irq_install_handler>
f0120cab:	83 c4 10             	add    $0x10,%esp
	//irq_install_handler(15, &disk_interrupt_handler);
	if (DISK_INT_BLK_METHOD == LCK_SLEEP)
	{
		init_channel(&DISKchannel, "DISK channel");
f0120cae:	83 ec 08             	sub    $0x8,%esp
f0120cb1:	68 4c dd 12 f0       	push   $0xf012dd4c
f0120cb6:	68 00 24 55 f0       	push   $0xf0552400
f0120cbb:	e8 30 de fe ff       	call   f010eaf0 <init_channel>
f0120cc0:	83 c4 10             	add    $0x10,%esp
		init_spinlock(&DISKlock, "DISK channel lock");
f0120cc3:	83 ec 08             	sub    $0x8,%esp
f0120cc6:	68 59 dd 12 f0       	push   $0xf012dd59
f0120ccb:	68 40 4f 55 f0       	push   $0xf0554f40
f0120cd0:	e8 98 da fe ff       	call   f010e76d <init_spinlock>
f0120cd5:	83 c4 10             	add    $0x10,%esp
	}
	else if (DISK_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
	}
}
f0120cd8:	90                   	nop
f0120cd9:	c9                   	leave  
f0120cda:	c3                   	ret    

f0120cdb <ide_wait_ready>:
//	}
//	return 0;
//}

static int ide_wait_ready(bool check_error)
{
f0120cdb:	55                   	push   %ebp
f0120cdc:	89 e5                	mov    %esp,%ebp
f0120cde:	83 ec 18             	sub    $0x18,%esp
	int r;

	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f0120ce1:	90                   	nop
f0120ce2:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0120ce9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120cec:	89 c2                	mov    %eax,%edx
f0120cee:	ec                   	in     (%dx),%al
f0120cef:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f0120cf2:	8a 45 ef             	mov    -0x11(%ebp),%al
f0120cf5:	0f b6 c0             	movzbl %al,%eax
f0120cf8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120cfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120cfe:	25 c0 00 00 00       	and    $0xc0,%eax
f0120d03:	83 f8 40             	cmp    $0x40,%eax
f0120d06:	75 da                	jne    f0120ce2 <ide_wait_ready+0x7>
	/* do nothing */;


	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f0120d08:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120d0c:	74 24                	je     f0120d32 <ide_wait_ready+0x57>
f0120d0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120d11:	83 e0 21             	and    $0x21,%eax
f0120d14:	85 c0                	test   %eax,%eax
f0120d16:	74 1a                	je     f0120d32 <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f0120d18:	83 ec 0c             	sub    $0xc,%esp
f0120d1b:	ff 75 f4             	pushl  -0xc(%ebp)
f0120d1e:	ff 75 f4             	pushl  -0xc(%ebp)
f0120d21:	68 6c dd 12 f0       	push   $0xf012dd6c
f0120d26:	6a 5d                	push   $0x5d
f0120d28:	68 8f dd 12 f0       	push   $0xf012dd8f
f0120d2d:	e8 e8 f5 fd ff       	call   f010031a <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f0120d32:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120d37:	c9                   	leave  
f0120d38:	c3                   	ret    

f0120d39 <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f0120d39:	55                   	push   %ebp
f0120d3a:	89 e5                	mov    %esp,%ebp
f0120d3c:	57                   	push   %edi
f0120d3d:	53                   	push   %ebx
f0120d3e:	83 ec 30             	sub    $0x30,%esp
	int r;

	assert(nsecs <= 256);
f0120d41:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f0120d48:	76 16                	jbe    f0120d60 <ide_read+0x27>
f0120d4a:	68 9a dd 12 f0       	push   $0xf012dd9a
f0120d4f:	68 a7 dd 12 f0       	push   $0xf012dda7
f0120d54:	6a 68                	push   $0x68
f0120d56:	68 8f dd 12 f0       	push   $0xf012dd8f
f0120d5b:	e8 ba f5 fd ff       	call   f010031a <_panic>

	//FUTURE NOTE: This BUSY-WAIT should be replaced by Interrupt to allow the OS to schedule another process till the device become ready [el7 :)]
	ide_wait_ready(0);
f0120d60:	83 ec 0c             	sub    $0xc,%esp
f0120d63:	6a 00                	push   $0x0
f0120d65:	e8 71 ff ff ff       	call   f0120cdb <ide_wait_ready>
f0120d6a:	83 c4 10             	add    $0x10,%esp

	outb(0x1F2, nsecs);
f0120d6d:	8b 45 10             	mov    0x10(%ebp),%eax
f0120d70:	0f b6 c0             	movzbl %al,%eax
f0120d73:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f0120d7a:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0120d7d:	8a 45 d2             	mov    -0x2e(%ebp),%al
f0120d80:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120d83:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f0120d84:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d87:	0f b6 c0             	movzbl %al,%eax
f0120d8a:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f0120d91:	88 45 d3             	mov    %al,-0x2d(%ebp)
f0120d94:	8a 45 d3             	mov    -0x2d(%ebp),%al
f0120d97:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120d9a:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f0120d9b:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d9e:	c1 e8 08             	shr    $0x8,%eax
f0120da1:	0f b6 c0             	movzbl %al,%eax
f0120da4:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f0120dab:	88 45 d4             	mov    %al,-0x2c(%ebp)
f0120dae:	8a 45 d4             	mov    -0x2c(%ebp),%al
f0120db1:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0120db4:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f0120db5:	8b 45 08             	mov    0x8(%ebp),%eax
f0120db8:	c1 e8 10             	shr    $0x10,%eax
f0120dbb:	0f b6 c0             	movzbl %al,%eax
f0120dbe:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f0120dc5:	88 45 d5             	mov    %al,-0x2b(%ebp)
f0120dc8:	8a 45 d5             	mov    -0x2b(%ebp),%al
f0120dcb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120dce:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f0120dcf:	a1 b0 22 55 f0       	mov    0xf05522b0,%eax
f0120dd4:	83 e0 01             	and    $0x1,%eax
f0120dd7:	c1 e0 04             	shl    $0x4,%eax
f0120dda:	88 c2                	mov    %al,%dl
f0120ddc:	8b 45 08             	mov    0x8(%ebp),%eax
f0120ddf:	c1 e8 18             	shr    $0x18,%eax
f0120de2:	83 e0 0f             	and    $0xf,%eax
f0120de5:	09 d0                	or     %edx,%eax
f0120de7:	83 c8 e0             	or     $0xffffffe0,%eax
f0120dea:	0f b6 c0             	movzbl %al,%eax
f0120ded:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f0120df4:	88 45 d6             	mov    %al,-0x2a(%ebp)
f0120df7:	8a 45 d6             	mov    -0x2a(%ebp),%al
f0120dfa:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0120dfd:	ee                   	out    %al,(%dx)
f0120dfe:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f0120e05:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
f0120e09:	8a 45 d7             	mov    -0x29(%ebp),%al
f0120e0c:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0120e0f:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f0120e10:	eb 55                	jmp    f0120e67 <ide_read+0x12e>
		if ((r = ide_wait_ready(1)) < 0)
f0120e12:	83 ec 0c             	sub    $0xc,%esp
f0120e15:	6a 01                	push   $0x1
f0120e17:	e8 bf fe ff ff       	call   f0120cdb <ide_wait_ready>
f0120e1c:	83 c4 10             	add    $0x10,%esp
f0120e1f:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0120e22:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0120e26:	79 05                	jns    f0120e2d <ide_read+0xf4>
			return r;
f0120e28:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120e2b:	eb 45                	jmp    f0120e72 <ide_read+0x139>
f0120e2d:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f0120e34:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120e37:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0120e3a:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f0120e41:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120e44:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f0120e47:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120e4a:	89 cb                	mov    %ecx,%ebx
f0120e4c:	89 df                	mov    %ebx,%edi
f0120e4e:	89 c1                	mov    %eax,%ecx
f0120e50:	fc                   	cld    
f0120e51:	f2 6d                	repnz insl (%dx),%es:(%edi)
f0120e53:	89 c8                	mov    %ecx,%eax
f0120e55:	89 fb                	mov    %edi,%ebx
f0120e57:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f0120e5a:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F4, (secno >> 8) & 0xFF);
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f0120e5d:	ff 4d 10             	decl   0x10(%ebp)
f0120e60:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f0120e67:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120e6b:	75 a5                	jne    f0120e12 <ide_read+0xd9>
		if ((r = ide_wait_ready(1)) < 0)
			return r;
		insl(0x1F0, dst, SECTSIZE/4);
	}

	return 0;
f0120e6d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120e72:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0120e75:	5b                   	pop    %ebx
f0120e76:	5f                   	pop    %edi
f0120e77:	5d                   	pop    %ebp
f0120e78:	c3                   	ret    

f0120e79 <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f0120e79:	55                   	push   %ebp
f0120e7a:	89 e5                	mov    %esp,%ebp
f0120e7c:	56                   	push   %esi
f0120e7d:	53                   	push   %ebx
f0120e7e:	83 ec 30             	sub    $0x30,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f0120e81:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f0120e88:	76 19                	jbe    f0120ea3 <ide_write+0x2a>
f0120e8a:	68 9a dd 12 f0       	push   $0xf012dd9a
f0120e8f:	68 a7 dd 12 f0       	push   $0xf012dda7
f0120e94:	68 82 00 00 00       	push   $0x82
f0120e99:	68 8f dd 12 f0       	push   $0xf012dd8f
f0120e9e:	e8 77 f4 fd ff       	call   f010031a <_panic>

	//LOG_STATMENT(cprintf("2\n");)
	ide_wait_ready(0);
f0120ea3:	83 ec 0c             	sub    $0xc,%esp
f0120ea6:	6a 00                	push   $0x0
f0120ea8:	e8 2e fe ff ff       	call   f0120cdb <ide_wait_ready>
f0120ead:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
	outb(0x1F2, nsecs);
f0120eb0:	8b 45 10             	mov    0x10(%ebp),%eax
f0120eb3:	0f b6 c0             	movzbl %al,%eax
f0120eb6:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f0120ebd:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0120ec0:	8a 45 d2             	mov    -0x2e(%ebp),%al
f0120ec3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120ec6:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f0120ec7:	8b 45 08             	mov    0x8(%ebp),%eax
f0120eca:	0f b6 c0             	movzbl %al,%eax
f0120ecd:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f0120ed4:	88 45 d3             	mov    %al,-0x2d(%ebp)
f0120ed7:	8a 45 d3             	mov    -0x2d(%ebp),%al
f0120eda:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120edd:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f0120ede:	8b 45 08             	mov    0x8(%ebp),%eax
f0120ee1:	c1 e8 08             	shr    $0x8,%eax
f0120ee4:	0f b6 c0             	movzbl %al,%eax
f0120ee7:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f0120eee:	88 45 d4             	mov    %al,-0x2c(%ebp)
f0120ef1:	8a 45 d4             	mov    -0x2c(%ebp),%al
f0120ef4:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0120ef7:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f0120ef8:	8b 45 08             	mov    0x8(%ebp),%eax
f0120efb:	c1 e8 10             	shr    $0x10,%eax
f0120efe:	0f b6 c0             	movzbl %al,%eax
f0120f01:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f0120f08:	88 45 d5             	mov    %al,-0x2b(%ebp)
f0120f0b:	8a 45 d5             	mov    -0x2b(%ebp),%al
f0120f0e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120f11:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f0120f12:	a1 b0 22 55 f0       	mov    0xf05522b0,%eax
f0120f17:	83 e0 01             	and    $0x1,%eax
f0120f1a:	c1 e0 04             	shl    $0x4,%eax
f0120f1d:	88 c2                	mov    %al,%dl
f0120f1f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120f22:	c1 e8 18             	shr    $0x18,%eax
f0120f25:	83 e0 0f             	and    $0xf,%eax
f0120f28:	09 d0                	or     %edx,%eax
f0120f2a:	83 c8 e0             	or     $0xffffffe0,%eax
f0120f2d:	0f b6 c0             	movzbl %al,%eax
f0120f30:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f0120f37:	88 45 d6             	mov    %al,-0x2a(%ebp)
f0120f3a:	8a 45 d6             	mov    -0x2a(%ebp),%al
f0120f3d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0120f40:	ee                   	out    %al,(%dx)
f0120f41:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f0120f48:	c6 45 d7 30          	movb   $0x30,-0x29(%ebp)
f0120f4c:	8a 45 d7             	mov    -0x29(%ebp),%al
f0120f4f:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0120f52:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f0120f53:	eb 55                	jmp    f0120faa <ide_write+0x131>
		if ((r = ide_wait_ready(1)) < 0)
f0120f55:	83 ec 0c             	sub    $0xc,%esp
f0120f58:	6a 01                	push   $0x1
f0120f5a:	e8 7c fd ff ff       	call   f0120cdb <ide_wait_ready>
f0120f5f:	83 c4 10             	add    $0x10,%esp
f0120f62:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0120f65:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0120f69:	79 05                	jns    f0120f70 <ide_write+0xf7>
		{
			LOG_STATMENT(cprintf("FAILURE to write %d sectors to disk\n",nsecs););
			return r;
f0120f6b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120f6e:	eb 45                	jmp    f0120fb5 <ide_write+0x13c>
f0120f70:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f0120f77:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f7a:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0120f7d:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f0120f84:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120f87:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f0120f8a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120f8d:	89 cb                	mov    %ecx,%ebx
f0120f8f:	89 de                	mov    %ebx,%esi
f0120f91:	89 c1                	mov    %eax,%ecx
f0120f93:	fc                   	cld    
f0120f94:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f0120f96:	89 c8                	mov    %ecx,%eax
f0120f98:	89 f3                	mov    %esi,%ebx
f0120f9a:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f0120f9d:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f0120fa0:	ff 4d 10             	decl   0x10(%ebp)
f0120fa3:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f0120faa:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120fae:	75 a5                	jne    f0120f55 <ide_write+0xdc>
		}
	}
	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f0120fb0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120fb5:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0120fb8:	5b                   	pop    %ebx
f0120fb9:	5e                   	pop    %esi
f0120fba:	5d                   	pop    %ebp
f0120fbb:	c3                   	ret    

f0120fbc <get_block_size>:

//=====================================================
// 1) GET BLOCK SIZE (including size of its meta data):
//=====================================================
__inline__ uint32 get_block_size(void* va)
{
f0120fbc:	55                   	push   %ebp
f0120fbd:	89 e5                	mov    %esp,%ebp
f0120fbf:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f0120fc2:	8b 45 08             	mov    0x8(%ebp),%eax
f0120fc5:	83 e8 04             	sub    $0x4,%eax
f0120fc8:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (*curBlkMetaData) & ~(0x1);
f0120fcb:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120fce:	8b 00                	mov    (%eax),%eax
f0120fd0:	83 e0 fe             	and    $0xfffffffe,%eax
}
f0120fd3:	c9                   	leave  
f0120fd4:	c3                   	ret    

f0120fd5 <is_free_block>:

//===========================
// 2) GET BLOCK STATUS:
//===========================
__inline__ int8 is_free_block(void* va)
{
f0120fd5:	55                   	push   %ebp
f0120fd6:	89 e5                	mov    %esp,%ebp
f0120fd8:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f0120fdb:	8b 45 08             	mov    0x8(%ebp),%eax
f0120fde:	83 e8 04             	sub    $0x4,%eax
f0120fe1:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (~(*curBlkMetaData) & 0x1) ;
f0120fe4:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120fe7:	8b 00                	mov    (%eax),%eax
f0120fe9:	83 e0 01             	and    $0x1,%eax
f0120fec:	85 c0                	test   %eax,%eax
f0120fee:	0f 94 c0             	sete   %al
}
f0120ff1:	c9                   	leave  
f0120ff2:	c3                   	ret    

f0120ff3 <alloc_block>:
//===========================
// 3) ALLOCATE BLOCK:
//===========================

void *alloc_block(uint32 size, int ALLOC_STRATEGY)
{
f0120ff3:	55                   	push   %ebp
f0120ff4:	89 e5                	mov    %esp,%ebp
f0120ff6:	83 ec 18             	sub    $0x18,%esp
	void *va = NULL;
f0120ff9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (ALLOC_STRATEGY)
f0121000:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121003:	83 f8 02             	cmp    $0x2,%eax
f0121006:	74 2b                	je     f0121033 <alloc_block+0x40>
f0121008:	83 f8 02             	cmp    $0x2,%eax
f012100b:	7f 07                	jg     f0121014 <alloc_block+0x21>
f012100d:	83 f8 01             	cmp    $0x1,%eax
f0121010:	74 0e                	je     f0121020 <alloc_block+0x2d>
f0121012:	eb 58                	jmp    f012106c <alloc_block+0x79>
f0121014:	83 f8 03             	cmp    $0x3,%eax
f0121017:	74 2d                	je     f0121046 <alloc_block+0x53>
f0121019:	83 f8 04             	cmp    $0x4,%eax
f012101c:	74 3b                	je     f0121059 <alloc_block+0x66>
f012101e:	eb 4c                	jmp    f012106c <alloc_block+0x79>
	{
	case DA_FF:
		va = alloc_block_FF(size);
f0121020:	83 ec 0c             	sub    $0xc,%esp
f0121023:	ff 75 08             	pushl  0x8(%ebp)
f0121026:	e8 49 01 00 00       	call   f0121174 <alloc_block_FF>
f012102b:	83 c4 10             	add    $0x10,%esp
f012102e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0121031:	eb 4a                	jmp    f012107d <alloc_block+0x8a>
	case DA_NF:
		va = alloc_block_NF(size);
f0121033:	83 ec 0c             	sub    $0xc,%esp
f0121036:	ff 75 08             	pushl  0x8(%ebp)
f0121039:	e8 4d 02 00 00       	call   f012128b <alloc_block_NF>
f012103e:	83 c4 10             	add    $0x10,%esp
f0121041:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0121044:	eb 37                	jmp    f012107d <alloc_block+0x8a>
	case DA_BF:
		va = alloc_block_BF(size);
f0121046:	83 ec 0c             	sub    $0xc,%esp
f0121049:	ff 75 08             	pushl  0x8(%ebp)
f012104c:	e8 c6 01 00 00       	call   f0121217 <alloc_block_BF>
f0121051:	83 c4 10             	add    $0x10,%esp
f0121054:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0121057:	eb 24                	jmp    f012107d <alloc_block+0x8a>
	case DA_WF:
		va = alloc_block_WF(size);
f0121059:	83 ec 0c             	sub    $0xc,%esp
f012105c:	ff 75 08             	pushl  0x8(%ebp)
f012105f:	e8 0a 02 00 00       	call   f012126e <alloc_block_WF>
f0121064:	83 c4 10             	add    $0x10,%esp
f0121067:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f012106a:	eb 11                	jmp    f012107d <alloc_block+0x8a>
	default:
		cprintf("Invalid allocation strategy\n");
f012106c:	83 ec 0c             	sub    $0xc,%esp
f012106f:	68 bc dd 12 f0       	push   $0xf012ddbc
f0121074:	e8 f3 fe fd ff       	call   f0100f6c <cprintf>
f0121079:	83 c4 10             	add    $0x10,%esp
		break;
f012107c:	90                   	nop
	}
	return va;
f012107d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0121080:	c9                   	leave  
f0121081:	c3                   	ret    

f0121082 <print_blocks_list>:
//===========================
// 4) PRINT BLOCKS LIST:
//===========================

void print_blocks_list(struct MemBlock_LIST list)
{
f0121082:	55                   	push   %ebp
f0121083:	89 e5                	mov    %esp,%ebp
f0121085:	53                   	push   %ebx
f0121086:	83 ec 14             	sub    $0x14,%esp
	cprintf("=========================================\n");
f0121089:	83 ec 0c             	sub    $0xc,%esp
f012108c:	68 dc dd 12 f0       	push   $0xf012dddc
f0121091:	e8 d6 fe fd ff       	call   f0100f6c <cprintf>
f0121096:	83 c4 10             	add    $0x10,%esp
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
f0121099:	83 ec 0c             	sub    $0xc,%esp
f012109c:	68 07 de 12 f0       	push   $0xf012de07
f01210a1:	e8 c6 fe fd ff       	call   f0100f6c <cprintf>
f01210a6:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(blk, &list)
f01210a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01210ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01210af:	eb 37                	jmp    f01210e8 <print_blocks_list+0x66>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
f01210b1:	83 ec 0c             	sub    $0xc,%esp
f01210b4:	ff 75 f4             	pushl  -0xc(%ebp)
f01210b7:	e8 19 ff ff ff       	call   f0120fd5 <is_free_block>
f01210bc:	83 c4 10             	add    $0x10,%esp
f01210bf:	0f be d8             	movsbl %al,%ebx
f01210c2:	83 ec 0c             	sub    $0xc,%esp
f01210c5:	ff 75 f4             	pushl  -0xc(%ebp)
f01210c8:	e8 ef fe ff ff       	call   f0120fbc <get_block_size>
f01210cd:	83 c4 10             	add    $0x10,%esp
f01210d0:	83 ec 04             	sub    $0x4,%esp
f01210d3:	53                   	push   %ebx
f01210d4:	50                   	push   %eax
f01210d5:	68 1f de 12 f0       	push   $0xf012de1f
f01210da:	e8 8d fe fd ff       	call   f0100f6c <cprintf>
f01210df:	83 c4 10             	add    $0x10,%esp
void print_blocks_list(struct MemBlock_LIST list)
{
	cprintf("=========================================\n");
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
	LIST_FOREACH(blk, &list)
f01210e2:	8b 45 10             	mov    0x10(%ebp),%eax
f01210e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01210e8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01210ec:	74 07                	je     f01210f5 <print_blocks_list+0x73>
f01210ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210f1:	8b 00                	mov    (%eax),%eax
f01210f3:	eb 05                	jmp    f01210fa <print_blocks_list+0x78>
f01210f5:	b8 00 00 00 00       	mov    $0x0,%eax
f01210fa:	89 45 10             	mov    %eax,0x10(%ebp)
f01210fd:	8b 45 10             	mov    0x10(%ebp),%eax
f0121100:	85 c0                	test   %eax,%eax
f0121102:	75 ad                	jne    f01210b1 <print_blocks_list+0x2f>
f0121104:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0121108:	75 a7                	jne    f01210b1 <print_blocks_list+0x2f>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
	}
	cprintf("=========================================\n");
f012110a:	83 ec 0c             	sub    $0xc,%esp
f012110d:	68 dc dd 12 f0       	push   $0xf012dddc
f0121112:	e8 55 fe fd ff       	call   f0100f6c <cprintf>
f0121117:	83 c4 10             	add    $0x10,%esp

}
f012111a:	90                   	nop
f012111b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f012111e:	c9                   	leave  
f012111f:	c3                   	ret    

f0121120 <initialize_dynamic_allocator>:
bool is_initialized = 0;
//==================================
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================
void initialize_dynamic_allocator(uint32 daStart, uint32 initSizeOfAllocatedSpace)
{
f0121120:	55                   	push   %ebp
f0121121:	89 e5                	mov    %esp,%ebp
f0121123:	83 ec 08             	sub    $0x8,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
f0121126:	8b 45 0c             	mov    0xc(%ebp),%eax
f0121129:	83 e0 01             	and    $0x1,%eax
f012112c:	85 c0                	test   %eax,%eax
f012112e:	74 03                	je     f0121133 <initialize_dynamic_allocator+0x13>
f0121130:	ff 45 0c             	incl   0xc(%ebp)
		if (initSizeOfAllocatedSpace == 0)
f0121133:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121137:	74 1e                	je     f0121157 <initialize_dynamic_allocator+0x37>
			return ;
		is_initialized = 1;
f0121139:	c7 05 b4 22 55 f0 01 	movl   $0x1,0xf05522b4
f0121140:	00 00 00 
	//==================================================================================
	//==================================================================================

	//TODO: [PROJECT'24.MS1 - #04] [3] DYNAMIC ALLOCATOR - initialize_dynamic_allocator
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("initialize_dynamic_allocator is not implemented yet");
f0121143:	83 ec 04             	sub    $0x4,%esp
f0121146:	68 38 de 12 f0       	push   $0xf012de38
f012114b:	6a 6a                	push   $0x6a
f012114d:	68 6c de 12 f0       	push   $0xf012de6c
f0121152:	e8 c3 f1 fd ff       	call   f010031a <_panic>
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
		if (initSizeOfAllocatedSpace == 0)
			return ;
f0121157:	90                   	nop
	//TODO: [PROJECT'24.MS1 - #04] [3] DYNAMIC ALLOCATOR - initialize_dynamic_allocator
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("initialize_dynamic_allocator is not implemented yet");
	//Your Code is Here...

}
f0121158:	c9                   	leave  
f0121159:	c3                   	ret    

f012115a <set_block_data>:
//==================================
// [2] SET BLOCK HEADER & FOOTER:
//==================================
void set_block_data(void* va, uint32 totalSize, bool isAllocated)
{
f012115a:	55                   	push   %ebp
f012115b:	89 e5                	mov    %esp,%ebp
f012115d:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #05] [3] DYNAMIC ALLOCATOR - set_block_data
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("set_block_data is not implemented yet");
f0121160:	83 ec 04             	sub    $0x4,%esp
f0121163:	68 84 de 12 f0       	push   $0xf012de84
f0121168:	6a 75                	push   $0x75
f012116a:	68 6c de 12 f0       	push   $0xf012de6c
f012116f:	e8 a6 f1 fd ff       	call   f010031a <_panic>

f0121174 <alloc_block_FF>:

//=========================================
// [3] ALLOCATE BLOCK BY FIRST FIT:
//=========================================
void *alloc_block_FF(uint32 size)
{
f0121174:	55                   	push   %ebp
f0121175:	89 e5                	mov    %esp,%ebp
f0121177:	83 ec 28             	sub    $0x28,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f012117a:	8b 45 08             	mov    0x8(%ebp),%eax
f012117d:	83 e0 01             	and    $0x1,%eax
f0121180:	85 c0                	test   %eax,%eax
f0121182:	74 03                	je     f0121187 <alloc_block_FF+0x13>
f0121184:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f0121187:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f012118b:	77 07                	ja     f0121194 <alloc_block_FF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f012118d:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f0121194:	a1 b4 22 55 f0       	mov    0xf05522b4,%eax
f0121199:	85 c0                	test   %eax,%eax
f012119b:	75 63                	jne    f0121200 <alloc_block_FF+0x8c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f012119d:	8b 45 08             	mov    0x8(%ebp),%eax
f01211a0:	83 c0 10             	add    $0x10,%eax
f01211a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f01211a6:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f01211ad:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01211b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01211b3:	01 d0                	add    %edx,%eax
f01211b5:	48                   	dec    %eax
f01211b6:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01211b9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01211bc:	ba 00 00 00 00       	mov    $0x0,%edx
f01211c1:	f7 75 f0             	divl   -0x10(%ebp)
f01211c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01211c7:	29 d0                	sub    %edx,%eax
f01211c9:	c1 e8 0c             	shr    $0xc,%eax
f01211cc:	83 ec 0c             	sub    $0xc,%esp
f01211cf:	50                   	push   %eax
f01211d0:	e8 f5 75 fe ff       	call   f01087ca <sbrk>
f01211d5:	83 c4 10             	add    $0x10,%esp
f01211d8:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f01211db:	83 ec 0c             	sub    $0xc,%esp
f01211de:	6a 00                	push   $0x0
f01211e0:	e8 e5 75 fe ff       	call   f01087ca <sbrk>
f01211e5:	83 c4 10             	add    $0x10,%esp
f01211e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f01211eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01211ee:	2b 45 e8             	sub    -0x18(%ebp),%eax
f01211f1:	83 ec 08             	sub    $0x8,%esp
f01211f4:	50                   	push   %eax
f01211f5:	ff 75 e8             	pushl  -0x18(%ebp)
f01211f8:	e8 23 ff ff ff       	call   f0121120 <initialize_dynamic_allocator>
f01211fd:	83 c4 10             	add    $0x10,%esp
	//==================================================================================
	//==================================================================================

	//TODO: [PROJECT'24.MS1 - #06] [3] DYNAMIC ALLOCATOR - alloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("alloc_block_FF is not implemented yet");
f0121200:	83 ec 04             	sub    $0x4,%esp
f0121203:	68 ac de 12 f0       	push   $0xf012deac
f0121208:	68 93 00 00 00       	push   $0x93
f012120d:	68 6c de 12 f0       	push   $0xf012de6c
f0121212:	e8 03 f1 fd ff       	call   f010031a <_panic>

f0121217 <alloc_block_BF>:
}
//=========================================
// [4] ALLOCATE BLOCK BY BEST FIT:
//=========================================
void *alloc_block_BF(uint32 size)
{
f0121217:	55                   	push   %ebp
f0121218:	89 e5                	mov    %esp,%ebp
f012121a:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - BONUS] [3] DYNAMIC ALLOCATOR - alloc_block_BF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("alloc_block_BF is not implemented yet");
f012121d:	83 ec 04             	sub    $0x4,%esp
f0121220:	68 d4 de 12 f0       	push   $0xf012ded4
f0121225:	68 9e 00 00 00       	push   $0x9e
f012122a:	68 6c de 12 f0       	push   $0xf012de6c
f012122f:	e8 e6 f0 fd ff       	call   f010031a <_panic>

f0121234 <free_block>:

//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void free_block(void *va)
{
f0121234:	55                   	push   %ebp
f0121235:	89 e5                	mov    %esp,%ebp
f0121237:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #07] [3] DYNAMIC ALLOCATOR - free_block
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("free_block is not implemented yet");
f012123a:	83 ec 04             	sub    $0x4,%esp
f012123d:	68 fc de 12 f0       	push   $0xf012defc
f0121242:	68 aa 00 00 00       	push   $0xaa
f0121247:	68 6c de 12 f0       	push   $0xf012de6c
f012124c:	e8 c9 f0 fd ff       	call   f010031a <_panic>

f0121251 <realloc_block_FF>:

//=========================================
// [6] REALLOCATE BLOCK BY FIRST FIT:
//=========================================
void *realloc_block_FF(void* va, uint32 new_size)
{
f0121251:	55                   	push   %ebp
f0121252:	89 e5                	mov    %esp,%ebp
f0121254:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #08] [3] DYNAMIC ALLOCATOR - realloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("realloc_block_FF is not implemented yet");
f0121257:	83 ec 04             	sub    $0x4,%esp
f012125a:	68 20 df 12 f0       	push   $0xf012df20
f012125f:	68 b5 00 00 00       	push   $0xb5
f0121264:	68 6c de 12 f0       	push   $0xf012de6c
f0121269:	e8 ac f0 fd ff       	call   f010031a <_panic>

f012126e <alloc_block_WF>:
/*********************************************************************************************/
//=========================================
// [7] ALLOCATE BLOCK BY WORST FIT:
//=========================================
void *alloc_block_WF(uint32 size)
{
f012126e:	55                   	push   %ebp
f012126f:	89 e5                	mov    %esp,%ebp
f0121271:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_WF is not implemented yet");
f0121274:	83 ec 04             	sub    $0x4,%esp
f0121277:	68 48 df 12 f0       	push   $0xf012df48
f012127c:	68 c1 00 00 00       	push   $0xc1
f0121281:	68 6c de 12 f0       	push   $0xf012de6c
f0121286:	e8 8f f0 fd ff       	call   f010031a <_panic>

f012128b <alloc_block_NF>:

//=========================================
// [8] ALLOCATE BLOCK BY NEXT FIT:
//=========================================
void *alloc_block_NF(uint32 size)
{
f012128b:	55                   	push   %ebp
f012128c:	89 e5                	mov    %esp,%ebp
f012128e:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_NF is not implemented yet");
f0121291:	83 ec 04             	sub    $0x4,%esp
f0121294:	68 70 df 12 f0       	push   $0xf012df70
f0121299:	68 ca 00 00 00       	push   $0xca
f012129e:	68 6c de 12 f0       	push   $0xf012de6c
f01212a3:	e8 72 f0 fd ff       	call   f010031a <_panic>

f01212a8 <__moddi3>:
f01212a8:	55                   	push   %ebp
f01212a9:	57                   	push   %edi
f01212aa:	56                   	push   %esi
f01212ab:	53                   	push   %ebx
f01212ac:	83 ec 2c             	sub    $0x2c,%esp
f01212af:	8b 74 24 40          	mov    0x40(%esp),%esi
f01212b3:	8b 7c 24 44          	mov    0x44(%esp),%edi
f01212b7:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f01212bb:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f01212bf:	89 d8                	mov    %ebx,%eax
f01212c1:	85 ff                	test   %edi,%edi
f01212c3:	0f 88 d3 00 00 00    	js     f012139c <__moddi3+0xf4>
f01212c9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f01212d0:	00 
f01212d1:	85 c0                	test   %eax,%eax
f01212d3:	0f 88 ab 00 00 00    	js     f0121384 <__moddi3+0xdc>
f01212d9:	89 0c 24             	mov    %ecx,(%esp)
f01212dc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f01212e0:	89 74 24 10          	mov    %esi,0x10(%esp)
f01212e4:	89 fb                	mov    %edi,%ebx
f01212e6:	8b 14 24             	mov    (%esp),%edx
f01212e9:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f01212ed:	89 d0                	mov    %edx,%eax
f01212ef:	89 54 24 18          	mov    %edx,0x18(%esp)
f01212f3:	89 ca                	mov    %ecx,%edx
f01212f5:	8b 0c 24             	mov    (%esp),%ecx
f01212f8:	89 34 24             	mov    %esi,(%esp)
f01212fb:	89 7c 24 14          	mov    %edi,0x14(%esp)
f01212ff:	85 d2                	test   %edx,%edx
f0121301:	75 15                	jne    f0121318 <__moddi3+0x70>
f0121303:	89 c7                	mov    %eax,%edi
f0121305:	39 d8                	cmp    %ebx,%eax
f0121307:	76 5b                	jbe    f0121364 <__moddi3+0xbc>
f0121309:	89 f0                	mov    %esi,%eax
f012130b:	89 da                	mov    %ebx,%edx
f012130d:	f7 f7                	div    %edi
f012130f:	89 d3                	mov    %edx,%ebx
f0121311:	89 d8                	mov    %ebx,%eax
f0121313:	31 d2                	xor    %edx,%edx
f0121315:	eb 09                	jmp    f0121320 <__moddi3+0x78>
f0121317:	90                   	nop
f0121318:	39 fa                	cmp    %edi,%edx
f012131a:	76 1c                	jbe    f0121338 <__moddi3+0x90>
f012131c:	89 f0                	mov    %esi,%eax
f012131e:	89 fa                	mov    %edi,%edx
f0121320:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f0121324:	85 c9                	test   %ecx,%ecx
f0121326:	74 07                	je     f012132f <__moddi3+0x87>
f0121328:	f7 d8                	neg    %eax
f012132a:	83 d2 00             	adc    $0x0,%edx
f012132d:	f7 da                	neg    %edx
f012132f:	83 c4 2c             	add    $0x2c,%esp
f0121332:	5b                   	pop    %ebx
f0121333:	5e                   	pop    %esi
f0121334:	5f                   	pop    %edi
f0121335:	5d                   	pop    %ebp
f0121336:	c3                   	ret    
f0121337:	90                   	nop
f0121338:	0f bd c2             	bsr    %edx,%eax
f012133b:	83 f0 1f             	xor    $0x1f,%eax
f012133e:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f0121342:	75 6c                	jne    f01213b0 <__moddi3+0x108>
f0121344:	39 fa                	cmp    %edi,%edx
f0121346:	72 05                	jb     f012134d <__moddi3+0xa5>
f0121348:	3b 0c 24             	cmp    (%esp),%ecx
f012134b:	77 0e                	ja     f012135b <__moddi3+0xb3>
f012134d:	8b 34 24             	mov    (%esp),%esi
f0121350:	29 ce                	sub    %ecx,%esi
f0121352:	19 d3                	sbb    %edx,%ebx
f0121354:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f0121358:	89 34 24             	mov    %esi,(%esp)
f012135b:	8b 04 24             	mov    (%esp),%eax
f012135e:	8b 54 24 14          	mov    0x14(%esp),%edx
f0121362:	eb bc                	jmp    f0121320 <__moddi3+0x78>
f0121364:	85 c9                	test   %ecx,%ecx
f0121366:	75 0b                	jne    f0121373 <__moddi3+0xcb>
f0121368:	b8 01 00 00 00       	mov    $0x1,%eax
f012136d:	31 d2                	xor    %edx,%edx
f012136f:	f7 f1                	div    %ecx
f0121371:	89 c1                	mov    %eax,%ecx
f0121373:	89 d8                	mov    %ebx,%eax
f0121375:	31 d2                	xor    %edx,%edx
f0121377:	f7 f1                	div    %ecx
f0121379:	8b 04 24             	mov    (%esp),%eax
f012137c:	f7 f1                	div    %ecx
f012137e:	89 d3                	mov    %edx,%ebx
f0121380:	eb 8f                	jmp    f0121311 <__moddi3+0x69>
f0121382:	66 90                	xchg   %ax,%ax
f0121384:	89 c8                	mov    %ecx,%eax
f0121386:	89 da                	mov    %ebx,%edx
f0121388:	f7 d8                	neg    %eax
f012138a:	83 d2 00             	adc    $0x0,%edx
f012138d:	f7 da                	neg    %edx
f012138f:	89 04 24             	mov    %eax,(%esp)
f0121392:	89 54 24 04          	mov    %edx,0x4(%esp)
f0121396:	e9 45 ff ff ff       	jmp    f01212e0 <__moddi3+0x38>
f012139b:	90                   	nop
f012139c:	f7 de                	neg    %esi
f012139e:	83 d7 00             	adc    $0x0,%edi
f01213a1:	f7 df                	neg    %edi
f01213a3:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f01213aa:	ff 
f01213ab:	e9 21 ff ff ff       	jmp    f01212d1 <__moddi3+0x29>
f01213b0:	b8 20 00 00 00       	mov    $0x20,%eax
f01213b5:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f01213b9:	29 f8                	sub    %edi,%eax
f01213bb:	89 c6                	mov    %eax,%esi
f01213bd:	89 44 24 14          	mov    %eax,0x14(%esp)
f01213c1:	89 f9                	mov    %edi,%ecx
f01213c3:	d3 e2                	shl    %cl,%edx
f01213c5:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f01213c9:	89 e8                	mov    %ebp,%eax
f01213cb:	89 f1                	mov    %esi,%ecx
f01213cd:	d3 e8                	shr    %cl,%eax
f01213cf:	09 d0                	or     %edx,%eax
f01213d1:	89 04 24             	mov    %eax,(%esp)
f01213d4:	89 ea                	mov    %ebp,%edx
f01213d6:	89 f9                	mov    %edi,%ecx
f01213d8:	d3 e2                	shl    %cl,%edx
f01213da:	89 d7                	mov    %edx,%edi
f01213dc:	89 da                	mov    %ebx,%edx
f01213de:	d3 e2                	shl    %cl,%edx
f01213e0:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f01213e4:	d3 e5                	shl    %cl,%ebp
f01213e6:	8b 44 24 10          	mov    0x10(%esp),%eax
f01213ea:	89 f1                	mov    %esi,%ecx
f01213ec:	d3 e8                	shr    %cl,%eax
f01213ee:	09 d0                	or     %edx,%eax
f01213f0:	d3 eb                	shr    %cl,%ebx
f01213f2:	89 da                	mov    %ebx,%edx
f01213f4:	f7 34 24             	divl   (%esp)
f01213f7:	89 d3                	mov    %edx,%ebx
f01213f9:	f7 e7                	mul    %edi
f01213fb:	89 c6                	mov    %eax,%esi
f01213fd:	89 d1                	mov    %edx,%ecx
f01213ff:	39 d3                	cmp    %edx,%ebx
f0121401:	72 29                	jb     f012142c <__moddi3+0x184>
f0121403:	74 33                	je     f0121438 <__moddi3+0x190>
f0121405:	89 e8                	mov    %ebp,%eax
f0121407:	29 f0                	sub    %esi,%eax
f0121409:	19 cb                	sbb    %ecx,%ebx
f012140b:	89 de                	mov    %ebx,%esi
f012140d:	8a 4c 24 14          	mov    0x14(%esp),%cl
f0121411:	d3 e6                	shl    %cl,%esi
f0121413:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0121417:	89 f9                	mov    %edi,%ecx
f0121419:	d3 e8                	shr    %cl,%eax
f012141b:	09 c6                	or     %eax,%esi
f012141d:	89 f0                	mov    %esi,%eax
f012141f:	89 f9                	mov    %edi,%ecx
f0121421:	d3 eb                	shr    %cl,%ebx
f0121423:	89 da                	mov    %ebx,%edx
f0121425:	e9 f6 fe ff ff       	jmp    f0121320 <__moddi3+0x78>
f012142a:	66 90                	xchg   %ax,%ax
f012142c:	29 f8                	sub    %edi,%eax
f012142e:	1b 14 24             	sbb    (%esp),%edx
f0121431:	89 d1                	mov    %edx,%ecx
f0121433:	89 c6                	mov    %eax,%esi
f0121435:	eb ce                	jmp    f0121405 <__moddi3+0x15d>
f0121437:	90                   	nop
f0121438:	39 c5                	cmp    %eax,%ebp
f012143a:	72 f0                	jb     f012142c <__moddi3+0x184>
f012143c:	89 d9                	mov    %ebx,%ecx
f012143e:	eb c5                	jmp    f0121405 <__moddi3+0x15d>

f0121440 <__udivdi3>:
f0121440:	55                   	push   %ebp
f0121441:	57                   	push   %edi
f0121442:	56                   	push   %esi
f0121443:	53                   	push   %ebx
f0121444:	83 ec 1c             	sub    $0x1c,%esp
f0121447:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f012144b:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f012144f:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0121453:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f0121457:	89 ca                	mov    %ecx,%edx
f0121459:	89 f8                	mov    %edi,%eax
f012145b:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f012145f:	85 f6                	test   %esi,%esi
f0121461:	75 2d                	jne    f0121490 <__udivdi3+0x50>
f0121463:	39 cf                	cmp    %ecx,%edi
f0121465:	77 65                	ja     f01214cc <__udivdi3+0x8c>
f0121467:	89 fd                	mov    %edi,%ebp
f0121469:	85 ff                	test   %edi,%edi
f012146b:	75 0b                	jne    f0121478 <__udivdi3+0x38>
f012146d:	b8 01 00 00 00       	mov    $0x1,%eax
f0121472:	31 d2                	xor    %edx,%edx
f0121474:	f7 f7                	div    %edi
f0121476:	89 c5                	mov    %eax,%ebp
f0121478:	31 d2                	xor    %edx,%edx
f012147a:	89 c8                	mov    %ecx,%eax
f012147c:	f7 f5                	div    %ebp
f012147e:	89 c1                	mov    %eax,%ecx
f0121480:	89 d8                	mov    %ebx,%eax
f0121482:	f7 f5                	div    %ebp
f0121484:	89 cf                	mov    %ecx,%edi
f0121486:	89 fa                	mov    %edi,%edx
f0121488:	83 c4 1c             	add    $0x1c,%esp
f012148b:	5b                   	pop    %ebx
f012148c:	5e                   	pop    %esi
f012148d:	5f                   	pop    %edi
f012148e:	5d                   	pop    %ebp
f012148f:	c3                   	ret    
f0121490:	39 ce                	cmp    %ecx,%esi
f0121492:	77 28                	ja     f01214bc <__udivdi3+0x7c>
f0121494:	0f bd fe             	bsr    %esi,%edi
f0121497:	83 f7 1f             	xor    $0x1f,%edi
f012149a:	75 40                	jne    f01214dc <__udivdi3+0x9c>
f012149c:	39 ce                	cmp    %ecx,%esi
f012149e:	72 0a                	jb     f01214aa <__udivdi3+0x6a>
f01214a0:	3b 44 24 08          	cmp    0x8(%esp),%eax
f01214a4:	0f 87 9e 00 00 00    	ja     f0121548 <__udivdi3+0x108>
f01214aa:	b8 01 00 00 00       	mov    $0x1,%eax
f01214af:	89 fa                	mov    %edi,%edx
f01214b1:	83 c4 1c             	add    $0x1c,%esp
f01214b4:	5b                   	pop    %ebx
f01214b5:	5e                   	pop    %esi
f01214b6:	5f                   	pop    %edi
f01214b7:	5d                   	pop    %ebp
f01214b8:	c3                   	ret    
f01214b9:	8d 76 00             	lea    0x0(%esi),%esi
f01214bc:	31 ff                	xor    %edi,%edi
f01214be:	31 c0                	xor    %eax,%eax
f01214c0:	89 fa                	mov    %edi,%edx
f01214c2:	83 c4 1c             	add    $0x1c,%esp
f01214c5:	5b                   	pop    %ebx
f01214c6:	5e                   	pop    %esi
f01214c7:	5f                   	pop    %edi
f01214c8:	5d                   	pop    %ebp
f01214c9:	c3                   	ret    
f01214ca:	66 90                	xchg   %ax,%ax
f01214cc:	89 d8                	mov    %ebx,%eax
f01214ce:	f7 f7                	div    %edi
f01214d0:	31 ff                	xor    %edi,%edi
f01214d2:	89 fa                	mov    %edi,%edx
f01214d4:	83 c4 1c             	add    $0x1c,%esp
f01214d7:	5b                   	pop    %ebx
f01214d8:	5e                   	pop    %esi
f01214d9:	5f                   	pop    %edi
f01214da:	5d                   	pop    %ebp
f01214db:	c3                   	ret    
f01214dc:	bd 20 00 00 00       	mov    $0x20,%ebp
f01214e1:	89 eb                	mov    %ebp,%ebx
f01214e3:	29 fb                	sub    %edi,%ebx
f01214e5:	89 f9                	mov    %edi,%ecx
f01214e7:	d3 e6                	shl    %cl,%esi
f01214e9:	89 c5                	mov    %eax,%ebp
f01214eb:	88 d9                	mov    %bl,%cl
f01214ed:	d3 ed                	shr    %cl,%ebp
f01214ef:	89 e9                	mov    %ebp,%ecx
f01214f1:	09 f1                	or     %esi,%ecx
f01214f3:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f01214f7:	89 f9                	mov    %edi,%ecx
f01214f9:	d3 e0                	shl    %cl,%eax
f01214fb:	89 c5                	mov    %eax,%ebp
f01214fd:	89 d6                	mov    %edx,%esi
f01214ff:	88 d9                	mov    %bl,%cl
f0121501:	d3 ee                	shr    %cl,%esi
f0121503:	89 f9                	mov    %edi,%ecx
f0121505:	d3 e2                	shl    %cl,%edx
f0121507:	8b 44 24 08          	mov    0x8(%esp),%eax
f012150b:	88 d9                	mov    %bl,%cl
f012150d:	d3 e8                	shr    %cl,%eax
f012150f:	09 c2                	or     %eax,%edx
f0121511:	89 d0                	mov    %edx,%eax
f0121513:	89 f2                	mov    %esi,%edx
f0121515:	f7 74 24 0c          	divl   0xc(%esp)
f0121519:	89 d6                	mov    %edx,%esi
f012151b:	89 c3                	mov    %eax,%ebx
f012151d:	f7 e5                	mul    %ebp
f012151f:	39 d6                	cmp    %edx,%esi
f0121521:	72 19                	jb     f012153c <__udivdi3+0xfc>
f0121523:	74 0b                	je     f0121530 <__udivdi3+0xf0>
f0121525:	89 d8                	mov    %ebx,%eax
f0121527:	31 ff                	xor    %edi,%edi
f0121529:	e9 58 ff ff ff       	jmp    f0121486 <__udivdi3+0x46>
f012152e:	66 90                	xchg   %ax,%ax
f0121530:	8b 54 24 08          	mov    0x8(%esp),%edx
f0121534:	89 f9                	mov    %edi,%ecx
f0121536:	d3 e2                	shl    %cl,%edx
f0121538:	39 c2                	cmp    %eax,%edx
f012153a:	73 e9                	jae    f0121525 <__udivdi3+0xe5>
f012153c:	8d 43 ff             	lea    -0x1(%ebx),%eax
f012153f:	31 ff                	xor    %edi,%edi
f0121541:	e9 40 ff ff ff       	jmp    f0121486 <__udivdi3+0x46>
f0121546:	66 90                	xchg   %ax,%ax
f0121548:	31 c0                	xor    %eax,%eax
f012154a:	e9 37 ff ff ff       	jmp    f0121486 <__udivdi3+0x46>
f012154f:	90                   	nop

f0121550 <__umoddi3>:
f0121550:	55                   	push   %ebp
f0121551:	57                   	push   %edi
f0121552:	56                   	push   %esi
f0121553:	53                   	push   %ebx
f0121554:	83 ec 1c             	sub    $0x1c,%esp
f0121557:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f012155b:	8b 74 24 34          	mov    0x34(%esp),%esi
f012155f:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0121563:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f0121567:	89 44 24 0c          	mov    %eax,0xc(%esp)
f012156b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f012156f:	89 f3                	mov    %esi,%ebx
f0121571:	89 fa                	mov    %edi,%edx
f0121573:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0121577:	89 34 24             	mov    %esi,(%esp)
f012157a:	85 c0                	test   %eax,%eax
f012157c:	75 1a                	jne    f0121598 <__umoddi3+0x48>
f012157e:	39 f7                	cmp    %esi,%edi
f0121580:	0f 86 a2 00 00 00    	jbe    f0121628 <__umoddi3+0xd8>
f0121586:	89 c8                	mov    %ecx,%eax
f0121588:	89 f2                	mov    %esi,%edx
f012158a:	f7 f7                	div    %edi
f012158c:	89 d0                	mov    %edx,%eax
f012158e:	31 d2                	xor    %edx,%edx
f0121590:	83 c4 1c             	add    $0x1c,%esp
f0121593:	5b                   	pop    %ebx
f0121594:	5e                   	pop    %esi
f0121595:	5f                   	pop    %edi
f0121596:	5d                   	pop    %ebp
f0121597:	c3                   	ret    
f0121598:	39 f0                	cmp    %esi,%eax
f012159a:	0f 87 ac 00 00 00    	ja     f012164c <__umoddi3+0xfc>
f01215a0:	0f bd e8             	bsr    %eax,%ebp
f01215a3:	83 f5 1f             	xor    $0x1f,%ebp
f01215a6:	0f 84 ac 00 00 00    	je     f0121658 <__umoddi3+0x108>
f01215ac:	bf 20 00 00 00       	mov    $0x20,%edi
f01215b1:	29 ef                	sub    %ebp,%edi
f01215b3:	89 fe                	mov    %edi,%esi
f01215b5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f01215b9:	89 e9                	mov    %ebp,%ecx
f01215bb:	d3 e0                	shl    %cl,%eax
f01215bd:	89 d7                	mov    %edx,%edi
f01215bf:	89 f1                	mov    %esi,%ecx
f01215c1:	d3 ef                	shr    %cl,%edi
f01215c3:	09 c7                	or     %eax,%edi
f01215c5:	89 e9                	mov    %ebp,%ecx
f01215c7:	d3 e2                	shl    %cl,%edx
f01215c9:	89 14 24             	mov    %edx,(%esp)
f01215cc:	89 d8                	mov    %ebx,%eax
f01215ce:	d3 e0                	shl    %cl,%eax
f01215d0:	89 c2                	mov    %eax,%edx
f01215d2:	8b 44 24 08          	mov    0x8(%esp),%eax
f01215d6:	d3 e0                	shl    %cl,%eax
f01215d8:	89 44 24 04          	mov    %eax,0x4(%esp)
f01215dc:	8b 44 24 08          	mov    0x8(%esp),%eax
f01215e0:	89 f1                	mov    %esi,%ecx
f01215e2:	d3 e8                	shr    %cl,%eax
f01215e4:	09 d0                	or     %edx,%eax
f01215e6:	d3 eb                	shr    %cl,%ebx
f01215e8:	89 da                	mov    %ebx,%edx
f01215ea:	f7 f7                	div    %edi
f01215ec:	89 d3                	mov    %edx,%ebx
f01215ee:	f7 24 24             	mull   (%esp)
f01215f1:	89 c6                	mov    %eax,%esi
f01215f3:	89 d1                	mov    %edx,%ecx
f01215f5:	39 d3                	cmp    %edx,%ebx
f01215f7:	0f 82 87 00 00 00    	jb     f0121684 <__umoddi3+0x134>
f01215fd:	0f 84 91 00 00 00    	je     f0121694 <__umoddi3+0x144>
f0121603:	8b 54 24 04          	mov    0x4(%esp),%edx
f0121607:	29 f2                	sub    %esi,%edx
f0121609:	19 cb                	sbb    %ecx,%ebx
f012160b:	89 d8                	mov    %ebx,%eax
f012160d:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f0121611:	d3 e0                	shl    %cl,%eax
f0121613:	89 e9                	mov    %ebp,%ecx
f0121615:	d3 ea                	shr    %cl,%edx
f0121617:	09 d0                	or     %edx,%eax
f0121619:	89 e9                	mov    %ebp,%ecx
f012161b:	d3 eb                	shr    %cl,%ebx
f012161d:	89 da                	mov    %ebx,%edx
f012161f:	83 c4 1c             	add    $0x1c,%esp
f0121622:	5b                   	pop    %ebx
f0121623:	5e                   	pop    %esi
f0121624:	5f                   	pop    %edi
f0121625:	5d                   	pop    %ebp
f0121626:	c3                   	ret    
f0121627:	90                   	nop
f0121628:	89 fd                	mov    %edi,%ebp
f012162a:	85 ff                	test   %edi,%edi
f012162c:	75 0b                	jne    f0121639 <__umoddi3+0xe9>
f012162e:	b8 01 00 00 00       	mov    $0x1,%eax
f0121633:	31 d2                	xor    %edx,%edx
f0121635:	f7 f7                	div    %edi
f0121637:	89 c5                	mov    %eax,%ebp
f0121639:	89 f0                	mov    %esi,%eax
f012163b:	31 d2                	xor    %edx,%edx
f012163d:	f7 f5                	div    %ebp
f012163f:	89 c8                	mov    %ecx,%eax
f0121641:	f7 f5                	div    %ebp
f0121643:	89 d0                	mov    %edx,%eax
f0121645:	e9 44 ff ff ff       	jmp    f012158e <__umoddi3+0x3e>
f012164a:	66 90                	xchg   %ax,%ax
f012164c:	89 c8                	mov    %ecx,%eax
f012164e:	89 f2                	mov    %esi,%edx
f0121650:	83 c4 1c             	add    $0x1c,%esp
f0121653:	5b                   	pop    %ebx
f0121654:	5e                   	pop    %esi
f0121655:	5f                   	pop    %edi
f0121656:	5d                   	pop    %ebp
f0121657:	c3                   	ret    
f0121658:	3b 04 24             	cmp    (%esp),%eax
f012165b:	72 06                	jb     f0121663 <__umoddi3+0x113>
f012165d:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f0121661:	77 0f                	ja     f0121672 <__umoddi3+0x122>
f0121663:	89 f2                	mov    %esi,%edx
f0121665:	29 f9                	sub    %edi,%ecx
f0121667:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f012166b:	89 14 24             	mov    %edx,(%esp)
f012166e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0121672:	8b 44 24 04          	mov    0x4(%esp),%eax
f0121676:	8b 14 24             	mov    (%esp),%edx
f0121679:	83 c4 1c             	add    $0x1c,%esp
f012167c:	5b                   	pop    %ebx
f012167d:	5e                   	pop    %esi
f012167e:	5f                   	pop    %edi
f012167f:	5d                   	pop    %ebp
f0121680:	c3                   	ret    
f0121681:	8d 76 00             	lea    0x0(%esi),%esi
f0121684:	2b 04 24             	sub    (%esp),%eax
f0121687:	19 fa                	sbb    %edi,%edx
f0121689:	89 d1                	mov    %edx,%ecx
f012168b:	89 c6                	mov    %eax,%esi
f012168d:	e9 71 ff ff ff       	jmp    f0121603 <__umoddi3+0xb3>
f0121692:	66 90                	xchg   %ax,%ax
f0121694:	39 44 24 04          	cmp    %eax,0x4(%esp)
f0121698:	72 ea                	jb     f0121684 <__umoddi3+0x134>
f012169a:	89 d9                	mov    %ebx,%ecx
f012169c:	e9 62 ff ff ff       	jmp    f0121603 <__umoddi3+0xb3>
